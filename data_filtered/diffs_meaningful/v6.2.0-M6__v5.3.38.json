{
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#addArguments(code,argumentCodeGenerator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the code for the method arguments using the specified\n\t * {@link ArgumentCodeGenerator} if necessary.\n\t * @param code the code builder to use to add method arguments\n\t * @param argumentCodeGenerator the code generator to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "argumentCodeGenerator"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "protected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator)",
    "source_code": "\tprotected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator) {\n\t\tList<CodeBlock> arguments = new ArrayList<>();\n\t\tTypeName[] argumentTypes = this.method.parameters.stream()\n\t\t\t\t.map(parameter -> parameter.type).toArray(TypeName[]::new);\n\t\tfor (int i = 0; i < argumentTypes.length; i++) {\n\t\t\tTypeName argumentType = argumentTypes[i];\n\t\t\tCodeBlock argumentCode = argumentCodeGenerator.generateCode(argumentType);\n\t\t\tif (argumentCode == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not generate code for \" + this\n\t\t\t\t\t\t+ \": parameter \" + i + \" of type \" + argumentType + \" is not supported\");\n\t\t\t}\n\t\t\targuments.add(argumentCode);\n\t\t}\n\t\tcode.add(CodeBlock.join(arguments, \", \"));\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethodWithMinimalParameters(clazz,methodName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none),\n\t * declared on the given class or one of its superclasses. Prefers public methods,\n\t * but will return a protected, package access, or private method too.\n\t * <p>Checks {@code Class.getMethods} first, falling back to\n\t * {@code findDeclaredMethodWithMinimalParameters}. This allows for finding public\n\t * methods without issues even in environments with restricted Java security settings.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t * @see Class#getMethods\n\t * @see #findDeclaredMethodWithMinimalParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "Method",
    "signature": "public Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName);\n\t\tif (targetMethod == null) {\n\t\t\ttargetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName);\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#newNestedPropertyAccessor(object,nestedPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new nested property accessor instance.\n\t * Can be overridden in subclasses to create a PropertyAccessor subclass.\n\t * @param object the object wrapped by this PropertyAccessor\n\t * @param nestedPath the nested path of the object\n\t * @return the nested PropertyAccessor instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "AbstractNestablePropertyAccessor",
    "signature": "protected AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath)",
    "source_code": "\tprotected abstract AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath);"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(pvs,ignoreUnknown)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "ignoreUnknown"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown)",
    "source_code": "\tpublic void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown) throws BeansException {\n\t\tsetPropertyValues(pvs, ignoreUnknown, false);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getMostSpecific(a,b)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "MatchStatus",
    "signature": "public MatchStatus getMostSpecific(MatchStatus a, MatchStatus b)",
    "source_code": "\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkGenericTypeMatch(bdHolder,descriptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given dependency type with its generic type information against the given\n\t * candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "protected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tprotected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tResolvableType dependencyType = descriptor.getResolvableType();\n\t\tif (dependencyType.getType() instanceof Class) {\n\t\t\t// No generic type -> we know it's a Class type-match, so no need to check again.\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvableType targetType = null;\n\t\tboolean cacheType = false;\n\t\tRootBeanDefinition rbd = null;\n\t\tif (bdHolder.getBeanDefinition() instanceof RootBeanDefinition rootBeanDef) {\n\t\t\trbd = rootBeanDef;\n\t\t}\n\t\tif (rbd != null) {\n\t\t\ttargetType = rbd.targetType;\n\t\t\tif (targetType == null) {\n\t\t\t\tcacheType = true;\n\t\t\t\t// First, check factory method return type, if applicable\n\t\t\t\ttargetType = getReturnTypeForFactoryMethod(rbd, descriptor);\n\t\t\t\tif (targetType == null) {\n\t\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(rbd);\n\t\t\t\t\tif (dbd != null) {\n\t\t\t\t\t\ttargetType = dbd.targetType;\n\t\t\t\t\t\tif (targetType == null) {\n\t\t\t\t\t\t\ttargetType = getReturnTypeForFactoryMethod(dbd, descriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\t// Regular case: straight bean instance, with BeanFactory available.\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tClass<?> beanType = this.beanFactory.getType(bdHolder.getBeanName());\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanType));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Fallback: no BeanFactory set, or no type resolvable through it\n\t\t\t// -> best-effort match against the target class if applicable.\n\t\t\tif (targetType == null && rbd != null && rbd.hasBeanClass() && rbd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = rbd.getBeanClass();\n\t\t\t\tif (!FactoryBean.class.isAssignableFrom(beanClass)) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (cacheType) {\n\t\t\trbd.targetType = targetType;\n\t\t}\n\n\t\t// Pre-declared target type: In case of a generic FactoryBean type,\n\t\t// unwrap nested generic type when matching a non-FactoryBean type.\n\t\tClass<?> targetClass = targetType.resolve();\n\t\tif (targetClass != null && FactoryBean.class.isAssignableFrom(targetClass)) {\n\t\t\tClass<?> classToMatch = dependencyType.resolve();\n\t\t\tif (classToMatch != null && !FactoryBean.class.isAssignableFrom(classToMatch) &&\n\t\t\t\t\t!classToMatch.isAssignableFrom(targetClass)) {\n\t\t\t\ttargetType = targetType.getGeneric();\n\t\t\t\tif (descriptor.fallbackMatchAllowed()) {\n\t\t\t\t\t// Matching the Class-based type determination for FactoryBean\n\t\t\t\t\t// objects in the lazy-determination getType code path above.\n\t\t\t\t\ttargetType = ResolvableType.forClass(targetType.resolve());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (descriptor.fallbackMatchAllowed()) {\n\t\t\t// Fallback matches allow unresolvable generics, e.g. plain HashMap to Map<String,String>;\n\t\t\t// and pragmatically also java.util.Properties to any Map (since despite formally being a\n\t\t\t// Map<Object,Object>, java.util.Properties is usually perceived as a Map<String,String>).\n\t\t\tif (targetType.hasUnresolvableGenerics()) {\n\t\t\t\treturn dependencyType.isAssignableFromResolvedPart(targetType);\n\t\t\t}\n\t\t\telse if (targetType.resolve() == Properties.class) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Full check for complex generic type match...\n\t\treturn dependencyType.isAssignableFrom(targetType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\tMergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\tif (annotation.isPresent()) {\n\t\t\t\treturn annotation.synthesize();\n\t\t\t}\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, e.g. in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\t\tMergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\tMergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#ofInnerBean(parent,innerBeanName,innerBeanDefinition)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link RegisteredBean} instance for an inner-bean.\n\t * @param parent the parent of the inner-bean\n\t * @param innerBeanName the name of the inner bean or {@code null} to\n\t * generate a name\n\t * @param innerBeanDefinition the inner-bean definition\n\t * @return a new {@link RegisteredBean} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent",
      "innerBeanName",
      "innerBeanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "RegisteredBean",
    "signature": "public RegisteredBean ofInnerBean(RegisteredBean parent,\n\t\t\t@Nullable String innerBeanName, BeanDefinition innerBeanDefinition)",
    "source_code": "\tpublic static RegisteredBean ofInnerBean(RegisteredBean parent,\n\t\t\t@Nullable String innerBeanName, BeanDefinition innerBeanDefinition) {\n\n\t\tAssert.notNull(parent, \"'parent' must not be null\");\n\t\tAssert.notNull(innerBeanDefinition, \"'innerBeanDefinition' must not be null\");\n\t\tInnerBeanResolver resolver = new InnerBeanResolver(parent, innerBeanName, innerBeanDefinition);\n\t\tSupplier<String> beanName = (StringUtils.hasLength(innerBeanName) ?\n\t\t\t\t() -> innerBeanName : resolver::resolveBeanName);\n\t\treturn new RegisteredBean(parent.getBeanFactory(), beanName,\n\t\t\t\tinnerBeanName == null, resolver::resolveMergedBeanDefinition, parent);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerDisposableBeanIfNecessary(beanName,bean,mbd)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given bean to the list of disposable beans in this factory,\n\t * registering its DisposableBean interface and/or the given destroy method\n\t * to be called on factory shutdown (if applicable). Only applies to singletons.\n\t * @param beanName the name of the bean\n\t * @param bean the bean instance\n\t * @param mbd the bean definition for the bean\n\t * @see RootBeanDefinition#isSingleton\n\t * @see RootBeanDefinition#getDependsOn\n\t * @see #registerDisposableBean\n\t * @see #registerDependentBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1906
    },
    "return": "void",
    "signature": "protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tif (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {\n\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t// Register a DisposableBean implementation that performs all destruction\n\t\t\t\t// work for the given bean: DestructionAwareBeanPostProcessors,\n\t\t\t\t// DisposableBean interface, custom destroy method.\n\t\t\t\tregisterDisposableBean(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A bean with a custom scope...\n\t\t\t\tScope scope = this.scopes.get(mbd.getScope());\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + mbd.getScope() + \"'\");\n\t\t\t\t}\n\t\t\t\tscope.registerDestructionCallback(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionAttributes(ele,beanName,containingBean,bd)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#registerBeanDefinitions(doc,readerContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation parses bean definitions according to the \"spring-beans\" XSD\n\t * (or DTD, historically).\n\t * <p>Opens a DOM Document; then initializes the default settings\n\t * specified at the {@code <beans/>} level; then parses the contained bean definitions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "doc",
      "readerContext"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)",
    "source_code": "\tpublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n\t\tthis.readerContext = readerContext;\n\t\tdoRegisterBeanDefinitions(doc.getDocumentElement());\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#doProcessConfigurationClass(configClass,sourceClass,filter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "sourceClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "SourceClass",
    "signature": "protected SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)",
    "source_code": "\tprotected final SourceClass doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass, filter);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,\n\t\t\t\tPropertySources.class, true)) {\n\t\t\tif (this.propertySourceRegistry != null) {\n\t\t\t\tthis.propertySourceRegistry.processPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Search for locally declared @ComponentScan annotations first.\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,\n\t\t\t\tMergedAnnotation::isDirectlyPresent);\n\n\t\t// Fall back to searching for @ComponentScan meta-annotations (which indirectly\n\t\t// includes locally declared composed annotations).\n\t\tif (componentScans.isEmpty()) {\n\t\t\tcomponentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),\n\t\t\t\t\tComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);\n\t\t}\n\n\t\tif (!componentScans.isEmpty()) {\n\t\t\tList<Condition> registerBeanConditions = collectRegisterBeanConditions(configClass);\n\t\t\tif (!registerBeanConditions.isEmpty()) {\n\t\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\t\"Component scan for configuration class [%s] could not be used with conditions in REGISTER_BEAN phase: %s\"\n\t\t\t\t\t\t\t\t.formatted(configClass.getMetadata().getClassName(), registerBeanConditions));\n\t\t\t}\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tif (methodMetadata.isAnnotated(\"kotlin.jvm.JvmStatic\") && !methodMetadata.isStatic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\")) {\n\t\t\t\tboolean superclassKnown = this.knownSuperclasses.containsKey(superclass);\n\t\t\t\tthis.knownSuperclasses.add(superclass, configClass);\n\t\t\t\tif (!superclassKnown) {\n\t\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerScope(annotationType,scopeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an extended JSR-330 scope annotation, mapping it onto a\n\t * specific Spring scope by name.\n\t * @param annotationType the JSR-330 annotation type by name\n\t * @param scopeName the Spring scope name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "scopeName"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void registerScope(String annotationType, String scopeName)",
    "source_code": "\tpublic final void registerScope(String annotationType, String scopeName) {\n\t\tthis.scopeMap.put(annotationType, scopeName);\n\t}"
  },
  "org.springframework.context.support.<unknown>#setProperty(property,newValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createSortedProperties(properties,omitComments)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@code Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * <p>The returned {@code Properties} instance will be populated with\n\t * properties from the supplied {@code properties} object, but default\n\t * properties from the supplied {@code properties} object will not be copied.\n\t * @param properties the {@code Properties} object from which to copy the\n\t * initial properties\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "omitComments"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "Properties",
    "signature": "public Properties createSortedProperties(Properties properties, boolean omitComments)",
    "source_code": "\tpublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\n\t\treturn new SortedProperties(properties, omitComments);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationDeclaredLocally(annotationType,clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is declared locally (i.e. <em>directly present</em>) on the supplied\n\t * {@code clazz}.\n\t * <p>The supplied {@link Class} may represent any type.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>Note: This method does <strong>not</strong> determine if the annotation\n\t * is {@linkplain java.lang.annotation.Inherited inherited}.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>directly present</em>\n\t * @see java.lang.Class#getDeclaredAnnotations()\n\t * @see java.lang.Class#getDeclaredAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\n\t}"
  },
  "org.springframework.core.io.<unknown>#invokeVfsMethod(method,target,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Object",
    "signature": "protected Object invokeVfsMethod(Method method, @Nullable Object target, Object... args)",
    "source_code": "\tprotected static Object invokeVfsMethod(Method method, @Nullable Object target, Object... args) throws IOException {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof IOException ioException) {\n\t\t\t\tthrow ioException;\n\t\t\t}\n\t\t\tReflectionUtils.handleInvocationTargetException(ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tReflectionUtils.handleReflectionException(ex);\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Invalid code path reached\");\n\t}"
  },
  "org.springframework.http.<unknown>#filename(filename,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filename",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "Builder",
    "signature": "public Builder filename(@Nullable String filename, @Nullable Charset charset)",
    "source_code": "\t\tpublic Builder filename(@Nullable String filename, @Nullable Charset charset) {\n\t\t\tthis.filename = filename;\n\t\t\tthis.charset = charset;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#put(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1864
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.http.<unknown>#setContentDispositionFormData(name,filename)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Content-Disposition} header when creating a\n\t * {@code \"multipart/form-data\"} request.\n\t * <p>Applications typically would not set this header directly but\n\t * rather prepare a {@code MultiValueMap<String, Object>}, containing an\n\t * Object or a {@link org.springframework.core.io.Resource} for each part,\n\t * and then pass that to the {@code RestTemplate} or {@code WebClient}.\n\t * @param name the control name\n\t * @param filename the filename (may be {@code null})\n\t * @see #getContentDisposition()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 917
    },
    "return": "void",
    "signature": "public void setContentDispositionFormData(String name, @Nullable String filename)",
    "source_code": "\tpublic void setContentDispositionFormData(String name, @Nullable String filename) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tContentDisposition.Builder disposition = ContentDisposition.formData().name(name);\n\t\tif (StringUtils.hasText(filename)) {\n\t\t\tdisposition.filename(filename);\n\t\t}\n\t\tsetContentDisposition(disposition.build());\n\t}"
  },
  "org.springframework.http.<unknown>#setProperty(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a \"dynamic\" property to be added to a generic {@link #getProperties()\n\t * properties map}.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param name the property name\n\t * @param value the property value, possibly {@code null} if the intent is\n\t * to include a property with its value set to \"null\"\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void setProperty(String name, @Nullable Object value)",
    "source_code": "\tpublic void setProperty(String name, @Nullable Object value) {\n\t\tthis.properties = (this.properties != null ? this.properties : new LinkedHashMap<>());\n\t\tthis.properties.put(name, value);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#read(type,contextClass,inputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(parsedSql,paramSource,declaredParams)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t * @param declaredParams the List of declared SqlParameter objects\n\t * (may be {@code null}). If specified, the parameter metadata will\n\t * be built into the value array in the form of SqlParameterValue objects.\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource",
      "declaredParams"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams)",
    "source_code": "\tpublic static Object[] buildValueArray(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {\n\n\t\tObject[] paramArray = new Object[parsedSql.getTotalParameterCount()];\n\t\tif (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Not allowed to mix named and traditional ? placeholders. You have \" +\n\t\t\t\t\tparsedSql.getNamedParameterCount() + \" named parameter(s) and \" +\n\t\t\t\t\tparsedSql.getUnnamedParameterCount() + \" traditional placeholder(s) in statement: \" +\n\t\t\t\t\tparsedSql.getOriginalSql());\n\t\t}\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\ttry {\n\t\t\t\tSqlParameter param = findParameter(declaredParams, paramName, i);\n\t\t\t\tObject paramValue = paramSource.getValue(paramName);\n\t\t\t\tif (paramValue instanceof SqlParameterValue) {\n\t\t\t\t\tparamArray[i] = paramValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparamArray[i] = (param != null ? new SqlParameterValue(param, paramValue) :\n\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(paramSource, paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"No value supplied for the SQL parameter '\" + paramName + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn paramArray;\n\t}"
  },
  "org.springframework.jms.config.<unknown>#createListenerContainer(endpoint,factory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create and start a new container using the specified factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "MessageListenerContainer",
    "signature": "protected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory)",
    "source_code": "\tprotected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory) {\n\n\t\tMessageListenerContainer listenerContainer = factory.createListenerContainer(endpoint);\n\n\t\tif (listenerContainer instanceof InitializingBean initializingBean) {\n\t\t\ttry {\n\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Failed to initialize message listener container\", ex);\n\t\t\t}\n\t\t}\n\n\t\tint containerPhase = listenerContainer.getPhase();\n\t\tif (containerPhase < Integer.MAX_VALUE) {  // a custom phase value\n\t\t\tif (this.phase < Integer.MAX_VALUE && this.phase != containerPhase) {\n\t\t\t\tthrow new IllegalStateException(\"Encountered phase mismatch between container factory definitions: \" +\n\t\t\t\t\t\tthis.phase + \" vs \" + containerPhase);\n\t\t\t}\n\t\t\tthis.phase = listenerContainer.getPhase();\n\t\t}\n\n\t\treturn listenerContainer;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createQueueConnection(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate the call straight to the target QueueConnectionFactory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\treturn doCreateQueueConnection(username, password);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queueName,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1019
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createConsumer(session,destination,messageSelector)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS MessageConsumer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1156
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\t// Only pass in the NoLocal flag in case of a Topic:\n\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\tif (isPubSubDomain()) {\n\t\t\treturn session.createConsumer(destination, messageSelector, isPubSubNoLocal());\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, messageSelector);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToTextMessage(object,session,marshaller)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link TextMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createTextMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "TextMessage",
    "signature": "protected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tResult result = new StreamResult(writer);\n\t\tmarshaller.marshal(object, result);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,dataSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "void",
    "signature": "public void addInline(String contentId, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, DataSource dataSource) throws MessagingException {\n\t\tAssert.notNull(contentId, \"Content ID must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\tmimeBodyPart.setDisposition(Part.INLINE);\n\t\tmimeBodyPart.setContentID(\"<\" + contentId + \">\");\n\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\tgetMimeMultipart().addBodyPart(mimeBodyPart);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(payload,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(getRequiredDefaultDestination(), payload, postProcessor);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "InvocableHandlerMethod",
    "signature": "protected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#extendMapping(composite,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "composite",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler)",
    "source_code": "\tprotected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler) {\n\n\t\tList<MessageCondition<?>> conditions = composite.getMessageConditions();\n\t\tAssert.isTrue(conditions.size() == 2 &&\n\t\t\t\t\t\tconditions.get(0) instanceof RSocketFrameTypeMessageCondition &&\n\t\t\t\t\t\tconditions.get(1) instanceof DestinationPatternsMessageCondition,\n\t\t\t\t\"Unexpected message condition types\");\n\n\t\tif (conditions.get(0) != RSocketFrameTypeMessageCondition.EMPTY_CONDITION) {\n\t\t\treturn composite;\n\t\t}\n\n\t\tint responseCardinality = getCardinality(handler.getReturnType());\n\t\tint requestCardinality = 0;\n\t\tfor (MethodParameter parameter : handler.getMethodParameters()) {\n\t\t\tif (getArgumentResolvers().getArgumentResolver(parameter) instanceof PayloadMethodArgumentResolver) {\n\t\t\t\trequestCardinality = getCardinality(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn new CompositeMessageCondition(\n\t\t\t\tRSocketFrameTypeMessageCondition.getCondition(requestCardinality, responseCardinality),\n\t\t\t\tconditions.get(1));\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#createMessage(payload,messageHeaders)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "messageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Message<T>",
    "signature": "public Message<T> createMessage(T payload, MessageHeaders messageHeaders)",
    "source_code": "\tpublic static <T> Message<T> createMessage(T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findNamedEntityManagerFactory(unitName,requestingBeanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current\n\t * Spring application context.\n\t * @param unitName the name of the persistence unit (never empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 570
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tAssert.state(this.beanFactory != null, \"ListableBeanFactory required for EntityManagerFactory bean lookup\");\n\n\t\tEntityManagerFactory emf = EntityManagerFactoryUtils.findEntityManagerFactory(this.beanFactory, unitName);\n\t\tif (requestingBeanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tcbf.registerDependentBean(unitName, requestingBeanName);\n\t\t}\n\t\treturn emf;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result,mimeContainer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 724
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\ttry {\n\t\t\tMarshaller marshaller = createMarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tmarshaller.setAttachmentMarshaller(new Jaxb2AttachmentMarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxResult(result)) {\n\t\t\t\tmarshalStaxResult(marshaller, graph, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmarshaller.marshal(graph, result);\n\t\t\t}\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setAdapters(XmlAdapter<?,adapters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@code XmlAdapter}s to be registered with the JAXB {@code Marshaller}\n\t * and {@code Unmarshaller}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "XmlAdapter<?",
      "adapters"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void setAdapters(XmlAdapter<?, ?>... adapters)",
    "source_code": "\tpublic void setAdapters(XmlAdapter<?, ?>... adapters) {\n\t\tthis.adapters = adapters;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setUnmarshallerProperties(Map<String,properties)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Unmarshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Unmarshaller}.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Unmarshaller#setProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void setUnmarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setUnmarshallerProperties(Map<String, ?> properties) {\n\t\tthis.unmarshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setFieldAliases(Map<String,fieldAliases)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field alias/type map, consisting of field names.\n\t * @see XStream#aliasField(String, Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "fieldAliases"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void setFieldAliases(Map<String, String> fieldAliases)",
    "source_code": "\tpublic void setFieldAliases(Map<String, String> fieldAliases) {\n\t\tthis.fieldAliases = fieldAliases;\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#invoke(proxy,method,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> proxy == args[0];\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\tcase \"unwrap\" -> this.target;\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> Mono.empty();\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.target, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(identifier,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "void",
    "signature": "public void bind(String identifier, Object value)",
    "source_code": "\t\tpublic void bind(String identifier, Object value) {\n\t\t\tthis.statement.bind(identifier, value);\n\t\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler ||\n\t\t\t\tbean instanceof ScheduledExecutorService) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, List.of(Scheduled.class, Schedules.class))) {\n\t\t\tMap<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {\n\t\t\t\t\t\tSet<Scheduled> scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, Scheduled.class, Schedules.class);\n\t\t\t\t\t\treturn (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @Scheduled annotations found on bean class: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, scheduledAnnotations) ->\n\t\t\t\t\t\tscheduledAnnotations.forEach(scheduled -> processScheduled(scheduled, method, bean)));\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(annotatedMethods.size() + \" @Scheduled methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t\tif ((this.beanFactory != null && !this.beanFactory.isSingleton(beanName)) ||\n\t\t\t\t\t\t(this.beanFactory instanceof SingletonBeanRegistry sbr && sbr.containsSingleton(beanName))) {\n\t\t\t\t\t// Either a prototype/scoped bean or a FactoryBean with a pre-existing managed singleton\n\t\t\t\t\t// -> trigger manual cancellation when ContextClosedEvent comes in\n\t\t\t\t\tthis.manualCancellationOnContextClose.add(bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#TaskExecutionOutcome(executionTime,status,throwable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n * @param executionTime the instant when the task execution started, {@code null} if the task has not started.\n * @param status        the {@link Status} of the execution outcome.\n * @param throwable     the exception thrown from the task execution, if any.\n * @author Brian Clozel\n * @since 6.2\n */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executionTime",
      "status",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 32
    },
    "return": "record",
    "signature": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable)",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\t}\n}"
  },
  "org.springframework.scheduling.config.<unknown>#addOneTimeTask(task,initialDelay)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered once after the given initial delay.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "initialDelay"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void addOneTimeTask(Runnable task, Duration initialDelay)",
    "source_code": "\tpublic void addOneTimeTask(Runnable task, Duration initialDelay) {\n\t\taddOneTimeTask(new OneTimeTask(task, initialDelay));\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#setGlobalBindings(Map<String,globalBindings)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the globally scoped bindings on the underlying script engine manager,\n\t * shared by all scripts, as an alternative to script argument bindings.\n\t * @since 4.2.2\n\t * @see #evaluate(ScriptSource, Map)\n\t * @see javax.script.ScriptEngineManager#setBindings(Bindings)\n\t * @see javax.script.SimpleBindings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "globalBindings"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setGlobalBindings(Map<String, Object> globalBindings)",
    "source_code": "\tpublic void setGlobalBindings(Map<String, Object> globalBindings) {\n\t\tBindings bindings = StandardScriptUtils.getBindings(globalBindings);\n\t\tthis.globalBindings = bindings;\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager != null) {\n\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestExecution(testInstance,testMethod,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>immediately after</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called before framework-specific\n\t * <em>after</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * order in which they were registered.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the\n\t * test method or by a TestExecutionListener, or {@code null} if none\n\t * was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString callbackName = \"afterTestExecution\";\n\t\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\t\tThrowable afterTestExecutionException = null;\n\n\t\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t\t// \"wrapper\"-style execution of listeners.\n\t\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\t\ttry {\n\t\t\t\t\ttestExecutionListener.afterTestExecution(getTestContext());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\t\tif (afterTestExecutionException == null) {\n\t\t\t\t\t\tafterTestExecutionException = ex;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tafterTestExecutionException.addSuppressed(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (afterTestExecutionException != null) {\n\t\t\t\tReflectionUtils.rethrowException(afterTestExecutionException);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tresetMethodInvoker();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#removeEldestEntry(Map.Entry<MergedContextConfiguration,eldest)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<MergedContextConfiguration",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {\n\t\t\tif (this.size() > DefaultContextCache.this.getMaxSize()) {\n\t\t\t\t// Do NOT delete \"DefaultContextCache.this.\"; otherwise, we accidentally\n\t\t\t\t// invoke java.util.Map.remove(Object, Object).\n\t\t\t\tDefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL);\n\t\t\t}\n\n\t\t\t// Return false since we invoke a custom eviction algorithm.\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.test.context.web.<unknown>#loadContextForAotRuntime(mergedConfig,initializer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load a {@link GenericWebApplicationContext} for AOT run-time execution based on\n\t * the supplied {@link MergedContextConfiguration} and\n\t * {@link ApplicationContextInitializer}.\n\t * @param mergedConfig the merged context configuration to use to load the\n\t * application context\n\t * @param initializer the {@code ApplicationContextInitializer} that should\n\t * be applied to the context in order to recreate bean definitions\n\t * @return a new web application context\n\t * @throws Exception if context loading failed\n\t * @since 6.0\n\t * @see AotContextLoader#loadContextForAotRuntime(MergedContextConfiguration, ApplicationContextInitializer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "initializer"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "GenericWebApplicationContext",
    "signature": "public GenericWebApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer)",
    "source_code": "\tpublic final GenericWebApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {\n\n\t\tAssert.notNull(mergedConfig, \"MergedContextConfiguration must not be null\");\n\t\tAssert.notNull(initializer, \"ApplicationContextInitializer must not be null\");\n\t\tif (!(mergedConfig instanceof WebMergedContextConfiguration webMergedConfig)) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tCannot load WebApplicationContext from non-web merged context configuration %s. \\\n\t\t\t\t\tConsider annotating your test class with @WebAppConfiguration.\"\"\"\n\t\t\t\t\t\t.formatted(mergedConfig));\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading WebApplicationContext for AOT runtime for \" + mergedConfig);\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Loading WebApplicationContext for AOT runtime for test class \" +\n\t\t\t\t\tmergedConfig.getTestClass().getName());\n\t\t}\n\n\t\tvalidateMergedContextConfiguration(webMergedConfig);\n\n\t\tGenericWebApplicationContext context = createContext();\n\t\ttry {\n\t\t\tconfigureWebResources(context, webMergedConfig);\n\t\t\tprepareContext(context, webMergedConfig);\n\t\t\tinitializer.initialize(context);\n\t\t\tcustomizeContext(context, webMergedConfig);\n\t\t\tcontext.refresh();\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ContextLoadException(context, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.socket.<unknown>#customizeContext(context,mergedConfig)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tif (context instanceof WebApplicationContext wac) {\n\t\t\tServletContext sc = wac.getServletContext();\n\t\t\tif (sc != null) {\n\t\t\t\tsc.setAttribute(\"jakarta.websocket.server.ServerContainer\", new MockServerContainer());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,strict)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t * @deprecated in favor of {@link #json(String, JsonCompareMode)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, boolean strict)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\tJsonCompareMode compareMode = (strict ? JsonCompareMode.STRICT : JsonCompareMode.LENIENT);\n\t\treturn json(expectedJsonContent, compareMode);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\"\n\t * matches, as well as direct equality.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithFields(clazz,fc,ff)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @param ff the filter that determines the fields to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc",
      "ff"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "void",
    "signature": "public void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff)",
    "source_code": "\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tClass<?> targetClass = clazz;\n\t\tdo {\n\t\t\tField[] fields = getDeclaredFields(targetClass);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (ff != null && !ff.matches(field)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfc.doWith(field);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t}\n\t\twhile (targetClass != null && targetClass != Object.class);\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(lhsType,rhsType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type following the Java generics rules.\n\t * @param lhsType the target type (left-hand side (LHS) type)\n\t * @param rhsType the value type (right-hand side (RHS) type) that should\n\t * be assigned to the target type\n\t * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\n\t * @see ClassUtils#isAssignable(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean isAssignable(Type lhsType, Type rhsType)",
    "source_code": "\tpublic static boolean isAssignable(Type lhsType, Type rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\n\t\t// all types are assignable to themselves and to class Object\n\t\tif (lhsType.equals(rhsType) || Object.class == lhsType) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lhsType instanceof Class<?> lhsClass) {\n\t\t\t// just comparing two classes\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t}\n\n\t\t\tif (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\tType rhsRaw = rhsParameterizedType.getRawType();\n\n\t\t\t\t// a parameterized type is always assignable to its raw class type\n\t\t\t\tif (rhsRaw instanceof Class<?> rhRawClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhRawClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lhsClass.isArray() && rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsClass.componentType(), rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\t// parameterized types are only assignable to other parameterized types and class types\n\t\tif (lhsType instanceof ParameterizedType lhsParameterizedType) {\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\tType lhsRaw = lhsParameterizedType.getRawType();\n\n\t\t\t\tif (lhsRaw instanceof Class<?> lhsClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\treturn isAssignable(lhsParameterizedType, rhsParameterizedType);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof GenericArrayType lhsGenericArrayType) {\n\t\t\tType lhsComponent = lhsGenericArrayType.getGenericComponentType();\n\n\t\t\tif (rhsType instanceof Class<?> rhsClass && rhsClass.isArray()) {\n\t\t\t\treturn isAssignable(lhsComponent, rhsClass.componentType());\n\t\t\t}\n\t\t\telse if (rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsComponent, rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof WildcardType lhsWildcardType) {\n\t\t\treturn isAssignable(lhsWildcardType, rhsType);\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#replace(inString,oldPattern,newPattern)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all occurrences of a substring within a string with another string.\n\t * @param inString {@code String} to examine\n\t * @param oldPattern {@code String} to replace\n\t * @param newPattern {@code String} to insert\n\t * @return a {@code String} with the replacements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "oldPattern",
      "newPattern"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "String",
    "signature": "public String replace(String inString, String oldPattern, @Nullable String newPattern)",
    "source_code": "\tpublic static String replace(String inString, String oldPattern, @Nullable String newPattern) {\n\t\tif (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n\t\t\treturn inString;\n\t\t}\n\t\tint index = inString.indexOf(oldPattern);\n\t\tif (index == -1) {\n\t\t\t// no occurrence -> can return input as-is\n\t\t\treturn inString;\n\t\t}\n\n\t\tint capacity = inString.length();\n\t\tif (newPattern.length() > oldPattern.length()) {\n\t\t\tcapacity += 16;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(capacity);\n\n\t\tint pos = 0;  // our position in the old string\n\t\tint patLen = oldPattern.length();\n\t\twhile (index >= 0) {\n\t\t\tsb.append(inString, pos, index);\n\t\t\tsb.append(newPattern);\n\t\t\tpos = index + patLen;\n\t\t\tindex = inString.indexOf(oldPattern, pos);\n\t\t}\n\n\t\t// append any characters to the right of a match\n\t\tsb.append(inString, pos, inString.length());\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#toArray(enumeration,array)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "A[]",
    "signature": "public A[] toArray(Enumeration<E> enumeration, A[] array)",
    "source_code": "\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startElement(uri,localName,qName,attributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "localName",
      "qName",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void startElement(String uri, String localName, String qName, Attributes attributes)",
    "source_code": "\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) {\n\t\tNode parent = getParent();\n\t\tElement element = this.document.createElementNS(uri, qName);\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tString attrUri = attributes.getURI(i);\n\t\t\tString attrQname = attributes.getQName(i);\n\t\t\tString value = attributes.getValue(i);\n\t\t\tif (!attrQname.startsWith(\"xmlns\")) {\n\t\t\t\telement.setAttributeNS(attrUri, attrQname, value);\n\t\t\t}\n\t\t}\n\t\telement = (Element) parent.appendChild(element);\n\t\tthis.elements.add(element);\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(message,statusCode,statusText,headers,body,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #create(HttpStatusCode, String, HttpHeaders, byte[], Charset)}\n\t * with an optional prepared message.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\tif (statusCode instanceof HttpStatus status) {\n\t\t\treturn switch (status) {\n\t\t\t\tcase BAD_REQUEST -> message != null ?\n\t\t\t\t\t\tnew BadRequest(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew BadRequest(statusText, headers, body, charset);\n\t\t\t\tcase UNAUTHORIZED -> message != null ?\n\t\t\t\t\t\tnew Unauthorized(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Unauthorized(statusText, headers, body, charset);\n\t\t\t\tcase FORBIDDEN -> message != null ?\n\t\t\t\t\t\tnew Forbidden(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Forbidden(statusText, headers, body, charset);\n\t\t\t\tcase NOT_FOUND -> message != null ?\n\t\t\t\t\t\tnew NotFound(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotFound(statusText, headers, body, charset);\n\t\t\t\tcase METHOD_NOT_ALLOWED -> message != null ?\n\t\t\t\t\t\tnew MethodNotAllowed(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew MethodNotAllowed(statusText, headers, body, charset);\n\t\t\t\tcase NOT_ACCEPTABLE -> message != null ?\n\t\t\t\t\t\tnew NotAcceptable(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotAcceptable(statusText, headers, body, charset);\n\t\t\t\tcase CONFLICT -> message != null ?\n\t\t\t\t\t\tnew Conflict(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Conflict(statusText, headers, body, charset);\n\t\t\t\tcase GONE -> message != null ?\n\t\t\t\t\t\tnew Gone(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Gone(statusText, headers, body, charset);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE -> message != null ?\n\t\t\t\t\t\tnew UnsupportedMediaType(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnsupportedMediaType(statusText, headers, body, charset);\n\t\t\t\tcase TOO_MANY_REQUESTS -> message != null ?\n\t\t\t\t\t\tnew TooManyRequests(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew TooManyRequests(statusText, headers, body, charset);\n\t\t\t\tcase UNPROCESSABLE_ENTITY -> message != null ?\n\t\t\t\t\t\tnew UnprocessableEntity(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnprocessableEntity(statusText, headers, body, charset);\n\t\t\t\tdefault -> message != null ?\n\t\t\t\t\t\tnew HttpClientErrorException(message, statusCode, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t\t};\n\t\t}\n\t\tif (message != null) {\n\t\t\treturn new HttpClientErrorException(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\treturn new HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Object... uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Object... uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.jsf.<unknown>#callNextHandlerInChain(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "protected void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tprotected final void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler) {\n\n\t\tNavigationHandler decoratedNavigationHandler = getDecoratedNavigationHandler();\n\n\t\tif (decoratedNavigationHandler instanceof DecoratingNavigationHandler decHandler) {\n\t\t\t// DecoratingNavigationHandler specified through constructor argument:\n\t\t\t// Call it with original NavigationHandler passed in.\n\t\t\tdecHandler.handleNavigation(facesContext, fromAction, outcome, originalNavigationHandler);\n\t\t}\n\t\telse if (decoratedNavigationHandler != null) {\n\t\t\t// Standard NavigationHandler specified through constructor argument:\n\t\t\t// Call it through standard API, without original NavigationHandler passed in.\n\t\t\t// The called handler will not be able to redirect to the original handler.\n\t\t\tdecoratedNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t\telse if (originalNavigationHandler != null) {\n\t\t\t// No NavigationHandler specified through constructor argument:\n\t\t\t// Call original handler, marking the end of this chain.\n\t\t\toriginalNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleResolvedValue(arg,name,parameter,mavContainer,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param mavContainer the {@link ModelAndViewContainer} (may be {@code null})\n\t * @param webRequest the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getForUriString(uriString,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the public resource URL for the given URI string.\n\t * <p>The URI string is expected to be a path and if it contains a query or\n\t * fragment those will be preserved in the resulting public resource URL.\n\t * @param uriString the URI string to transform\n\t * @param exchange the current exchange\n\t * @return the resolved public resource URL path, or empty if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriString",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Mono<String>",
    "signature": "public Mono<String> getForUriString(String uriString, ServerWebExchange exchange)",
    "source_code": "\tpublic final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tint queryIndex = getQueryIndex(uriString);\n\t\tString lookupPath = uriString.substring(0, queryIndex);\n\t\tString query = uriString.substring(queryIndex);\n\t\tPathContainer parsedLookupPath = PathContainer.parsePath(lookupPath);\n\n\t\treturn resolveResourceUrl(exchange, parsedLookupPath).map(resolvedPath ->\n\t\t\t\trequest.getPath().contextPath().value() + resolvedPath + query);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveResource(exchange, requestPath, locations)\n\t\t\t\t.switchIfEmpty(Mono.defer(() ->\n\t\t\t\t\t\tresolveVersionedResource(exchange, requestPath, locations, chain)));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#transform(exchange,inputResource,transformerChain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "inputResource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<Resource>",
    "signature": "public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain) {\n\n\t\treturn transformerChain.transform(exchange, inputResource)\n\t\t\t\t.flatMap(outputResource -> {\n\t\t\t\t\tString filename = outputResource.getFilename();\n\t\t\t\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\t\t\t\tinputResource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\t\t\t\treturn Mono.just(outputResource);\n\t\t\t\t\t}\n\n\t\t\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\t\t\t\t\tFlux<DataBuffer> flux = DataBufferUtils\n\t\t\t\t\t\t\t.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE);\n\t\t\t\t\treturn DataBufferUtils.join(flux)\n\t\t\t\t\t\t\t.flatMap(dataBuffer -> {\n\t\t\t\t\t\t\t\tString cssContent = dataBuffer.toString(DEFAULT_CHARSET);\n\t\t\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t\t\t\treturn transformContent(cssContent, outputResource, transformerChain, exchange);\n\t\t\t\t\t\t\t});\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleNoMatch(mappings,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param exchange the current exchange\n\t * @return an alternative HandlerMethod or {@code null}\n\t * @throws Exception provides details that can be translated into an error status code\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange) throws Exception {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveName(name,parameter,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given parameter type and value name into an argument value.\n\t * @param name the name of the value being resolved\n\t * @param parameter the method parameter to resolve to an argument value\n\t * (pre-nested in case of a {@link java.util.Optional} declaration)\n\t * @param exchange the current exchange\n\t * @return the resolved argument (may be empty {@link Mono})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange)",
    "source_code": "\tprotected abstract Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange);"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#doDispatch(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the actual dispatching to the handler.\n\t * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.\n\t * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters\n\t * to find the first that supports the handler class.\n\t * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers\n\t * themselves to decide which methods are acceptable.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1048
    },
    "return": "void",
    "signature": "protected void doDispatch(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n\t\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new ServletException(\"Handler dispatch failed: \" + err, err);\n\t\t\t}\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew ServletException(\"Handler processing failed: \" + err, err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t\tasyncManager.setMultipartRequestParsed(multipartRequestParsed);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed || asyncManager.isMultipartRequestParsed()) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerPathMatcher(pathMatcherRef,context,source)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link PathMatcher}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link PathMatcher} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcherRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (pathMatcherRef != null) {\n\t\t\tif (context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(PATH_MATCHER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(pathMatcherRef.getBeanName(), PATH_MATCHER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition pathMatcherDef = new RootBeanDefinition(AntPathMatcher.class);\n\t\t\tpathMatcherDef.setSource(source);\n\t\t\tpathMatcherDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(PATH_MATCHER_BEAN_NAME, pathMatcherDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(pathMatcherDef, PATH_MATCHER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(PATH_MATCHER_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#read(b,off,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\t\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\t\treturn this.delegate.read(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tServletConfig config = this.servletConfig;\n\t\t\tif (config == null || !this.useSharedServletConfig) {\n\t\t\t\tconfig = new DelegatingServletConfig(beanName, this.servletContext);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tservlet.init(config);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Servlet.init threw exception\", ex);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleNoMatch(infos,lookupPath,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate all RequestMappingInfo's once again, look if any match by URL at\n\t * least and raise exceptions according to what doesn't match.\n\t * @throws HttpRequestMethodNotSupportedException if there are matches by URL\n\t * but not by HTTP method\n\t * @throws HttpMediaTypeNotAcceptableException if there are matches by URL\n\t * but not by consumable/producible media types\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infos",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(\n\t\t\tSet<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request) throws ServletException {\n\n\t\tif (CollectionUtils.isEmpty(infos)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPartialMatchHelper helper = new PartialMatchHelper(infos, request);\n\t\tif (helper.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (helper.hasMethodsMismatch()) {\n\t\t\tSet<String> methods = helper.getAllowedMethods();\n\t\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\t\tSet<MediaType> mediaTypes = helper.getConsumablePatchMediaTypes();\n\t\t\t\tHttpOptionsHandler handler = new HttpOptionsHandler(methods, mediaTypes);\n\t\t\t\treturn new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD);\n\t\t\t}\n\t\t\tthrow new HttpRequestMethodNotSupportedException(request.getMethod(), methods);\n\t\t}\n\n\t\tif (helper.hasConsumesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getConsumableMediaTypes();\n\t\t\tMediaType contentType = null;\n\t\t\tif (StringUtils.hasLength(request.getContentType())) {\n\t\t\t\ttry {\n\t\t\t\t\tcontentType = MediaType.parseMediaType(request.getContentType());\n\t\t\t\t}\n\t\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage(), new ArrayList<>(mediaTypes));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tcontentType, new ArrayList<>(mediaTypes), HttpMethod.valueOf(request.getMethod()));\n\t\t}\n\n\t\tif (helper.hasProducesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getProducibleMediaTypes();\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(new ArrayList<>(mediaTypes));\n\t\t}\n\n\t\tif (helper.hasParamsMismatch()) {\n\t\t\tList<String[]> conditions = helper.getParamConditions();\n\t\t\tthrow new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap());\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#data(object,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder data(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic SseEventBuilder data(Object object, @Nullable MediaType mediaType) {\n\t\t\tappend(\"data:\");\n\t\t\tsaveAppendedText();\n\t\t\tif (object instanceof String text) {\n\t\t\t\tobject = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t}\n\t\t\tthis.dataToSend.add(new DataWithMediaType(object, mediaType));\n\t\t\tappend('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestParameter(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingServletRequestParameterException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestParameter(MissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestParameter(\n\t\t\tMissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleNoResourceFoundException(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoResourceFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoResourceFoundException(NoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoResourceFoundException(\n\t\t\tNoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleServletRequestBindingException(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServletRequestBindingException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleServletRequestBindingException(ServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleServletRequestBindingException(\n\t\t\tServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#doResolveException(request,response,handler,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\t// ErrorResponse exceptions that expose HTTP response details\n\t\t\tif (ex instanceof ErrorResponse errorResponse) {\n\t\t\t\tModelAndView mav = null;\n\t\t\t\tif (ex instanceof HttpRequestMethodNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpRequestMethodNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotAcceptable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingPathVariableException theEx) {\n\t\t\t\t\tmav = handleMissingPathVariable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestParameterException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestParameter(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestPartException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestPartException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof ServletRequestBindingException theEx) {\n\t\t\t\t\tmav = handleServletRequestBindingException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MethodArgumentNotValidException theEx) {\n\t\t\t\t\tmav = handleMethodArgumentNotValidException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HandlerMethodValidationException theEx) {\n\t\t\t\t\tmav = handleHandlerMethodValidationException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof NoHandlerFoundException theEx) {\n\t\t\t\t\tmav = handleNoHandlerFoundException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof NoResourceFoundException theEx) {\n\t\t\t\t\tmav = handleNoResourceFoundException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof AsyncRequestTimeoutException theEx) {\n\t\t\t\t\tmav = handleAsyncRequestTimeoutException(theEx, request, response, handler);\n\t\t\t\t}\n\n\t\t\t\treturn (mav != null ? mav :\n\t\t\t\t\t\thandleErrorResponse(errorResponse, request, response, handler));\n\t\t\t}\n\n\t\t\t// Other, lower level exceptions\n\n\t\t\tif (ex instanceof ConversionNotSupportedException theEx) {\n\t\t\t\treturn handleConversionNotSupported(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof TypeMismatchException theEx) {\n\t\t\t\treturn handleTypeMismatch(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotReadableException theEx) {\n\t\t\t\treturn handleHttpMessageNotReadable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotWritableException theEx) {\n\t\t\t\treturn handleHttpMessageNotWritable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof MethodValidationException theEx) {\n\t\t\t\treturn handleMethodValidationException(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof AsyncRequestNotUsableException) {\n\t\t\t\treturn handleAsyncRequestNotUsableException(\n\t\t\t\t\t\t(AsyncRequestNotUsableException) ex, request, response, handler);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception handlerEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", handlerEx);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMethodArgumentNotValidException(ex,request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an argument annotated with {@code @Valid} such as\n\t * an {@link RequestBody} or {@link RequestPart} argument fails validation.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#isSelected(bindStatus,candidateValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the supplied candidate value is equal to the value bound to\n\t * the supplied {@link BindStatus}. Equality in this case differs from standard Java equality and\n\t * is described in more detail <a href=\"#equality-contract\">here</a>.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindStatus",
      "candidateValue"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue)",
    "source_code": "\tpublic static boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue) {\n\t\t// Check obvious equality matches with the candidate first,\n\t\t// both with the rendered value and with the original value.\n\t\tObject boundValue = bindStatus.getValue();\n\t\tif (ObjectUtils.nullSafeEquals(boundValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tObject actualValue = bindStatus.getActualValue();\n\t\tif (actualValue != null && actualValue != boundValue &&\n\t\t\t\tObjectUtils.nullSafeEquals(actualValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (actualValue != null) {\n\t\t\tboundValue = actualValue;\n\t\t}\n\t\telse if (boundValue == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Non-null value but no obvious equality with the candidate value:\n\t\t// go into more exhaustive comparisons.\n\t\tboolean selected = false;\n\t\tif (candidateValue != null) {\n\t\t\tif (boundValue.getClass().isArray()) {\n\t\t\t\tselected = collectionCompare(CollectionUtils.arrayToList(boundValue), candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Collection<?> collection) {\n\t\t\t\tselected = collectionCompare(collection, candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Map<?, ?> map) {\n\t\t\t\tselected = mapCompare(map, candidateValue, bindStatus);\n\t\t\t}\n\t\t}\n\t\tif (!selected) {\n\t\t\tselected = exhaustiveCompare(boundValue, candidateValue, bindStatus.getEditor(), null);\n\t\t}\n\t\treturn selected;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#applyLifecycleMethods(viewName,view)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @since 5.0\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 615
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#prepareResponse(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setCharacterEncoding(this.encoding.getJavaName());\n\t\tif (this.disableCaching) {\n\t\t\tresponse.addHeader(\"Cache-Control\", \"no-store\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#isEligibleForMarshalling(modelKey,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given value from the current view's model is eligible\n\t * for marshalling through the configured {@link Marshaller}.\n\t * <p>The default implementation calls {@link Marshaller#supports(Class)},\n\t * unwrapping a given {@link JAXBElement} first if applicable.\n\t * @param modelKey the value's key in the model (never {@code null})\n\t * @param value the value to check (never {@code null})\n\t * @return whether the given value is to be considered as eligible\n\t * @see Marshaller#supports(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "modelKey",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleForMarshalling(String modelKey, Object value)",
    "source_code": "\tprotected boolean isEligibleForMarshalling(String modelKey, Object value) {\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tClass<?> classToCheck = value.getClass();\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\tclassToCheck = jaxbElement.getDeclaredType();\n\t\t}\n\t\treturn this.marshaller.supports(classToCheck);\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handlePongMessage(session,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void handlePongMessage(WebSocketSession session, PongMessage message)",
    "source_code": "\tprotected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,handler,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn connectAsync(url, handshakeHeaders, null, handler, uriVariables);\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleWebSocketVersionNotSupported(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "void",
    "signature": "protected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tString version = request.getHeaders().getFirst(\"Sec-WebSocket-Version\");\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to unsupported WebSocket version: \" + version +\n\t\t\t\t\t\t\t\". Supported versions: \" + Arrays.toString(getSupportedVersions()), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.UPGRADE_REQUIRED);\n\t\tresponse.getHeaders().set(WebSocketHttpHeaders.SEC_WEBSOCKET_VERSION,\n\t\t\t\tStringUtils.arrayToCommaDelimitedString(getSupportedVersions()));\n\t}"
  }
}