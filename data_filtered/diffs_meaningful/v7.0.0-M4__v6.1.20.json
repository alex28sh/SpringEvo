{
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forMethod(methodName,parameterTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is optional.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, false, null);\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.store.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#retrieve(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn CompletableFuture.supplyAsync(() ->\n\t\t\t\t(T) fromStoreValue(this.store.computeIfAbsent(key, k -> toStoreValue(valueLoader.get().join()))));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doGet(cache,key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#get(Object, Callable)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#get(Object, Callable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "T",
    "signature": "protected T doGet(Cache cache, Object key, Callable<T> valueLoader)",
    "source_code": "\tprotected <T> @Nullable T doGet(Cache cache, Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.get(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\ttry {\n\t\t\t\treturn valueLoader.call();\n\t\t\t}\n\t\t\tcatch (Exception ex2) {\n\t\t\t\tthrow new Cache.ValueRetrievalException(key, valueLoader, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#forField(fieldName,resourceName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field and resource name.\n\t * @param fieldName the field name\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forField(String fieldName, String resourceName)",
    "source_code": "\tpublic static ResourceElementResolver forField(String fieldName, String resourceName) {\n\t\treturn new ResourceFieldResolver(resourceName, false, fieldName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getLazyResolutionProxyIfNecessary(descriptor,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\tpublic @Nullable Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : null);\n\t}"
  },
  "org.springframework.context.support.<unknown>#formatMessage(msg,args,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Format the given message String, using cached MessageFormats.\n\t * By default invoked for passed-in default messages, to resolve\n\t * any argument placeholders found in them.\n\t * @param msg the message to format\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none\n\t * @param locale the Locale used for formatting\n\t * @return the formatted message (with resolved arguments)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "msg",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "protected String formatMessage(String msg, Object @Nullable [] args, Locale locale)",
    "source_code": "\tprotected String formatMessage(String msg, Object @Nullable [] args, Locale locale) {\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\treturn msg;\n\t\t}\n\t\tMap<Locale, MessageFormat> messageFormatsPerLocale = this.messageFormatsPerMessage\n\t\t\t\t.computeIfAbsent(msg, key -> new ConcurrentHashMap<>());\n\t\tMessageFormat messageFormat = messageFormatsPerLocale.computeIfAbsent(locale, key -> {\n\t\t\ttry {\n\t\t\t\treturn createMessageFormat(msg, locale);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid message format - probably not intended for formatting,\n\t\t\t\t// rather using a message structure with no arguments involved...\n\t\t\t\tif (isAlwaysUseMessageFormat()) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Silently proceed with raw message if format not enforced...\n\t\t\t\treturn INVALID_MESSAGE_FORMAT;\n\t\t\t}\n\t\t});\n\t\tif (messageFormat == INVALID_MESSAGE_FORMAT) {\n\t\t\treturn msg;\n\t\t}\n\t\tsynchronized (messageFormat) {\n\t\t\treturn messageFormat.format(resolveArguments(args, locale));\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "public String getMessage(String code, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, locale);\n\t}"
  },
  "org.springframework.core.<unknown>#isAssignableFrom(type,Map<Type,matchedBefore)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1744
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of\n\t * the specified {@code annotationName} in the annotation hierarchy above\n\t * the supplied {@link AnnotatedElement} and store the results in a\n\t * {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn getAnnotations(element).stream(annotationName)\n\t\t\t\t.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotation(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within\n\t * a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "A",
    "signature": "public A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotationAttributes(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within\n\t * a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(\n\t\t\tAnnotatedElement element, Class<? extends Annotation> annotationType) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, false, false);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetType)",
    "source_code": "\tpublic <T> @Nullable T getProperty(String key, Class<T> targetType) {\n\t\treturn this.propertyResolver.getProperty(key, targetType);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getRequiredProperty(key,valueType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "T",
    "signature": "public T getRequiredProperty(String key, Class<T> valueType)",
    "source_code": "\tpublic <T> T getRequiredProperty(String key, Class<T> valueType) throws IllegalStateException {\n\t\tT value = getProperty(key, valueType);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Required key '\" + key + \"' not found\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic NettyDataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.byteBuf.readBytes(destination, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.expression.common.<unknown>#setValue(rootObject,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toShort(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a short using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "short",
    "signature": "public short toShort(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static short toShort(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Short.class);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(context,rootObject,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValueTypeDescriptor(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}"
  },
  "org.springframework.http.<unknown>#body(body,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 715
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body, Type type)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}"
  },
  "org.springframework.http.<unknown>#compare(other,strong)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a strong or weak comparison to another {@link ETag}.\n\t * @param other the ETag to compare to\n\t * @param strong whether to perform strong or weak comparison\n\t * @return whether there is a match or not\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3.2\">RFC 9110, Section 8.8.3.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "strong"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "boolean",
    "signature": "public boolean compare(ETag other, boolean strong)",
    "source_code": "\tpublic boolean compare(ETag other, boolean strong) {\n\t\tif (!StringUtils.hasLength(tag()) || !StringUtils.hasLength(other.tag())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strong && (weak() || other.weak())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tag().equals(other.tag());\n\t}"
  },
  "org.springframework.http.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 1803
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeWithRequest(request,bufferedOutput,bufferResponse)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute with the given request and body.\n\t * @param request the request to execute with\n\t * @param bufferedOutput the body to write\n\t * @param bufferResponse whether to buffer the response\n\t * @return the resulting response\n\t * @throws IOException in case of I/O errors from execution\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "bufferedOutput",
      "bufferResponse"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeWithRequest(ClientHttpRequest request, byte[] bufferedOutput, boolean bufferResponse)",
    "source_code": "\tprotected ClientHttpResponse executeWithRequest(\n\t\t\tClientHttpRequest request, byte[] bufferedOutput, boolean bufferResponse) throws IOException {\n\n\t\tif (bufferedOutput.length > 0) {\n\t\t\tlong contentLength = request.getHeaders().getContentLength();\n\t\t\tif (contentLength > -1 && contentLength != bufferedOutput.length) {\n\t\t\t\trequest.getHeaders().setContentLength(bufferedOutput.length);\n\t\t\t}\n\t\t\tif (request instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\tstreamingOutputMessage.setBody(bufferedOutput);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStreamUtils.copy(bufferedOutput, request.getBody());\n\t\t\t}\n\t\t}\n\n\t\tClientHttpResponse response = request.execute();\n\t\treturn (bufferResponse ? new BufferingClientHttpResponseWrapper(response) : response);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#execute(sql,Map<String,paramMap,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(sql, new MapSqlParameterSource(paramMap), action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getPreparedStatementCreatorFactory(parsedSql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreatorFactory} based on the given SQL and named parameters.\n\t * @param parsedSql parsed representation of the given SQL statement\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreatorFactory}\n\t * @since 5.1.3\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t * @see #getParsedSql(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "PreparedStatementCreatorFactory",
    "signature": "protected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tprotected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource) {\n\n\t\tString sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\n\t\tList<SqlParameter> declaredParameters = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);\n\t\treturn new PreparedStatementCreatorFactory(sqlToUse, declaredParameters);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,Map<String,paramMap,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,Map<String,paramMap,rse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "T",
    "signature": "public T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, new MapSqlParameterSource(paramMap), rse);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,paramSource,elementType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new SingleColumnRowMapper<>(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForObject(sql,Map<String,paramMap,RowMapper<T>rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "RowMapper<T>rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#execute(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object>",
    "signature": "public Object> execute(Map<String, ?> args)",
    "source_code": "\tpublic Map<String, Object> execute(Map<String, ?> args) {\n\t\treturn doExecute(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#matchInParameterValuesWithInsertColumns(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the provided in parameter values with registered parameters and parameters\n\t * defined via meta-data processing.\n\t * @param args the parameter values provided as a Map\n\t * @return a List of values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 647
    },
    "return": "List<Object>",
    "signature": "protected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args)",
    "source_code": "\tprotected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args) {\n\t\treturn this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#customizeConfigurer(type,customizer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer customizeConfigurer(EmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer(\n\t\t\tEmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer) {\n\n\t\tEmbeddedDatabaseConfigurer defaultConfigurer = getConfigurer(type);\n\t\treturn customizer.apply(defaultConfigurer);\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBinaryStream(pos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "InputStream",
    "signature": "public InputStream getBinaryStream(long pos, long length)",
    "source_code": "\tpublic InputStream getBinaryStream(long pos, long length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getDate(columnIndex,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Date",
    "signature": "public Date getDate(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Date getDate(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDate(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerEndpoint(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#addSession(session,connection)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given Session to this resource holder,\n\t * registered for a specific Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void addSession(Session session, @Nullable Connection connection)",
    "source_code": "\tpublic final void addSession(Session session, @Nullable Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Session because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tif (!this.sessions.contains(session)) {\n\t\t\tthis.sessions.add(session);\n\t\t\tif (connection != null) {\n\t\t\t\tDeque<Session> sessions =\n\t\t\t\t\t\tthis.sessionsPerConnection.computeIfAbsent(connection, k -> new ArrayDeque<>());\n\t\t\t\tsessions.add(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,payload,Map<String,headers,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tMessage<?> message = doConvert(payload, headers, postProcessor);\n\t\tsend(destinationName, message);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(destinationName,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "protected void doSend(String destinationName, Message<?> message)",
    "source_code": "\tprotected void doSend(String destinationName, Message<?> message) {\n\t\ttry {\n\t\t\tobtainJmsTemplate().send(destinationName, createMessageCreator(message));\n\t\t}\n\t\tcatch (JmsException ex) {\n\t\t\tthrow convertJmsException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#getAttributeName(property,useStrictCasing)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMX attribute name to use for the given JavaBeans property.\n\t * <p>When using strict casing, a JavaBean property with a getter method\n\t * such as {@code getFoo()} translates to an attribute called\n\t * {@code Foo}. With strict casing disabled, {@code getFoo()}\n\t * would translate to just {@code foo}.\n\t * @param property the JavaBeans property descriptor\n\t * @param useStrictCasing whether to use strict casing\n\t * @return the JMX attribute name to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "useStrictCasing"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String getAttributeName(PropertyDescriptor property, boolean useStrictCasing)",
    "source_code": "\tpublic static String getAttributeName(PropertyDescriptor property, boolean useStrictCasing) {\n\t\tif (useStrictCasing) {\n\t\t\treturn StringUtils.capitalize(property.getName());\n\t\t}\n\t\telse {\n\t\t\treturn property.getName();\n\t\t}\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#getBean(name,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object",
    "signature": "public Object getBean(String name, @Nullable Object @Nullable ... args)",
    "source_code": "\tpublic Object getBean(String name, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(name);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destination,request,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(destination, request, null, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#receiveAndConvert(destinationName,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "T",
    "signature": "public T receiveAndConvert(String destinationName, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) {\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.receiveAndConvert(destination, targetClass);\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#tcp(host,port)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "port"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester tcp(String host, int port)",
    "source_code": "\tpublic RSocketRequester tcp(String host, int port) {\n\t\treturn transport(TcpClientTransport.create(host, port));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendRedirect(url,sc,clearBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 646
    },
    "return": "void",
    "signature": "public void sendRedirect(String url, int sc, boolean clearBuffer)",
    "source_code": "\tpublic void sendRedirect(String url, int sc, boolean clearBuffer) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot send redirect - response is already committed\");\n\t\tAssert.notNull(url, \"Redirect URL must not be null\");\n\t\tsetHeader(HttpHeaders.LOCATION, url);\n\t\tsetStatus(sc);\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void lock(Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#persist(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "public void persist(String entityName, Object entity)",
    "source_code": "\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#get(timeout,unit)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}"
  },
  "org.springframework.test.context.<unknown>#findAnnotationDescriptor(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}\n\t * on the supplied {@link Class}, traversing its annotations, interfaces,\n\t * superclasses, and enclosing classes if no annotation can be found on the\n\t * given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return a corresponding\n\t * {@code AnnotationDescriptor} if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the corresponding annotation descriptor if the annotation was found;\n\t * otherwise {@code null}\n\t * @see #findAnnotationDescriptorForTypes(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "AnnotationDescriptor<T>",
    "signature": "public AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable AnnotationDescriptor<T> findAnnotationDescriptor(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\tAssert.notNull(annotationType, \"Annotation type must not be null\");\n\t\treturn findAnnotationDescriptor(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass,\n\t\t\tnew HashSet<>());\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertBoolean(content,encoding,expectedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Boolean.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue)",
    "source_code": "\tpublic void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, Boolean.parseBoolean(actual));\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNodeList(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link NodeList},\n\t * and assert it with the given {@code Matcher<NodeList>}.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)",
    "source_code": "\tpublic void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)\n\t\t\tthrows Exception {\n\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\tNodeList nodeList = evaluateXpath(document, XPathConstants.NODESET, NodeList.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + getXpathExpression(), nodeList, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetClass,name,value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the static {@linkplain Field field} with the given\n\t * {@code name}/{@code type} on the provided {@code targetClass} to\n\t * the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setField(Class<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField(\n\t\t\tClass<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\n\t\tsetField(null, targetClass, name, value, type);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetObject,name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name} on the\n\t * provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, String, Object, Class)},\n\t * supplying {@code null} for the {@code type} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setField(Object targetObject, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Object targetObject, String name, @Nullable Object value) {\n\t\tsetField(targetObject, name, value, null);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(json,strict)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "json",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String json, boolean strict)",
    "source_code": "\t\tpublic BodyContentSpec json(String json, boolean strict) {\n\t\t\tJsonCompareMode compareMode = (strict ? JsonCompareMode.STRICT : JsonCompareMode.LENIENT);\n\t\t\treturn json(json, compareMode);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#map(source,targetType,configuration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType",
      "configuration"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "T",
    "signature": "public T map(Object source, TypeRef<T> targetType, Configuration configuration)",
    "source_code": "\tpublic <T> @Nullable T map(Object source, TypeRef<T> targetType, Configuration configuration) {\n\t\treturn mapToTargetType(source, ResolvableType.forType(targetType.getType()));\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultWebTestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#from(applicationContext,Function<DefaultMockMvcBuilder,customizations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext",
      "Function<DefaultMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations) {\n\n\t\tDefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(applicationContext);\n\t\tMockMvc mockMvc = customizations.apply(builder);\n\t\treturn create(mockMvc);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#isInvokedOn(controllerType,Function<T,handlerMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "Function<T",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.util.<unknown>#addResourcePathToPackagePath(clazz,resourceName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "String",
    "signature": "public String addResourcePathToPackagePath(Class<?> clazz, String resourceName)",
    "source_code": "\tpublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n\t\tAssert.notNull(resourceName, \"Resource name must not be null\");\n\t\tif (!resourceName.startsWith(\"/\")) {\n\t\t\treturn classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\n\t\t}\n\t\treturn classPackageAsResourcePath(clazz) + resourceName;\n\t}"
  },
  "org.springframework.util.<unknown>#compare(mimeType1,mimeType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "int",
    "signature": "public int compare(T mimeType1, T mimeType2)",
    "source_code": "\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#getMethodCountForName(clazz,methodName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of methods with a given name (with any argument types),\n\t * for the given class and/or its superclasses. Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return the number of methods with the given name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 1288
    },
    "return": "int",
    "signature": "public int getMethodCountForName(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static int getMethodCountForName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tint count = 0;\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tcount += getMethodCountForName(ifc, methodName);\n\t\t}\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tcount += getMethodCountForName(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.<unknown>#getPubliclyAccessibleMethodIfPossible(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first publicly accessible method in the supplied method's type hierarchy that\n\t * has a method signature equivalent to the supplied method, if possible.\n\t * <p>If the supplied method is {@code public} and declared in a {@code public} type,\n\t * the supplied method will be returned.\n\t * <p>Otherwise, this method recursively searches the class hierarchy and implemented\n\t * interfaces for an equivalent method that is {@code public} and declared in a\n\t * {@code public} type.\n\t * <p>If a publicly accessible equivalent method cannot be found, the supplied method\n\t * will be returned, indicating that no such equivalent method exists. Consequently,\n\t * callers of this method must manually validate the accessibility of the returned method\n\t * if public access is a requirement.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning. This is also useful for invoking methods via a public API in bytecode\n\t * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\n\t * For example, if a non-public class overrides {@code toString()}, this method will\n\t * traverse up the type hierarchy to find the first public type that declares the method\n\t * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding publicly accessible method, or the original method if none found\n\t * @since 6.2\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1483
    },
    "return": "Method",
    "signature": "public Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\t// If the method is not public, we can abort the search immediately; or if the method's\n\t\t// declaring class is public, the method is already publicly accessible.\n\t\tif (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\treturn method;\n\t\t}\n\n\t\tMethod interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\n\t\t// If we found a method in a public interface, return the interface method.\n\t\tif (!interfaceMethod.equals(method)) {\n\t\t\treturn interfaceMethod;\n\t\t}\n\n\t\tMethod result = publiclyAccessibleMethodCache.computeIfAbsent(method,\n\t\t\t\tkey -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\n\t\treturn (result != null ? result : method);\n\t}"
  },
  "org.springframework.util.<unknown>#getQualifiedMethodName(method,clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1147
    },
    "return": "String",
    "signature": "public String getQualifiedMethodName(Method method, @Nullable Class<?> clazz)",
    "source_code": "\tpublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n\t}"
  },
  "org.springframework.util.<unknown>#handleUnresolvablePlaceholder(key,text)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "text"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "String",
    "signature": "public String handleUnresolvablePlaceholder(String key, String text)",
    "source_code": "\t\tpublic String handleUnresolvablePlaceholder(String key, String text) {\n\t\t\tif (this.ignoreUnresolvablePlaceholders) {\n\t\t\t\treturn toPlaceholderText(key);\n\t\t\t}\n\t\t\tString originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\n\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#hasConstructor(clazz,paramTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public constructor with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding constructor\n\t * @see Class#getConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1160
    },
    "return": "boolean",
    "signature": "public boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)",
    "source_code": "\tpublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n\t\treturn (getConstructorIfAvailable(clazz, paramTypes) != null);\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(superType,subType,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending subtype\n\t * will be appended. In any other case, a \":\" with a space and the name of the\n\t * offending subtype will be appended.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isCacheSafe(clazz,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is cache-safe in the given context,\n\t * i.e. whether it is loaded by the given ClassLoader or a parent of it.\n\t * @param clazz the class to analyze\n\t * @param classLoader the ClassLoader to potentially cache metadata in\n\t * (can be {@code null} which indicates the system class loader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "boolean",
    "signature": "public boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tClassLoader target = clazz.getClassLoader();\n\t\t\t// Common cases\n\t\t\tif (target == classLoader || target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (classLoader == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Check for match in ancestors -> positive\n\t\t\tClassLoader current = classLoader;\n\t\t\twhile (current != null) {\n\t\t\t\tcurrent = current.getParent();\n\t\t\t\tif (current == target) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for match in children -> negative\n\t\t\twhile (target != null) {\n\t\t\t\ttarget = target.getParent();\n\t\t\t\tif (target == classLoader) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Fallback for ClassLoaders without parent/child relationship:\n\t\t// safe if same Class can be loaded from given ClassLoader\n\t\treturn (classLoader != null && isLoadable(clazz, classLoader));\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(Map<?,map,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\n\t * @param map the map to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Map<?, ?> map, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Map<?, ?> map, String message) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notNull(object,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.notNull(entity.getId(),\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#split(toSplit,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1078
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.validation.method.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.errors.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#rejectValue(field,errorCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.errors.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveExceptionMappingByExceptionType(exceptionType,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (for example, for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType)",
    "source_code": "\tpublic @Nullable ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToFlux(Function<ClientResponse,responseHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "Flux<V>",
    "signature": "public Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler) {\n\t\t\treturn exchange().flatMapMany(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.concatWith(Flux.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bodyValue(body,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\treturn initBuilder(body, BodyInserters.fromValue(body, bodyType));\n\t}"
  },
  "org.springframework.web.reactive.result.condition.<unknown>#compareTo(other,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int compareTo(ProducesRequestCondition other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(ProducesRequestCondition other, ServerWebExchange exchange) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (NotAcceptableStatusException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#format(fragmentFlux,fragment,hints,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragmentFlux",
      "fragment",
      "hints",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> format(Flux<DataBuffer> fragmentFlux, Fragment fragment, @Nullable Object hints,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic Flux<DataBuffer> format(\n\t\t\t\tFlux<DataBuffer> fragmentFlux, Fragment fragment, @Nullable Object hints,\n\t\t\t\tServerWebExchange exchange) {\n\n\t\t\tMediaType mediaType = exchange.getResponse().getHeaders().getContentType();\n\t\t\tCharset charset = (mediaType != null && mediaType.getCharset() != null ?\n\t\t\t\t\tmediaType.getCharset() : StandardCharsets.UTF_8);\n\t\t\tAssert.state(hints == null || hints instanceof ServerSentEvent, \"Expected ServerSentEvent\");\n\n\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\n\t\t\tServerSentEvent<?> sse = (ServerSentEvent<?>) hints;\n\t\t\tCharSequence eventText = (sse != null ? sse.format() :\n\t\t\t\t\t(fragment.viewName() != null ? \"event:\" + fragment.viewName() + \"\\n\" : \"\") + \"data:\");\n\n\t\t\tDataBuffer prefix = encodeText(eventText.toString(), charset, bufferFactory);\n\t\t\tDataBuffer suffix = encodeText(\"\\n\\n\", charset, bufferFactory);\n\n\t\t\tMono<DataBuffer> content = DataBufferUtils.join(fragmentFlux)\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tString text;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttext = buffer.toString(charset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext = text.replace(\"\\n\", \"\\ndata:\");\n\t\t\t\t\t\treturn bufferFactory.wrap(text.getBytes(charset));\n\t\t\t\t\t});\n\n\t\t\treturn Flux.concat(Flux.just(prefix), content, Flux.just(suffix));\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#sendRedirect(targetUrl,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param targetUrl the target URL to redirect to\n\t * @param exchange current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange) {\n\t\tString transformedUrl = (isRemoteHost(targetUrl) ? targetUrl : exchange.transformUrl(targetUrl));\n\t\tServerHttpResponse response = exchange.getResponse();\n\t\tresponse.getHeaders().setLocation(URI.create(transformedUrl));\n\t\tresponse.setStatusCode(getStatusCode());\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#checkNotModified(eTag,lastModified)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eTag",
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String eTag, Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#process(method,arguments,builder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "arguments",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void process(Method method, @Nullable Object[] arguments, HttpRequestValues.Builder builder)",
    "source_code": "\t\tpublic void process(Method method, @Nullable Object[] arguments, HttpRequestValues.Builder builder) {\n\t\t\tfor (HttpRequestValues.Processor processor : this.processors) {\n\t\t\t\tprocessor.process(method, arguments, builder);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#findMatchingViewName(exceptionMappings,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a matching view name in the given exception mappings.\n\t * @param exceptionMappings mappings between exception class names and error view names\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the view name, or {@code null} if none found\n\t * @see #setExceptionMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionMappings",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "String",
    "signature": "protected String findMatchingViewName(Properties exceptionMappings, Exception ex)",
    "source_code": "\tprotected @Nullable String findMatchingViewName(Properties exceptionMappings, Exception ex) {\n\t\tString viewName = null;\n\t\tString dominantMapping = null;\n\t\tint deepest = Integer.MAX_VALUE;\n\t\tfor (Enumeration<?> names = exceptionMappings.propertyNames(); names.hasMoreElements();) {\n\t\t\tString exceptionMapping = (String) names.nextElement();\n\t\t\tint depth = getDepth(exceptionMapping, ex);\n\t\t\tif (depth >= 0 && (depth < deepest || (depth == deepest &&\n\t\t\t\t\tdominantMapping != null && exceptionMapping.length() > dominantMapping.length()))) {\n\t\t\t\tdeepest = depth;\n\t\t\t\tdominantMapping = exceptionMapping;\n\t\t\t\tviewName = exceptionMappings.getProperty(exceptionMapping);\n\t\t\t}\n\t\t}\n\t\tif (viewName != null && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Resolving to view '\" + viewName + \"' based on mapping [\" + dominantMapping + \"]\");\n\t\t}\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#preHandle(request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tString newLocale = request.getParameter(getParamName());\n\t\tif (newLocale != null) {\n\t\t\tif (checkHttpMethod(request.getMethod())) {\n\t\t\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\t\t\tif (localeResolver == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"No LocaleResolver found: not in a DispatcherServlet request?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlocaleResolver.setLocale(request, response, parseLocaleValue(newLocale));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (isIgnoreInvalidLocale()) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Ignoring invalid locale value [\" + newLocale + \"]: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Proceed in any case.\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleBindException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#applyCacheSeconds(response,cacheSeconds)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given cache seconds and generate corresponding HTTP headers,\n\t * i.e. allow caching for the given number of seconds in case of a positive\n\t * value, prevent caching if given a 0 value, do nothing else.\n\t * Does not tell the browser to revalidate the resource.\n\t * @param response current HTTP response\n\t * @param cacheSeconds positive number of seconds into the future that the\n\t * response should be cacheable for, 0 to prevent caching\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "cacheSeconds"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void applyCacheSeconds(HttpServletResponse response, int cacheSeconds)",
    "source_code": "\tprotected final void applyCacheSeconds(HttpServletResponse response, int cacheSeconds) {\n\t\tCacheControl cControl;\n\t\tif (cacheSeconds > 0) {\n\t\t\tcControl = CacheControl.maxAge(cacheSeconds, TimeUnit.SECONDS);\n\t\t}\n\t\telse if (cacheSeconds == 0) {\n\t\t\tcControl = CacheControl.noStore();\n\t\t}\n\t\telse {\n\t\t\tcControl = CacheControl.empty();\n\t\t}\n\t\tapplyCacheControl(response, cControl);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 826
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}"
  },
  "org.springframework.web.util.<unknown>#build(Map<String,uriVars)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVars)",
    "source_code": "\t\tpublic URI build(Map<String, ?> uriVars) {\n\t\t\tif (!CollectionUtils.isEmpty(defaultUriVariables)) {\n\t\t\t\tMap<String, Object> map = new HashMap<>(defaultUriVariables.size() + uriVars.size());\n\t\t\t\tmap.putAll(defaultUriVariables);\n\t\t\t\tmap.putAll(uriVars);\n\t\t\t\turiVars = map;\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.VALUES_ONLY)) {\n\t\t\t\turiVars = UriUtils.encodeUriVariables(uriVars);\n\t\t\t}\n\t\t\tUriComponents uric = this.uriComponentsBuilder.build().expand(uriVars);\n\t\t\treturn createUri(uric);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#decode(source,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component value by replacing each\n\t * \"<i>{@code %xy}</i>\" sequence with a hexadecimal representation of the\n\t * character in the specified character encoding, leaving other characters\n\t * unmodified.\n\t * @param source the encoded URI component value\n\t * @param charset the character encoding to use to decode the \"<i>{@code %xy}</i>\"\n\t * sequences\n\t * @return the decoded value\n\t * @throws IllegalArgumentException if the given source contains invalid encoded\n\t * sequences\n\t * @since 5.0\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String) java.net.URLDecoder#decode\n\t * for HTML form decoding\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "String",
    "signature": "public String decode(String source, Charset charset)",
    "source_code": "\tpublic static String decode(String source, Charset charset) {\n\t\treturn StringUtils.uriDecode(source, charset);\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParam(name,values)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\treturn queryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  }
}