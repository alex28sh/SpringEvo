{
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#invokeMethod(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\tpublic Object invokeMethod(String name, Object args) {\n\t\treturn this.metaClass.invokeMethod(this, name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#load(relativeClass,resourceNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeClass",
      "resourceNames"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void load(Class<?> relativeClass, String... resourceNames)",
    "source_code": "\tpublic void load(Class<?> relativeClass, String... resourceNames) {\n\t\tResource[] resources = new Resource[resourceNames.length];\n\t\tfor (int i = 0; i < resourceNames.length; i++) {\n\t\t\tresources[i] = new ClassPathResource(resourceNames[i], relativeClass);\n\t\t}\n\t\tload(resources);\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tif (bean instanceof ApplicationListener<?> applicationListener) {\n\t\t\ttry {\n\t\t\t\tApplicationEventMulticaster multicaster = this.applicationContext.getApplicationEventMulticaster();\n\t\t\t\tmulticaster.removeApplicationListener(applicationListener);\n\t\t\t\tmulticaster.removeApplicationListenerBean(beanName);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t// ApplicationEventMulticaster not initialized yet - no need to remove a listener\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerAlias(beanName,alias)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void registerAlias(String beanName, String alias)",
    "source_code": "\tpublic void registerAlias(String beanName, String alias) {\n\t\tthis.beanFactory.registerAlias(beanName, alias);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,constructorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(null, beanClass, constructorArgs);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\t@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(beanName, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * <p>This method can be overridden to adapt the registration mechanism for\n\t * all {@code registerBean} methods (since they all delegate to this one).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean (in case\n\t * of {@code null}, resolving a public constructor to be autowired instead)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tClassDerivedBeanDefinition beanDefinition = new ClassDerivedBeanDefinition(beanClass);\n\t\tif (supplier != null) {\n\t\t\tbeanDefinition.setInstanceSupplier(supplier);\n\t\t}\n\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\tcustomizer.customize(beanDefinition);\n\t\t}\n\n\t\tString nameToUse = (beanName != null ? beanName : beanClass.getName());\n\t\tregisterBeanDefinition(nameToUse, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tthis.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#setProperty(property,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer read(byte[] destination, int offset, int length) {\n\t\tAssert.notNull(destination, \"Byte array must not be null\");\n\t\tassertIndex(this.readPosition <= this.writePosition - length,\n\t\t\t\t\"readPosition %d and length %d should be smaller than writePosition %d\",\n\t\t\t\tthis.readPosition, length, this.writePosition);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.readPosition + length;\n\t\ttmp.clear().position(this.readPosition).limit(limit);\n\t\ttmp.get(destination, offset, length);\n\n\t\tthis.readPosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer slice(int index, int length)",
    "source_code": "\tpublic DefaultDataBuffer slice(int index, int length) {\n\t\tcheckIndex(index, length);\n\t\tint oldPosition = this.byteBuffer.position();\n\t\ttry {\n\t\t\tthis.byteBuffer.position(index);\n\t\t\tByteBuffer slice = this.byteBuffer.slice();\n\t\t\tslice.limit(length);\n\t\t\treturn new SlicedDefaultDataBuffer(slice, this.dataBufferFactory, length);\n\t\t}\n\t\tfinally {\n\t\t\tthis.byteBuffer.position(oldPosition);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer write(byte[] source, int offset, int length) {\n\t\tAssert.notNull(source, \"Byte array must not be null\");\n\t\tensureWritable(length);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.writePosition + length;\n\t\ttmp.clear().position(this.writePosition).limit(limit);\n\t\ttmp.put(source, offset, length);\n\n\t\tthis.writePosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tHttpClientContext context = this.contextProvider.apply(method, uri);\n\n\t\tif (context.getCookieStore() == null) {\n\t\t\tcontext.setCookieStore(new BasicCookieStore());\n\t\t}\n\n\t\tHttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,\n\t\t\t\tcontext, this.dataBufferFactory);\n\n\t\treturn requestCallback.apply(request).then(Mono.defer(() -> execute(request, context)));\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canRead(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.decoder.canDecode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decode(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decodeToMono(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,elementType,mediaType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tmediaType = (mediaType != null && mediaType.getCharset() != null ? mediaType : DEFAULT_MEDIA_TYPE);\n\t\tDataBufferFactory bufferFactory = message.bufferFactory();\n\n\t\tmessage.getHeaders().setContentType(mediaType);\n\t\treturn message.writeAndFlushWith(encode(input, elementType, mediaType, bufferFactory, hints));\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tHttpHeaders headers = response.getHeaders();\n\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\n\t\tList<HttpRange> ranges;\n\t\ttry {\n\t\t\tranges = request.getHeaders().getRange();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tresponse.setStatusCode(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE);\n\t\t\treturn response.setComplete();\n\t\t}\n\n\t\treturn Mono.from(inputStream).flatMap(resource -> {\n\t\t\tif (ranges.isEmpty()) {\n\t\t\t\treturn writeResource(resource, elementType, mediaType, response, hints);\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.PARTIAL_CONTENT);\n\t\t\tList<ResourceRegion> regions = HttpRange.toResourceRegions(ranges, resource);\n\t\t\tMediaType resourceMediaType = getResourceMediaType(mediaType, resource, hints);\n\t\t\tif (regions.size() == 1){\n\t\t\t\tResourceRegion region = regions.get(0);\n\t\t\t\theaders.setContentType(resourceMediaType);\n\t\t\t\tlong contentLength = lengthOf(resource);\n\t\t\t\tif (contentLength != -1) {\n\t\t\t\t\tlong start = region.getPosition();\n\t\t\t\t\tlong end = start + region.getCount() - 1;\n\t\t\t\t\tend = Math.min(end, contentLength - 1);\n\t\t\t\t\theaders.add(\"Content-Range\", \"bytes \" + start + '-' + end + '/' + contentLength);\n\t\t\t\t\theaders.setContentLength(end - start + 1);\n\t\t\t\t}\n\t\t\t\treturn writeSingleRegion(region, response, hints);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString boundary = MimeTypeUtils.generateMultipartBoundaryString();\n\t\t\t\tMediaType multipartType = MediaType.parseMediaType(\"multipart/byteranges;boundary=\" + boundary);\n\t\t\t\theaders.setContentType(multipartType);\n\t\t\t\tMap<String, Object> allHints = Hints.merge(hints, ResourceRegionEncoder.BOUNDARY_STRING_HINT, boundary);\n\t\t\t\treturn encodeAndWriteRegions(Flux.fromIterable(regions), resourceMediaType, response, allHints);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeReader(reader,elementType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param elementType the target type of element values to read to\n\t * @param hints a map with serialization hints;\n\t * the Reactor Context, when available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectReader} to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectReader customizeReader(\n\t\t\tObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn reader;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getJavaType(type,contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MimeType,registrar)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and supported\n\t * {@link #getMimeTypes() MimeTypes} for the given class. Therefore it is\n\t * important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MimeType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MimeType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#read(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Part>>",
    "signature": "public Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<MultiValueMap<String, Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints) {\n\n\t\treturn Flux.from(readMono(elementType, message, hints));\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#write(parts,elementType,mediaType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parts",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\tbyte[] boundary = generateMultipartBoundary();\n\n\t\tmediaType = getMultipartMediaType(mediaType, boundary);\n\t\toutputMessage.getHeaders().setContentType(mediaType);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Encoding Publisher<Part>\");\n\t\t}\n\n\t\tFlux<DataBuffer> body = Flux.from(parts)\n\t\t\t\t.concatMap(part -> encodePart(boundary, part, outputMessage.bufferFactory()))\n\t\t\t\t.concatWith(generateLastLine(boundary, outputMessage.bufferFactory()))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\n\t\treturn outputMessage.writeWith(body);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#registerWithDefaultConfig(codec,configConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "configConsumer"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "BufferedImage",
    "signature": "public BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tImageInputStream imageInputStream = null;\n\t\tImageReader imageReader = null;\n\t\t// We cannot use try-with-resources here for the ImageInputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\timageInputStream = createImageInputStream(inputMessage.getBody());\n\t\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\t\tif (contentType == null) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"No Content-Type header\", inputMessage);\n\t\t\t}\n\t\t\tIterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(contentType.toString());\n\t\t\tif (imageReaders.hasNext()) {\n\t\t\t\timageReader = imageReaders.next();\n\t\t\t\tImageReadParam irp = imageReader.getDefaultReadParam();\n\t\t\t\tprocess(irp);\n\t\t\t\timageReader.setInput(imageInputStream, true);\n\t\t\t\treturn imageReader.read(0, irp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\"Could not find javax.imageio.ImageReader for Content-Type [\" + contentType + \"]\",\n\t\t\t\t\t\tinputMessage);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (imageReader != null) {\n\t\t\t\timageReader.dispose();\n\t\t\t}\n\t\t\tif (imageInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\timageInputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, e.g. via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<AnnotationIntrospector, AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializerByType(type,deserializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom deserializer for the given type.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "deserializer"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer) {\n\t\tthis.deserializers.put(type, deserializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializersByType(Map<Class<?>,deserializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers for the given types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIn(target,mixinSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param target class (or interface) whose annotations to effectively override\n\t * @param mixinSource class (or interface) whose annotations are to be \"added\"\n\t * to target's annotations as value\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "mixinSource"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource) {\n\t\tthis.mixIns.put(target, mixinSource);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#visibility(accessor,visibility)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessor",
      "visibility"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#isAsyncReturnValue(returnValue,returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "boolean",
    "signature": "public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType)",
    "source_code": "\tpublic boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\treturn (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\tasyncHandler.isAsyncReturnValue(returnValue, returnType));\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException{\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveBeanByName(name,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\t\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(propertySources,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,\n\t * ServletContext, ServletConfig)} that always provides {@code null} for the\n\t * {@link ServletConfig} parameter.\n\t * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertySources",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {\n\t\tinitServletPropertySources(propertySources, servletContext, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(sources,servletContext,servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with\n\t * actual instances populated with the given {@code servletContext} and\n\t * {@code servletConfig} objects.\n\t * <p>This method is idempotent with respect to the fact it may be called any number\n\t * of times but will perform replacement of stub property sources with their\n\t * corresponding actual property sources once and only once.\n\t * @param sources the {@link MutablePropertySources} to initialize (must not\n\t * be {@code null})\n\t * @param servletContext the current {@link ServletContext} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME\n\t * servlet context property source} has already been initialized)\n\t * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME\n\t * servlet config property source} has already been initialized)\n\t * @see org.springframework.core.env.PropertySource.StubPropertySource\n\t * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sources",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tAssert.notNull(sources, \"'propertySources' must not be null\");\n\t\tString name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;\n\t\tif (servletContext != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletContextPropertySource(name, servletContext));\n\t\t}\n\t\tname = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;\n\t\tif (servletConfig != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletConfigPropertySource(name, servletConfig));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (getServletContext() != null && bean instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(getServletContext());\n\t\t}\n\t\tif (getServletConfig() != null && bean instanceof ServletConfigAware servletConfigAware) {\n\t\t\tservletConfigAware.setServletConfig(getServletConfig());\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,servletContext,servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tif (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);\n\t\t}\n\n\t\tif (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {\n\t\t\tMap<String, String> parameterMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletContext.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletContext.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (servletConfig != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletConfig.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletConfig.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(parameterMap));\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {\n\t\t\tMap<String, Object> attributeMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> attrNameEnum = servletContext.getAttributeNames();\n\t\t\t\twhile (attrNameEnum.hasMoreElements()) {\n\t\t\t\t\tString attrName = (String) attrNameEnum.nextElement();\n\t\t\t\t\tattributeMap.put(attrName, servletContext.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(attributeMap));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue instanceof Map map) {\n\t\t\tmavContainer.addAllAttributes(map);\n\t\t}\n\t\telse if (returnValue != null) {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type [\" +\n\t\t\t\t\treturnType.getParameterType().getName() + \"] in method: \" + returnType.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveName(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\n\t\tif (servletRequest != null) {\n\t\t\tObject mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);\n\t\t\tif (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {\n\t\t\t\treturn mpArg;\n\t\t\t}\n\t\t}\n\n\t\tObject arg = null;\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(name);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\targ = (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\tif (arg == null) {\n\t\t\tString[] paramValues = request.getParameterValues(name);\n\t\t\tif (paramValues != null) {\n\t\t\t\targ = (paramValues.length == 1 ? paramValues[0] : paramValues);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#removeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the given attributes from the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tfor (String key : attributes.keySet()) {\n\t\t\t\tgetModel().remove(key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#setBinding(attributeName,enabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register whether data binding should occur for a corresponding model attribute,\n\t * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.\n\t * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},\n\t * a hard {@link #setBindingDisabled} declaration will always override it.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "enabled"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setBinding(String attributeName, boolean enabled)",
    "source_code": "\tpublic void setBinding(String attributeName, boolean enabled) {\n\t\tif (!enabled) {\n\t\t\tthis.noBinding.add(attributeName);\n\t\t}\n\t\telse {\n\t\t\tthis.noBinding.remove(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#buildAndExpand(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code UriComponents} instance and replaces URI template variables\n\t * with the values from a map. This is a shortcut method which combines\n\t * calls to {@link #build()} and then {@link UriComponents#expand(Map)}.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI components with expanded values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "UriComponents",
    "signature": "public UriComponents buildAndExpand(Map<String, ?> uriVariables)",
    "source_code": "\tpublic UriComponents buildAndExpand(Map<String, ?> uriVariables) {\n\t\treturn build().expand(uriVariables);\n\t}"
  },
  "org.springframework.web.util.<unknown>#parseForwardedFor(request,remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7239#section-5.2\">RFC 7239, Section 5.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor(\n\t\t\tHttpRequest request, @Nullable InetSocketAddress remoteAddress) {\n\n\t\tint port = (remoteAddress != null ?\n\t\t\t\tremoteAddress.getPort() : \"https\".equals(request.getURI().getScheme()) ? 443 : 80);\n\n\t\tString forwardedHeader = request.getHeaders().getFirst(\"Forwarded\");\n\t\tif (StringUtils.hasText(forwardedHeader)) {\n\t\t\tString forwardedToUse = StringUtils.tokenizeToStringArray(forwardedHeader, \",\")[0];\n\t\t\tMatcher matcher = FORWARDED_FOR_PATTERN.matcher(forwardedToUse);\n\t\t\tif (matcher.find()) {\n\t\t\t\tString value = matcher.group(1).trim();\n\t\t\t\tString host = value;\n\t\t\t\tint portSeparatorIdx = value.lastIndexOf(':');\n\t\t\t\tint squareBracketIdx = value.lastIndexOf(']');\n\t\t\t\tif (portSeparatorIdx > squareBracketIdx) {\n\t\t\t\t\tif (squareBracketIdx == -1 && value.indexOf(':') != portSeparatorIdx) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid IPv4 address: \" + value);\n\t\t\t\t\t}\n\t\t\t\t\thost = value.substring(0, portSeparatorIdx);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tport = Integer.parseInt(value, portSeparatorIdx + 1, value.length(), 10);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Failed to parse a port from \\\"forwarded\\\"-type header value: \" + value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn InetSocketAddress.createUnresolved(host, port);\n\t\t\t}\n\t\t}\n\n\t\tString forHeader = request.getHeaders().getFirst(\"X-Forwarded-For\");\n\t\tif (StringUtils.hasText(forHeader)) {\n\t\t\tString host = StringUtils.tokenizeToStringArray(forHeader, \",\")[0];\n\t\t\treturn InetSocketAddress.createUnresolved(host, port);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\treturn queryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParamIfPresent(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\tpublic UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\tvalue.ifPresent(v -> {\n\t\t\tif (v instanceof Collection<?> values) {\n\t\t\t\tqueryParam(name, values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueryParam(name, v);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tthis.queryParams.addAll(params);\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\treturn replaceQueryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tthis.queryParams.clear();\n\t\tif (params != null) {\n\t\t\tthis.queryParams.putAll(params);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#setParsedRequestPath(requestPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the cached, parsed {@code RequestPath} to the given value.\n\t * @param requestPath the value to set to, or if {@code null} the cache\n\t * value is cleared.\n\t * @param request the current request\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request)",
    "source_code": "\tpublic static void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request) {\n\t\tif (requestPath != null) {\n\t\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\t}\n\t\telse {\n\t\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#uriVariables(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure URI variables to be expanded at build time.\n\t * <p>The provided variables may be a subset of all required ones. At build\n\t * time, the available ones are expanded, while unresolved URI placeholders\n\t * are left in place and can still be expanded later.\n\t * <p>In contrast to {@link UriComponents#expand(Map)} or\n\t * {@link #buildAndExpand(Map)}, this method is useful when you need to\n\t * supply URI variables without building the {@link UriComponents} instance\n\t * just yet, or perhaps pre-expand some shared default values such as host\n\t * and port.\n\t * @param uriVariables the URI variables to use\n\t * @return this UriComponentsBuilder\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uriVariables(Map<String, Object> uriVariables)",
    "source_code": "\tpublic UriComponentsBuilder uriVariables(Map<String, Object> uriVariables) {\n\t\tthis.uriVariables.putAll(uriVariables);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#matches(pathIndex,matchingContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathIndex",
      "matchingContext"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(int pathIndex, MatchingContext matchingContext)",
    "source_code": "\tpublic boolean matches(int pathIndex, MatchingContext matchingContext) {\n\t\t// No need to handle 'match start' checking as this captures everything\n\t\t// anyway and cannot be followed by anything else\n\t\t// assert next == null\n\n\t\t// If there is more data, it must start with the separator\n\t\tif (pathIndex < matchingContext.pathLength && !matchingContext.isSeparator(pathIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (matchingContext.determineRemainingPath) {\n\t\t\tmatchingContext.remainingPathIndex = matchingContext.pathLength;\n\t\t}\n\t\tif (matchingContext.extractingVariables) {\n\t\t\t// Collect the parameters from all the remaining segments\n\t\t\tMultiValueMap<String,String> parametersCollector = null;\n\t\t\tfor (int i = pathIndex; i < matchingContext.pathLength; i++) {\n\t\t\t\tElement element = matchingContext.pathElements.get(i);\n\t\t\t\tif (element instanceof PathSegment pathSegment) {\n\t\t\t\t\tMultiValueMap<String, String> parameters = pathSegment.parameters();\n\t\t\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\t\t\tif (parametersCollector == null) {\n\t\t\t\t\t\t\tparametersCollector = new LinkedMultiValueMap<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparametersCollector.addAll(parameters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatchingContext.set(this.variableName, pathToString(pathIndex, matchingContext.pathElements),\n\t\t\t\t\tparametersCollector == null?NO_PARAMETERS:parametersCollector);\n\t\t}\n\t\treturn true;\n\t}"
  }
}