{
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "T",
    "signature": "public T get(Object key, final Callable<T> valueLoader)",
    "source_code": "\tpublic <T> T get(Object key, final Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.cache.get(key, new LoadFunction(valueLoader)));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,props)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Map props)",
    "source_code": "    public static void addProperties(BeanGenerator gen, Map props) {\n        for (Iterator it = props.keySet().iterator(); it.hasNext();) {\n            String name = (String)it.next();\n            gen.addProperty(name, (Class)props.get(name));\n        }\n    }"
  },
  "org.springframework.cglib.beans.<unknown>#newInstance(superclass,props)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superclass",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "Object",
    "signature": "public Object newInstance(String superclass, Map props)",
    "source_code": "        public Object newInstance(String superclass, Map props);"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 944
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\n        return begin_method(e, method, method.getModifiers());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method,access)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n        return e.begin_method(access,\n                              method.getSignature(),\n                              method.getExceptionTypes());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#hash_code(e,type,multiplier,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.context.annotation.<unknown>#registerAnnotationConfigProcessors(registry,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Set<BeanDefinitionHolder>",
    "signature": "public Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)",
    "source_code": "\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n\t\tif (beanFactory != null) {\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\tbeanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif (jakartaAnnotationsPresent && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JSR-250 support, and if present add an InitDestroyAnnotationBeanPostProcessor\n\t\t// for the javax variant of PostConstruct/PreDestroy.\n\t\tif (jsr250Present && !registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition def = new RootBeanDefinition(InitDestroyAnnotationBeanPostProcessor.class);\n\t\t\t\tdef.getPropertyValues().add(\"initAnnotationType\", classLoader.loadClass(\"javax.annotation.PostConstruct\"));\n\t\t\t\tdef.getPropertyValues().add(\"destroyAnnotationType\", classLoader.loadClass(\"javax.annotation.PreDestroy\"));\n\t\t\t\tdef.setSource(source);\n\t\t\t\tbeanDefs.add(registerPostProcessor(registry, def, JSR250_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t// Failed to load javax variants of the annotation types -> ignore.\n\t\t\t}\n\t\t}\n\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\tregisterTypeName(paramName, typeName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getTypedValue(source,parameterName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a wrapped value if parameter has type information, plain object if not.\n\t * @param source the source of parameter values and type information\n\t * @param parameterName the name of the parameter\n\t * @return the value object\n\t * @see SqlParameterValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Object",
    "signature": "public Object getTypedValue(SqlParameterSource source, String parameterName)",
    "source_code": "\tpublic static Object getTypedValue(SqlParameterSource source, String parameterName) {\n\t\tint sqlType = source.getSqlType(parameterName);\n\t\tif (sqlType != SqlParameterSource.TYPE_UNKNOWN) {\n\t\t\treturn new SqlParameterValue(sqlType, source.getTypeName(parameterName), source.getValue(parameterName));\n\t\t}\n\t\telse {\n\t\t\treturn source.getValue(parameterName);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends Object> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends Object> map) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromJson(payload,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "protected Object fromJson(String payload, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(String payload, Type resolvedType);"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#send(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void send(D destination, Message<?> message)",
    "source_code": "\tpublic void send(D destination, Message<?> message) {\n\t\tdoSend(destination, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#invoke(message,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given message.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param message the current message being processed\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Object",
    "signature": "public Object invoke(Message<?> message, Object... providedArgs)",
    "source_code": "\tpublic Object invoke(Message<?> message, Object... providedArgs) throws Exception {\n\t\tObject[] args = getMethodArgumentValues(message, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, Class<?> elementClass)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, Class<?> elementClass) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forClass(elementClass));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forType(elementTypeRef));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,vars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "vars"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec route(String route, Object... vars)",
    "source_code": "\tpublic RequestSpec route(String route, Object... vars) {\n\t\treturn new DefaultRequestSpec(route, vars);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#responder(strategies,candidateHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create an RSocket {@link SocketAcceptor}\n\t * backed by handlers with annotated methods. Effectively a shortcut for:\n\t * <pre class=\"code\">\n\t * RSocketMessageHandler handler = new RSocketMessageHandler();\n\t * handler.setHandlers(handlers);\n\t * handler.setRSocketStrategies(strategies);\n\t * handler.afterPropertiesSet();\n\t *\n\t * SocketAcceptor acceptor = handler.responder();\n\t * </pre>\n\t * <p>This is intended for programmatic creation and registration of a\n\t * client-side responder. For example:\n\t * <pre class=\"code\">\n\t * SocketAcceptor responder =\n\t *         RSocketMessageHandler.responder(strategies, new ClientHandler());\n\t *\n\t * RSocketRequester.builder()\n\t *         .rsocketConnector(connector -&gt; connector.acceptor(responder))\n\t *         .connectTcp(\"localhost\", server.address().getPort());\n\t * </pre>\n\t *\n\t * <p>Note that the given handlers do not need to have any stereotype\n\t * annotations such as {@code @Controller} which helps to avoid overlap with\n\t * server side handlers that may be used in the same application. However,\n\t * for more advanced scenarios, e.g. discovering handlers through a custom\n\t * stereotype annotation, consider declaring {@code RSocketMessageHandler}\n\t * as a bean, and then obtain the responder from it.\n\t * @param strategies the strategies to set on the created\n\t * {@code RSocketMessageHandler}\n\t * @param candidateHandlers a list of Objects and/or Classes with annotated\n\t * handler methods; used to call {@link #setHandlers(List)} with\n\t * on the created {@code RSocketMessageHandler}\n\t * @return a configurer that may be passed into\n\t * {@link org.springframework.messaging.rsocket.RSocketRequester.Builder#rsocketConnector}\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategies",
      "candidateHandlers"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "SocketAcceptor",
    "signature": "public SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers)",
    "source_code": "\tpublic static SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers) {\n\t\tAssert.notEmpty(candidateHandlers, \"No handlers\");\n\t\tList<Object> handlers = new ArrayList<>(candidateHandlers.length);\n\t\tfor (Object obj : candidateHandlers) {\n\t\t\thandlers.add(obj instanceof Class<?> clazz ? BeanUtils.instantiateClass(clazz) : obj);\n\t\t}\n\t\tRSocketMessageHandler handler = new RSocketMessageHandler();\n\t\thandler.setHandlers(handlers);\n\t\thandler.setRSocketStrategies(strategies);\n\t\thandler.afterPropertiesSet();\n\t\treturn handler.responder();\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload) throws MessagingException {\n\t\tconvertAndSendToUser(user, destination, payload, (MessagePostProcessor) null);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#processHeadersToSend(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new map and puts the given headers under the key\n\t * {@link NativeMessageHeaderAccessor#NATIVE_HEADERS NATIVE_HEADERS NATIVE_HEADERS NATIVE_HEADERS}.\n\t * effectively treats the input header map as headers to be sent out to the\n\t * destination.\n\t * <p>However if the given headers already contain the key\n\t * {@code NATIVE_HEADERS NATIVE_HEADERS} then the same headers instance is\n\t * returned without changes.\n\t * <p>Also if the given headers were prepared and obtained with\n\t * {@link SimpMessageHeaderAccessor#getMessageHeaders()} then the same headers\n\t * instance is also returned without changes.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\tif (headers == null) {\n\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\tinitHeaders(headerAccessor);\n\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\treturn headerAccessor.getMessageHeaders();\n\t\t}\n\t\tif (headers.containsKey(NativeMessageHeaderAccessor.NATIVE_HEADERS)) {\n\t\t\treturn headers;\n\t\t}\n\t\tif (headers instanceof MessageHeaders messageHeaders) {\n\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(messageHeaders, SimpMessageHeaderAccessor.class);\n\t\t\tif (accessor != null) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t}\n\n\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\tinitHeaders(headerAccessor);\n\t\theaders.forEach((key, value) -> headerAccessor.setNativeHeader(key, (value != null ? value.toString() : null)));\n\t\treturn headerAccessor.getMessageHeaders();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#handleTcpConnectionFailure(error,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked when any TCP connectivity issue is detected, i.e. failure to establish\n\t\t * the TCP connection, failure to send a message, missed heartbeat, etc.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "error",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String error, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String error, @Nullable Throwable ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"TCP connection failure in session \" + this.sessionId + \": \" + error, ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsendStompErrorFrameToClient(error);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failure while clearing TCP connection state in session \" + this.sessionId, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setSystemSubscriptions(Map<String,subscriptions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more destinations to subscribe to on the shared \"system\"\n\t * connection along with MessageHandler's to handle received messages.\n\t * <p>This is for internal use in a multi-application server scenario where\n\t * servers forward messages to each other (e.g. unresolved user destinations).\n\t * @param subscriptions the destinations to subscribe to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "subscriptions"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "public void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions)",
    "source_code": "\tpublic void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {\n\t\tthis.systemSubscriptions.clear();\n\t\tif (subscriptions != null) {\n\t\t\tthis.systemSubscriptions.putAll(subscriptions);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#send(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic final boolean send(Message<?> message, long timeout) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tMessage<?> messageToUse = message;\n\t\tChannelInterceptorChain chain = new ChannelInterceptorChain();\n\t\tboolean sent = false;\n\t\ttry {\n\t\t\tmessageToUse = chain.applyPreSend(messageToUse, this);\n\t\t\tif (messageToUse == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsent = sendInternal(messageToUse, timeout);\n\t\t\tchain.applyPostSend(messageToUse, this, sent);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, null);\n\t\t\treturn sent;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex);\n\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\tthrow messagingException;\n\t\t\t}\n\t\t\tthrow new MessageDeliveryException(messageToUse,\"Failed to send message to \" + this, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\tMessageDeliveryException ex2 =\n\t\t\t\t\tnew MessageDeliveryException(messageToUse, \"Failed to send message to \" + this, err);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex2);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#sendInternal(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor == null) {\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void delete(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\tsession.delete(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1150
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Session interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Invoke method on target Session.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t// If return value is a Query or Criteria, apply transaction timeout.\n\t\t\t\t// Applies to createQuery, getNamedQuery, createCriteria.\n\t\t\t\tif (retVal instanceof Criteria criteria) {\n\t\t\t\t\tprepareCriteria(criteria);\n\t\t\t\t}\n\t\t\t\telse if (retVal instanceof Query<?> query) {\n\t\t\t\t\tprepareQuery(query);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id)",
    "source_code": "\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#merge(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void update(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshal(graph,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshals the object graph with the given root into the provided {@code javax.xml.transform.Result}.\n\t * <p>This implementation inspects the given result, and calls {@code marshalDomResult},\n\t * {@code marshalSaxResult}, or {@code marshalStreamResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param result the result to marshal to\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code result} if neither a {@code DOMResult},\n\t * a {@code SAXResult}, nor a {@code StreamResult}\n\t * @see #marshalDomResult(Object, javax.xml.transform.dom.DOMResult)\n\t * @see #marshalSaxResult(Object, javax.xml.transform.sax.SAXResult)\n\t * @see #marshalStreamResult(Object, javax.xml.transform.stream.StreamResult)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic final void marshal(Object graph, Result result) throws IOException, XmlMappingException {\n\t\tif (result instanceof DOMResult domResult) {\n\t\t\tmarshalDomResult(graph, domResult);\n\t\t}\n\t\telse if (StaxUtils.isStaxResult(result)) {\n\t\t\tmarshalStaxResult(graph, result);\n\t\t}\n\t\telse if (result instanceof SAXResult saxResult) {\n\t\t\tmarshalSaxResult(graph, saxResult);\n\t\t}\n\t\telse if (result instanceof StreamResult streamResult) {\n\t\t\tmarshalStreamResult(graph, streamResult);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Result type: \" + result.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}.\n\t * @param graph the root of the object graph to marshal\n\t * @param contentHandler the SAX {@code ContentHandler}\n\t * @param lexicalHandler the SAX2 {@code LexicalHandler}. Can be {@code null}.\n\t * @throws XmlMappingException if the given object cannot be marshalled to the handlers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected abstract void marshalSaxHandlers(\n\t\t\tObject graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}."
  },
  "org.springframework.r2dbc.connection.lookup.<unknown>#setTargetConnectionFactories(Map<?,targetConnectionFactories)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target {@link ConnectionFactory ConnectionFactories},\n\t * with the lookup key as key. The mapped value can either be a corresponding\n\t * {@link ConnectionFactory} instance or a connection factory name String (to be\n\t * resolved via a {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the generic lookup\n\t * process only. The concrete key representation will be handled by\n\t * {@link #resolveSpecifiedLookupKey(Object)} and {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "targetConnectionFactories"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories)",
    "source_code": "\tpublic void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories) {\n\t\tthis.targetConnectionFactories = targetConnectionFactories;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#buildAdvice(executor,exceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "executor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Advice",
    "signature": "protected Advice buildAdvice(@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tprotected Advice buildAdvice(\n\t\t\t@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tAnnotationAsyncExecutionInterceptor interceptor = new AnnotationAsyncExecutionInterceptor(null);\n\t\tinterceptor.configure(executor, exceptionHandler);\n\t\treturn interceptor;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#createRefreshableProxy(ts,interfaces,proxyTargetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a refreshable proxy for the given AOP TargetSource.\n\t * @param ts the refreshable TargetSource\n\t * @param interfaces the proxy interfaces (may be {@code null} to\n\t * indicate proxying of all interfaces implemented by the target class)\n\t * @return the generated proxy\n\t * @see RefreshableScriptTargetSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "interfaces",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Object",
    "signature": "protected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass)",
    "source_code": "\tprotected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.setTargetSource(ts);\n\t\tClassLoader classLoader = this.beanClassLoader;\n\n\t\tif (interfaces != null) {\n\t\t\tproxyFactory.setInterfaces(interfaces);\n\t\t}\n\t\telse {\n\t\t\tClass<?> targetClass = ts.getTargetClass();\n\t\t\tif (targetClass != null) {\n\t\t\t\tproxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.beanClassLoader));\n\t\t\t}\n\t\t}\n\n\t\tif (proxyTargetClass) {\n\t\t\tclassLoader = null;  // force use of Class.getClassLoader()\n\t\t\tproxyFactory.setProxyTargetClass(true);\n\t\t}\n\n\t\tDelegatingIntroductionInterceptor introduction = new DelegatingIntroductionInterceptor(ts);\n\t\tintroduction.suppressInterface(TargetSource.class);\n\t\tproxyFactory.addAdvice(introduction);\n\n\t\treturn proxyFactory.getProxy(classLoader);\n\t}"
  },
  "org.springframework.ui.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#addAttribute(attributeName,attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (ignored if {@code null},\n\t * just removing an existing entry if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.util.<unknown>#applyRelativePath(path,relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given relative path to the given Java resource path,\n\t * assuming standard Java folder separation (i.e. \"/\" separators).\n\t * @param path the path to start from (usually a full file path)\n\t * @param relativePath the relative path to apply\n\t * (relative to the full file path above)\n\t * @return the full file path that results from applying the relative path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "String",
    "signature": "public String applyRelativePath(String path, String relativePath)",
    "source_code": "\tpublic static String applyRelativePath(String path, String relativePath) {\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (separatorIndex != -1) {\n\t\t\tString newPath = path.substring(0, separatorIndex);\n\t\t\tif (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n\t\t\t\tnewPath += FOLDER_SEPARATOR_CHAR;\n\t\t\t}\n\t\t\treturn newPath + relativePath;\n\t\t}\n\t\telse {\n\t\t\treturn relativePath;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#collectionToDelimitedString(coll,delim)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1303
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim)",
    "source_code": "\tpublic static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {\n\t\treturn collectionToDelimitedString(coll, delim, \"\", \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#countOccurrencesOf(str,sub)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Count the occurrences of the substring {@code sub} in string {@code str}.\n\t * @param str string to search in\n\t * @param sub string to search for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "sub"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "int",
    "signature": "public int countOccurrencesOf(String str, String sub)",
    "source_code": "\tpublic static int countOccurrencesOf(String str, String sub) {\n\t\tif (!hasLength(str) || !hasLength(sub)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint count = 0;\n\t\tint pos = 0;\n\t\tint idx;\n\t\twhile ((idx = str.indexOf(sub, pos)) != -1) {\n\t\t\t++count;\n\t\t\tpos = idx + sub.length();\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.<unknown>#delete(inString,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delete all occurrences of the given substring.\n\t * @param inString the original {@code String}\n\t * @param pattern the pattern to delete all occurrences of\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "String",
    "signature": "public String delete(String inString, String pattern)",
    "source_code": "\tpublic static String delete(String inString, String pattern) {\n\t\treturn replace(inString, pattern, \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#delimitedListToStringArray(str,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into a\n\t * {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1191
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {\n\t\treturn delimitedListToStringArray(str, delimiter, null);\n\t}"
  },
  "org.springframework.util.<unknown>#findValueOfType(collection,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "T",
    "signature": "public T findValueOfType(Collection<?> collection, @Nullable Class<T> type)",
    "source_code": "\tpublic static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.util.<unknown>#splitArrayElementsIntoProperties(array,delimiter,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the\n\t * delimiter providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the\n\t * {@code Properties} instance.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @param charsToDelete one or more characters to remove from each element\n\t * prior to attempting the split operation (typically the quotation mark\n\t * symbol), or {@code null} if no removal should occur\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(\n\t\t\tString[] array, String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tProperties result = new Properties();\n\t\tfor (String element : array) {\n\t\t\tif (charsToDelete != null) {\n\t\t\t\telement = deleteAny(element, charsToDelete);\n\t\t\t}\n\t\t\tString[] splittedElement = split(element, delimiter);\n\t\t\tif (splittedElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.<unknown>#substringMatch(str,index,substring)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test whether the given string matches the given substring\n\t * at the given index.\n\t * @param str the original string (or StringBuilder)\n\t * @param index the index in the original string to start matching against\n\t * @param substring the substring to match at the given index\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "index",
      "substring"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "boolean",
    "signature": "public boolean substringMatch(CharSequence str, int index, CharSequence substring)",
    "source_code": "\tpublic static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n\t\tif (index + substring.length() > str.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < substring.length(); i++) {\n\t\t\tif (str.charAt(index + i) != substring.charAt(i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.util.<unknown>#unmodifiableMultiValueMap(K,targetMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "V>",
    "signature": "public V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(\n\t\t\tMultiValueMap<? extends K, ? extends V> targetMap) {\n\n\t\tAssert.notNull(targetMap, \"'targetMap' must not be null\");\n\t\tif (targetMap instanceof UnmodifiableMultiValueMap) {\n\t\t\treturn (MultiValueMap<K, V>) targetMap;\n\t\t}\n\t\treturn new UnmodifiableMultiValueMap<>(targetMap);\n\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(v1,v2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v1",
      "v2"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "public int compare(Boolean v1, Boolean v2)",
    "source_code": "\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#noHandlerFound(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * No handler found &rarr; set appropriate HTTP response status.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception if preparing the response failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1290
    },
    "return": "void",
    "signature": "protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tif (pageNotFoundLogger.isWarnEnabled()) {\n\t\t\tpageNotFoundLogger.warn(\"No mapping for \" + request.getMethod() + \" \" + getRequestUri(request));\n\t\t}\n\t\tif (this.throwExceptionIfNoHandlerFound) {\n\t\t\tthrow new NoHandlerFoundException(request.getMethod(), getRequestUri(request),\n\t\t\t\t\tnew ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\telse {\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine an error ModelAndView via the registered HandlerExceptionResolvers.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time of the exception\n\t * (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to\n\t * @throws Exception if no error ModelAndView found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1331
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\t// Success and error responses may use different content types\n\t\trequest.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\n\t\t// Check registered HandlerExceptionResolvers...\n\t\tModelAndView exMv = null;\n\t\tif (this.handlerExceptionResolvers != null) {\n\t\t\tfor (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {\n\t\t\t\texMv = resolver.resolveException(request, response, handler, ex);\n\t\t\t\tif (exMv != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exMv != null) {\n\t\t\tif (exMv.isEmpty()) {\n\t\t\t\trequest.setAttribute(EXCEPTION_ATTRIBUTE, ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// We might still need view name translation for a plain error model...\n\t\t\tif (!exMv.hasView()) {\n\t\t\t\tString defaultViewName = getDefaultViewName(request);\n\t\t\t\tif (defaultViewName != null) {\n\t\t\t\t\texMv.setViewName(defaultViewName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Using resolved error view: \" + exMv, ex);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using resolved error view: \" + exMv);\n\t\t\t}\n\t\t\tWebUtils.exposeErrorRequestAttributes(request, ex, getServletName());\n\t\t\treturn exMv;\n\t\t}\n\n\t\tthrow ex;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#render(mv,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Render the given ModelAndView.\n\t * <p>This is the last stage in handling a request. It may involve resolving the view by name.\n\t * @param mv the ModelAndView to render\n\t * @param request current HTTP servlet request\n\t * @param response current HTTP servlet response\n\t * @throws ServletException if view is missing or cannot be resolved\n\t * @throws Exception if there's a problem rendering the view\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1381
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\t// Determine locale for request and apply it to the response.\n\t\tLocale locale =\n\t\t\t\t(this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t// We need to resolve the view name.\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No need to lookup: the ModelAndView object contains the actual View object.\n\t\t\tview = mv.getView();\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" +\n\t\t\t\t\t\t\"View object in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t// Delegate to the View object for rendering.\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view [\" + view + \"] \");\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, mv.getStatus());\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleBindException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleConversionNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion cannot occur.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the ConversionNotSupportedException could be\n\t * rethrown as-is.\n\t * @param ex the ConversionNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#exposeLocalizationContext(request,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param request the current HTTP request\n\t * @param messageSource the MessageSource to expose,\n\t * typically the current ApplicationContext (may be {@code null})\n\t * @see #exposeLocalizationContext(RequestContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource)",
    "source_code": "\tpublic static void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource) {\n\t\tLocale jstlLocale = RequestContextUtils.getLocale(request);\n\t\tConfig.set(request, Config.FMT_LOCALE, jstlLocale);\n\t\tTimeZone timeZone = RequestContextUtils.getTimeZone(request);\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(request, Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tif (messageSource != null) {\n\t\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, request);\n\t\t\tConfig.set(request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getBindStatus(path,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders (named keys with braces {@code {}}).\n\t * For example, send in a relative URL {@code foo/{bar}?spam={spam}} and a parameter map\n\t * {@code {bar=baz,spam=nuts}} and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlAwareMessageSource(servletContext,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks JSTL's \"jakarta.servlet.jsp.jstl.fmt.localizationContext\"\n\t * context-param and creates a corresponding child message source,\n\t * with the provided Spring-defined MessageSource as parent.\n\t * @param servletContext the ServletContext we're running in\n\t * (to check JSTL-related context-params in {@code web.xml})\n\t * @param messageSource the MessageSource to expose, typically\n\t * the ApplicationContext of the current DispatcherServlet\n\t * @return the MessageSource to expose to JSTL; first checking the\n\t * JSTL-defined bundle, then the Spring-defined MessageSource\n\t * @see org.springframework.context.ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "MessageSource",
    "signature": "public MessageSource getJstlAwareMessageSource(@Nullable ServletContext servletContext, MessageSource messageSource)",
    "source_code": "\tpublic static MessageSource getJstlAwareMessageSource(\n\t\t\t@Nullable ServletContext servletContext, MessageSource messageSource) {\n\n\t\tif (servletContext != null) {\n\t\t\tString jstlInitParam = servletContext.getInitParameter(Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\tif (jstlInitParam != null) {\n\t\t\t\t// Create a ResourceBundleMessageSource for the specified resource bundle\n\t\t\t\t// basename in the JSTL context-param in web.xml, wiring it with the given\n\t\t\t\t// Spring-defined MessageSource as parent.\n\t\t\t\tResourceBundleMessageSource jstlBundleWrapper = new ResourceBundleMessageSource();\n\t\t\t\tjstlBundleWrapper.setBasename(jstlInitParam);\n\t\t\t\tjstlBundleWrapper.setParentMessageSource(messageSource);\n\t\t\t\treturn jstlBundleWrapper;\n\t\t\t}\n\t\t}\n\t\treturn messageSource;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,defaultMessage,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, defaultMessage, getLocale());\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 711
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#accept(webSocketSession,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "void",
    "signature": "public void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable)",
    "source_code": "\t\tpublic void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable) {\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.connectionHandler.afterConnectFailure(throwable);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterConnectionClosed(session,closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\t\tcancelInactivityTasks();\n\t\t\tthis.connectionHandler.afterConnectionClosed();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,handler,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn connectAsync(url, handshakeHeaders, null, handler, uriVariables);\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#filterRequestedExtensions(request,requestedExtensions,supportedExtensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Filter the list of requested WebSocket extensions.\n\t * <p>As of 4.1, the default implementation of this method filters the list to\n\t * leave only extensions that are both requested and supported.\n\t * @param request the current request\n\t * @param requestedExtensions the list of extensions requested by the client\n\t * @param supportedExtensions the list of extensions supported by the server\n\t * @return the selected extensions or an empty list\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestedExtensions",
      "supportedExtensions"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "List<WebSocketExtension>",
    "signature": "protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions)",
    "source_code": "\tprotected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {\n\n\t\tList<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size());\n\t\tfor (WebSocketExtension extension : requestedExtensions) {\n\t\t\tif (supportedExtensions.contains(extension)) {\n\t\t\t\tresult.add(extension);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleInvalidConnectHeader(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Connection header\" + request.getHeaders().getConnection(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"\\\"Connection\\\" must be \\\"upgrade\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTextMessage(webSocketSession,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession webSocketSession, TextMessage message)",
    "source_code": "\t\tpublic void handleTextMessage(WebSocketSession webSocketSession, TextMessage message) throws Exception {\n\t\t\tthis.sockJsSession.handleFrame(message.getPayload());\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTransportError(webSocketSession,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {\n\t\t\tthis.sockJsSession.handleTransportError(ex);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequest(request,response,wsHandler,wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession)",
    "source_code": "\tpublic void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession) throws SockJsException {\n\n\t\tWebSocketServerSockJsSession sockJsSession = (WebSocketServerSockJsSession) wsSession;\n\t\ttry {\n\t\t\twsHandler = new SockJsWebSocketHandler(getServiceConfig(), wsHandler, sockJsSession);\n\t\t\tthis.handshakeHandler.doHandshake(request, response, wsHandler, sockJsSession.getAttributes());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"WebSocket handshake failure\", wsSession.getId(), ex);\n\t\t}\n\t}"
  }
}