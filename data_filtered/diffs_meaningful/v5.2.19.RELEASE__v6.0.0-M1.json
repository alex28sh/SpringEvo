{
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn !this.adviceMethod.equals(method);\n\t\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvisor(pos,advisor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advisor"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void addAdvisor(int pos, Advisor advisor)",
    "source_code": "\tpublic void addAdvisor(int pos, Advisor advisor) throws AopConfigException {\n\t\tif (advisor instanceof IntroductionAdvisor) {\n\t\t\tvalidateIntroductionAdvisor((IntroductionAdvisor) advisor);\n\t\t}\n\t\taddAdvisorInternal(pos, advisor);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass) {\n\t\treturn canApply(pc, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.mm1.matches(method, targetClass) && this.mm2.matches(method, targetClass));\n\t\t}"
  },
  "org.springframework.beans.<unknown>#add(propertyName,propertyValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a PropertyValue object, replacing any existing one for the\n\t * corresponding property or getting merged with it (if applicable).\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue)",
    "source_code": "\tpublic MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(\n\t\t\t\t\t\t(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,beanName,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\tpublic void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\tCollection<InjectedElement> checkedElements = this.checkedElements;\n\t\tCollection<InjectedElement> elementsToIterate =\n\t\t\t\t(checkedElements != null ? checkedElements : this.injectedElements);\n\t\tif (!elementsToIterate.isEmpty()) {\n\t\t\tfor (InjectedElement element : elementsToIterate) {\n\t\t\t\telement.inject(target, beanName, pvs);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#needsRefresh(metadata,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given injection metadata needs to be refreshed.\n\t * @param metadata the existing metadata instance\n\t * @param clazz the current target class\n\t * @return {@code true} indicating a refresh, {@code false} otherwise\n\t * @see #needsRefresh(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "boolean",
    "signature": "public boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz)",
    "source_code": "\tpublic static boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz) {\n\t\treturn (metadata == null || metadata.needsRefresh(clazz));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param newValue the argument value in the form of a ValueHolder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, ValueHolder newValue)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, ValueHolder newValue) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tAssert.notNull(newValue, \"ValueHolder must not be null\");\n\t\taddOrMergeIndexedArgumentValue(index, newValue);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @param requiredName the parameter name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName) {\n\t\treturn getArgumentValue(index, requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireConstructor(beanName,mbd,ctors,explicitArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "ctors",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1327
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "T",
    "signature": "public T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n\t\t\tthrows BeansException {\n\n\t\treturn doGetBean(name, requiredType, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectForBeanInstance(beanInstance,name,beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden in order to implicitly register the currently created bean as\n\t * dependent on further beans getting programmatically retrieved during a\n\t * {@link Supplier} callback.\n\t * @since 5.0\n\t * @see #obtainFromSupplier\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanInstance",
      "name",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1242
    },
    "return": "Object",
    "signature": "protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object getObjectForBeanInstance(\n\t\t\tObject beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {\n\n\t\tString currentlyCreatedBean = this.currentlyCreatedBean.get();\n\t\tif (currentlyCreatedBean != null) {\n\t\t\tregisterDependentBean(beanName, currentlyCreatedBean);\n\t\t}\n\n\t\treturn super.getObjectForBeanInstance(beanInstance, name, beanName, mbd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 805
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(\n\t\t\tString beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(bdName)) {\n\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);\n\t\t}\n\t\telse if (containsSingleton(beanName)) {\n\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);\n\t\t}\n\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver);\n\t\t}\n\t\telse if (parent instanceof ConfigurableListableBeanFactory) {\n\t\t\t// If no DefaultListableBeanFactory, can't pass the resolver along.\n\t\t\treturn ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor);\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix,resourceDescription)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(Map, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\tint beanCount = 0;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tif (!(key instanceof String keyString)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Illegal key [\" + key + \"]: only Strings allowed\");\n\t\t\t}\n\t\t\tif (keyString.startsWith(prefix)) {\n\t\t\t\t// Key is of form: prefix<name>.property\n\t\t\t\tString nameAndProperty = keyString.substring(prefix.length());\n\t\t\t\t// Find dot before property name, ignoring dots in property keys.\n\t\t\t\tint sepIdx ;\n\t\t\t\tint propKeyIdx = nameAndProperty.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX);\n\t\t\t\tif (propKeyIdx != -1) {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR, propKeyIdx);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR);\n\t\t\t\t}\n\t\t\t\tif (sepIdx != -1) {\n\t\t\t\t\tString beanName = nameAndProperty.substring(0, sepIdx);\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Found bean name '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!getRegistry().containsBeanDefinition(beanName)) {\n\t\t\t\t\t\t// If we haven't already registered it...\n\t\t\t\t\t\tregisterBeanDefinition(beanName, map, prefix + beanName, resourceDescription);\n\t\t\t\t\t\t++beanCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Ignore it: It wasn't a valid bean name and property,\n\t\t\t\t\t// although it did start with the required prefix.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Invalid bean name and property [\" + nameAndProperty + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn beanCount;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionAttributes(ele,beanName,containingBean,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,beanName,containingBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\tparseMetaElements(ele, bd);\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#processBeanDefinition(ele,delegate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ele",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t// Register the final decorated instance.\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerScope(annotationType,scopeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an extended JSR-330 scope annotation, mapping it onto a\n\t * specific Spring scope by name.\n\t * @param annotationType the JSR-330 annotation type by name\n\t * @param scopeName the Spring scope name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "scopeName"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void registerScope(String annotationType, String scopeName)",
    "source_code": "\tpublic final void registerScope(String annotationType, String scopeName) {\n\t\tthis.scopeMap.put(annotationType, scopeName);\n\t}"
  },
  "org.springframework.context.event.<unknown>#getDetailedErrorMessage(bean,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add additional details such as the bean type and method signature to\n\t * the given error message.\n\t * @param message error message to append the HandlerMethod details to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "String",
    "signature": "protected String getDetailedErrorMessage(Object bean, String message)",
    "source_code": "\tprotected String getDetailedErrorMessage(Object bean, String message) {\n\t\tStringBuilder sb = new StringBuilder(message).append('\\n');\n\t\tsb.append(\"HandlerMethod details: \\n\");\n\t\tsb.append(\"Bean [\").append(bean.getClass().getName()).append(\"]\\n\");\n\t\tsb.append(\"Method [\").append(this.method.toGenericString()).append(\"]\\n\");\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 1305
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1365
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,keyType,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K}\n\t * is not bound to the supplied {@code keyType}, type safety cannot be\n\t * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\n\t * scenarios, the caller is responsible for ensuring that the {@code keyType}\n\t * is an enum type matching type {@code K}. As an alternative, the caller\n\t * may wish to treat the return value as a raw map or map keyed by\n\t * {@link Object}. Similarly, type safety cannot be enforced if the\n\t * desired {@code mapType} is {@link MultiValueMap}.\n\t * @param mapType the desired type of the target map (never {@code null})\n\t * @param keyType the map's key type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumMap} creation)\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\n\t * the supplied {@code keyType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashMap\n\t * @see java.util.TreeMap\n\t * @see org.springframework.util.LinkedMultiValueMap\n\t * @see java.util.EnumMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (mapType.isInterface()) {\n\t\t\tif (Map.class == mapType) {\n\t\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t\t}\n\t\t\telse if (SortedMap.class == mapType || NavigableMap.class == mapType) {\n\t\t\t\treturn new TreeMap<>();\n\t\t\t}\n\t\t\telse if (MultiValueMap.class == mapType) {\n\t\t\t\treturn new LinkedMultiValueMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map interface: \" + mapType.getName());\n\t\t\t}\n\t\t}\n\t\telse if (EnumMap.class == mapType) {\n\t\t\tAssert.notNull(keyType, \"Cannot create EnumMap for unknown key type\");\n\t\t\treturn new EnumMap(asEnumType(keyType));\n\t\t}\n\t\telse {\n\t\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map type: \" + mapType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not instantiate Map type: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1139
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} parameter.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1258
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(method, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,implementationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1299
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType) {\n\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\timplementationType = (implementationType != null ? implementationType :\n\t\t\t\tforType(methodParameter.getContainingClass()));\n\t\tResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\n\t\treturn forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#getNested(nestingLevel,Map<Integer,typeIndexesPerLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (e.g. a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (may be {@code null})\n\t * @return a {@link ResolvableType} for the nested level, or {@link #NONE}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel",
      "Map<Integer",
      "typeIndexesPerLevel"
    ],
    "position": {
      "column": 1,
      "line": 638
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel)",
    "source_code": "\tpublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\n\t\tResolvableType result = this;\n\t\tfor (int i = 2; i <= nestingLevel; i++) {\n\t\t\tif (result.isArray()) {\n\t\t\t\tresult = result.getComponentType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle derived types\n\t\t\t\twhile (result != ResolvableType.NONE && !result.hasGenerics()) {\n\t\t\t\t\tresult = result.getSuperType();\n\t\t\t\t}\n\t\t\t\tInteger index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\n\t\t\t\tindex = (index == null ? result.getGenerics().length - 1 : index);\n\t\t\t\tresult = result.getGeneric(index);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(annotatedElement,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the supplied element.\n\t * <p><strong>Warning</strong>: this method operates generically on\n\t * annotated elements. In other words, this method does not execute\n\t * specialized search algorithms for classes or methods. If you require\n\t * the more specific semantics of {@link #findAnnotation(Class, Class)}\n\t * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\n\t * instead.\n\t * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "A",
    "signature": "public A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(\n\t\t\tAnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\n\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(method,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "A",
    "signature": "public A findAnnotation(Method method, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\n\t\t\treturn method.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(methodParameter,nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the method parameter.\n\t * <p>For example, if the methodParameter is a {@code List<String>} and the\n\t * nesting level is 1, the nested type descriptor will be String.class.\n\t * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\n\t * level is 2, the nested type descriptor will also be a String.class.\n\t * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\n\t * level is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\n\t * nesting level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\n\t * For example, if the method parameter is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param methodParameter the method parameter with a nestingLevel of 1\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the method parameter\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the nesting level of the input\n\t * {@link MethodParameter} argument is not 1, or if the types up to the\n\t * specified nesting level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {\n\t\tif (methodParameter.getNestingLevel() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"MethodParameter nesting level must be 1: \" +\n\t\t\t\t\t\"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal\");\n\t\t}\n\t\treturn nested(new TypeDescriptor(methodParameter), nestingLevel);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canCompare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "boolean",
    "signature": "public boolean canCompare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic boolean canCompare(@Nullable Object left, @Nullable Object right) {\n\t\tif (left == null || right == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Number && right instanceof Number) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Comparable && right instanceof Comparable) {\n\t\t\tClass<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass());\n\t\t\treturn ancestor != null && Comparable.class.isAssignableFrom(ancestor);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "int",
    "signature": "public int compare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic int compare(@Nullable Object left, @Nullable Object right) throws SpelEvaluationException {\n\t\t// If one is null, check if the other is\n\t\tif (left == null) {\n\t\t\treturn (right == null ? 0 : -1);\n\t\t}\n\t\telse if (right == null) {\n\t\t\treturn 1;  // left cannot be null at this point\n\t\t}\n\n\t\t// Basic number comparisons\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn leftBigDecimal.compareTo(rightBigDecimal);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn Float.compare(leftNumber.floatValue(), rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn leftBigInteger.compareTo(rightBigInteger);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn Long.compare(leftNumber.longValue(), rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn Integer.compare(leftNumber.intValue(), rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn Short.compare(leftNumber.shortValue(), rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn Byte.compare(leftNumber.byteValue(), rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtype -> best guess is double multiplication\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (left instanceof Comparable) {\n\t\t\t\treturn ((Comparable<Object>) left).compareTo(right);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassCastException ex) {\n\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t\t}\n\n\t\tthrow new SpelEvaluationException(SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t}"
  },
  "org.springframework.http.<unknown>#fromClientResponse(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie. Unlike\n\t * {@link #from(String, String)} this option assumes input from a remote\n\t * server, which can be handled more leniently, e.g. ignoring a empty domain\n\t * name with double quotes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t * @since 5.2.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder fromClientResponse(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder fromClientResponse(final String name, final String value) {\n\t\treturn from(name, value, true);\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part where the Object may be:\n\t * <ul>\n\t * <li>String -- form field\n\t * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n\t * <li>Object -- content to be encoded (e.g. to JSON)\n\t * <li>{@link HttpEntity} -- part content and headers although generally it's\n\t * easier to add headers through the returned builder\n\t * <li>{@link Part} -- a part from a server request\n\t * </ul>\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part)",
    "source_code": "\tpublic PartBuilder part(String name, Object part) {\n\t\treturn part(name, part, null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #part(String, Object)} that also accepts a MediaType.\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @param contentType the media type to help with encoding the part\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part, @Nullable MediaType contentType)",
    "source_code": "\tpublic PartBuilder part(String name, Object part, @Nullable MediaType contentType) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(part, \"'part' must not be null\");\n\n\t\tif (part instanceof Part partObject) {\n\t\t\tPartBuilder builder = asyncPart(name, partObject.content(), DataBuffer.class);\n\t\t\tif (!partObject.headers().isEmpty()) {\n\t\t\t\tbuilder.headers(headers -> {\n\t\t\t\t\theaders.putAll(partObject.headers());\n\t\t\t\t\tString filename = headers.getContentDisposition().getFilename();\n\t\t\t\t\t// reset to parameter name\n\t\t\t\t\theaders.setContentDispositionFormData(name, filename);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\n\t\tif (part instanceof PublisherEntity<?,?> publisherEntity) {\n\t\t\tPublisherPartBuilder<?, ?> builder = new PublisherPartBuilder<>(name, publisherEntity);\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\tthis.parts.add(name, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tObject partBody;\n\t\tHttpHeaders partHeaders = null;\n\t\tif (part instanceof HttpEntity<?> httpEntity) {\n\t\t\tpartBody = httpEntity.getBody();\n\t\t\tpartHeaders = new HttpHeaders();\n\t\t\tpartHeaders.putAll(httpEntity.getHeaders());\n\t\t}\n\t\telse {\n\t\t\tpartBody = part;\n\t\t}\n\n\t\tif (partBody instanceof Publisher) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tUse asyncPart(String, Publisher, Class) \\\n\t\t\t\t\tor asyncPart(String, Publisher, ParameterizedTypeReference) \\\n\t\t\t\t\tor MultipartBodyBuilder.PublisherEntity\"\"\");\n\t\t}\n\n\t\tDefaultPartBuilder builder = new DefaultPartBuilder(name, partHeaders, partBody);\n\t\tif (contentType != null) {\n\t\t\tbuilder.contentType(contentType);\n\t\t}\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\n\t\tif (inputStream instanceof Mono) {\n\t\t\treturn Mono.from(inputStream)\n\t\t\t\t\t.map(value -> encodeValue(value, bufferFactory, elementType, mimeType, hints))\n\t\t\t\t\t.flux();\n\t\t}\n\t\telse {\n\t\t\tbyte[] separator = getStreamingMediaTypeSeparator(mimeType);\n\t\t\tif (separator != null) { // streaming\n\t\t\t\ttry {\n\t\t\t\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\t\t\t\tif (mapper == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + elementType);\n\t\t\t\t\t}\n\t\t\t\t\tObjectWriter writer = createObjectWriter(mapper, elementType, mimeType, null, hints);\n\t\t\t\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\t\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\t\t\t\t\tJsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding);\n\t\t\t\t\tSequenceWriter sequenceWriter = writer.writeValues(generator);\n\n\t\t\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t\t\t.map(value -> encodeStreamingValue(value, bufferFactory, hints, sequenceWriter, byteBuilder,\n\t\t\t\t\t\t\t\t\tseparator))\n\t\t\t\t\t\t\t.doAfterTerminate(() -> {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tbyteBuilder.release();\n\t\t\t\t\t\t\t\t\tgenerator.close();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\t\t\t\tlogger.error(\"Could not close Encoder resources\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\treturn Flux.error(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { // non-streaming\n\t\t\t\tResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\n\t\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t\t.collectList()\n\t\t\t\t\t\t.map(list -> encodeValue(list, bufferFactory, listType, mimeType, hints))\n\t\t\t\t\t\t.flux();\n\t\t\t}\n\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1083
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes) throws DataAccessException {\n\t\tif (batchArgs.isEmpty()) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\treturn batchUpdate(\n\t\t\t\tsql,\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.size();\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newPreparedStatementCreator(sqlToUse,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new PreparedStatementCreator for the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sqlToUse",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "PreparedStatementCreator",
    "signature": "public PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params)",
    "source_code": "\tpublic PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params) {\n\t\treturn new PreparedStatementCreatorImpl(\n\t\t\t\tsqlToUse, params != null ? Arrays.asList(params) : Collections.emptyList());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 910
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, argTypes, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract database meta-data via the given DatabaseMetaDataCallback.\n\t * <p>This method will open a connection to the database and retrieve its meta-data.\n\t * Since this method is called before the exception translation feature is configured\n\t * for a DataSource, this method can not rely on SQLException translation itself.\n\t * <p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked\n\t * exception and any calling code should catch and handle this exception. You can just\n\t * log the error and hope for the best, but there is probably a more serious error that\n\t * will reappear when you try to access the database again.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param action callback that will do the actual work\n\t * @return object containing the extracted information, as returned by\n\t * the DatabaseMetaDataCallback's {@code processMetaData} method\n\t * @throws MetaDataAccessException if meta-data access failed\n\t * @see java.sql.DatabaseMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)\n\t\t\tthrows MetaDataAccessException {\n\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = DataSourceUtils.getConnection(dataSource);\n\t\t\tDatabaseMetaData metaData;\n\t\t\ttry {\n\t\t\t\tmetaData = con.getMetaData();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tif (DataSourceUtils.isConnectionTransactional(con, dataSource)) {\n\t\t\t\t\t// Probably a closed thread-bound Connection - retry against fresh Connection\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t\t\t\tcon = null;\n\t\t\t\t\tlogger.debug(\"Failed to obtain DatabaseMetaData from transactional Connection - \" +\n\t\t\t\t\t\t\t\"retrying against fresh Connection\", ex);\n\t\t\t\t\tcon = dataSource.getConnection();\n\t\t\t\t\tmetaData = con.getMetaData();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metaData == null) {\n\t\t\t\t// should only happen in test environments\n\t\t\t\tthrow new MetaDataAccessException(\"DatabaseMetaData returned by Connection [\" + con + \"] was null\");\n\t\t\t}\n\t\t\treturn action.processMetaData(metaData);\n\t\t}\n\t\tcatch (CannotGetJdbcConnectionException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Could not get Connection for extracting meta-data\", ex);\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Error while extracting DatabaseMetaData\", ex);\n\t\t}\n\t\tcatch (AbstractMethodError err) {\n\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver\", err);\n\t\t}\n\t\tfinally {\n\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,metaDataMethodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Call the specified method on DatabaseMetaData for the given DataSource,\n\t * and extract the invocation result.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param metaDataMethodName the name of the DatabaseMetaData method to call\n\t * @return the object returned by the specified DatabaseMetaData method\n\t * @throws MetaDataAccessException if we couldn't access the DatabaseMetaData\n\t * or failed to invoke the specified method\n\t * @see java.sql.DatabaseMetaData\n\t * @deprecated as of 5.2.9, in favor of\n\t * {@link #extractDatabaseMetaData(DataSource, DatabaseMetaDataCallback)}\n\t * with a lambda expression or method reference and a generically typed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "metaDataMethodName"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)\n\t\t\tthrows MetaDataAccessException {\n\n\t\treturn (T) extractDatabaseMetaData(dataSource,\n\t\t\t\tdbmd -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\"No method named '\" + metaDataMethodName +\n\t\t\t\t\t\t\t\t\"' found on DatabaseMetaData instance [\" + dbmd + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Could not access DatabaseMetaData method '\" + metaDataMethodName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tif (ex.getTargetException() instanceof SQLException) {\n\t\t\t\t\t\t\tthrow (SQLException) ex.getTargetException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Invocation of DatabaseMetaData method '\" + metaDataMethodName + \"' failed\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createConnection(username, password)}\n\t * method of the target ConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.ConnectionFactory#createConnection(String, String)\n\t * @see jakarta.jms.ConnectionFactory#createConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Connection",
    "signature": "protected Connection doCreateConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected Connection doCreateConnection(@Nullable String username, @Nullable String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn target.createConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn target.createConnection();\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map.\n\t * <p>This operation will overwrite any existing values. Use\n\t * {@link #copyHeadersIfAbsent(Map)} to avoid overwriting values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "void",
    "signature": "public void copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic void copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tif (headersToCopy == null || this.headers == headersToCopy) {\n\t\t\treturn;\n\t\t}\n\t\theadersToCopy.forEach((key, value) -> {\n\t\t\tif (!isReadOnly(key)) {\n\t\t\t\tsetHeader(key, value);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given values will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "void",
    "signature": "public void addParameter(String name, String... values)",
    "source_code": "\tpublic void addParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tString[] oldArr = this.parameters.get(name);\n\t\tif (oldArr != null) {\n\t\t\tString[] newArr = new String[oldArr.length + values.length];\n\t\t\tSystem.arraycopy(oldArr, 0, newArr, 0, oldArr.length);\n\t\t\tSystem.arraycopy(values, 0, newArr, oldArr.length, values.length);\n\t\t\tthis.parameters.put(name, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.parameters.put(name, values);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setStatus(status,errorMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "errorMessage"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "public void setStatus(int status, String errorMessage)",
    "source_code": "\tpublic void setStatus(int status, String errorMessage) {\n\t\tif (!this.isCommitted()) {\n\t\t\tthis.status = status;\n\t\t\tthis.errorMessage = errorMessage;\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tInjectionMetadata metadata = findPersistenceMetadata(beanName, beanType, null);\n\t\tmetadata.checkConfigMembers(beanDefinition);\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#getJdbcConnection(entityManager,readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "ConnectionHandle",
    "signature": "public ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)",
    "source_code": "\tpublic ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)\n\t\t\tthrows PersistenceException, SQLException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\treturn new HibernateConnectionHandle(session);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(dataHandler,elementNamespace,elementLocalName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataHandler",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 978
    },
    "return": "String",
    "signature": "public String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName) {\n\t\t\tString host = getHost(elementNamespace, dataHandler);\n\t\t\tString contentId = UUID.randomUUID() + \"@\" + host;\n\t\t\tthis.mimeContainer.addAttachment(\"<\" + contentId + \">\", dataHandler);\n\t\t\tcontentId = URLEncoder.encode(contentId, StandardCharsets.UTF_8);\n\t\t\treturn CID + contentId;\n\t\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#params(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(name,attr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can end or start with \"*\" for matching multiple methods.\n\t * @param name class and method name, separated by a dot\n\t * @param attr attribute associated with the method\n\t * @throws IllegalArgumentException in case of an invalid name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String name, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String name, TransactionAttribute attr) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tint lastDotIndex = name.lastIndexOf('.');\n\t\tif (lastDotIndex == -1) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + name + \"' is not a valid method name: format is FQN.methodName\");\n\t\t}\n\t\tString className = name.substring(0, lastDotIndex);\n\t\tString methodName = name.substring(lastDotIndex + 1);\n\t\tClass<?> clazz = ClassUtils.resolveClassName(className, this.beanClassLoader);\n\t\taddTransactionalMethod(clazz, methodName, attr);\n\t}"
  },
  "org.springframework.util.<unknown>#removeIf(Entry<K,filter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "boolean",
    "signature": "public boolean removeIf(Predicate<? super Entry<K, List<V>>> filter)",
    "source_code": "\t\tpublic boolean removeIf(Predicate<? super Entry<K, List<V>>> filter) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors,validationHints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#getFeatureDescriptors(elContext,base)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Iterator<FeatureDescriptor>",
    "signature": "public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base)",
    "source_code": "\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveUrlPath(resourceUrlPath, locations)\n\t\t\t\t.flatMap(baseUrl -> {\n\t\t\t\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\t\t\t\tVersionStrategy strategy = getStrategyForPath(resourceUrlPath);\n\t\t\t\t\t\tif (strategy == null) {\n\t\t\t\t\t\t\treturn Mono.just(baseUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chain.resolveResource(null, baseUrl, locations)\n\t\t\t\t\t\t\t\t.flatMap(resource -> strategy.getResourceVersion(resource)\n\t\t\t\t\t\t\t\t\t\t.map(version -> strategy.addVersion(baseUrl, version)));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compareTo(other,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} to ensure they have conditions with\n\t * content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, ServerWebExchange exchange) {\n\t\tint result = this.patternsCondition.compareTo(other.getPatternsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(resolvable,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(resolvable, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(session,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void onError(Session session, Throwable exception)",
    "source_code": "\tpublic void onError(Session session, Throwable exception) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(exception);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide request parameters identifying the request for this FlashMap.\n\t * @param params a Map with the names and values of expected parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tparams.forEach((key, values) -> {\n\t\t\t\tfor (String value : values) {\n\t\t\t\t\taddTargetRequestParam(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#postProcess(webRequest,task,concurrentResult)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task",
      "concurrentResult"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult)",
    "source_code": "\t\tpublic <T> void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tresetContextHolders(request, null, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "void",
    "signature": "public void addHeader(String name, String value)",
    "source_code": "\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addIntHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 502
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\t\t\tpublic void addIntHeader(String name, int value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addIntHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject oldValue = this.servletRequest.getAttribute(key);\n\t\t\tthis.servletRequest.setAttribute(key, value);\n\t\t\treturn oldValue;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Optional<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Optional<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHandlerMap(Map<String,handlerMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure the resource mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. However if this property is\n\t * used, the auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap)",
    "source_code": "\tpublic void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap) {\n\t\tif (handlerMap != null) {\n\t\t\tthis.handlerMap.clear();\n\t\t\tthis.handlerMap.putAll(handlerMap);\n\t\t\tthis.autodetect = false;\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#expand(uriVariables,encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "PathComponent",
    "signature": "public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder)",
    "source_code": "\t\tpublic PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {\n\t\t\tList<PathComponent> expandedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\texpandedComponents.add(pathComponent.expand(uriVariables, encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(expandedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeRequest(request,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate request object of the specified type, if available,\n\t * unwrapping the given request as far as necessary.\n\t * @param request the servlet request to introspect\n\t * @param requiredType the desired type of request object\n\t * @return the matching request object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "T",
    "signature": "public T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(request)) {\n\t\t\t\treturn (T) request;\n\t\t\t}\n\t\t\telse if (request instanceof ServletRequestWrapper wrapper) {\n\t\t\t\treturn getNativeRequest(wrapper.getRequest(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRealPath(servletContext,path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the real path of the given path within the web application,\n\t * as provided by the servlet container.\n\t * <p>Prepends a slash if the path does not already start with a slash,\n\t * and throws a FileNotFoundException if the path cannot be resolved to\n\t * a resource (in contrast to ServletContext's {@code getRealPath},\n\t * which returns null).\n\t * @param servletContext the servlet context of the web application\n\t * @param path the path within the web application\n\t * @return the corresponding real path\n\t * @throws FileNotFoundException if the path cannot be resolved to a resource\n\t * @see jakarta.servlet.ServletContext#getRealPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "path"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "String",
    "signature": "public String getRealPath(ServletContext servletContext, String path)",
    "source_code": "\tpublic static String getRealPath(ServletContext servletContext, String path) throws FileNotFoundException {\n\t\tAssert.notNull(servletContext, \"ServletContext must not be null\");\n\t\t// Interpret location as relative to the web application root directory.\n\t\tif (!path.startsWith(\"/\")) {\n\t\t\tpath = \"/\" + path;\n\t\t}\n\t\tString realPath = servletContext.getRealPath(path);\n\t\tif (realPath == null) {\n\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\"ServletContext resource [\" + path + \"] cannot be resolved to absolute file path - \" +\n\t\t\t\t\t\"web application archive not expanded?\");\n\t\t}\n\t\treturn realPath;\n\t}"
  }
}