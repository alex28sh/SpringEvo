{
  "org.springframework.aot.generate.<unknown>#handleFile(kind,path,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler)",
    "source_code": "\tpublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\n\t\tFileSystemFileHandler fileHandler = new FileSystemFileHandler(toPath(kind, path));\n\t\thandler.accept(fileHandler);\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn convertIfNecessary((field != null ? field.getName() : null), value, requiredType,\n\t\t\t\t(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifiers(bdHolder,annotationsToSearch)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tif (ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\treturn true;\n\t\t}\n\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\tif (isPlainJavaAnnotation(type)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean checkMeta = true;\n\t\t\tboolean fallbackToMeta = false;\n\t\t\tif (isQualifier(type)) {\n\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckMeta = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkMeta) {\n\t\t\t\tboolean foundMeta = false;\n\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\tif (isPlainJavaAnnotation(metaType)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#retrieve(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn CompletableFuture.supplyAsync(() ->\n\t\t\t\t(T) fromStoreValue(this.store.computeIfAbsent(key, k -> toStoreValue(valueLoader.get().join()))));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doClear(cache,immediate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#clear()} on the specified {@link Cache} and\n\t * invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "immediate"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "protected void doClear(Cache cache, boolean immediate)",
    "source_code": "\tprotected void doClear(Cache cache, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.invalidate();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheClearError(ex, cache);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doPut(cache,key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#put(Object, Object)} on the specified {@link Cache}\n\t * and invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "protected void doPut(Cache cache, Object key, @Nullable Object value)",
    "source_code": "\tprotected void doPut(Cache cache, Object key, @Nullable Object value) {\n\t\ttry {\n\t\t\tcache.put(key, value);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCachePutError(ex, cache, key, value);\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#cacheException(exceptionCache,filter,cacheKey,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionCache",
      "filter",
      "cacheKey",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "protected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex)",
    "source_code": "\tprotected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {\n\t\tif (exceptionCache == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (filter.match(ex.getClass())) {\n\t\t\tdoPut(exceptionCache, cacheKey, ex);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#resolveAndSet(registeredBean,instance)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void resolveAndSet(RegisteredBean registeredBean, Object instance)",
    "source_code": "\t\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\t\tMethod method = getMethod(registeredBean);\n\t\t\tObject resolved = resolve(registeredBean);\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved);\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#setTimeoutForShutdownPhase(phase,timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of a specific phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param phase the phase value (matching {@link SmartLifecycle#getPhase()})\n\t * @param timeout the corresponding timeout value (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setTimeoutForShutdownPhase(int phase, long timeout)",
    "source_code": "\tpublic void setTimeoutForShutdownPhase(int phase, long timeout) {\n\t\tthis.timeoutsForShutdownPhases.put(phase, timeout);\n\t}"
  },
  "org.springframework.core.<unknown>#forParameter(executable,parameterIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "Nullness",
    "signature": "public Nullness forParameter(Executable executable, int parameterIndex)",
    "source_code": "\t\tpublic static Nullness forParameter(Executable executable, int parameterIndex) {\n\t\t\tKFunction<?> function;\n\t\t\tPredicate<KParameter> predicate;\n\t\t\tif (executable instanceof Method method) {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tpredicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction((Constructor<?>) executable);\n\t\t\t\tpredicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||\n\t\t\t\t\t\tKParameter.Kind.INSTANCE.equals(p.getKind()));\n\t\t\t}\n\t\t\tif (function == null) {\n\t\t\t\treturn Nullness.UNSPECIFIED;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\tif (predicate.test(kParameter) && parameterIndex == i++) {\n\t\t\t\t\treturn (kParameter.getType().isMarkedNullable() ? Nullness.NULLABLE : Nullness.NON_NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Nullness.UNSPECIFIED;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#and(container,repeatable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an additional explicit relationship between a container and\n\t * repeatable annotation.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #of(Class, Class)}.\n\t * @param container the container annotation type\n\t * @param repeatable the repeatable annotation type\n\t * @return a new {@link RepeatableContainers} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "container",
      "repeatable"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers and(Class<? extends Annotation> container,\n\t\t\tClass<? extends Annotation> repeatable)",
    "source_code": "\tpublic RepeatableContainers and(Class<? extends Annotation> container,\n\t\t\tClass<? extends Annotation> repeatable) {\n\n\t\treturn new ExplicitRepeatableContainer(this, repeatable, container);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAllMergedAnnotations(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn findAnnotations(element).stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAllMergedAnnotations(element,annotationTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\n\t\treturn findAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedAnnotation(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 627
    },
    "return": "A",
    "signature": "public A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType,predicate)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate) {\n\n\t\treturn get(annotationType, predicate, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllAnnotationAttributes(element,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of the specified\n\t * {@code annotationName} in the annotation hierarchy above the supplied\n\t * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(\n\t\t\tAnnotatedElement element, String annotationName) {\n\n\t\treturn getAllAnnotationAttributes(element, annotationName, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllMergedAnnotations(element,annotationTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes) {\n\n\t\treturn getAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#addInstance(factoryType,factoryInstance)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryInstance the implementation instances to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryInstance"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void addInstance(String factoryType, T... factoryInstance)",
    "source_code": "\tpublic <T> void addInstance(String factoryType, T... factoryInstance) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(factoryType, key -> new ArrayList<>());\n\t\tfor (T factoryImplementation : factoryInstance) {\n\t\t\tString reference = \"!\" + factoryType + \":\" + factoryImplementation.getClass().getName()\n\t\t\t\t\t+ this.sequence.getAndIncrement();\n\t\t\timplementations.add(reference);\n\t\t\tthis.implementations.put(reference, factoryImplementation);\n\t\t}\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(context,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue(context);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), expectedResultType);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(rootObject,desiredResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType) throws EvaluationException {\n\t\tString value = getValue(rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), desiredResultType);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#setValue(context,rootObject,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toBoolean(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a boolean using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "boolean",
    "signature": "public boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Boolean.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toDouble(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a double using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "double",
    "signature": "public double toDouble(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static double toDouble(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Double.class);\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#generateCodeForArgument(methodVisitor,argument,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>Delegates to {@link #generateCodeForArgument(MethodVisitor, SpelNode, String)}\n\t * with the {@linkplain #toDescriptor(Class) descriptor} for\n\t * the supplied {@code requiredType}.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredType}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, int.class)}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredType the required type for the argument when invoking the\n\t * corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType) {\n\t\tgenerateCodeForArgument(methodVisitor, argument, toDescriptor(requiredType));\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(context,rootObject,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#print(value,style)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style) {\n\t\treturn print(value, style, null);\n\t}"
  },
  "org.springframework.http.<unknown>#hasHeaderValues(headerName,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this HttpHeaders contains exactly the given list\n\t * of values for the given header name.\n\t * @param headerName the header name\n\t * @param values the expected list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1912
    },
    "return": "boolean",
    "signature": "public boolean hasHeaderValues(String headerName, List<String> values)",
    "source_code": "\tpublic boolean hasHeaderValues(String headerName, List<String> values) {\n\t\treturn ObjectUtils.nullSafeEquals(this.headers.get(headerName), values);\n\t}"
  },
  "org.springframework.http.<unknown>#method(method,uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, @Nullable Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#put(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, @Nullable Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1813
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\t\t\tStreamUtils.copy(body, outputStream);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tif (!uri.isAbsolute()) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n\t\t}\n\n\t\tif (!this.httpClient.isStarted()) {\n\t\t\ttry {\n\t\t\t\tthis.httpClient.start();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tRequest jettyRequest = this.httpClient.newRequest(uri).method(method.toString());\n\t\tJettyClientHttpRequest request = new JettyClientHttpRequest(jettyRequest, this.bufferFactory);\n\n\t\treturn requestCallback.apply(request).then(execute(request));\n\t}"
  },
  "org.springframework.http.converter.protobuf.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Message",
    "signature": "protected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = PROTOBUF;\n\t\t}\n\t\tCharset charset = contentType.getCharset();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\tMessage.Builder builder = getMessageBuilder(clazz);\n\t\tif (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tbuilder.mergeFrom(inputMessage.getBody(), this.extensionRegistry);\n\t\t}\n\t\telse if (TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tInputStreamReader reader = new InputStreamReader(inputMessage.getBody(), charset);\n\t\t\tTextFormat.merge(reader, this.extensionRegistry, builder);\n\t\t}\n\t\telse if (this.protobufFormatSupport != null) {\n\t\t\tthis.protobufFormatSupport.merge(\n\t\t\t\t\tinputMessage.getBody(), charset, contentType, this.extensionRegistry, builder);\n\t\t}\n\t\treturn builder.build();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(value,headers,result)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "protected void writeToResult(Object value, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object value, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(value, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,batchArgs,generatedKeyHolder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder) {\n\t\treturn batchUpdate(sql, batchArgs, generatedKeyHolder, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#execute(sql,Map<String,paramMap,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(sql, new MapSqlParameterSource(paramMap), action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,Map<String,paramMap,rch)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)\n\t\t\tthrows DataAccessException {\n\n\t\tquery(sql, new MapSqlParameterSource(paramMap), rch);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,paramSource,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,paramSource,rse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "T",
    "signature": "public T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rse);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#execute(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object>",
    "signature": "public Object> execute(Map<String, ?> args)",
    "source_code": "\tpublic Map<String, Object> execute(Map<String, ?> args) {\n\t\treturn doExecute(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#executeFunction(returnType,Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T executeFunction(Class<T> returnType, Map<String, ?> args)",
    "source_code": "\tpublic <T> @Nullable T executeFunction(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBinaryStream(pos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "InputStream",
    "signature": "public InputStream getBinaryStream(long pos, long length)",
    "source_code": "\tpublic InputStream getBinaryStream(long pos, long length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes,offset,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes",
      "offset",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes, int offset, int len)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setClobAsAsciiStream(ps,paramIndex,asciiStream,contentLength)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "asciiStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)",
    "source_code": "\t\tpublic void setClobAsAsciiStream(\n\t\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)\n\t\t\t\tthrows SQLException {\n\n\t\t\tif (streamAsLob) {\n\t\t\t\tif (asciiStream != null) {\n\t\t\t\t\tReader reader = new InputStreamReader(asciiStream, StandardCharsets.US_ASCII);\n\t\t\t\t\tif (contentLength >= 0) {\n\t\t\t\t\t\tps.setClob(paramIndex, reader, contentLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tps.setClob(paramIndex, reader);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (wrapAsLob) {\n\t\t\t\tif (asciiStream != null) {\n\t\t\t\t\tps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contentLength >= 0) {\n\t\t\t\tps.setAsciiStream(paramIndex, asciiStream, contentLength);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tps.setAsciiStream(paramIndex, asciiStream);\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(asciiStream != null ? \"Set ASCII stream for CLOB with length \" + contentLength :\n\t\t\t\t\t\t\"Set CLOB to null\");\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getObject(columnIndex,Map<String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(int, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "Object",
    "signature": "public Object getObject(int columnIndex, Map<String, Class<?>> map)",
    "source_code": "\tpublic @Nullable Object getObject(int columnIndex, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, map);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(payload,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, payload, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), payload, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(request,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor) {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn convertSendAndReceive(defaultDestination, request, targetClass, postProcessor);\n\t\t}\n\t\telse {\n\t\t\treturn convertSendAndReceive(getRequiredDefaultDestinationName(), request, targetClass, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#appendIdentityToObjectName(objectName,managedResource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append an additional key/value pair to an existing {@link ObjectName} with the key being\n\t * the static value {@code identity} and the value being the identity hash code of the\n\t * managed resource being exposed on the supplied {@link ObjectName}. This can be used to\n\t * provide a unique {@link ObjectName} for each distinct instance of a particular bean or\n\t * class. Useful when generating {@link ObjectName ObjectNames} at runtime for a set of\n\t * managed resources based on the template value supplied by a\n\t * {@link org.springframework.jmx.export.naming.ObjectNamingStrategy}.\n\t * @param objectName the original JMX ObjectName\n\t * @param managedResource the MBean instance\n\t * @return an ObjectName with the MBean identity added\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see org.springframework.util.ObjectUtils#getIdentityHexString(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectName",
      "managedResource"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ObjectName",
    "signature": "public ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)",
    "source_code": "\tpublic static ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\tHashtable<String, String> keyProperties = objectName.getKeyPropertyList();\n\t\tkeyProperties.put(IDENTITY_OBJECT_NAME_KEY, ObjectUtils.getIdentityHexString(managedResource));\n\t\treturn ObjectNameManager.getInstance(objectName.getDomain(), keyProperties);\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#getBean(name,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\ttry {\n\t\t\tif (isSingleton(name)) {\n\t\t\t\treturn doGetSingleton(name, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lookup(name, requiredType);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException ex) {\n\t\t\tthrow new NoSuchBeanDefinitionException(name, \"not found in JNDI environment\");\n\t\t}\n\t\tcatch (TypeMismatchNamingException ex) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, ex.getRequiredType(), ex.getActualType());\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"JNDI environment\", name, \"JNDI lookup failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,inputStreamSource,contentType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName and content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1082
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, inlineFilename);\n\t\taddInline(contentId, inlineFilename, dataSource);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destinationName,payload)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload) {\n\t\tconvertAndSend(destinationName, payload, null, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doConvert(message,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert from the given message to the given target class.\n\t * @param message the message to convert\n\t * @param targetClass the target class to convert the payload to\n\t * @return the converted payload of the reply message (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "T",
    "signature": "protected T doConvert(Message<?> message, Class<T> targetClass)",
    "source_code": "\tprotected <T> @Nullable T doConvert(Message<?> message, Class<T> targetClass) {\n\t\tMessageConverter messageConverter = getMessageConverter();\n\t\tT value = (T) messageConverter.fromMessage(message, targetClass);\n\t\tif (value == null) {\n\t\t\tthrow new MessageConversionException(message, \"Unable to convert payload [\" + message.getPayload() +\n\t\t\t\t\t\"] to type [\" + targetClass + \"] using converter [\" + messageConverter + \"]\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getDestination(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String getDestination(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getDestination(Map<String, Object> headers) {\n\t\treturn (String) headers.get(DESTINATION_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "TaskExecutor",
    "signature": "public TaskExecutor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic TaskExecutor brokerChannelExecutor(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tChannelRegistration registration = registry.getBrokerChannelRegistration();\n\t\tTaskExecutor executor = getTaskExecutor(registration, \"brokerChannel-\", () -> {\n\t\t\t// Should never be used\n\t\t\tThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();\n\t\t\tthreadPoolTaskExecutor.setCorePoolSize(0);\n\t\t\tthreadPoolTaskExecutor.setMaxPoolSize(1);\n\t\t\tthreadPoolTaskExecutor.setQueueCapacity(0);\n\t\t\treturn threadPoolTaskExecutor;\n\t\t});\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.test.context.<unknown>#findMergedAnnotation(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied class, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy, and synthesize the result back\n\t * into an annotation of the specified {@code annotationType}.\n\t * <p>In the context of this method, the term \"above\" means within the\n\t * {@linkplain Class#getSuperclass() superclass} hierarchy or within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @see AnnotatedElementUtils#findMergedAnnotation(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "T",
    "signature": "public T findMergedAnnotation(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable T findMergedAnnotation(Class<?> clazz, Class<T> annotationType) {\n\t\treturn findMergedAnnotation(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#apply(reset,settings)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset",
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "MockSettings",
    "signature": "public MockSettings apply(MockReset reset, MockSettings settings)",
    "source_code": "\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "AbstractMockitoBeanOverrideHandler",
    "signature": "public AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockitoBean) {\n\t\t\tAssert.state(mockitoBean.types().length == 0,\n\t\t\t\t\t\"The @MockitoBean 'types' attribute must be omitted when declared on a field\");\n\t\t\treturn new MockitoBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockitoBean);\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean mockitoSpyBean) {\n\t\t\tAssert.state(mockitoSpyBean.types().length == 0,\n\t\t\t\t\t\"The @MockitoSpyBean 'types' attribute must be omitted when declared on a field\");\n\t\t\treturn new MockitoSpyBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockitoSpyBean);\n\t\t}\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\texpected either @MockitoBean or @MockitoSpyBean on field %s.%s\"\"\"\n\t\t\t\t\t.formatted(field.getDeclaringClass().getName(), field.getName()));\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertBoolean(content,encoding,expectedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Boolean.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue)",
    "source_code": "\tpublic void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, Boolean.parseBoolean(actual));\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNode(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link Node},\n\t * and assert it with the given {@code Matcher<Node>}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)",
    "source_code": "\tpublic void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)\n\t\t\tthrows Exception {\n\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, node, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNumber(content,encoding,expectedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Double.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue)",
    "source_code": "\tpublic void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertString(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)",
    "source_code": "\tpublic void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)\n\t\t\tthrows Exception {\n\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, actual, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeMethod(targetClass,name,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the static method with the given {@code name} on the supplied target\n\t * class with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "T",
    "signature": "public T invokeMethod(Class<?> targetClass, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Class<?> targetClass, String name, Object... args) {\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\treturn invokeMethod(null, targetClass, name, args);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetClass,name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the static {@linkplain Field field} with the given {@code name} on\n\t * the provided {@code targetClass} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} and {@code type} arguments.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setField(Class<?> targetClass, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Class<?> targetClass, String name, @Nullable Object value) {\n\t\tsetField(null, targetClass, name, value, null);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(expectedJson,comparator)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJson",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 670
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String expectedJson, JsonComparator comparator)",
    "source_code": "\t\tpublic BodyContentSpec json(String expectedJson, JsonComparator comparator) {\n\t\t\tthis.result.assertWithDiagnostics(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tcomparator.assertIsMatch(expectedJson, getBodyAsString());\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AssertionError(\"JSON parsing error\", ex);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI for the request using a URI template and URI variables.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "B",
    "signature": "public B uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\tpublic B uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\treturn updateUri(initUri(uriTemplate, uriVariables), uriTemplate);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#doFilter(request,response,filterChain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tString requestPath = UrlPathHelper.defaultInstance.getPathWithinApplication(httpRequest);\n\n\t\tif (matchDispatcherType(httpRequest.getDispatcherType()) && matchRequestPath(requestPath)) {\n\t\t\tthis.delegate.doFilter(request, response, filterChain);\n\t\t}\n\t\telse {\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isVisible(clazz,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader == null) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getClassLoader() == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Visible if same Class can be loaded from given ClassLoader\n\t\treturn isLoadable(clazz, classLoader);\n\t}"
  },
  "org.springframework.util.<unknown>#notNull(object,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, String message)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, String message) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notNull(object,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.notNull(entity.getId(),\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#simpleMatch(pattern,str)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(@Nullable String pattern, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\n\t\tif (pattern == null || str == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint firstIndex = pattern.indexOf('*');\n\t\tif (firstIndex == -1) {\n\t\t\treturn pattern.equals(str);\n\t\t}\n\n\t\tif (firstIndex == 0) {\n\t\t\tif (pattern.length() == 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tint nextIndex = pattern.indexOf('*', 1);\n\t\t\tif (nextIndex == -1) {\n\t\t\t\treturn str.endsWith(pattern.substring(1));\n\t\t\t}\n\t\t\tString part = pattern.substring(1, nextIndex);\n\t\t\tif (part.isEmpty()) {\n\t\t\t\treturn simpleMatch(pattern.substring(nextIndex), str);\n\t\t\t}\n\t\t\tint partIndex = str.indexOf(part);\n\t\t\twhile (partIndex != -1) {\n\t\t\t\tif (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpartIndex = str.indexOf(part, partIndex + 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (str.length() >= firstIndex &&\n\t\t\t\tpattern.startsWith(str.substring(0, firstIndex)) &&\n\t\t\t\tsimpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#reject(errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.errors.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.errors.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.client.<unknown>#cookie(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#of(predicate,errorHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "StatusHandler",
    "signature": "public StatusHandler of(Predicate<HttpStatusCode> predicate,\n\t\t\tRestClient.ResponseSpec.ErrorHandler errorHandler)",
    "source_code": "\tpublic static StatusHandler of(Predicate<HttpStatusCode> predicate,\n\t\t\tRestClient.ResponseSpec.ErrorHandler errorHandler) {\n\t\tAssert.notNull(predicate, \"Predicate must not be null\");\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\treturn new StatusHandler(response -> predicate.test(response.getStatusCode()), errorHandler);\n\t}"
  },
  "org.springframework.web.client.<unknown>#setBodyConvertFunction(Function<ResolvableType,bodyConvertFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a function to use to decode the response error content\n\t * via {@link #getResponseBodyAs(Class)}.\n\t * @param bodyConvertFunction the function to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ResolvableType",
      "bodyConvertFunction"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction)",
    "source_code": "\tpublic void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction) {\n\t\tthis.bodyConvertFunction = bodyConvertFunction;\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#registerDeferredResultInterceptor(key,interceptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link DeferredResultProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor)",
    "source_code": "\tpublic void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"DeferredResultProcessingInterceptor is required\");\n\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attribute(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthenticationCredentials(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\tAssert.notNull(statusCodePredicate, \"StatusCodePredicate must not be null\");\n\t\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\t\t\tint index = this.statusHandlers.size() - this.defaultStatusHandlerCount;  // Default handlers always last\n\t\t\tthis.statusHandlers.add(index, new StatusHandler(statusCodePredicate, exceptionFunction));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriFunction.apply(uriBuilder));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getModelAndView(viewName,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView for the given view name and exception.\n\t * <p>The default implementation adds the specified exception attribute.\n\t * Can be overridden in subclasses.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the ModelAndView instance\n\t * @see #setExceptionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView getModelAndView(String viewName, Exception ex)",
    "source_code": "\tprotected ModelAndView getModelAndView(String viewName, Exception ex) {\n\t\tModelAndView mv = new ModelAndView(viewName);\n\t\tif (this.exceptionAttribute != null) {\n\t\t\tmv.addObject(this.exceptionAttribute, ex);\n\t\t}\n\t\treturn mv;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#resolveException(request,response,handler,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this resolver is supposed to apply (i.e. if the supplied handler\n\t * matches any of the configured {@linkplain #setMappedHandlers handlers} or\n\t * {@linkplain #setMappedHandlerClasses handler classes}), and then delegate\n\t * to the {@link #doResolveException} template method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tpublic @Nullable ModelAndView resolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tif (shouldApplyTo(request, handler)) {\n\t\t\tprepareResponse(ex, response);\n\t\t\tModelAndView result = doResolveException(request, response, handler, ex);\n\t\t\tif (result != null && !disconnectedClientHelper.checkAndLogClientDisconnectedException(ex)) {\n\t\t\t\t// Print debug message when warn logger is not enabled.\n\t\t\t\tif (logger.isDebugEnabled() && (this.warnLogger == null || !this.warnLogger.isWarnEnabled())) {\n\t\t\t\t\tlogger.debug(buildLogMessage(ex, request) + (result.isEmpty() ? \"\" : \" to \" + result));\n\t\t\t\t}\n\t\t\t\t// Explicitly configured warn logger in logException method.\n\t\t\t\tlogException(ex, request);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequestInternal(request,response,wsHandler,sockJsSession)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, AbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tprotected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, AbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = readMessages(request);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tlogger.error(\"Failed to read message\", ex);\n\t\t\tif (ex.getClass().getName().contains(\"Mapping\")) {\n\t\t\t\t// for example, Jackson's JsonMappingException, indicating an incomplete payload\n\t\t\t\thandleReadError(response, \"Payload expected.\", sockJsSession.getId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\thandleReadError(response, \"Broken JSON encoding.\", sockJsSession.getId());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Failed to read message\", ex);\n\t\t\thandleReadError(response, \"Failed to read message(s)\", sockJsSession.getId());\n\t\t\treturn;\n\t\t}\n\t\tif (messages == null) {\n\t\t\thandleReadError(response, \"Payload expected.\", sockJsSession.getId());\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Received message(s): \" + Arrays.toString(messages));\n\t\t}\n\t\tresponse.setStatusCode(getResponseStatus());\n\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\n\t\tsockJsSession.delegateMessages(messages);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeAuthority(authority,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded authority\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "authority",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String",
    "signature": "public String encodeAuthority(String authority, Charset charset)",
    "source_code": "\tpublic static String encodeAuthority(String authority, Charset charset) {\n\t\treturn encode(authority, charset, HierarchicalUriComponents.Type.AUTHORITY);\n\t}"
  },
  "org.springframework.web.util.<unknown>#handle(c,url,p)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "c",
      "url",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 1706
    },
    "return": "void",
    "signature": "public void handle(int c, UrlRecord url, WhatWgUrlParser p)",
    "source_code": "\t\tpublic abstract void handle(int c, UrlRecord url, WhatWgUrlParser p);"
  },
  "org.springframework.web.util.<unknown>#parseForwardedFor(request,remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @deprecated in favor of {@link ForwardedHeaderUtils#parseForwardedFor};\n\t * to be removed in 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor(\n\t\t\tHttpRequest request, @Nullable InetSocketAddress remoteAddress) {\n\n\t\treturn ForwardedHeaderUtils.parseForwardedFor(\n\t\t\t\trequest.getURI(), request.getHeaders(), remoteAddress);\n\t}"
  },
  "org.springframework.web.util.<unknown>#setDefaultUriVariables(Map<String,defaultUriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide default URI variable values to use when expanding URI templates\n\t * with a Map of variables.\n\t * @param defaultUriVariables default URI variable values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "defaultUriVariables"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables)",
    "source_code": "\tpublic void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables) {\n\t\tif (defaultUriVariables != null) {\n\t\t\tif (this.defaultUriVariables == null) {\n\t\t\t\tthis.defaultUriVariables = new HashMap<>(defaultUriVariables);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.defaultUriVariables.putAll(defaultUriVariables);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.defaultUriVariables != null) {\n\t\t\t\tthis.defaultUriVariables.clear();\n\t\t\t}\n\t\t}\n\t}"
  }
}