{
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jp,jpMatch,returnValue,t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "t"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t)",
    "source_code": "\tprotected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t) throws Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target,editable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the given target bean,\n\t * only setting properties defined in the given \"editable\" class (or interface).\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects. See the\n\t * documentation for {@link #copyProperties(Object, Object)} for details.\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @param editable the class (or interface) to restrict property setting to\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target",
      "editable"
    ],
    "position": {
      "column": 1,
      "line": 741
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target, Class<?> editable)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {\n\t\tcopyProperties(source, target, editable, (String[]) null);\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setPropertyValues(Map<?, ?> map)",
    "source_code": "\tpublic void setPropertyValues(Map<?, ?> map) throws BeansException {\n\t\tsetPropertyValues(new MutablePropertyValues(map));\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex) {\n\t\treturn generateCode(parameterTypes, startIndex, \"args\");\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerCustomEditor(requiredType,propertyEditorClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditorClass"
    ],
    "position": {
      "column": 1,
      "line": 853
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tAssert.notNull(propertyEditorClass, \"PropertyEditor class must not be null\");\n\t\tthis.customEditors.put(requiredType, propertyEditorClass);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerScope(scopeName,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 1023
    },
    "return": "void",
    "signature": "public void registerScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void registerScope(String scopeName, Scope scope) {\n\t\tAssert.notNull(scopeName, \"Scope identifier must not be null\");\n\t\tAssert.notNull(scope, \"Scope must not be null\");\n\t\tif (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot replace existing scopes 'singleton' and 'prototype'\");\n\t\t}\n\t\tScope previous = this.scopes.put(scopeName, scope);\n\t\tif (previous != null && previous != scope) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Replacing scope '\" + scopeName + \"' from [\" + previous + \"] to [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering scope '\" + scopeName + \"' with implementation [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerSingleton(beanName,singletonObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "singletonObject"
    ],
    "position": {
      "column": 1,
      "line": 1174
    },
    "return": "void",
    "signature": "public void registerSingleton(String beanName, Object singletonObject)",
    "source_code": "\tpublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {\n\t\tsuper.registerSingleton(beanName, singletonObject);\n\t\tupdateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));\n\t\tclearByTypeCache();\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#processBeanDefinition(ele,delegate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ele",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t// Register the final decorated instance.\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\t!CollectionUtils.isEmpty(this.cacheOperationSource.getCacheOperations(method, targetClass)));\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method,access)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n        return e.begin_method(access,\n                              method.getSignature(),\n                              method.getExceptionTypes());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#push_object(e,obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void push_object(CodeEmitter e, Object obj)",
    "source_code": "    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }"
  },
  "org.springframework.context.expression.<unknown>#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanExpressionContext, \"Target must be of type BeanExpressionContext\");\n\t\treturn new TypedValue(((BeanExpressionContext) target).getObject(name));\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 1341
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.core.<unknown>#computeAttribute(name,Function<String,computeFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.core.<unknown>#getNested(nestingLevel,Map<Integer,typeIndexesPerLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (e.g. a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (can be {@code null})\n\t * @return a {@code ResolvableType} for the nested level, or {@link #NONE}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel",
      "Map<Integer",
      "typeIndexesPerLevel"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel)",
    "source_code": "\tpublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\n\t\tResolvableType result = this;\n\t\tfor (int i = 2; i <= nestingLevel; i++) {\n\t\t\tif (result.isArray()) {\n\t\t\t\tresult = result.getComponentType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle derived types\n\t\t\t\twhile (result != ResolvableType.NONE && !result.hasGenerics()) {\n\t\t\t\t\tresult = result.getSuperType();\n\t\t\t\t}\n\t\t\t\tInteger index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\n\t\t\t\tindex = (index == null ? result.getGenerics().length - 1 : index);\n\t\t\t\tresult = result.getGeneric(index);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationInherited(annotationType,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@code clazz} and is\n\t * {@linkplain java.lang.annotation.Inherited inherited}\n\t * (i.e. not <em>directly present</em>).\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked. In accordance with standard meta-annotation\n\t * semantics in Java, the inheritance hierarchy for interfaces will not\n\t * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\n\t * for the {@code @Inherited} meta-annotation for further details regarding\n\t * annotation inheritance.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> and <em>inherited</em>\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see #isAnnotationDeclaredLocally(Class, Class)\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotation::isDirectlyPresent)\n\t\t\t\t.findFirst().orElseGet(MergedAnnotation::missing)\n\t\t\t\t.getAggregateIndex() > 0;\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertCheckCast(mv,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n\t * @param mv the method visitor into which the instruction should be inserted\n\t * @param descriptor the descriptor of the type to cast to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "void",
    "signature": "public void insertCheckCast(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() != 1) {\n\t\t\tif (descriptor.charAt(0) == '[') {\n\t\t\t\tif (isPrimitiveArray(descriptor)) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor + \";\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!descriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #part(String, Object)} that also accepts a MediaType.\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @param contentType the media type to help with encoding the part\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part, @Nullable MediaType contentType)",
    "source_code": "\tpublic PartBuilder part(String name, Object part, @Nullable MediaType contentType) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(part, \"'part' must not be null\");\n\n\t\tif (part instanceof Part partObject) {\n\t\t\tPartBuilder builder = asyncPart(name, partObject.content(), DataBuffer.class);\n\t\t\tif (!partObject.headers().isEmpty()) {\n\t\t\t\tbuilder.headers(headers -> {\n\t\t\t\t\theaders.putAll(partObject.headers());\n\t\t\t\t\tString filename = headers.getContentDisposition().getFilename();\n\t\t\t\t\t// reset to parameter name\n\t\t\t\t\theaders.setContentDispositionFormData(name, filename);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\n\t\tif (part instanceof PublisherEntity<?,?> publisherEntity) {\n\t\t\tPublisherPartBuilder<?, ?> builder = new PublisherPartBuilder<>(name, publisherEntity);\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\tthis.parts.add(name, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tObject partBody;\n\t\tHttpHeaders partHeaders = null;\n\t\tif (part instanceof HttpEntity<?> httpEntity) {\n\t\t\tpartBody = httpEntity.getBody();\n\t\t\tpartHeaders = new HttpHeaders();\n\t\t\tpartHeaders.putAll(httpEntity.getHeaders());\n\t\t}\n\t\telse {\n\t\t\tpartBody = part;\n\t\t}\n\n\t\tif (partBody instanceof Publisher) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tUse asyncPart(String, Publisher, Class) \\\n\t\t\t\t\tor asyncPart(String, Publisher, ParameterizedTypeReference) \\\n\t\t\t\t\tor MultipartBodyBuilder.PublisherEntity\"\"\");\n\t\t}\n\n\t\tDefaultPartBuilder builder = new DefaultPartBuilder(name, partHeaders, partBody);\n\t\tif (contentType != null) {\n\t\t\tbuilder.contentType(contentType);\n\t\t}\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(actualType,elementType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn read(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(mappedClass,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @since 5.2.3\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(psc, null, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 931
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 892
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, args, argTypes, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * Named parameters are substituted for a JDBC placeholder and any select list\n\t * is expanded to the required number of placeholders.\n\t * <p>This is a shortcut version of\n\t * {@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}.\n\t * @param sql the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, paramSource);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#applyTimeout(stmt,dataSource,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the specified timeout - overridden by the current transaction timeout,\n\t * if any - to the given JDBC Statement object.\n\t * @param stmt the JDBC Statement object\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @param timeout the timeout to apply (or 0 for no timeout outside of a transaction)\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.Statement#setQueryTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stmt",
      "dataSource",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void applyTimeout(Statement stmt, @Nullable DataSource dataSource, int timeout)",
    "source_code": "\tpublic static void applyTimeout(Statement stmt, @Nullable DataSource dataSource, int timeout) throws SQLException {\n\t\tAssert.notNull(stmt, \"No Statement specified\");\n\t\tConnectionHolder holder = null;\n\t\tif (dataSource != null) {\n\t\t\tholder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\t}\n\t\tif (holder != null && holder.hasTimeout()) {\n\t\t\t// Remaining transaction timeout overrides specified value.\n\t\t\tstmt.setQueryTimeout(holder.getTimeToLiveInSeconds());\n\t\t}\n\t\telse if (timeout >= 0) {\n\t\t\t// No current transaction timeout -> apply specified value.\n\t\t\tstmt.setQueryTimeout(timeout);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#lookupColumnName(resultSetMetaData,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the column name to use. The column name is determined based on a\n\t * lookup using ResultSetMetaData.\n\t * <p>This method's implementation takes into account clarifications expressed\n\t * in the JDBC 4.0 specification:\n\t * <p><i>columnLabel - the label for the column specified with the SQL AS clause.\n\t * If the SQL AS clause was not specified, then the label is the name of the column</i>.\n\t * @param resultSetMetaData the current meta-data to use\n\t * @param columnIndex the index of the column for the lookup\n\t * @return the column name to use\n\t * @throws SQLException in case of lookup failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultSetMetaData",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "String",
    "signature": "public String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex)",
    "source_code": "\tpublic static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {\n\t\tString name = resultSetMetaData.getColumnLabel(columnIndex);\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\tname = resultSetMetaData.getColumnName(columnIndex);\n\t\t}\n\t\treturn name;\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queueName,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1028
    },
    "return": "T",
    "signature": "public T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tString destinationName, final Object message, final MessagePostProcessor postProcessor)\n\t\tthrows JmsException {\n\n\t\tsend(destinationName, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 890
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> doSendAndReceive(session, destination, messageCreator), true);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,jsonView)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Java object to a JMS Message using the specified json view\n\t * and the supplied session  to create the message object.\n\t * @param object the object to convert\n\t * @param session the Session to use for creating a JMS Message\n\t * @param jsonView the view to use to filter the content\n\t * @return the JMS Message\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @throws MessageConversionException in case of conversion failure\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "jsonView"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tif (jsonView != null) {\n\t\t\treturn toMessage(object, session, this.objectMapper.writerWithView(jsonView));\n\t\t}\n\t\telse {\n\t\t\treturn toMessage(object, session, this.objectMapper.writer());\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#setEnvironment(Map<String,environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the environment for the JMX connector.\n\t * @see javax.management.remote.JMXConnectorFactory#connect(javax.management.remote.JMXServiceURL, java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setEnvironment(@Nullable Map<String, ?> environment)",
    "source_code": "\tpublic void setEnvironment(@Nullable Map<String, ?> environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertFrom(message,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "boolean",
    "signature": "protected boolean canConvertFrom(Message<?> message, Class<?> targetClass)",
    "source_code": "\tprotected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {\n\t\treturn (supports(targetClass) && supportsMimeType(message.getHeaders()));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalStateException(\"No handler for return value type: \" + returnType.getParameterType());\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing return value with \" + handler);\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, message);\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,routeVars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the route to a remote handler as described in\n\t * {@link RSocketRequester#route(String, Object...)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "routeVars"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MetadataEncoder",
    "signature": "public MetadataEncoder route(String route, Object... routeVars)",
    "source_code": "\tpublic MetadataEncoder route(String route, Object... routeVars) {\n\t\tthis.route = expand(route, routeVars);\n\t\tassertMetadataEntryCount();\n\t\treturn this;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#refresh(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void refresh(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)\n\t\t\tthrows PersistenceException {\n\n\t\tAssert.notNull(emf, \"No EntityManagerFactory specified\");\n\n\t\tEntityManagerHolder emHolder =\n\t\t\t\t(EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null) {\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tif (!emHolder.isSynchronizedWithTransaction()) {\n\t\t\t\t\tif (TransactionSynchronizationManager.isActualTransactionActive()) {\n\t\t\t\t\t\t// Try to explicitly synchronize the EntityManager itself\n\t\t\t\t\t\t// with an ongoing JTA transaction, if any.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\temHolder.getEntityManager().joinTransaction();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (TransactionRequiredException ex) {\n\t\t\t\t\t\t\tlogger.debug(\"Could not join transaction because none was actually active\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\tObject transactionData = prepareTransaction(emHolder.getEntityManager(), emf);\n\t\t\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, false));\n\t\t\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Use holder's reference count to track synchronizedWithTransaction access.\n\t\t\t\t// isOpen() check used below to find out about it.\n\t\t\t\temHolder.requested();\n\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// unsynchronized EntityManager demanded\n\t\t\t\tif (emHolder.isTransactionActive() && !emHolder.isOpen()) {\n\t\t\t\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// EntityManagerHolder with an active transaction coming from JpaTransactionManager,\n\t\t\t\t\t// with no synchronized EntityManager having been requested by application code before.\n\t\t\t\t\t// Unbind in order to register a new unsynchronized EntityManager instead.\n\t\t\t\t\tTransactionSynchronizationManager.unbindResource(emf);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Either a previously bound unsynchronized EntityManager, or the application\n\t\t\t\t\t// has requested a synchronized EntityManager before and therefore upgraded\n\t\t\t\t\t// this transaction's EntityManager to synchronized before.\n\t\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t// Indicate that we can't obtain a transactional EntityManager.\n\t\t\treturn null;\n\t\t}\n\n\t\t// Create a new EntityManager for use within the current transaction.\n\t\tlogger.debug(\"Opening JPA EntityManager\");\n\t\tEntityManager em = null;\n\t\tif (!synchronizedWithTransaction) {\n\t\t\ttry {\n\t\t\t\tem = emf.createEntityManager(SynchronizationType.UNSYNCHRONIZED, properties);\n\t\t\t}\n\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\t// JPA 2.1 API available but method not actually implemented in persistence provider:\n\t\t\t\t// falling back to regular createEntityManager method.\n\t\t\t}\n\t\t}\n\t\tif (em == null) {\n\t\t\tem = (!CollectionUtils.isEmpty(properties) ? emf.createEntityManager(properties) : emf.createEntityManager());\n\t\t}\n\n\t\ttry {\n\t\t\t// Use same EntityManager for further JPA operations within the transaction.\n\t\t\t// Thread-bound object will get removed by synchronization at transaction completion.\n\t\t\temHolder = new EntityManagerHolder(em);\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tObject transactionData = prepareTransaction(em, emf);\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, true));\n\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unsynchronized - just scope it for the transaction, as demanded by the JPA 2.1 spec...\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionScopedEntityManagerSynchronization(emHolder, emf));\n\t\t\t}\n\t\t\tTransactionSynchronizationManager.bindResource(emf, emHolder);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Unexpected exception from external delegation call -> close EntityManager and rethrow.\n\t\t\tcloseEntityManager(em);\n\t\t\tthrow ex;\n\t\t}\n\n\t\treturn em;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#getTransactionalEntityManager(emf,Map<?,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Note: Will return {@code null} if no thread-bound EntityManager found!\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws DataAccessResourceFailureException if the EntityManager couldn't be obtained\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "EntityManager",
    "signature": "public EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)\n\t\t\tthrows DataAccessResourceFailureException {\n\t\ttry {\n\t\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Could not obtain JPA EntityManager\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanDefinition, beanType, beanName);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setFieldAliases(Map<String,fieldAliases)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field alias/type map, consisting of field names.\n\t * @see XStream#aliasField(String, Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "fieldAliases"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void setFieldAliases(Map<String, String> fieldAliases)",
    "source_code": "\tpublic void setFieldAliases(Map<String, String> fieldAliases) {\n\t\tthis.fieldAliases = fieldAliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalInputStream(inputStream,dataHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 834
    },
    "return": "Object",
    "signature": "public Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\tif (this.streamDriver != null) {\n\t\t\treturn doUnmarshal(this.streamDriver.createReader(inputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\treturn unmarshalReader(new InputStreamReader(inputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#flatMap(Function<Result,mappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Result",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Flux<R>",
    "signature": "public Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction)",
    "source_code": "\t\tpublic <R> Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn flatMap(this.sqlSupplier, mappingFunction);\n\t\t}"
  },
  "org.springframework.scripting.support.<unknown>#evaluate(script,Map<String,argumentBindings)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "argumentBindings"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings) {\n\t\tScriptEngine engine = getScriptEngine(script);\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(argumentBindings)) {\n\t\t\t\treturn engine.eval(script.getScriptAsString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBindings bindings = StandardScriptUtils.getBindings(argumentBindings);\n\t\t\t\treturn engine.eval(script.getScriptAsString(), bindings);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access script for ScriptEngine\", ex);\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ScriptCompilationException(script, new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,strict)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, boolean strict)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tthis.jsonHelper.assertJsonEqual(expectedJsonContent, mockRequest.getBodyAsString(), strict);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#header(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder header(String name, Object... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.util.<unknown>#addIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void addIfAbsent(K key, @Nullable V value)",
    "source_code": "\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#concatenateStringArrays(array1,array2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array1",
      "array2"
    ],
    "position": {
      "column": 1,
      "line": 995
    },
    "return": "String[]",
    "signature": "public String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2)",
    "source_code": "\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#convertNumberToTargetClass(number,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given number into an instance of the given target class.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the converted number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.lang.Byte\n\t * @see java.lang.Short\n\t * @see java.lang.Integer\n\t * @see java.lang.Long\n\t * @see java.math.BigInteger\n\t * @see java.lang.Float\n\t * @see java.lang.Double\n\t * @see java.math.BigDecimal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "number",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T convertNumberToTargetClass(Number number, Class<T> targetClass)",
    "source_code": "\tpublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tAssert.notNull(number, \"Number must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\n\t\tif (targetClass.isInstance(number)) {\n\t\t\treturn (T) number;\n\t\t}\n\t\telse if (Byte.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Byte.valueOf(number.byteValue());\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Short.valueOf(number.shortValue());\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Integer.valueOf(number.intValue());\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\treturn (T) Long.valueOf(value);\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\tif (number instanceof BigDecimal bigDecimal) {\n\t\t\t\t// do not lose precision - use BigDecimal's own conversion\n\t\t\t\treturn (T) bigDecimal.toBigInteger();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// original value is not a Big* number - use standard long conversion\n\t\t\t\treturn (T) BigInteger.valueOf(number.longValue());\n\t\t\t}\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) Float.valueOf(number.floatValue());\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) Double.valueOf(number.doubleValue());\n\t\t}\n\t\telse if (BigDecimal.class == targetClass) {\n\t\t\t// always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\n\t\t\t// (see BigDecimal javadoc for details)\n\t\t\treturn (T) new BigDecimal(number.toString());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" +\n\t\t\t\t\tnumber.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#endsWithIgnoreCase(str,suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} ends with the specified suffix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param suffix the suffix to look for\n\t * @see java.lang.String#endsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "boolean",
    "signature": "public boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix)",
    "source_code": "\tpublic static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {\n\t\treturn (str != null && suffix != null && str.length() >= suffix.length() &&\n\t\t\t\tstr.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()));\n\t}"
  },
  "org.springframework.util.<unknown>#isEmpty(Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean isEmpty(@Nullable Map<?, ?> map)",
    "source_code": "\tpublic static boolean isEmpty(@Nullable Map<?, ?> map) {\n\t\treturn (map == null || map.isEmpty());\n\t}"
  },
  "org.springframework.util.xml.<unknown>#processingInstruction(target,data)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "data"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void processingInstruction(String target, String data)",
    "source_code": "\tpublic void processingInstruction(String target, String data) {\n\t\tNode parent = getParent();\n\t\tProcessingInstruction pi = this.document.createProcessingInstruction(target, data);\n\t\tparent.appendChild(pi);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.source.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code HttpClientErrorException} or an HTTP status specific subclass.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(null, statusCode, statusText, headers, body, charset);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(uriTemplate,method,requestCallback,responseExtractor,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 761
    },
    "return": "T",
    "signature": "public T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables)",
    "source_code": "\tpublic <T> T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {\n\n\t\tURI url = getUriTemplateHandler().expand(uriTemplate, uriVariables);\n\t\treturn doExecute(url, uriTemplate, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.method.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given key-value pair as\n\t * URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * @param name the key to add to the form\n\t * @param value the value to add to the form\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(String name, String value)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(String name, String value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultFormInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doGet(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate GET requests to processRequest/doService.\n\t * <p>Will also be invoked by HttpServlet's default implementation of {@code doHead},\n\t * with a {@code NoBodyResponse} that just captures the content length.\n\t * @see #doService\n\t * @see #doHead\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "void",
    "signature": "protected void doGet(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addAll(Entry<String,c)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<String",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "boolean",
    "signature": "public boolean addAll(Collection<? extends Entry<String, Object>> c)",
    "source_code": "\t\t\t\tpublic boolean addAll(Collection<? extends Entry<String, Object>> c) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#register(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 630
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tString name = null;\n\t\t\t\tif (getNamingStrategy() != null) {\n\t\t\t\t\tname = getNamingStrategy().getName(handlerMethod, mapping);\n\t\t\t\t\taddMappingName(name, handlerMethod);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tcorsConfig.validateAllowPrivateNetwork();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, name, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyWrite(body,returnType,contentType,converterType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "returnType",
      "contentType",
      "converterType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "Object",
    "signature": "public Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType,\n\t\t\tMediaType contentType, Class<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic final Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType,\n\t\t\tMediaType contentType, Class<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (body == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMappingJacksonValue container = getOrCreateContainer(body);\n\t\tbeforeBodyWriteInternal(container, contentType, returnType, request, response);\n\t\treturn container;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setLocationCharsets(Map<Resource,locationCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#exposeLocalizationContext(request,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param request the current HTTP request\n\t * @param messageSource the MessageSource to expose,\n\t * typically the current ApplicationContext (may be {@code null})\n\t * @see #exposeLocalizationContext(RequestContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource)",
    "source_code": "\tpublic static void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource) {\n\t\tLocale jstlLocale = RequestContextUtils.getLocale(request);\n\t\tConfig.set(request, Config.FMT_LOCALE, jstlLocale);\n\t\tTimeZone timeZone = RequestContextUtils.getTimeZone(request);\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(request, Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tif (messageSource != null) {\n\t\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, request);\n\t\t\tConfig.set(request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#webSocketMessageBrokerStats(stompBrokerRelayMessageHandler,subProtocolWebSocketHandler,@Qualifier(\"clientInboundChannelExecutor\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stompBrokerRelayMessageHandler",
      "subProtocolWebSocketHandler",
      "@Qualifier(\"clientInboundChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "WebSocketMessageBrokerStats",
    "signature": "public WebSocketMessageBrokerStats webSocketMessageBrokerStats(@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\")",
    "source_code": "\tpublic WebSocketMessageBrokerStats webSocketMessageBrokerStats(\n\t\t\t@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\") TaskExecutor inboundExecutor,\n\t\t\t@Qualifier(\"clientOutboundChannelExecutor\") TaskExecutor outboundExecutor,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\") TaskScheduler scheduler) {\n\n\t\tWebSocketMessageBrokerStats stats = new WebSocketMessageBrokerStats();\n\t\tstats.setSubProtocolWebSocketHandler((SubProtocolWebSocketHandler) subProtocolWebSocketHandler);\n\t\tif (stompBrokerRelayMessageHandler instanceof StompBrokerRelayMessageHandler sbrmh) {\n\t\t\tstats.setStompBrokerRelay(sbrmh);\n\t\t}\n\t\tstats.setInboundChannelExecutor(inboundExecutor);\n\t\tstats.setOutboundChannelExecutor(outboundExecutor);\n\t\tstats.setSockJsTaskScheduler(scheduler);\n\t\treturn stats;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRequest(servletRequest,servletResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\ttry {\n\t\t\tthis.sockJsService.handleRequest(request, response, getSockJsPath(servletRequest), this.webSocketHandler);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new SockJsException(\"Uncaught failure in SockJS request, uri=\" + request.getURI(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(BiFunction<String,Type,encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<String",
      "Type",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1043
    },
    "return": "PathComponent",
    "signature": "public PathComponent encode(BiFunction<String, Type, String> encoder)",
    "source_code": "\t\tpublic PathComponent encode(BiFunction<String, Type, String> encoder) {\n\t\t\tList<PathComponent> encodedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\tencodedComponents.add(pathComponent.encode(encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(encodedComponents);\n\t\t}"
  }
}