{
  "org.springframework.beans.factory.annotation.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the provided bean definition is an autowire candidate.\n\t * <p>To be considered a candidate the bean's <em>autowire-candidate</em>\n\t * attribute must not have been set to 'false'. Also, if an annotation on\n\t * the field or parameter to be autowired is recognized by this bean factory\n\t * as a <em>qualifier</em>, the bean must 'match' against the annotation as\n\t * well as any attributes it may contain. The bean definition must contain\n\t * the same qualifier or match by meta attributes. A \"value\" attribute will\n\t * fall back to match against the bean name or an alias if a qualifier or\n\t * attribute does not match.\n\t * @see Qualifier\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tboolean match = super.isAutowireCandidate(bdHolder, descriptor);\n\t\tif (match) {\n\t\t\tmatch = checkQualifiers(bdHolder, descriptor.getAnnotations());\n\t\t\tif (match) {\n\t\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\t\tif (methodParam != null) {\n\t\t\t\t\tMethod method = methodParam.getMethod();\n\t\t\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\t\t\tmatch = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addBean(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new singleton bean.\n\t * <p>Will overwrite any existing instance for the given name.\n\t * @param name the name of the bean\n\t * @param bean the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beans.put(name, bean);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create a new instance of a dynamically generated subclass implementing the\n\t\t * required lookups.\n\t\t * @param ctor constructor to use. If this is {@code null}, use the\n\t\t * no-arg constructor (no parameterization, or Setter Injection)\n\t\t * @param args arguments to use for the constructor.\n\t\t * Ignored if the {@code ctor} parameter is {@code null}.\n\t\t * @return new instance of the dynamically generated subclass\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "public Object instantiate(@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\t\tpublic Object instantiate(@Nullable Constructor<?> ctor, Object... args) {\n\t\t\tClass<?> subclass = createEnhancedSubclass(this.beanDefinition);\n\t\t\tObject instance;\n\t\t\tif (ctor == null) {\n\t\t\t\tinstance = BeanUtils.instantiateClass(subclass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());\n\t\t\t\t\tinstance = enhancedSubclassConstructor.newInstance(args);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new BeanInstantiationException(this.beanDefinition.getBeanClass(),\n\t\t\t\t\t\t\t\"Failed to invoke constructor for CGLIB enhanced subclass [\" + subclass.getName() + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPR-10785: set callbacks directly on the instance instead of in the\n\t\t\t// enhanced class (via the Enhancer) in order to avoid memory leaks.\n\t\t\tFactory factory = (Factory) instance;\n\t\t\tfactory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n\t\t\t\t\tnew LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n\t\t\t\t\tnew ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});\n\t\t\treturn instance;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#intercept(obj,method,args,mp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "mp"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\tReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(ro != null, \"ReplaceOverride not found\");\n\t\t\t// TODO could cache if a singleton for minor performance optimization\n\t\t\tMethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);\n\t\t\treturn mr.reimplement(obj, method, args);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers) {\n\n\t\tdoRegisterBean(beanClass, name, null, supplier, customizers);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,qualifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers) {\n\t\tdoRegisterBean(beanClass, null, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, null, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBeanDefinition(definitionHolder,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified bean with the given registry.\n\t * <p>Can be overridden in subclasses, e.g. to adapt the registration\n\t * process or to register further bean definitions for each scanned bean.\n\t * @param definitionHolder the bean definition plus bean name for the bean\n\t * @param registry the BeanDefinitionRegistry to register the bean with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definitionHolder",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(exc,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1193
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, Attachment attachment)",
    "source_code": "\t\tpublic void failed(Throwable exc, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\n\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\tthis.writing.set(false);\n\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.expression.spel.<unknown>#areBoxingCompatible(desc1,desc2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether boxing/unboxing can get from one type to the other.\n\t * <p>Assumes at least one of the types is in boxed form (i.e. single char descriptor).\n\t * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "boolean",
    "signature": "public boolean areBoxingCompatible(String desc1, String desc2)",
    "source_code": "\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n\t\tif (desc1.equals(desc2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (desc1.length() == 1) {\n\t\t\treturn checkPairs(desc1, desc2);\n\t\t}\n\t\telse if (desc2.length() == 1) {\n\t\t\treturn checkPairs(desc2, desc1);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertArrayStore(mv,arrayElementType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertOptimalLoad(mv,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the optimal instruction for loading a number on the stack.\n\t * @param mv where to insert the bytecode\n\t * @param value the value to be loaded\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "void",
    "signature": "public void insertOptimalLoad(MethodVisitor mv, int value)",
    "source_code": "\tpublic static void insertOptimalLoad(MethodVisitor mv, int value) {\n\t\tif (value < 6) {\n\t\t\tmv.visitInsn(ICONST_0+value);\n\t\t}\n\t\telse if (value < Byte.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(BIPUSH, value);\n\t\t}\n\t\telse if (value < Short.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(SIPUSH, value);\n\t\t}\n\t\telse {\n\t\t\tmv.visitLdcInsn(value);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxNumberInsns(mv,targetDescriptor,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * For numbers, use the appropriate method on the number to convert it to the primitive type requested.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param targetDescriptor the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "public void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxNumberInsns(\n\t\t\tMethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {\n\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (targetDescriptor) {\n\t\t\tcase 'D' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\t// does not handle Z, B, C, S\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + targetDescriptor + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#createInvocableHandlerMethod(bean,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\t\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\t\treturn getMessageHandlerMethodFactory().createInvocableHandlerMethod(bean, method);\n\t\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @see #registerListenerContainer(JmsListenerEndpoint, JmsListenerContainerFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory) {\n\t\tregisterListenerContainer(endpoint, factory, false);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Session",
    "signature": "public Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(Session.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queue,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 984
    },
    "return": "T",
    "signature": "public T browse(Queue queue, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(Queue queue, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queue, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queueName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 990
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 996
    },
    "return": "T",
    "signature": "public T browseSelected(String messageSelector, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browseSelected(defaultQueue, messageSelector, action);\n\t\t}\n\t\telse {\n\t\t\treturn browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queue,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "T",
    "signature": "public T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queueName,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "T",
    "signature": "public T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tDestination destination, final Object message, final MessagePostProcessor postProcessor)\n\t\t\tthrows JmsException {\n\n\t\tsend(destination, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "void",
    "signature": "public void convertAndSend(Object message, MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destinationName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "T",
    "signature": "public T execute(final String destinationName, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final String destinationName, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final Destination destination, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> doReceive(session, destination, messageSelector), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destinationName,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final String destinationName, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doReceive(session, destination, messageSelector);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destinationName,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 846
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(String destinationName, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destinationName, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destinationName,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void send(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#commitIfNecessary(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a commit or message acknowledgement, as appropriate.\n\t * @param session the JMS Session to commit\n\t * @param message the Message to acknowledge\n\t * @throws jakarta.jms.JMSException in case of commit failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 770
    },
    "return": "void",
    "signature": "protected void commitIfNecessary(Session session, @Nullable Message message)",
    "source_code": "\tprotected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {\n\t\t// Commit session or acknowledge message.\n\t\tif (session.getTransacted()) {\n\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\telse if (message != null && isClientAcknowledge(session)) {\n\t\t\tmessage.acknowledge();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doReceiveAndExecute(invoker,session,consumer,status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status)",
    "source_code": "\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status) throws JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\tMessageConsumer consumerToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tboolean transactional = false;\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tsessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, true);\n\t\t\t\ttransactional = (sessionToUse != null);\n\t\t\t}\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tConnection conToUse;\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\tconToUse = getSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconToUse = createConnection();\n\t\t\t\t\tconToClose = conToUse;\n\t\t\t\t\tconToUse.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = createSession(conToUse);\n\t\t\t\tsessionToClose = sessionToUse;\n\t\t\t}\n\t\t\tMessageConsumer consumerToUse = consumer;\n\t\t\tif (consumerToUse == null) {\n\t\t\t\tconsumerToUse = createListenerConsumer(sessionToUse);\n\t\t\t\tconsumerToClose = consumerToUse;\n\t\t\t}\n\t\t\tMessage message = receiveMessage(consumerToUse);\n\t\t\tif (message != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received message of type [\" + message.getClass() + \"] from consumer [\" +\n\t\t\t\t\t\t\tconsumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") + \"session [\" +\n\t\t\t\t\t\t\tsessionToUse + \"]\");\n\t\t\t\t}\n\t\t\t\tmessageReceived(invoker, sessionToUse);\n\t\t\t\tboolean exposeResource = (!transactional && isExposeListenerSession() &&\n\t\t\t\t\t\t!TransactionSynchronizationManager.hasResource(obtainConnectionFactory()));\n\t\t\t\tif (exposeResource) {\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\t\tobtainConnectionFactory(), new LocallyExposedJmsResourceHolder(sessionToUse));\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tdoExecuteListener(sessionToUse, message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Rolling back transaction because of listener exception thrown: \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t}\n\t\t\t\t\thandleListenerException(ex);\n\t\t\t\t\t// Rethrow JMSException to indicate an infrastructure problem\n\t\t\t\t\t// that may have to trigger recovery...\n\t\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\t\tthrow jmsException;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (exposeResource) {\n\t\t\t\t\t\tTransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Indicate that a message has been received.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Consumer [\" + consumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") +\n\t\t\t\t\t\t\t\"session [\" + sessionToUse + \"] did not receive a message\");\n\t\t\t\t}\n\t\t\t\tnoMessageReceived(invoker, sessionToUse);\n\t\t\t\t// Nevertheless call commit, in order to reset the transaction timeout (if any).\n\t\t\t\tif (shouldCommitAfterNoMessageReceived(sessionToUse)) {\n\t\t\t\t\tcommitIfNecessary(sessionToUse, null);\n\t\t\t\t}\n\t\t\t\t// Indicate that no message has been received.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumerToClose);\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#receiveAndExecute(invoker,session,consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the listener for a message received from the given consumer,\n\t * wrapping the entire operation in an external transaction if demanded.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doReceiveAndExecute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "boolean",
    "signature": "protected boolean receiveAndExecute(Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer)",
    "source_code": "\tprotected boolean receiveAndExecute(\n\t\t\tObject invoker, @Nullable Session session, @Nullable MessageConsumer consumer)\n\t\t\tthrows JMSException {\n\n\t\tif (this.transactionManager != null) {\n\t\t\t// Execute receive within transaction.\n\t\t\tTransactionStatus status = this.transactionManager.getTransaction(this.transactionDefinition);\n\t\t\tboolean messageReceived;\n\t\t\ttry {\n\t\t\t\tmessageReceived = doReceiveAndExecute(invoker, session, consumer, status);\n\t\t\t}\n\t\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\t\trollbackOnException(this.transactionManager, status, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.transactionManager.commit(status);\n\t\t\t}\n\t\t\tcatch (TransactionException ex) {\n\t\t\t\t// Propagate transaction system exceptions as infrastructure problems.\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t// Typically a late persistence exception from a listener-used resource\n\t\t\t\t// -> handle it as listener exception, not as an infrastructure problem.\n\t\t\t\t// E.g. a database locking failure should not lead to listener shutdown.\n\t\t\t\thandleListenerException(ex);\n\t\t\t}\n\t\t\treturn messageReceived;\n\t\t}\n\n\t\telse {\n\t\t\t// Execute receive outside of transaction.\n\t\t\treturn doReceiveAndExecute(invoker, session, consumer, null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#closeConnection(con,stop)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t * @param stop whether to call {@code stop()} before closing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "stop"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void closeConnection(@Nullable Connection con, boolean stop)",
    "source_code": "\tpublic static void closeConnection(@Nullable Connection con, boolean stop) {\n\t\tif (con != null) {\n\t\t\ttry {\n\t\t\t\tif (stop) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcon.stop();\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcon.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.debug(\"Unexpected exception on closing JMS Connection\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#fromHeaders(headers,jmsMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers",
      "jmsMessage"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage)",
    "source_code": "\tpublic void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\tObject jmsCorrelationId = headers.get(JmsHeaders.CORRELATION_ID);\n\t\t\tif (jmsCorrelationId instanceof Number) {\n\t\t\t\tjmsCorrelationId = jmsCorrelationId.toString();\n\t\t\t}\n\t\t\tif (jmsCorrelationId instanceof String correlationId) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSCorrelationID(correlationId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSCorrelationID - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDestination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);\n\t\t\tif (jmsReplyTo != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSReplyTo(jmsReplyTo);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSReplyTo - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);\n\t\t\tif (jmsType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSType(jmsType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSType - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString headerName = entry.getKey();\n\t\t\t\tif (StringUtils.hasText(headerName) && !headerName.startsWith(JmsHeaders.PREFIX)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value != null && SUPPORTED_PROPERTY_TYPES.contains(value.getClass())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString propertyName = fromHeaderName(headerName);\n\t\t\t\t\t\t\tjmsMessage.setObjectProperty(propertyName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (headerName.startsWith(\"JMSX\")) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping reserved header '\" + headerName +\n\t\t\t\t\t\t\t\t\t\t\t\"' since it cannot be set by client\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to map message header '\" + headerName + \"' to JMS property\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from MessageHeaders to JMS properties\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#createAndConfigureMBean(managedResource,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates an MBean that is configured with the appropriate management\n\t * interface for the supplied managed resource.\n\t * @param managedResource the resource that is to be exported as an MBean\n\t * @param beanKey the key associated with the managed bean\n\t * @see #createModelMBean()\n\t * @see #getMBeanInfo(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedResource",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)",
    "source_code": "\tprotected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)\n\t\t\tthrows MBeanExportException {\n\t\ttry {\n\t\t\tModelMBean mbean = createModelMBean();\n\t\t\tmbean.setModelMBeanInfo(getMBeanInfo(managedResource, beanKey));\n\t\t\tmbean.setManagedResource(managedResource, MR_TYPE_OBJECT_REFERENCE);\n\t\t\treturn mbean;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MBeanExportException(\"Could not create ModelMBean for managed resource [\" +\n\t\t\t\t\tmanagedResource + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerBeanNameOrInstance(mapValue,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an individual bean with the {@link #setServer MBeanServer}.\n\t * <p>This method is responsible for deciding <strong>how</strong> a bean\n\t * should be exposed to the {@code MBeanServer}. Specifically, if the\n\t * supplied {@code mapValue} is the name of a bean that is configured\n\t * for lazy initialization, then a proxy to the resource is registered with\n\t * the {@code MBeanServer} so that the lazy load behavior is\n\t * honored. If the bean is already an MBean then it will be registered\n\t * directly with the {@code MBeanServer} without any intervention. For\n\t * all other beans or bean names, the resource itself is registered with\n\t * the {@code MBeanServer} directly.\n\t * @param mapValue the value configured for this bean in the beans map;\n\t * may be either the {@code String} name of a bean, or the bean itself\n\t * @param beanKey the key associated with this bean in the beans map\n\t * @return the {@code ObjectName} under which the resource was registered\n\t * @throws MBeanExportException if the export failed\n\t * @see #setBeans\n\t * @see #registerBeanInstance\n\t * @see #registerLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapValue",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "ObjectName",
    "signature": "protected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey)",
    "source_code": "\tprotected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey) throws MBeanExportException {\n\t\ttry {\n\t\t\tif (mapValue instanceof String beanName) {\n\t\t\t\t// Bean name pointing to a potentially lazy-init bean in the factory.\n\t\t\t\tif (this.beanFactory == null) {\n\t\t\t\t\tthrow new MBeanExportException(\"Cannot resolve bean names if not running in a BeanFactory\");\n\t\t\t\t}\n\t\t\t\tif (isBeanDefinitionLazyInit(this.beanFactory, beanName)) {\n\t\t\t\t\tObjectName objectName = registerLazyInit(beanName, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject bean = this.beanFactory.getBean(beanName);\n\t\t\t\t\tObjectName objectName = registerBeanInstance(bean, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Plain bean instance -> register it directly.\n\t\t\t\tif (this.beanFactory != null) {\n\t\t\t\t\tMap<String, ?> beansOfSameType =\n\t\t\t\t\t\t\tthis.beanFactory.getBeansOfType(mapValue.getClass(), false, this.allowEagerInit);\n\t\t\t\t\tfor (Map.Entry<String, ?> entry : beansOfSameType.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue() == mapValue) {\n\t\t\t\t\t\t\tString beanName = entry.getKey();\n\t\t\t\t\t\t\tObjectName objectName = registerBeanInstance(mapValue, beanKey);\n\t\t\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\t\t\treturn objectName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn registerBeanInstance(mapValue, beanKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + mapValue + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueListenableFutureCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleNoMatch(ts,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#createPayload(data,metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Payload from the given metadata and data.\n\t * <p>If at least one is {@link NettyDataBuffer} then {@link ByteBufPayload}\n\t * is created with either obtaining the underlying native {@link ByteBuf}\n\t * or using {@link Unpooled#wrappedBuffer(ByteBuffer...)} if necessary.\n\t * Otherwise, if both are {@link DefaultDataBuffer}, then\n\t * {@link DefaultPayload} is created.\n\t * @param data the data part for the payload\n\t * @param metadata the metadata part for the payload\n\t * @return the created payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Payload",
    "signature": "public Payload createPayload(DataBuffer data, DataBuffer metadata)",
    "source_code": "\tpublic static Payload createPayload(DataBuffer data, DataBuffer metadata) {\n\t\treturn data instanceof NettyDataBuffer || metadata instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data), asByteBuf(metadata)) :\n\t\t\t\tDefaultPayload.create(asByteBuffer(data), asByteBuffer(metadata));\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReflectionHints(hints,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tthis.registerMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#createMessage(payload,messageHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "messageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Message<T>",
    "signature": "public Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders)",
    "source_code": "\tpublic static <T> Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name. If the provided value is {@code null},\n\t * the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue) {\n\t\tthis.headerAccessor.setHeader(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not already\n\t * associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue) {\n\t\tthis.headerAccessor.setHeaderIfAbsent(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source,\n\t * using the default ClassLoader.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t * @see #createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces) throws EvalError {\n\t\treturn createBshObject(scriptSource, scriptInterfaces, ClassUtils.getDefaultClassLoader());\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)\n\t\t\tthrows EvalError {\n\n\t\tObject result = evaluateBshScript(scriptSource, scriptInterfaces, classLoader);\n\t\tif (result instanceof Class<?> clazz) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.util.concurrent.<unknown>#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\treturn adaptInternal(this.adaptee.get(timeout, unit));\n\t}"
  },
  "org.springframework.util.xml.<unknown>#setFeature(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setFeature(String name, boolean value)",
    "source_code": "\tpublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n\t\tif (NAMESPACES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacesFeature = value;\n\t\t}\n\t\telse if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacePrefixesFeature = value;\n\t\t}\n\t\telse {\n\t\t\tsuper.setFeature(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fieldTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter, applying it to the specified field types only, if any,\n\t * or otherwise to all fields matching the {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add (does not need to generically declare a\n\t * field type if field types are explicitly specified as parameters)\n\t * @param fieldTypes the field types to apply the formatter to, or none if to be\n\t * derived from the given {@link Formatter} implementation class\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fieldTypes"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tif (ObjectUtils.isEmpty(fieldTypes)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (Class<?> fieldType : fieldTypes) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fields"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, String... fields)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,field,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "field",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 703
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(channel,context,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void onError(WebSocketChannel channel, Void context, Throwable throwable)",
    "source_code": "\t\tpublic void onError(WebSocketChannel channel, Void context, Throwable throwable) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(throwable);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleValue(returnValue,returnType,mav,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given reactive return value and decide whether to adapt it\n\t * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.\n\t * @return an emitter for streaming, or {@code null} if handled internally\n\t * with a {@link DeferredResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mav",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "ResponseBodyEmitter",
    "signature": "public ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request)",
    "source_code": "\tpublic ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request) throws Exception {\n\n\t\tAssert.notNull(returnValue, \"Expected return value\");\n\t\tClass<?> clazz = returnValue.getClass();\n\t\tReactiveAdapter adapter = this.adapterRegistry.getAdapter(clazz);\n\t\tAssert.state(adapter != null, () -> \"Unexpected return value type: \" + clazz);\n\n\t\tif (isContextPropagationPresent) {\n\t\t\treturnValue = ContextSnapshotHelper.writeReactorContext(returnValue);\n\t\t}\n\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(returnType).getGeneric();\n\t\tClass<?> elementClass = elementType.toClass();\n\n\t\tCollection<MediaType> mediaTypes = getMediaTypes(request);\n\t\tOptional<MediaType> mediaType = mediaTypes.stream().filter(MimeType::isConcrete).findFirst();\n\n\t\tif (adapter.isMultiValue()) {\n\t\t\tif (mediaTypes.stream().anyMatch(MediaType.TEXT_EVENT_STREAM::includes) ||\n\t\t\t\t\tServerSentEvent.class.isAssignableFrom(elementClass)) {\n\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\tSseEmitter emitter = new SseEmitter(STREAMING_TIMEOUT_VALUE);\n\t\t\t\tnew SseEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tif (CharSequence.class.isAssignableFrom(elementClass)) {\n\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\tResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN));\n\t\t\t\tnew TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tfor (MediaType type : mediaTypes) {\n\t\t\t\tfor (MediaType streamingType : JSON_STREAMING_MEDIA_TYPES) {\n\t\t\t\t\tif (streamingType.includes(type)) {\n\t\t\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\t\t\tResponseBodyEmitter emitter = getEmitter(streamingType);\n\t\t\t\t\t\tnew JsonEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\t\t\treturn emitter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Not streaming...\n\t\tDeferredResult<Object> result = new DeferredResult<>();\n\t\tnew DeferredResultSubscriber(result, adapter, elementType).connect(adapter, returnValue);\n\t\tWebAsyncUtils.getAsyncManager(request).startDeferredResultProcessing(result, mav);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#createTargetUrl(Map<String,model,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL by checking if the redirect string is a URI template first,\n\t * expanding it with the given model, and then optionally appending simple type model\n\t * attributes as query String parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tif (this.contextRelative && getUrl().startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(getContextPath(request));\n\t\t}\n\t\ttargetUrl.append(getUrl());\n\n\t\tString enc = this.encodingScheme;\n\t\tif (enc == null) {\n\t\t\tenc = request.getCharacterEncoding();\n\t\t}\n\t\tif (enc == null) {\n\t\t\tenc = WebUtils.DEFAULT_CHARACTER_ENCODING;\n\t\t}\n\n\t\tif (this.expandUriTemplateVariables && StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> variables = getCurrentRequestUriVariables(request);\n\t\t\ttargetUrl = replaceUriTemplateVariables(targetUrl.toString(), model, variables, enc);\n\t\t}\n\t\tif (isPropagateQueryProperties()) {\n\t\t\tappendCurrentQueryParams(targetUrl, request);\n\t\t}\n\t\tif (this.exposeModelAttributes) {\n\t\t\tappendQueryProperties(targetUrl, model, enc);\n\t\t}\n\n\t\treturn targetUrl.toString();\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#getHttp11StatusCode(request,response,targetUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determines the status code to use for HTTP 1.1 compatible requests.\n\t * <p>The default implementation returns the {@link #setStatusCode(HttpStatusCode) statusCode}\n\t * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.\n\t * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).\n\t * @param request the request to inspect\n\t * @param response the servlet response\n\t * @param targetUrl the target URL\n\t * @return the response status\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getHttp11StatusCode(HttpServletRequest request, HttpServletResponse response, String targetUrl)",
    "source_code": "\tprotected HttpStatusCode getHttp11StatusCode(\n\t\t\tHttpServletRequest request, HttpServletResponse response, String targetUrl) {\n\n\t\tif (this.statusCode != null) {\n\t\t\treturn this.statusCode;\n\t\t}\n\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\tif (attributeStatusCode != null) {\n\t\t\treturn attributeStatusCode;\n\t\t}\n\t\treturn HttpStatus.SEE_OTHER;\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageFromClient(session,webSocketMessage,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {\n\n\t\tList<Message<byte[]>> messages;\n\t\ttry {\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage) {\n\t\t\t\tbyteBuffer = ((BinaryMessage) webSocketMessage).getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBufferingStompDecoder decoder = this.decoders.get(session.getId());\n\t\t\tif (decoder == null) {\n\t\t\t\tif (!session.isOpen()) {\n\t\t\t\t\tlogger.trace(\"Dropped inbound WebSocket message due to closed session\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new IllegalStateException(\"No decoder for session id '\" + session.getId() + \"'\");\n\t\t\t}\n\n\t\t\tmessages = decoder.decode(byteBuffer);\n\t\t\tif (messages.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received in session \" +\n\t\t\t\t\t\t\tsession + \", bufferSize=\" + decoder.getBufferSize() +\n\t\t\t\t\t\t\t\", bufferSizeLimit=\" + decoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Failed to parse \" + webSocketMessage +\n\t\t\t\t\t\t\" in session \" + session.getId() + \". Sending STOMP ERROR to client.\", ex);\n\t\t\t}\n\t\t\thandleError(session, ex, null);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Message<byte[]> message : messages) {\n\t\t\tStompHeaderAccessor headerAccessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(headerAccessor != null, \"No StompHeaderAccessor\");\n\n\t\t\tStompCommand command = headerAccessor.getCommand();\n\t\t\tboolean isConnect = StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command);\n\n\t\t\tboolean sent = false;\n\t\t\ttry {\n\n\t\t\t\theaderAccessor.setSessionId(session.getId());\n\t\t\t\theaderAccessor.setSessionAttributes(session.getAttributes());\n\t\t\t\theaderAccessor.setUser(getUser(session));\n\t\t\t\tif (isConnect) {\n\t\t\t\t\theaderAccessor.setUserChangeCallback(user -> {\n\t\t\t\t\t\tif (user != null && user != session.getPrincipal()) {\n\t\t\t\t\t\t\tthis.stompAuthentications.put(session.getId(), user);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\theaderAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat());\n\t\t\t\tif (!detectImmutableMessageInterceptor(outputChannel)) {\n\t\t\t\t\theaderAccessor.setImmutable();\n\t\t\t\t}\n\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"From client: \" + headerAccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t}\n\n\t\t\t\tif (isConnect) {\n\t\t\t\t\tthis.stats.incrementConnectCount();\n\t\t\t\t}\n\t\t\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\t\t\tsent = outputChannel.send(message);\n\n\t\t\t\t\tif (sent) {\n\t\t\t\t\t\tif (this.eventPublisher != null) {\n\t\t\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\t\t\tif (isConnect) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.SUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.UNSUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to send message to MessageChannel in session \" + session.getId(), ex);\n\t\t\t\t}\n\t\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\t\t// Skip unsent CONNECT messages (likely auth issues)\n\t\t\t\t\tif (!isConnect || sent) {\n\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" + session.getId() +\n\t\t\t\t\t\t\t\t\":\" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thandleError(session, ex, message);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageToClient(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle STOMP messages going back out to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void handleMessageToClient(WebSocketSession session, Message<?> message)",
    "source_code": "\tpublic void handleMessageToClient(WebSocketSession session, Message<?> message) {\n\t\tif (!(message.getPayload() instanceof byte[] payload)) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Expected byte[] payload. Ignoring \" + message + \".\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor accessor = getStompHeaderAccessor(message);\n\t\tStompCommand command = accessor.getCommand();\n\n\t\tif (StompCommand.MESSAGE.equals(command)) {\n\t\t\tif (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"No STOMP \\\"subscription\\\" header in \" + message);\n\t\t\t}\n\t\t\tString origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\tif (origDestination != null) {\n\t\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\t\taccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\t\taccessor.setDestination(origDestination);\n\t\t\t}\n\t\t}\n\t\telse if (StompCommand.CONNECTED.equals(command)) {\n\t\t\tthis.stats.incrementConnectedCount();\n\t\t\taccessor = afterStompSessionConnected(message, accessor, session);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes());\n\t\t\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {\n\t\t\tMessage<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message);\n\t\t\tif (errorMessage != null) {\n\t\t\t\taccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\t\tpayload = errorMessage.getPayload();\n\t\t\t}\n\t\t}\n\n\t\tRunnable task = OrderedMessageChannelDecorator.getNextMessageTask(message);\n\t\tif (task != null) {\n\t\t\tAssert.isInstanceOf(ConcurrentWebSocketSessionDecorator.class, session);\n\t\t\t((ConcurrentWebSocketSessionDecorator) session).setMessageCallback(m -> task.run());\n\t\t}\n\n\t\tsendToClient(session, accessor, payload);\n\t}"
  }
}