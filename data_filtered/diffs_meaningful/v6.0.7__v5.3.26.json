{
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jpMatch,returnValue,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the advice method.\n\t * @param jpMatch the JoinPointMatch that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the invocation result\n\t * @throws Throwable in case of invocation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 616
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object invokeAdviceMethod(\n\t\t\t@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)\n\t\t\tthrows Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matchesJoinPoint(thisObject,targetObject,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "thisObject",
      "targetObject",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 697
    },
    "return": "JoinPointMatch",
    "signature": "public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args)",
    "source_code": "\t\tpublic JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {\n\t\t\ttry {\n\t\t\t\treturn this.primary.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t\tcatch (ReflectionWorldException ex) {\n\t\t\t\treturn this.other.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#shouldSkip(beanClass,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses should override this method to return {@code true} if the\n\t * given bean should not be considered for auto-proxying by this post-processor.\n\t * <p>Sometimes we need to be able to avoid this happening, e.g. if it will lead to\n\t * a circular reference or if the existing target instance needs to be preserved.\n\t * This implementation returns {@code false} unless the bean name indicates an\n\t * \"original instance\" according to {@code AutowireCapableBeanFactory} conventions.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @return whether to skip the given bean\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#ORIGINAL_INSTANCE_SUFFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "protected boolean shouldSkip(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n\t\treturn AutoProxyUtils.isOriginalInstance(beanName, beanClass);\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(pvs,ignoreUnknown)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "ignoreUnknown"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown)",
    "source_code": "\tpublic void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown) throws BeansException {\n\t\tsetPropertyValues(pvs, ignoreUnknown, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tapplyPropertyValues(beanName, bd, bw, bd.getPropertyValues());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getTypeForFactoryBean(beanName,mbd,allowInit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation attempts to query the FactoryBean's generic parameter metadata\n\t * if present to determine the object type. If not present, i.e. the FactoryBean is\n\t * declared as a raw type, checks the FactoryBean's {@code getObjectType} method\n\t * on a plain instance of the FactoryBean, without bean properties applied yet.\n\t * If this doesn't return a type yet, and {@code allowInit} is {@code true} a\n\t * full creation of the FactoryBean is used as fallback (through delegation to the\n\t * superclass's implementation).\n\t * <p>The shortcut check for a FactoryBean is only applied in case of a singleton\n\t * FactoryBean. If the FactoryBean instance itself is not kept as singleton,\n\t * it will be fully created to check the type of its exposed object.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "allowInit"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit)",
    "source_code": "\tprotected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit) {\n\t\t// Check if the bean definition itself has defined the type with an attribute\n\t\tResolvableType result = getTypeForFactoryBeanFromAttributes(mbd);\n\t\tif (result != ResolvableType.NONE) {\n\t\t\treturn result;\n\t\t}\n\n\t\tResolvableType beanType =\n\t\t\t\t(mbd.hasBeanClass() ? ResolvableType.forClass(mbd.getBeanClass()) : ResolvableType.NONE);\n\n\t\t// For instance supplied beans try the target type and bean class\n\t\tif (mbd.getInstanceSupplier() != null) {\n\t\t\tresult = getFactoryBeanGeneric(mbd.targetType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = getFactoryBeanGeneric(beanType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// Consider factory methods\n\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\tString factoryMethodName = mbd.getFactoryMethodName();\n\n\t\t// Scan the factory bean methods\n\t\tif (factoryBeanName != null) {\n\t\t\tif (factoryMethodName != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from its factory method\n\t\t\t\t// declaration without instantiating the containing bean at all.\n\t\t\t\tBeanDefinition factoryBeanDefinition = getBeanDefinition(factoryBeanName);\n\t\t\t\tClass<?> factoryBeanClass;\n\t\t\t\tif (factoryBeanDefinition instanceof AbstractBeanDefinition abstractBeanDefinition &&\n\t\t\t\t\t\tabstractBeanDefinition.hasBeanClass()) {\n\t\t\t\t\tfactoryBeanClass = abstractBeanDefinition.getBeanClass();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tRootBeanDefinition fbmbd = getMergedBeanDefinition(factoryBeanName, factoryBeanDefinition);\n\t\t\t\t\tfactoryBeanClass = determineTargetType(factoryBeanName, fbmbd);\n\t\t\t\t}\n\t\t\t\tif (factoryBeanClass != null) {\n\t\t\t\t\tresult = getTypeForFactoryBeanFromMethod(factoryBeanClass, factoryMethodName);\n\t\t\t\t\tif (result.resolve() != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If not resolvable above and the referenced factory bean doesn't exist yet,\n\t\t\t// exit here - we don't want to force the creation of another bean just to\n\t\t\t// obtain a FactoryBean's object type...\n\t\t\tif (!isBeanEligibleForMetadataCaching(factoryBeanName)) {\n\t\t\t\treturn ResolvableType.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// If we're allowed, we can create the factory bean and call getObjectType() early\n\t\tif (allowInit) {\n\t\t\tFactoryBean<?> factoryBean = (mbd.isSingleton() ?\n\t\t\t\t\tgetSingletonFactoryBeanForTypeCheck(beanName, mbd) :\n\t\t\t\t\tgetNonSingletonFactoryBeanForTypeCheck(beanName, mbd));\n\t\t\tif (factoryBean != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from this early stage of the instance.\n\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\tif (type != null) {\n\t\t\t\t\treturn ResolvableType.forClass(type);\n\t\t\t\t}\n\t\t\t\t// No type found for shortcut FactoryBean instance:\n\t\t\t\t// fall back to full creation of the FactoryBean instance.\n\t\t\t\treturn super.getTypeForFactoryBean(beanName, mbd, true);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryBeanName == null && mbd.hasBeanClass() && factoryMethodName != null) {\n\t\t\t// No early bean instantiation possible: determine FactoryBean's type from\n\t\t\t// static factory method signature or from class inheritance hierarchy...\n\t\t\treturn getTypeForFactoryBeanFromMethod(mbd.getBeanClass(), factoryMethodName);\n\t\t}\n\t\tresult = getFactoryBeanGeneric(beanType);\n\t\tif (result.resolve() != null) {\n\t\t\treturn result;\n\t\t}\n\t\treturn ResolvableType.NONE;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperationMetadata(operation,method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link CacheOperationMetadata} for the specified operation.\n\t * <p>Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be\n\t * used for the operation.\n\t * @param operation the operation\n\t * @param method the method on which the operation is invoked\n\t * @param targetClass the target type\n\t * @return the resolved metadata for the operation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "CacheOperationMetadata",
    "signature": "protected CacheOperationMetadata getCacheOperationMetadata(CacheOperation operation, Method method, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationMetadata getCacheOperationMetadata(\n\t\t\tCacheOperation operation, Method method, Class<?> targetClass) {\n\n\t\tCacheOperationCacheKey cacheKey = new CacheOperationCacheKey(operation, method, targetClass);\n\t\tCacheOperationMetadata metadata = this.metadataCache.get(cacheKey);\n\t\tif (metadata == null) {\n\t\t\tKeyGenerator operationKeyGenerator;\n\t\t\tif (StringUtils.hasText(operation.getKeyGenerator())) {\n\t\t\t\toperationKeyGenerator = getBean(operation.getKeyGenerator(), KeyGenerator.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationKeyGenerator = getKeyGenerator();\n\t\t\t}\n\t\t\tCacheResolver operationCacheResolver;\n\t\t\tif (StringUtils.hasText(operation.getCacheResolver())) {\n\t\t\t\toperationCacheResolver = getBean(operation.getCacheResolver(), CacheResolver.class);\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(operation.getCacheManager())) {\n\t\t\t\tCacheManager cacheManager = getBean(operation.getCacheManager(), CacheManager.class);\n\t\t\t\toperationCacheResolver = new SimpleCacheResolver(cacheManager);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationCacheResolver = getCacheResolver();\n\t\t\t\tAssert.state(operationCacheResolver != null, \"No CacheResolver/CacheManager set\");\n\t\t\t}\n\t\t\tmetadata = new CacheOperationMetadata(operation, method, targetClass,\n\t\t\t\t\toperationKeyGenerator, operationCacheResolver);\n\t\t\tthis.metadataCache.put(cacheKey, metadata);\n\t\t}\n\t\treturn metadata;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperations(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Collection<CacheOperation>",
    "signature": "public Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass) {\n\t\t// look for direct name match\n\t\tString methodName = method.getName();\n\t\tCollection<CacheOperation> ops = this.nameMap.get(methodName);\n\n\t\tif (ops == null) {\n\t\t\t// Look for most specific name match.\n\t\t\tString bestNameMatch = null;\n\t\t\tfor (String mappedName : this.nameMap.keySet()) {\n\t\t\t\tif (isMatch(methodName, mappedName)\n\t\t\t\t\t\t&& (bestNameMatch == null || bestNameMatch.length() <= mappedName.length())) {\n\t\t\t\t\tops = this.nameMap.get(mappedName);\n\t\t\t\t\tbestNameMatch = mappedName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ops;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 652
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tGeneratedMethod generatedMethod = beanFactoryInitializationCode\n\t\t\t\t\t.getMethods()\n\t\t\t\t\t.add(\"processPropertySources\", this::generateAddPropertySourceProcessorMethod);\n\t\t\tbeanFactoryInitializationCode\n\t\t\t\t\t.addInitializer(generatedMethod.toMethodReference());\n\t\t}"
  },
  "org.springframework.context.expression.<unknown>#getExpression(Map<ExpressionKey,cache,elementKey,expression)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Expression} for the specified SpEL value\n\t * <p>{@link #parseExpression(String) Parse the expression} if it hasn't been already.\n\t * @param cache the cache to use\n\t * @param elementKey the element on which the expression is defined\n\t * @param expression the expression to parse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<ExpressionKey",
      "cache",
      "elementKey",
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Expression",
    "signature": "protected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression)",
    "source_code": "\tprotected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression) {\n\n\t\tExpressionKey expressionKey = createKey(elementKey, expression);\n\t\tExpression expr = cache.get(expressionKey);\n\t\tif (expr == null) {\n\t\t\texpr = parseExpression(expression);\n\t\t\tcache.put(expressionKey, expr);\n\t\t}\n\t\treturn expr;\n\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactory,props)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Implemented for compatibility with\n\t * {@link org.springframework.beans.factory.config.PlaceholderConfigurerSupport}.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @deprecated in favor of\n\t * {@link #processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"Call processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver) instead\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveArguments(args,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Searches through the given array of objects, finds any MessageSourceResolvable\n\t * objects and resolves them.\n\t * <p>Allows for messages to have MessageSourceResolvables as arguments.\n\t * @param args array of arguments for a message\n\t * @param locale the locale to resolve through\n\t * @return an array of arguments with any MessageSourceResolvables resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {\n\t\tif (ObjectUtils.isEmpty(args)) {\n\t\t\treturn super.resolveArguments(args, locale);\n\t\t}\n\t\tList<Object> resolvedArgs = new ArrayList<>(args.length);\n\t\tfor (Object arg : args) {\n\t\t\tif (arg instanceof MessageSourceResolvable messageSourceResolvable) {\n\t\t\t\tresolvedArgs.add(getMessage(messageSourceResolvable, locale));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvedArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs.toArray();\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveCodeWithoutArguments(code,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to resolve a message without arguments\n\t * in an optimized fashion, i.e. to resolve without involving a MessageFormat.\n\t * <p>The default implementation <i>does</i> use MessageFormat, through\n\t * delegating to the {@link #resolveCode} method. Subclasses are encouraged\n\t * to replace this with optimized resolution.\n\t * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented\n\t * in an efficient fashion. In particular, it does not detect that a message\n\t * pattern doesn't contain argument placeholders in the first place. Therefore,\n\t * it is advisable to circumvent MessageFormat for messages without arguments.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the message String, or {@code null} if not found\n\t * @see #resolveCode\n\t * @see java.text.MessageFormat\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "String",
    "signature": "protected String resolveCodeWithoutArguments(String code, Locale locale)",
    "source_code": "\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\tif (messageFormat != null) {\n\t\t\tsynchronized (messageFormat) {\n\t\t\t\treturn messageFormat.format(new Object[0]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,elementType,capacity)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the supplied {@code elementType}, type safety cannot be\n\t * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\n\t * In such scenarios, the caller is responsible for ensuring that the\n\t * supplied {@code elementType} is an enum type matching type {@code E}.\n\t * As an alternative, the caller may wish to treat the return value as a\n\t * raw collection or collection of {@link Object}.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param elementType the collection's element type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumSet} creation)\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType} is\n\t * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\n\t * the supplied {@code elementType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashSet\n\t * @see java.util.ArrayList\n\t * @see java.util.TreeSet\n\t * @see java.util.EnumSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (LinkedHashSet.class == collectionType || HashSet.class == collectionType ||\n\t\t\t\tSet.class == collectionType || Collection.class == collectionType) {\n\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t}\n\t\telse if (ArrayList.class == collectionType || List.class == collectionType) {\n\t\t\treturn new ArrayList<>(capacity);\n\t\t}\n\t\telse if (LinkedList.class == collectionType) {\n\t\t\treturn new LinkedList<>();\n\t\t}\n\t\telse if (TreeSet.class == collectionType || NavigableSet.class == collectionType\n\t\t\t\t|| SortedSet.class == collectionType) {\n\t\t\treturn new TreeSet<>();\n\t\t}\n\t\telse if (EnumSet.class.isAssignableFrom(collectionType)) {\n\t\t\tAssert.notNull(elementType, \"Cannot create EnumSet for unknown element type\");\n\t\t\treturn EnumSet.noneOf(asEnumType(elementType));\n\t\t}\n\t\telse {\n\t\t\tif (collectionType.isInterface() || !Collection.class.isAssignableFrom(collectionType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Collection type: \" + collectionType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not instantiate Collection type: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#forType(type,owner)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@link ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 1369
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner)",
    "source_code": "\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotationType,attributeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given the\n\t * {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @param attributeName the name of the attribute value to retrieve.\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1179
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(\n\t\t\t@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\n\n\t\tif (annotationType == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#canDecode(elementType,mimeType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\treturn (ByteBuf.class.isAssignableFrom(elementType.toClass()) &&\n\t\t\t\tsuper.canDecode(elementType, mimeType));\n\t}"
  },
  "org.springframework.core.task.support.<unknown>#doExecute(concurrentExecutor,taskDecorator,runnable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the given {@code Runnable} (which may be a user-supplied task\n\t * or a wrapper around a user-supplied task) with the given executor.\n\t * @param concurrentExecutor the underlying JDK concurrent executor to delegate to\n\t * @param taskDecorator the specified decorator to be applied, if any\n\t * @param runnable the runnable to execute\n\t * @throws RejectedExecutionException if the given runnable cannot be accepted\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "concurrentExecutor",
      "taskDecorator",
      "runnable"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "protected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable)",
    "source_code": "\tprotected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable)\n\t\t\tthrows RejectedExecutionException{\n\n\t\tconcurrentExecutor.execute(taskDecorator != null ? taskDecorator.decorate(runnable) : runnable);\n\t}"
  },
  "org.springframework.http.<unknown>#setInstant(headerName,date)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1436
    },
    "return": "void",
    "signature": "public void setInstant(String headerName, Instant date)",
    "source_code": "\tpublic void setInstant(String headerName, Instant date) {\n\t\tsetZonedDateTime(headerName, ZonedDateTime.ofInstant(date, GMT));\n\t}"
  },
  "org.springframework.http.client.<unknown>#header(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic PartBuilder header(String headerName, String... headerValues) {\n\t\t\tinitHeadersIfNecessary().addAll(headerName, Arrays.asList(headerValues));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#setHttpContextFactory(BiFunction<HttpMethod,URI,httpContextFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a factory to pre-create the {@link HttpContext} for each request.\n\t * <p>This may be useful for example in mutual TLS authentication where a\n\t * different {@code RestTemplate} for each client certificate such that\n\t * all calls made through a given {@code RestTemplate} instance as associated\n\t * for the same client identity. {@link HttpClientContext#setUserToken(Object)}\n\t * can be used to specify a fixed user token for all requests.\n\t * @param httpContextFactory the context factory to use\n\t * @since 5.2.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<HttpMethod",
      "URI",
      "httpContextFactory"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory)",
    "source_code": "\tpublic void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory) {\n\t\tthis.httpContextFactory = httpContextFactory;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(type,clazz,mediaType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canWrite(clazz, mediaType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#read(type,contextClass,inputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeInternal(object,type,outputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tJsonEncoding encoding = getJsonEncoding(contentType);\n\n\t\tClass<?> clazz = (object instanceof MappingJacksonValue mappingJacksonValue ?\n\t\t\t\tmappingJacksonValue.getValue().getClass() : object.getClass());\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, contentType);\n\t\tAssert.state(objectMapper != null, () -> \"No ObjectMapper for \" + clazz.getName());\n\n\t\tOutputStream outputStream = StreamUtils.nonClosing(outputMessage.getBody());\n\t\ttry (JsonGenerator generator = objectMapper.getFactory().createGenerator(outputStream, encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\t\t\tJavaType javaType = null;\n\n\t\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\t\tserializationView = mappingJacksonValue.getSerializationView();\n\t\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t\t}\n\t\t\tif (type != null && TypeUtils.isAssignable(type, value.getClass())) {\n\t\t\t\tjavaType = getJavaType(type, null);\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tobjectMapper.writerWithView(serializationView) : objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tif (javaType != null && (javaType.isContainerType() || javaType.isTypeOrSubTypeOf(Optional.class))) {\n\t\t\t\tobjectWriter = objectWriter.forType(javaType);\n\t\t\t}\n\t\t\tSerializationConfig config = objectWriter.getConfig();\n\t\t\tif (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &&\n\t\t\t\t\tconfig.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n\t\t\t\tobjectWriter = objectWriter.with(this.ssePrettyPrinter);\n\t\t\t}\n\t\t\tobjectWriter = customizeWriter(objectWriter, javaType, contentType);\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t\tcatch (InvalidDefinitionException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Type definition error: \" + ex.getType(), ex);\n\t\t}\n\t\tcatch (JsonProcessingException ex) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not write JSON: \" + ex.getOriginalMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#write(t,type,contentType,outputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(callString,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callString",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1217
    },
    "return": "T",
    "signature": "public T execute(String callString, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String callString, CallableStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimpleCallableStatementCreator(callString), action);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(csc,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1173
    },
    "return": "T",
    "signature": "public T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(csc, \"CallableStatementCreator must not be null\");\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString sql = getSql(csc);\n\t\t\tlogger.debug(\"Calling stored procedure\" + (sql != null ? \" [\" + sql  + \"]\" : \"\"));\n\t\t}\n\n\t\tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n\t\tCallableStatement cs = null;\n\t\ttry {\n\t\t\tcs = csc.createCallableStatement(con);\n\t\t\tapplyStatementSettings(cs);\n\t\t\tT result = action.doInCallableStatement(cs);\n\t\t\thandleWarnings(cs);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\t// Release Connection early, to avoid potential connection pool deadlock\n\t\t\t// in the case when the exception translator hasn't been initialized yet.\n\t\t\tif (csc instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t}\n\t\t\tString sql = getSql(csc);\n\t\t\tcsc = null;\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tcs = null;\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\tcon = null;\n\t\t\tthrow translateException(\"CallableStatementCallback\", sql, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (csc instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t}\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractReturnedResults(cs,updateCountParameters,resultSetParameters,updateCount)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract returned ResultSets from the completed stored procedure.\n\t * @param cs a JDBC wrapper for the stored procedure\n\t * @param updateCountParameters the parameter list of declared update count parameters for the stored procedure\n\t * @param resultSetParameters the parameter list of declared resultSet parameters for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "updateCountParameters",
      "resultSetParameters",
      "updateCount"
    ],
    "position": {
      "column": 1,
      "line": 1269
    },
    "return": "Object>",
    "signature": "protected Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount)",
    "source_code": "\tprotected Map<String, Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount) throws SQLException {\n\n\t\tMap<String, Object> results = new LinkedHashMap<>(4);\n\t\tint rsIndex = 0;\n\t\tint updateIndex = 0;\n\t\tboolean moreResults;\n\t\tif (!this.skipResultsProcessing) {\n\t\t\tdo {\n\t\t\t\tif (updateCount == -1) {\n\t\t\t\t\tif (resultSetParameters != null && resultSetParameters.size() > rsIndex) {\n\t\t\t\t\t\tSqlReturnResultSet declaredRsParam = (SqlReturnResultSet) resultSetParameters.get(rsIndex);\n\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), declaredRsParam));\n\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString rsName = RETURN_RESULT_SET_PREFIX + (rsIndex + 1);\n\t\t\t\t\t\t\tSqlReturnResultSet undeclaredRsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), undeclaredRsParam));\n\t\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (updateCountParameters != null && updateCountParameters.size() > updateIndex) {\n\t\t\t\t\t\tSqlReturnUpdateCount ucParam = (SqlReturnUpdateCount) updateCountParameters.get(updateIndex);\n\t\t\t\t\t\tString declaredUcName = ucParam.getName();\n\t\t\t\t\t\tresults.put(declaredUcName, updateCount);\n\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString undeclaredName = RETURN_UPDATE_COUNT_PREFIX + (updateIndex + 1);\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnUpdateCount parameter named '\" + undeclaredName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.put(undeclaredName, updateCount);\n\t\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmoreResults = cs.getMoreResults();\n\t\t\t\tupdateCount = cs.getUpdateCount();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (moreResults || updateCount != -1);\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 862
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), newArgPreparedStatementSetter(args), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#setTargetDataSources(Map<Object,targetDataSources)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target DataSources, with the lookup key as key.\n\t * The mapped value can either be a corresponding {@link javax.sql.DataSource}\n\t * instance or a data source name String (to be resolved via a\n\t * {@link #setDataSourceLookup DataSourceLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the\n\t * generic lookup process only. The concrete key representation will\n\t * be handled by {@link #resolveSpecifiedLookupKey(Object)} and\n\t * {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Object",
      "targetDataSources"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setTargetDataSources(Map<Object, Object> targetDataSources)",
    "source_code": "\tpublic void setTargetDataSources(Map<Object, Object> targetDataSources) {\n\t\tthis.targetDataSources = targetDataSources;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doResume(transaction,suspendedResources)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tString destinationName, final Object message, final MessagePostProcessor postProcessor)\n\t\tthrows JmsException {\n\n\t\tsend(destinationName, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forQueue(result,queueName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the queue with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "queueName"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forQueue(T result, String queueName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forQueue(T result, String queueName) {\n\t\tAssert.notNull(queueName, \"Queue name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(queueName, false));\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,jsonView)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Java object to a JMS Message using the specified json view\n\t * and the supplied session  to create the message object.\n\t * @param object the object to convert\n\t * @param session the Session to use for creating a JMS Message\n\t * @param jsonView the view to use to filter the content\n\t * @return the JMS Message\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @throws MessageConversionException in case of conversion failure\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "jsonView"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tif (jsonView != null) {\n\t\t\treturn toMessage(object, session, this.objectMapper.writerWithView(jsonView));\n\t\t}\n\t\telse {\n\t\t\treturn toMessage(object, session, this.objectMapper.writer());\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,objectWriter)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Message",
    "signature": "protected Message toMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected Message toMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tMessage message;\n\t\ttry {\n\t\t\tmessage = switch (this.targetType) {\n\t\t\t\tcase TEXT -> mapToTextMessage(object, session, objectWriter);\n\t\t\t\tcase BYTES -> mapToBytesMessage(object, session, objectWriter);\n\t\t\t\tdefault -> mapToMessage(object, session, objectWriter, this.targetType);\n\t\t\t};\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not map JSON object [\" + object + \"]\", ex);\n\t\t}\n\t\tsetTypeIdOnMessage(object, message);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#createAndConfigureMBean(managedResource,beanKey)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates an MBean that is configured with the appropriate management\n\t * interface for the supplied managed resource.\n\t * @param managedResource the resource that is to be exported as an MBean\n\t * @param beanKey the key associated with the managed bean\n\t * @see #createModelMBean()\n\t * @see #getMBeanInfo(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedResource",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)",
    "source_code": "\tprotected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)\n\t\t\tthrows MBeanExportException {\n\t\ttry {\n\t\t\tModelMBean mbean = createModelMBean();\n\t\t\tmbean.setModelMBeanInfo(getMBeanInfo(managedResource, beanKey));\n\t\t\tmbean.setManagedResource(managedResource, MR_TYPE_OBJECT_REFERENCE);\n\t\t\treturn mbean;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MBeanExportException(\"Could not create ModelMBean for managed resource [\" +\n\t\t\t\t\tmanagedResource + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\tpublic Object put(String key, Object value) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerMethodHints(hints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tregisterParameterHints(hints, method);\n\t\tregisterReturnValueHints(hints, method);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerParameterHints(hints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "protected void registerParameterHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerParameterHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\tif (Message.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, getMessageType(methodParameter));\n\t\t\t}\n\t\t\telse if (couldBePayload(methodParameter)) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#resolveArgument(parameter,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the content of the given message payload through a compatible\n\t * {@link Decoder}.\n\t *\n\t * <p>Validation is applied if the method argument is annotated with\n\t * {@code @jakarta.validation.Valid} or\n\t * {@link org.springframework.validation.annotation.Validated}. Validation\n\t * failure results in an {@link MethodArgumentNotValidException}.\n\t * @param parameter the target method argument that we are decoding to\n\t * @param message the message from which the content was extracted\n\t * @return a Mono with the result of argument resolution\n\t * @see #extractContent(MethodParameter, Message)\n\t * @see #getMimeType(Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic final Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message) {\n\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tMimeType mimeType = getMimeType(message);\n\t\tmimeType = mimeType != null ? mimeType : MimeTypeUtils.APPLICATION_OCTET_STREAM;\n\n\t\tFlux<DataBuffer> content = extractContent(parameter, message);\n\t\treturn decodeContent(parameter, message, ann == null || ann.required(), content, mimeType);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#compare(match1,match2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,Map<String,headers,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(user, \"User must not be null\");\n\t\tString username = user;\n\t\tAssert.isTrue(!user.contains(\"%2F\"), () -> \"Invalid sequence \\\"%2F\\\" in user name: \" + username);\n\t\tuser = StringUtils.replace(user, \"/\", \"%2F\");\n\t\tdestination = destination.startsWith(\"/\") ? destination : \"/\" + destination;\n\t\tsuper.convertAndSend(this.destinationPrefix + user + destination, payload, headers, postProcessor);\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\t\tDestinationHelper destinationHelper = getDestinationHelper(headers, returnType);\n\n\t\tSendToUser sendToUser = destinationHelper.getSendToUser();\n\t\tif (sendToUser != null) {\n\t\t\tboolean broadcast = sendToUser.broadcast();\n\t\t\tString user = getUserName(message, headers);\n\t\t\tif (user == null) {\n\t\t\t\tif (sessionId == null) {\n\t\t\t\t\tthrow new MissingSessionUserException(message);\n\t\t\t\t}\n\t\t\t\tuser = sessionId;\n\t\t\t\tbroadcast = false;\n\t\t\t}\n\t\t\tString[] destinations = getTargetDestinations(sendToUser, message, this.defaultUserDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tif (broadcast) {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(null, returnType));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSendTo sendTo = destinationHelper.getSendTo();\n\t\tif (sendTo != null || sendToUser == null) {\n\t\t\tString[] destinations = getTargetDestinations(sendTo, message, this.defaultDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tthis.messagingTemplate.convertAndSend(destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#verifyType(headerName,headerValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "protected void verifyType(@Nullable String headerName, @Nullable Object headerValue)",
    "source_code": "\tprotected void verifyType(@Nullable String headerName, @Nullable Object headerValue) {\n\t\tif (headerName != null && headerValue != null) {\n\t\t\tif (MessageHeaders.ERROR_CHANNEL.equals(headerName) ||\n\t\t\t\t\tMessageHeaders.REPLY_CHANNEL.endsWith(headerName)) {\n\t\t\t\tif (!(headerValue instanceof MessageChannel || headerValue instanceof String)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"'\" + headerName + \"' header value must be a MessageChannel or String\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doBegin(transaction,definition)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tHibernateTransactionObject txObject = (HibernateTransactionObject) transaction;\n\n\t\tif (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Pre-bound JDBC Connection found! HibernateTransactionManager does not support \" +\n\t\t\t\t\t\"running within DataSourceTransactionManager if told to manage the DataSource itself. \" +\n\t\t\t\t\t\"It is recommended to use a single HibernateTransactionManager for all transactions \" +\n\t\t\t\t\t\"on a single DataSource, no matter whether Hibernate or JDBC access.\");\n\t\t}\n\n\t\tSessionImplementor session = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasSessionHolder() || txObject.getSessionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tInterceptor entityInterceptor = getEntityInterceptor();\n\t\t\t\tSession newSession = (entityInterceptor != null ?\n\t\t\t\t\t\tobtainSessionFactory().withOptions().interceptor(entityInterceptor).openSession() :\n\t\t\t\t\t\tobtainSessionFactory().openSession());\n\t\t\t\tif (this.sessionInitializer != null) {\n\t\t\t\t\tthis.sessionInitializer.accept(newSession);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Opened new Session [\" + newSession + \"] for Hibernate transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setSession(newSession);\n\t\t\t}\n\n\t\t\tsession = txObject.getSessionHolder().getSession().unwrap(SessionImplementor.class);\n\n\t\t\tboolean holdabilityNeeded = this.allowResultAccessAfterCompletion && !txObject.isNewSession();\n\t\t\tboolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);\n\t\t\tif (holdabilityNeeded || isolationLevelNeeded || definition.isReadOnly()) {\n\t\t\t\tif (this.prepareConnection && ConnectionReleaseMode.ON_CLOSE.equals(\n\t\t\t\t\t\tsession.getJdbcCoordinator().getLogicalConnection().getConnectionHandlingMode().getReleaseMode())) {\n\t\t\t\t\t// We're allowed to change the transaction settings of the JDBC Connection.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Preparing JDBC Connection of Hibernate Session [\" + session + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tConnection con = session.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection();\n\t\t\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\t\t\t\t\tif (this.allowResultAccessAfterCompletion && !txObject.isNewSession()) {\n\t\t\t\t\t\tint currentHoldability = con.getHoldability();\n\t\t\t\t\t\tif (currentHoldability != ResultSet.HOLD_CURSORS_OVER_COMMIT) {\n\t\t\t\t\t\t\ttxObject.setPreviousHoldability(currentHoldability);\n\t\t\t\t\t\t\tcon.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttxObject.connectionPrepared();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Not allowed to change the transaction settings of the JDBC Connection.\n\t\t\t\t\tif (isolationLevelNeeded) {\n\t\t\t\t\t\t// We should set a specific isolation level but are not allowed to...\n\t\t\t\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\t\t\t\"HibernateTransactionManager is not allowed to support custom isolation levels: \" +\n\t\t\t\t\t\t\t\t\"make sure that its 'prepareConnection' flag is on (the default) and that the \" +\n\t\t\t\t\t\t\t\t\"Hibernate connection release mode is set to ON_CLOSE.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not preparing JDBC Connection of Hibernate Session [\" + session + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (definition.isReadOnly() && txObject.isNewSession()) {\n\t\t\t\t// Just set to MANUAL in case of a new Session for this transaction.\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\t\t// As of 5.1, we're also setting Hibernate's read-only entity mode by default.\n\t\t\t\tsession.setDefaultReadOnly(true);\n\t\t\t}\n\n\t\t\tif (!definition.isReadOnly() && !txObject.isNewSession()) {\n\t\t\t\t// We need AUTO or COMMIT for a non-read-only transaction.\n\t\t\t\tFlushMode flushMode = session.getHibernateFlushMode();\n\t\t\t\tif (FlushMode.MANUAL.equals(flushMode)) {\n\t\t\t\t\tsession.setHibernateFlushMode(FlushMode.AUTO);\n\t\t\t\t\ttxObject.getSessionHolder().setPreviousFlushMode(flushMode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransaction hibTx;\n\n\t\t\t// Register transaction timeout.\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t// Use Hibernate's own transaction timeout mechanism on Hibernate 3.1+\n\t\t\t\t// Applies to all statements, also to inserts, updates and deletes!\n\t\t\t\thibTx = session.getTransaction();\n\t\t\t\thibTx.setTimeout(timeout);\n\t\t\t\thibTx.begin();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Open a plain Hibernate transaction without specified timeout.\n\t\t\t\thibTx = session.beginTransaction();\n\t\t\t}\n\n\t\t\t// Add the Hibernate transaction to the session holder.\n\t\t\ttxObject.getSessionHolder().setTransaction(hibTx);\n\n\t\t\t// Register the Hibernate Session's JDBC Connection for the DataSource, if set.\n\t\t\tif (getDataSource() != null) {\n\t\t\t\tfinal SessionImplementor sessionToUse = session;\n\t\t\t\tConnectionHolder conHolder = new ConnectionHolder(\n\t\t\t\t\t\t() -> sessionToUse.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection());\n\t\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t\tconHolder.setTimeoutInSeconds(timeout);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Exposing Hibernate transaction as JDBC [\" + conHolder.getConnectionHandle() + \"]\");\n\t\t\t\t}\n\t\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), conHolder);\n\t\t\t\ttxObject.setConnectionHolder(conHolder);\n\t\t\t}\n\n\t\t\t// Bind the session holder to the thread.\n\t\t\tif (txObject.isNewSessionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainSessionFactory(), txObject.getSessionHolder());\n\t\t\t}\n\t\t\ttxObject.getSessionHolder().setSynchronizedWithTransaction(true);\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewSession()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (session != null && session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {\n\t\t\t\t\t\tsession.getTransaction().rollback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.debug(\"Could not rollback Session after failed transaction begin\", ex);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t\t\ttxObject.setSessionHolder(null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open Hibernate Session for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setJpaPropertyMap(Map<String,jpaProperties)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify JPA properties as a Map, to be passed into\n\t * {@code Persistence.createEntityManagerFactory} (if any).\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @see jakarta.persistence.Persistence#createEntityManagerFactory(String, Map)\n\t * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(PersistenceUnitInfo, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jpaProperties"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties)",
    "source_code": "\tpublic void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties) {\n\t\tif (jpaProperties != null) {\n\t\t\tthis.jpaPropertyMap.putAll(jpaProperties);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#createContainerEntityManagerFactory(info,properties)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "info",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties)",
    "source_code": "\tpublic EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties) {\n\t\tfinal List<String> mergedClassesAndPackages = new ArrayList<>(info.getManagedClassNames());\n\t\tif (info instanceof SmartPersistenceUnitInfo smartInfo) {\n\t\t\tmergedClassesAndPackages.addAll(smartInfo.getManagedPackages());\n\t\t}\n\t\treturn new EntityManagerFactoryBuilderImpl(\n\t\t\t\tnew PersistenceUnitInfoDescriptor(info) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic List<String> getManagedClassNames() {\n\t\t\t\t\t\treturn mergedClassesAndPackages;\n\t\t\t\t\t}\n\t\t\t\t}, properties).build();\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(index,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void bind(int index, Object value)",
    "source_code": "\t\tpublic void bind(int index, Object value) {\n\t\t\tthis.statement.bind(index, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnectionMany(Function<Connection,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> inConnectionMany(Function<Connection, Flux<T>> action)",
    "source_code": "\tpublic <T> Flux<T> inConnectionMany(Function<Connection, Flux<T>> action) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Flux.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy, also preparing returned Statements.\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Flux.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnectionMany\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"executeMany\", getSql(action), ex));\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#createScheduler(schedulerFactory,schedulerName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the Scheduler instance for the given factory and scheduler name.\n\t * Called by {@link #afterPropertiesSet}.\n\t * <p>The default implementation invokes SchedulerFactory's {@code getScheduler}\n\t * method. Can be overridden for custom Scheduler creation.\n\t * @param schedulerFactory the factory to create the Scheduler with\n\t * @param schedulerName the name of the scheduler to create\n\t * @return the Scheduler instance\n\t * @throws SchedulerException if thrown by Quartz methods\n\t * @see #afterPropertiesSet\n\t * @see org.quartz.SchedulerFactory#getScheduler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "schedulerFactory",
      "schedulerName"
    ],
    "position": {
      "column": 1,
      "line": 664
    },
    "return": "Scheduler",
    "signature": "protected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)",
    "source_code": "\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)\n\t\t\tthrows SchedulerException {\n\n\t\t// Override thread context ClassLoader to work around naive Quartz ClassLoadHelper loading.\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tboolean overrideClassLoader = (this.resourceLoader != null &&\n\t\t\t\tthis.resourceLoader.getClassLoader() != threadContextClassLoader);\n\t\tif (overrideClassLoader) {\n\t\t\tcurrentThread.setContextClassLoader(this.resourceLoader.getClassLoader());\n\t\t}\n\t\ttry {\n\t\t\tSchedulerRepository repository = SchedulerRepository.getInstance();\n\t\t\tsynchronized (repository) {\n\t\t\t\tScheduler existingScheduler = (schedulerName != null ? repository.lookup(schedulerName) : null);\n\t\t\t\tScheduler newScheduler = schedulerFactory.getScheduler();\n\t\t\t\tif (newScheduler == existingScheduler) {\n\t\t\t\t\tthrow new IllegalStateException(\"Active Scheduler of name '\" + schedulerName + \"' already registered \" +\n\t\t\t\t\t\t\t\"in Quartz SchedulerRepository. Cannot create a new Spring-managed Scheduler of the same name!\");\n\t\t\t\t}\n\t\t\t\tif (!this.exposeSchedulerInRepository) {\n\t\t\t\t\t// Need to remove it in this case, since Quartz shares the Scheduler instance by default!\n\t\t\t\t\tSchedulerRepository.getInstance().remove(newScheduler.getSchedulerName());\n\t\t\t\t}\n\t\t\t\treturn newScheduler;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (overrideClassLoader) {\n\t\t\t\t// Reset original thread context ClassLoader.\n\t\t\t\tcurrentThread.setContextClassLoader(threadContextClassLoader);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#startScheduler(scheduler,startupDelay)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Start the Quartz Scheduler, respecting the \"startupDelay\" setting.\n\t * @param scheduler the Scheduler to start\n\t * @param startupDelay the number of seconds to wait before starting\n\t * the Scheduler asynchronously\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduler",
      "startupDelay"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "protected void startScheduler(final Scheduler scheduler, final int startupDelay)",
    "source_code": "\tprotected void startScheduler(final Scheduler scheduler, final int startupDelay) throws SchedulerException {\n\t\tif (startupDelay <= 0) {\n\t\t\tlogger.info(\"Starting Quartz Scheduler now\");\n\t\t\tscheduler.start();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Will start Quartz Scheduler [\" + scheduler.getSchedulerName() +\n\t\t\t\t\t\t\"] in \" + startupDelay + \" seconds\");\n\t\t\t}\n\t\t\t// Not using the Quartz startDelayed method since we explicitly want a daemon\n\t\t\t// thread here, not keeping the JVM alive in case of all other threads ending.\n\t\t\tThread schedulerThread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t// simply proceed\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler.start();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tschedulerThread.setName(\"Quartz Scheduler [\" + scheduler.getSchedulerName() + \"]\");\n\t\t\tschedulerThread.setDaemon(true);\n\t\t\tschedulerThread.start();\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#getScriptSource(beanName,scriptSourceLocator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a ScriptSource for the given bean, lazily creating it\n\t * if not cached already.\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator associated with the bean\n\t * @return the corresponding ScriptSource instance\n\t * @see #convertToScriptSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource getScriptSource(String beanName, String scriptSourceLocator)",
    "source_code": "\tprotected ScriptSource getScriptSource(String beanName, String scriptSourceLocator) {\n\t\treturn this.scriptSourceCache.computeIfAbsent(beanName, key ->\n\t\t\t\tconvertToScriptSource(beanName, scriptSourceLocator, this.resourceLoader));\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\t// We only apply special treatment to ScriptFactory implementations here.\n\t\tif (!ScriptFactory.class.isAssignableFrom(beanClass)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAssert.state(this.beanFactory != null, \"No BeanFactory set\");\n\t\tBeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);\n\t\tString scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName;\n\t\tString scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName;\n\t\tprepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName);\n\n\t\tScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\tScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\tboolean isFactoryBean = false;\n\t\ttry {\n\t\t\tClass<?> scriptedObjectType = scriptFactory.getScriptedObjectType(scriptSource);\n\t\t\t// Returned type may be null if the factory is unable to determine the type.\n\t\t\tif (scriptedObjectType != null) {\n\t\t\t\tisFactoryBean = FactoryBean.class.isAssignableFrom(scriptedObjectType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\"Could not determine scripted object type for \" + scriptFactory, ex);\n\t\t}\n\n\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\tif (refreshCheckDelay >= 0) {\n\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\t\t\tRefreshableScriptTargetSource ts = new RefreshableScriptTargetSource(this.scriptBeanFactory,\n\t\t\t\t\tscriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean);\n\t\t\tboolean proxyTargetClass = resolveProxyTargetClass(bd);\n\t\t\tString language = (String) bd.getAttribute(LANGUAGE_ATTRIBUTE);\n\t\t\tif (proxyTargetClass && (language == null || !language.equals(\"groovy\"))) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\n\t\t\t\t\t\t\"Cannot use proxyTargetClass=true with script beans where language is not 'groovy': '\" +\n\t\t\t\t\t\tlanguage + \"'\");\n\t\t\t}\n\t\t\tts.setRefreshCheckDelay(refreshCheckDelay);\n\t\t\treturn createRefreshableProxy(ts, interfaces, proxyTargetClass);\n\t\t}\n\n\t\tif (isFactoryBean) {\n\t\t\tscriptedObjectBeanName = BeanFactory.FACTORY_BEAN_PREFIX + scriptedObjectBeanName;\n\t\t}\n\t\treturn this.scriptBeanFactory.getBean(scriptedObjectBeanName);\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#prepareScriptBeans(bd,scriptFactoryBeanName,scriptedObjectBeanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the script beans in the internal BeanFactory that this\n\t * post-processor uses. Each original bean definition will be split\n\t * into a ScriptFactory definition and a scripted object definition.\n\t * @param bd the original bean definition in the main BeanFactory\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptedObjectBeanName the name of the internal scripted object bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptedObjectBeanName"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "protected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName)",
    "source_code": "\tprotected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {\n\t\t// Avoid recreation of the script bean definition in case of a prototype.\n\t\tsynchronized (this.scriptBeanFactory) {\n\t\t\tif (!this.scriptBeanFactory.containsBeanDefinition(scriptedObjectBeanName)) {\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(\n\t\t\t\t\t\tscriptFactoryBeanName, createScriptFactoryBeanDefinition(bd));\n\t\t\t\tScriptFactory scriptFactory =\n\t\t\t\t\t\tthis.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\t\t\tScriptSource scriptSource =\n\t\t\t\t\t\tgetScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\n\t\t\t\tClass<?>[] scriptedInterfaces = interfaces;\n\t\t\t\tif (scriptFactory.requiresConfigInterface() && !bd.getPropertyValues().isEmpty()) {\n\t\t\t\t\tClass<?> configInterface = createConfigInterface(bd, interfaces);\n\t\t\t\t\tscriptedInterfaces = ObjectUtils.addObjectToArray(interfaces, configInterface);\n\t\t\t\t}\n\n\t\t\t\tBeanDefinition objectBd = createScriptedObjectBeanDefinition(\n\t\t\t\t\t\tbd, scriptFactoryBeanName, scriptSource, scriptedInterfaces);\n\t\t\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\t\t\tif (refreshCheckDelay >= 0) {\n\t\t\t\t\tobjectBd.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(scriptedObjectBeanName, objectBd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formData(MultiValueMap<String,expected)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as form data and compare to the given {@code MultiValueMap}.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formData(MultiValueMap<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formData(MultiValueMap<String, String> expected) {\n\t\treturn formData(expected, true);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#render(mv,request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setModelAndView(mv);\n\t\tsuper.render(mv, request, response);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getCacheKey(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a cache key for the given method and target class.\n\t * <p>Must not produce same key for overloaded methods.\n\t * Must produce same key for different instances of the same method.\n\t * @param method the method (never {@code null})\n\t * @param targetClass the target class (may be {@code null})\n\t * @return the cache key (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {\n\t\treturn new MethodClassKey(method, targetClass);\n\t}"
  },
  "org.springframework.util.<unknown>#contains(enumeration,element)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Enumeration<?> enumeration, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tObject candidate = enumeration.nextElement();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#delimitedListToStringArray(str,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into a\n\t * {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1191
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {\n\t\treturn delimitedListToStringArray(str, delimiter, null);\n\t}"
  },
  "org.springframework.util.<unknown>#findValueOfType(collection,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "T",
    "signature": "public T findValueOfType(Collection<?> collection, @Nullable Class<T> type)",
    "source_code": "\tpublic static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.util.<unknown>#getField(field,target)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the field represented by the supplied {@link Field field object} on the\n\t * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\n\t * semantics, the returned value is automatically wrapped if the underlying field\n\t * has a primitive type.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to get\n\t * @param target the target object from which to get the field\n\t * (or {@code null} for a static field)\n\t * @return the field's current value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "Object",
    "signature": "public Object getField(Field field, @Nullable Object target)",
    "source_code": "\tpublic static Object getField(Field field, @Nullable Object target) {\n\t\ttry {\n\t\t\treturn field.get(target);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}"
  },
  "org.springframework.util.<unknown>#invokeMethod(method,target,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with the\n\t * supplied arguments. The target object can be {@code null} when invoking a\n\t * static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @param args the invocation arguments (may be {@code null})\n\t * @return the invocation result, if any\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args)",
    "source_code": "\tpublic static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends V> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.util.<unknown>#replace(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "V",
    "signature": "public V replace(@Nullable K key, final @Nullable V value)",
    "source_code": "\tpublic V replace(@Nullable K key, final @Nullable V value) {\n\t\treturn doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tprotected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null) {\n\t\t\t\t\tV oldValue = entry.getValue();\n\t\t\t\t\tentry.setValue(value);\n\t\t\t\t\treturn oldValue;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.util.<unknown>#uriDecode(source,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component value. Based on the following rules:\n\t * <ul>\n\t * <li>Alphanumeric characters {@code \"a\"} through {@code \"z\"}, {@code \"A\"} through {@code \"Z\"},\n\t * and {@code \"0\"} through {@code \"9\"} stay the same.</li>\n\t * <li>Special characters {@code \"-\"}, {@code \"_\"}, {@code \".\"}, and {@code \"*\"} stay the same.</li>\n\t * <li>A sequence \"{@code %<i>xy</i>}\" is interpreted as a hexadecimal representation of the character.</li>\n\t * </ul>\n\t * @param source the encoded String\n\t * @param charset the character set\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "String",
    "signature": "public String uriDecode(String source, Charset charset)",
    "source_code": "\tpublic static String uriDecode(String source, Charset charset) {\n\t\tint length = source.length();\n\t\tif (length == 0) {\n\t\t\treturn source;\n\t\t}\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n\t\tboolean changed = false;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tint ch = source.charAt(i);\n\t\t\tif (ch == '%') {\n\t\t\t\tif (i + 2 < length) {\n\t\t\t\t\tchar hex1 = source.charAt(i + 1);\n\t\t\t\t\tchar hex2 = source.charAt(i + 2);\n\t\t\t\t\tint u = Character.digit(hex1, 16);\n\t\t\t\t\tint l = Character.digit(hex2, 16);\n\t\t\t\t\tif (u == -1 || l == -1) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tbaos.write((char) ((u << 4) + l));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbaos.write(ch);\n\t\t\t}\n\t\t}\n\t\treturn (changed ? StreamUtils.copyToString(baos, charset) : source);\n\t}"
  },
  "org.springframework.validation.<unknown>#findCustomEditor(requiredType,propertyPath)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 714
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath)",
    "source_code": "\tpublic PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {\n\t\treturn getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors,validationHints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.source.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(entity,responseType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(entity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(doExecute(resolveUrl(entity), resolveUriTemplate(entity), entity.getMethod(), requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,servletContext,servletConfig)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tif (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);\n\t\t}\n\n\t\tif (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {\n\t\t\tMap<String, String> parameterMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletContext.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletContext.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (servletConfig != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletConfig.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletConfig.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(parameterMap));\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {\n\t\t\tMap<String, Object> attributeMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> attrNameEnum = servletContext.getAttributeNames();\n\t\t\t\twhile (attrNameEnum.hasMoreElements()) {\n\t\t\t\t\tString attrName = (String) attrNameEnum.nextElement();\n\t\t\t\t\tattributeMap.put(attrName, servletContext.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(attributeMap));\n\t\t}\n\t}"
  },
  "org.springframework.web.filter.<unknown>#invokeDelegate(delegate,request,response,filterChain)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the delegate Filter with the given request and response.\n\t * @param delegate the delegate Filter\n\t * @param request the current HTTP request\n\t * @param response the current HTTP response\n\t * @param filterChain the current FilterChain\n\t * @throws ServletException if thrown by the Filter\n\t * @throws IOException if thrown by the Filter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "delegate",
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void invokeDelegate(\n\t\t\tFilter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tdelegate.doFilter(request, response, filterChain);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add non-null return values to the {@link ModelAndViewContainer}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue != null) {\n\t\t\tString name = ModelFactory.getNameForReturnValue(returnValue, returnType);\n\t\t\tmavContainer.addAttribute(name, returnValue);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.multipart.support.<unknown>#doFilterInternal(request,response,filterChain)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a multipart request via this filter's MultipartResolver,\n\t * and wrap the original request with a MultipartHttpServletRequest if appropriate.\n\t * <p>All later elements in the filter chain, most importantly servlets, benefit\n\t * from proper parameter extraction in the multipart case, and are able to cast to\n\t * MultipartHttpServletRequest if they need to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tMultipartResolver multipartResolver = lookupMultipartResolver(request);\n\n\t\tHttpServletRequest processedRequest = request;\n\t\tif (multipartResolver.isMultipart(processedRequest)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolving multipart request\");\n\t\t\t}\n\t\t\tprocessedRequest = multipartResolver.resolveMultipart(processedRequest);\n\t\t}\n\t\telse {\n\t\t\t// A regular request...\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not a multipart request\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfilterChain.doFilter(processedRequest, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (processedRequest instanceof MultipartHttpServletRequest multipartRequest) {\n\t\t\t\tmultipartResolver.cleanupMultipart(multipartRequest);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(MultiValueMap<String,formData)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formData"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(MultiValueMap<String, String> formData)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,typeReference)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, typeReference);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#statusError(statusPredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function to create the exception\n\t * @return the filter to generate an error signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction)",
    "source_code": "\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction) {\n\n\t\tAssert.notNull(statusPredicate, \"Predicate must not be null\");\n\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\n\t\treturn ExchangeFilterFunction.ofResponseProcessor(\n\t\t\t\tresponse -> (statusPredicate.test(response.statusCode()) ?\n\t\t\t\t\t\tMono.error(exceptionFunction.apply(response)) : Mono.just(response)));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,result)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(position - 1, ')', content, result);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMissingRequestValueException(ex,headers,status,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingRequestValueException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMissingRequestValueException(MissingRequestValueException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMissingRequestValueException(\n\t\t\tMissingRequestValueException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#update(name,required,defaultValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "required",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "NamedValueInfo",
    "signature": "public NamedValueInfo update(String name, boolean required, @Nullable String defaultValue)",
    "source_code": "\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPut(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate PUT requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "protected void doPut(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPut(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleRequest(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tcorsProcessor.processRequest(this.config, request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(path,lookupPath,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when parsed {@code PathPattern}s are {@link #usesPathPatterns() enabled}.\n\t * @param path the parsed RequestPath\n\t * @param lookupPath the String lookupPath for checking direct hits\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(RequestPath path, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(\n\t\t\tRequestPath path, String lookupPath, HttpServletRequest request) throws Exception {\n\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.pathPatternHandlerMap.keySet()) {\n\t\t\tif (pattern.matches(path.pathWithinApplication())) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\t\tPathPattern pattern = matches.get(0);\n\t\thandler = this.pathPatternHandlerMap.get(pattern);\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\t\tvalidateHandler(handler, request);\n\t\tString pathWithinMapping = pattern.extractPathWithinPattern(path.pathWithinApplication()).value();\n\t\tpathWithinMapping = UrlPathHelper.defaultInstance.removeSemicolonContent(pathWithinMapping);\n\t\treturn buildPathExposingHandler(handler, pattern.getPatternString(), pathWithinMapping, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @param request the current request\n\t * @return the created {@code ProblemDetail} instance\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request) {\n\n\t\tErrorResponse.Builder builder = ErrorResponse.builder(ex, status, defaultDetail);\n\t\tif (detailMessageCode != null) {\n\t\t\tbuilder.detailMessageCode(detailMessageCode);\n\t\t}\n\t\tif (detailMessageArguments != null) {\n\t\t\tbuilder.detailMessageArguments(detailMessageArguments);\n\t\t}\n\t\treturn builder.build().updateAndGetBody(this.messageSource, LocaleContextHolder.getLocale());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotAcceptable(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMediaTypeNotAcceptableException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(\n\t\t\tHttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpRequestMethodNotSupported(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpRequestMethodNotSupportedException}.\n\t * <p>This method logs a warning and delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpRequestMethodNotSupported(\n\t\t\tHttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleInternal(request,response,handlerMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 775
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tModelAndView mav;\n\t\tcheckRequest(request);\n\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No HttpSession available -> no mutex necessary\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No synchronization on session demanded at all...\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\n\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprepareResponse(response);\n\t\t\t}\n\t\t}\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureTransformer(Map<String,model,response,transformer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link Transformer} instance.\n\t * <p>The default implementation copies parameters from the model into the\n\t * Transformer's {@link Transformer#setParameter parameter set}.\n\t * This implementation also copies the {@link #setOutputProperties output properties}\n\t * into the {@link Transformer} {@link Transformer#setOutputProperty output properties}.\n\t * Indentation properties are set as well.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t * @see #copyModelParameters(Map, Transformer)\n\t * @see #copyOutputProperties(Transformer)\n\t * @see #configureIndentation(Transformer)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer)",
    "source_code": "\tprotected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer) {\n\n\t\tcopyModelParameters(model, transformer);\n\t\tcopyOutputProperties(transformer);\n\t\tconfigureIndentation(transformer);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTransportError(webSocketSession,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {\n\t\t\tthis.sockJsSession.handleTransportError(ex);\n\t\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#set(key,value,MultiValueMap<String,parameters)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "MultiValueMap<String",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 691
    },
    "return": "void",
    "signature": "public void set(String key, String value, MultiValueMap<String,String> parameters)",
    "source_code": "\t\tpublic void set(String key, String value, MultiValueMap<String,String> parameters) {\n\t\t\tif (this.extractedUriVariables == null) {\n\t\t\t\tthis.extractedUriVariables = new HashMap<>();\n\t\t\t}\n\t\t\tthis.extractedUriVariables.put(key, value);\n\n\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\tif (this.extractedMatrixVariables == null) {\n\t\t\t\t\tthis.extractedMatrixVariables = new HashMap<>();\n\t\t\t\t}\n\t\t\t\tthis.extractedMatrixVariables.put(key, CollectionUtils.unmodifiableMultiValueMap(parameters));\n\t\t\t}\n\t\t}"
  }
}