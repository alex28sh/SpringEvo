{
  "org.springframework.aop.aspectj.<unknown>#couldMatchJoinPointsInType(someClass,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "someClass",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "boolean",
    "signature": "public boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context)",
    "source_code": "\t\tpublic boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context) {\n\t\t\treturn (contextMatch(someClass) == FuzzyBoolean.YES);\n\t\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#findQualifiedExecutor(beanFactory,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a target executor for the given qualifier.\n\t * @param qualifier the qualifier to resolve\n\t * @return the target executor, or {@code null} if none available\n\t * @since 4.2.6\n\t * @see #getExecutorQualifier(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "Executor",
    "signature": "protected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier)",
    "source_code": "\tprotected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier) {\n\t\tif (beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\"BeanFactory must be set on \" + getClass().getSimpleName() +\n\t\t\t\t\t\" to access qualified executor '\" + qualifier + \"'\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, Executor.class, qualifier);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(mm1,mm2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>either</i> (or both) of the given MethodMatchers matches.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that either\n\t * of the given MethodMatchers matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew UnionIntroductionAwareMethodMatcher(mm1, mm2) : new UnionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValue(propertyName,propertyValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overloaded version of {@code addPropertyValue} that takes\n\t * a property name and a property value.\n\t * <p>Note: we recommend using the more concise and chaining-capable variant\n\t * {@link #add(String, Object)}.\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @see #addPropertyValue(PropertyValue)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void addPropertyValue(String propertyName, Object propertyValue)",
    "source_code": "\tpublic void addPropertyValue(String propertyName, Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfType(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn doGetBean(name, null, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "T",
    "signature": "public T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n\t\t\tthrows BeansException {\n\n\t\treturn doGetBean(name, requiredType, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeanByName(name,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) {\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\treturn getBean(name, descriptor.getDependencyType());\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorate(node,definition,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tif (node instanceof Attr attr) {\n\t\t\tString propertyName = parserContext.getDelegate().getLocalName(attr);\n\t\t\tString propertyValue = attr.getValue();\n\t\t\tMutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();\n\t\t\tif (pvs.contains(propertyName)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Property '\" + propertyName + \"' is already defined using \" +\n\t\t\t\t\t\t\"both <property> and inline syntax. Only one approach may be used per property.\", attr);\n\t\t\t}\n\t\t\tif (propertyName.endsWith(REF_SUFFIX)) {\n\t\t\t\tpropertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);\n\t\t\t}\n\t\t}\n\t\treturn definition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElement(ele,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a property element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 839
    },
    "return": "void",
    "signature": "public void parsePropertyElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElement(Element ele, BeanDefinition bd) {\n\t\tString propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(propertyName)) {\n\t\t\terror(\"Tag 'property' must have a 'name' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new PropertyEntry(propertyName));\n\t\ttry {\n\t\t\tif (bd.getPropertyValues().contains(propertyName)) {\n\t\t\t\terror(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject val = parsePropertyValue(ele, bd, propertyName);\n\t\t\tPropertyValue pv = new PropertyValue(propertyName, val);\n\t\t\tparseMetaElements(ele, pv);\n\t\t\tpv.setSource(extractSource(ele));\n\t\t\tbd.getPropertyValues().addPropertyValue(pv);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.<unknown>#compare(o1,o2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "int",
    "signature": "public int compare(T o1, T o2)",
    "source_code": "\tpublic int compare(T o1, T o2) {\n\t\tObject v1 = getPropertyValue(o1);\n\t\tObject v2 = getPropertyValue(o2);\n\t\tif (this.sortDefinition.isIgnoreCase() && (v1 instanceof String text1) && (v2 instanceof String text2)) {\n\t\t\tv1 = text1.toLowerCase();\n\t\t\tv2 = text2.toLowerCase();\n\t\t}\n\n\t\tint result;\n\n\t\t// Put an object with null property at the end of the sort result.\n\t\ttry {\n\t\t\tif (v1 != null) {\n\t\t\t\tresult = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (v2 != null ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not sort objects [\" + o1 + \"] and [\" + o2 + \"]\", ex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (this.sortDefinition.isAscending() ? result : -result);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 1338
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tif (ApplicationListener.class.isAssignableFrom(beanType)) {\n\t\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createSortedProperties(properties,omitComments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@code Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * <p>The returned {@code Properties} instance will be populated with\n\t * properties from the supplied {@code properties} object, but default\n\t * properties from the supplied {@code properties} object will not be copied.\n\t * @param properties the {@code Properties} object from which to copy the\n\t * initial properties\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "omitComments"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "Properties",
    "signature": "public Properties createSortedProperties(Properties properties, boolean omitComments)",
    "source_code": "\tpublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\n\t\treturn new SortedProperties(properties, omitComments);\n\t}"
  },
  "org.springframework.core.<unknown>#forType(type,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@link ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 1369
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner)",
    "source_code": "\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(Converter<?,converter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Converter<?",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void addConverter(Converter<?, ?> converter)",
    "source_code": "\tpublic void addConverter(Converter<?, ?> converter) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);\n\t\tif (typeInfo == null && converter instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), Converter.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"Converter [\" + converter.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readInputStream(inputStreamSupplier,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@link InputStream} from the given supplier, and read it into a\n\t * {@code Flux} of {@code DataBuffer}s. Closes the input stream when the\n\t * Flux is terminated.\n\t * @param inputStreamSupplier the supplier for the input stream to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStreamSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readInputStream(Callable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readInputStream(\n\t\t\tCallable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(inputStreamSupplier, \"'inputStreamSupplier' must not be null\");\n\t\treturn readByteChannel(() -> Channels.newChannel(inputStreamSupplier.call()), bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "Netty5DataBuffer",
    "signature": "public Netty5DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic Netty5DataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.buffer.writeBytes(source, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 703
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.http.<unknown>#createByteRange(firstBytePos,lastBytePos)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code HttpRange} from the given fist to last position.\n\t * @param firstBytePos the first byte position\n\t * @param lastBytePos the last byte position\n\t * @return a byte range that ranges from {@code firstPos} till {@code lastPos}\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7233#section-2.1\">Byte Ranges</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "firstBytePos",
      "lastBytePos"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HttpRange",
    "signature": "public HttpRange createByteRange(long firstBytePos, long lastBytePos)",
    "source_code": "\tpublic static HttpRange createByteRange(long firstBytePos, long lastBytePos) {\n\t\treturn new ByteRange(firstBytePos, lastBytePos);\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part from {@link Publisher} content.\n\t * @param name the name of the part to add\n\t * @param publisher a Publisher of content for the part\n\t * @param elementClass the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(String name, P publisher, Class<T> elementClass) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, elementClass);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#setHttpContextFactory(BiFunction<HttpMethod,URI,httpContextFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a factory to pre-create the {@link HttpContext} for each request.\n\t * <p>This may be useful for example in mutual TLS authentication where a\n\t * different {@code RestTemplate} for each client certificate such that\n\t * all calls made through a given {@code RestTemplate} instance as associated\n\t * for the same client identity. {@link HttpClientContext#setUserToken(Object)}\n\t * can be used to specify a fixed user token for all requests.\n\t * @param httpContextFactory the context factory to use\n\t * @since 5.2.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<HttpMethod",
      "URI",
      "httpContextFactory"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory)",
    "source_code": "\tpublic void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory) {\n\t\tthis.httpContextFactory = httpContextFactory;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#processResultSet(rs,param)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given ResultSet from a stored procedure.\n\t * @param rs the ResultSet to process\n\t * @param param the corresponding stored procedure parameter\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "param"
    ],
    "position": {
      "column": 1,
      "line": 1378
    },
    "return": "Object>",
    "signature": "protected Object> processResultSet(@Nullable ResultSet rs, ResultSetSupportingSqlParameter param)",
    "source_code": "\tprotected Map<String, Object> processResultSet(\n\t\t\t@Nullable ResultSet rs, ResultSetSupportingSqlParameter param) throws SQLException {\n\n\t\tif (rs != null) {\n\t\t\ttry {\n\t\t\t\tif (param.getRowMapper() != null) {\n\t\t\t\t\tRowMapper<?> rowMapper = param.getRowMapper();\n\t\t\t\t\tObject data = (new RowMapperResultSetExtractor<>(rowMapper)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t\telse if (param.getRowCallbackHandler() != null) {\n\t\t\t\t\tRowCallbackHandler rch = param.getRowCallbackHandler();\n\t\t\t\t\t(new RowCallbackHandlerResultSetExtractor(rch)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(),\n\t\t\t\t\t\t\t\"ResultSet returned from stored procedure was processed\");\n\t\t\t\t}\n\t\t\t\telse if (param.getResultSetExtractor() != null) {\n\t\t\t\t\tObject data = param.getResultSetExtractor().extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyMap();\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, @Nullable Object... args)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,typeName,inValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * (optional, only used for SQL NULL and SqlTypeValue)\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * Named parameters are substituted for a JDBC placeholder and any select list\n\t * is expanded to the required number of placeholders.\n\t * <p>This is a shortcut version of\n\t * {@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}.\n\t * @param sql the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, paramSource);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doCloseConnection(con,dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the Connection, unless a {@link SmartDataSource} doesn't want us to.\n\t * @param con the Connection to close if necessary\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see Connection#close()\n\t * @see SmartDataSource#shouldClose(Connection)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "void",
    "signature": "public void doCloseConnection(Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void doCloseConnection(Connection con, @Nullable DataSource dataSource) throws SQLException {\n\t\tif (!(dataSource instanceof SmartDataSource smartDataSource) || smartDataSource.shouldClose(con)) {\n\t\t\tcon.close();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#setCredentialsForCurrentThread(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set user credentials for this proxy and the current thread.\n\t * The given username and password will be applied to all subsequent\n\t * {@code createConnection()} calls on this ConnectionFactory proxy.\n\t * <p>This will override any statically specified user credentials,\n\t * that is, values of the \"username\" and \"password\" bean properties.\n\t * @param username the username to apply\n\t * @param password the password to apply\n\t * @see #removeCredentialsFromCurrentThread\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setCredentialsForCurrentThread(String username, String password)",
    "source_code": "\tpublic void setCredentialsForCurrentThread(String username, String password) {\n\t\tthis.threadBoundCredentials.set(new JmsUserCredentials(username, password));\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Object conversionHint)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Object conversionHint)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\treturn toMessage(object, session, getSerializationView(conversionHint));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,file)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 934
    },
    "return": "void",
    "signature": "public void addInline(String contentId, File file)",
    "source_code": "\tpublic void addInline(String contentId, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddInline(contentId, dataSource);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscription(sessionId,subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void addSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void addSubscription(String sessionId, Subscription subscription) {\n\t\t\tSessionInfo info = this.sessions.computeIfAbsent(sessionId, _sessionId -> new SessionInfo());\n\t\t\tinfo.addSubscription(subscription);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#afterMessageHandled(message,ch,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "ch",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void afterMessageHandled(Message<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterMessageHandled(\n\t\t\t\tMessage<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex) {\n\n\t\t\tRunnable task = getNextMessageTask(message);\n\t\t\tif (task != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setSystemSubscriptions(Map<String,subscriptions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more destinations to subscribe to on the shared \"system\"\n\t * connection along with MessageHandler's to handle received messages.\n\t * <p>This is for internal use in a multi-application server scenario where\n\t * servers forward messages to each other (e.g. unresolved user destinations).\n\t * @param subscriptions the destinations to subscribe to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "subscriptions"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "public void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions)",
    "source_code": "\tpublic void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {\n\t\tthis.systemSubscriptions.clear();\n\t\tif (subscriptions != null) {\n\t\t\tthis.systemSubscriptions.putAll(subscriptions);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendError(status,errorMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "errorMessage"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "public void sendError(int status, String errorMessage)",
    "source_code": "\tpublic void sendError(int status, String errorMessage) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot set error status - response is already committed\");\n\t\tthis.status = status;\n\t\tthis.errorMessage = errorMessage;\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#bulkUpdate(queryString,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryString",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1014
    },
    "return": "int",
    "signature": "public int bulkUpdate(String queryString, @Nullable Object... values)",
    "source_code": "\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceUnits(Map<String,persistenceUnits)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the persistence units for EntityManagerFactory lookups,\n\t * as a Map from persistence unit name to persistence unit JNDI name\n\t * (which needs to resolve to an EntityManagerFactory instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-unit-ref}\n\t * entries in the Jakarta EE deployment descriptor, matching the target persistence unit.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all lookup\n\t * driven by the standard JPA annotations, and all EntityManagerFactory\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario.\n\t * <p>If no corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\"\n\t * are specified, {@code @PersistenceContext} will be resolved to\n\t * EntityManagers built on top of the EntityManagerFactory defined here.\n\t * Note that those will be Spring-managed EntityManagers, which implement\n\t * transaction synchronization based on Spring's facilities.\n\t * If you prefer the Jakarta EE server's own EntityManager handling,\n\t * specify corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceUnits"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "public void setPersistenceUnits(Map<String, String> persistenceUnits)",
    "source_code": "\tpublic void setPersistenceUnits(Map<String, String> persistenceUnits) {\n\t\tthis.persistenceUnits = persistenceUnits;\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalXmlEventWriter(graph,eventWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param eventWriter the {@code XMLEventWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected abstract void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}."
  },
  "org.springframework.scheduling.quartz.<unknown>#setSchedulerContextAsMap(Map<String,schedulerContextAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register objects in the Scheduler context via a given Map.\n\t * These objects will be available to any Job that runs in this Scheduler.\n\t * <p>Note: When using persistent Jobs whose JobDetail will be kept in the\n\t * database, do not put Spring-managed beans or an ApplicationContext\n\t * reference into the JobDataMap but rather into the SchedulerContext.\n\t * @param schedulerContextAsMap a Map with String keys and any objects as\n\t * values (for example Spring-managed beans)\n\t * @see JobDetailFactoryBean#setJobDataAsMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "schedulerContextAsMap"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap)",
    "source_code": "\tpublic void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap) {\n\t\tthis.schedulerContextMap = schedulerContextAsMap;\n\t}"
  },
  "org.springframework.util.<unknown>#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void add(K key, @Nullable V value)",
    "source_code": "\tpublic void add(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void addAll(K key, List<? extends V> values)",
    "source_code": "\tpublic void addAll(K key, List<? extends V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addIfAbsent(K key, @Nullable V value)",
    "source_code": "\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#applyRelativePath(path,relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given relative path to the given Java resource path,\n\t * assuming standard Java folder separation (i.e. \"/\" separators).\n\t * @param path the path to start from (usually a full file path)\n\t * @param relativePath the relative path to apply\n\t * (relative to the full file path above)\n\t * @return the full file path that results from applying the relative path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 670
    },
    "return": "String",
    "signature": "public String applyRelativePath(String path, String relativePath)",
    "source_code": "\tpublic static String applyRelativePath(String path, String relativePath) {\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (separatorIndex != -1) {\n\t\t\tString newPath = path.substring(0, separatorIndex);\n\t\t\tif (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n\t\t\t\tnewPath += FOLDER_SEPARATOR_CHAR;\n\t\t\t}\n\t\t\treturn newPath + relativePath;\n\t\t}\n\t\telse {\n\t\t\treturn relativePath;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfAbsent(key,String,mappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "String",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "V",
    "signature": "public V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction)",
    "source_code": "\tpublic V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction) {\n\t\tString oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\n\t\tif (oldKey != null) {\n\t\t\tV oldKeyValue = this.targetMap.get(oldKey);\n\t\t\tif (oldKeyValue != null) {\n\t\t\t\treturn oldKeyValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey = oldKey;\n\t\t\t}\n\t\t}\n\t\treturn this.targetMap.computeIfAbsent(key, mappingFunction);\n\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,hash,restructure)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hash",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "V>",
    "signature": "public V> getReference(@Nullable Object key, int hash, Restructure restructure)",
    "source_code": "\t\tpublic Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\n\t\t\tif (restructure == Restructure.WHEN_NECESSARY) {\n\t\t\t\trestructureIfNecessary(false);\n\t\t\t}\n\t\t\tif (this.count.get() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Use a local copy to protect against other threads writing\n\t\t\tReference<K, V>[] references = this.references;\n\t\t\tint index = getIndex(hash, references);\n\t\t\tReference<K, V> head = references[index];\n\t\t\treturn findInChain(head, key, hash);\n\t\t}"
  },
  "org.springframework.util.<unknown>#tokenizeToStringArray(str,delimiters,trimTokens,ignoreEmptyTokens)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @param trimTokens trim the tokens via {@link String#trim()}\n\t * @param ignoreEmptyTokens omit empty tokens from the result array\n\t * (only applies to tokens that are empty after trimming; StringTokenizer\n\t * will not consider subsequent delimiters as token in the first place).\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters",
      "trimTokens",
      "ignoreEmptyTokens"
    ],
    "position": {
      "column": 1,
      "line": 1161
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)",
    "source_code": "\tpublic static String[] tokenizeToStringArray(\n\t\t\t@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\tStringTokenizer st = new StringTokenizer(str, delimiters);\n\t\tList<String> tokens = new ArrayList<>();\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tString token = st.nextToken();\n\t\t\tif (trimTokens) {\n\t\t\t\ttoken = token.trim();\n\t\t\t}\n\t\t\tif (!ignoreEmptyTokens || token.length() > 0) {\n\t\t\t\ttokens.add(token);\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(tokens);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startElement(uri,localName,qName,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "localName",
      "qName",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void startElement(String uri, String localName, String qName, Attributes attributes)",
    "source_code": "\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) {\n\t\tNode parent = getParent();\n\t\tElement element = this.document.createElementNS(uri, qName);\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tString attrUri = attributes.getURI(i);\n\t\t\tString attrQname = attributes.getQName(i);\n\t\t\tString value = attributes.getValue(i);\n\t\t\tif (!attrQname.startsWith(\"xmlns\")) {\n\t\t\t\telement.setAttributeNS(attrUri, attrQname, value);\n\t\t\t}\n\t\t}\n\t\telement = (Element) parent.appendChild(element);\n\t\tthis.elements.add(element);\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerTypeHints(hints,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 623
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 616
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Object... uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Object... uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#insert(outputMessage,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputMessage",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> insert(ClientHttpRequest outputMessage, Context context)",
    "source_code": "\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, HttpEntity<?>>> messageWriter =\n\t\t\t\t\tfindWriter(context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);\n\t\t\tMultiValueMap<String, HttpEntity<?>> body = this.builder.build();\n\t\t\treturn messageWriter.write(Mono.just(body), MULTIPART_DATA_TYPE,\n\t\t\t\t\tMediaType.MULTIPART_FORM_DATA, outputMessage, context.hints());\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#parse(content,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, '\\'', content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, '\"', content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractUnquotedLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders --\n\t * named keys with braces {@code {}}. For example, send in a relative URL\n\t * {@code foo/{bar}?spam={spam}} and a parameter map {@code {bar=baz,spam=nuts}}\n\t * and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the current web application with an\n\t * absolute path also URL-encoded accordingly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = StringUtils.applyRelativePath(getContextPath() + \"/\", relativeUrl);\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\treturn getExchange().transformUrl(url);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPost(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate POST requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "protected void doPost(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#preHandle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\tthis.requestInterceptor.preHandle(new DispatcherServletWebRequest(request, response));\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeAndHandle(webRequest,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\t\tsetResponseStatus(webRequest);\n\n\t\tif (returnValue == null) {\n\t\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\t\tdisableContentCachingIfNecessary(webRequest);\n\t\t\t\tmavContainer.setRequestHandled(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tmavContainer.setRequestHandled(false);\n\t\tAssert.state(this.returnValueHandlers != null, \"No return value handlers\");\n\t\ttry {\n\t\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#parse(content,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, \"'\", content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, \"\\\"\", content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#transform(request,resource,transformerChain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "resource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Resource",
    "signature": "public Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)\n\t\t\tthrows IOException {\n\n\t\tresource = transformerChain.transform(request, resource);\n\n\t\tString filename = resource.getFilename();\n\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\tresource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tbyte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream());\n\t\tString content = new String(bytes, DEFAULT_CHARSET);\n\n\t\tSortedSet<ContentChunkInfo> links = new TreeSet<>();\n\t\tfor (LinkParser parser : this.linkParsers) {\n\t\t\tparser.parse(content, links);\n\t\t}\n\n\t\tif (links.isEmpty()) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tint index = 0;\n\t\tStringWriter writer = new StringWriter();\n\t\tfor (ContentChunkInfo linkContentChunkInfo : links) {\n\t\t\twriter.write(content.substring(index, linkContentChunkInfo.getStart()));\n\t\t\tString link = content.substring(linkContentChunkInfo.getStart(), linkContentChunkInfo.getEnd());\n\t\t\tString newLink = null;\n\t\t\tif (!hasScheme(link)) {\n\t\t\t\tString absolutePath = toAbsolutePath(link, request);\n\t\t\t\tnewLink = resolveUrlPath(absolutePath, request, resource, transformerChain);\n\t\t\t}\n\t\t\twriter.write(newLink != null ? newLink : link);\n\t\t\tindex = linkContentChunkInfo.getEnd();\n\t\t}\n\t\twriter.write(content.substring(index));\n\n\t\treturn new TransformedResource(resource, writer.toString().getBytes(DEFAULT_CHARSET));\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlAwareMessageSource(servletContext,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks JSTL's \"jakarta.servlet.jsp.jstl.fmt.localizationContext\"\n\t * context-param and creates a corresponding child message source,\n\t * with the provided Spring-defined MessageSource as parent.\n\t * @param servletContext the ServletContext we're running in\n\t * (to check JSTL-related context-params in {@code web.xml})\n\t * @param messageSource the MessageSource to expose, typically\n\t * the ApplicationContext of the current DispatcherServlet\n\t * @return the MessageSource to expose to JSTL; first checking the\n\t * JSTL-defined bundle, then the Spring-defined MessageSource\n\t * @see org.springframework.context.ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "MessageSource",
    "signature": "public MessageSource getJstlAwareMessageSource(@Nullable ServletContext servletContext, MessageSource messageSource)",
    "source_code": "\tpublic static MessageSource getJstlAwareMessageSource(\n\t\t\t@Nullable ServletContext servletContext, MessageSource messageSource) {\n\n\t\tif (servletContext != null) {\n\t\t\tString jstlInitParam = servletContext.getInitParameter(Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\tif (jstlInitParam != null) {\n\t\t\t\t// Create a ResourceBundleMessageSource for the specified resource bundle\n\t\t\t\t// basename in the JSTL context-param in web.xml, wiring it with the given\n\t\t\t\t// Spring-defined MessageSource as parent.\n\t\t\t\tResourceBundleMessageSource jstlBundleWrapper = new ResourceBundleMessageSource();\n\t\t\t\tjstlBundleWrapper.setBasename(jstlInitParam);\n\t\t\t\tjstlBundleWrapper.setParentMessageSource(messageSource);\n\t\t\t\treturn jstlBundleWrapper;\n\t\t\t}\n\t\t}\n\t\treturn messageSource;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#isEligibleProperty(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given model element should be exposed\n\t * as a query property.\n\t * <p>The default implementation considers Strings and primitives\n\t * as eligible, and also arrays and Collections/Iterables with\n\t * corresponding elements. This can be overridden in subclasses.\n\t * @param key the key of the model element\n\t * @param value the value of the model element\n\t * @return whether the element is eligible as query property\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleProperty(String key, @Nullable Object value)",
    "source_code": "\tprotected boolean isEligibleProperty(String key, @Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isEligibleValue(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value.getClass().isArray()) {\n\t\t\tint length = Array.getLength(value);\n\t\t\tif (length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tObject element = Array.get(value, i);\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Collection<?> coll) {\n\t\t\tif (coll.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Object element : coll) {\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  }
}