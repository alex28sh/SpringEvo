{
  "org.springframework.aop.framework.<unknown>#equalsAdvisors(a,b)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the advisors behind the given AdvisedSupport objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "boolean",
    "signature": "public boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn a.getAdvisorCount() == b.getAdvisorCount() && Arrays.equals(a.getAdvisors(), b.getAdvisors());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#prepareProxyFactory(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a {@link ProxyFactory} for the given bean.\n\t * <p>Subclasses may customize the handling of the target instance and in\n\t * particular the exposure of the target class. The default introspection\n\t * of interfaces for non-target-class proxies and the configured advisor\n\t * will be applied afterwards; {@link #customizeProxyFactory} allows for\n\t * late customizations of those parts right before proxy creation.\n\t * @param bean the bean instance to create a proxy for\n\t * @param beanName the corresponding bean name\n\t * @return the ProxyFactory, initialized with this processor's\n\t * {@link ProxyConfig} settings and the specified bean\n\t * @since 4.2.3\n\t * @see #customizeProxyFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "ProxyFactory",
    "signature": "protected ProxyFactory prepareProxyFactory(Object bean, String beanName)",
    "source_code": "\tprotected ProxyFactory prepareProxyFactory(Object bean, String beanName) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.copyFrom(this);\n\t\tproxyFactory.setTarget(bean);\n\t\treturn proxyFactory;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanClass, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanClass, String beanName) {\n\t\tfindLifecycleMetadata(beanDefinition, beanClass);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanName, beanType, beanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addScope(scopeName,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given scope to this configurer's map of scopes.\n\t * @param scopeName the name of the scope\n\t * @param scope the scope implementation\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void addScope(String scopeName, Scope scope) {\n\t\tif (this.scopes == null) {\n\t\t\tthis.scopes = new LinkedHashMap<>(1);\n\t\t}\n\t\tthis.scopes.put(scopeName, scope);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getFlattenedMap(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a flattened version of the given map, recursively following any nested Map\n\t * or Collection values. Entries from the resulting map retain the same order as the\n\t * source. When called with the Map from a {@link MatchCallback} the result will\n\t * contain the same values as the {@link MatchCallback} Properties.\n\t * @param source the source map\n\t * @return a flattened map\n\t * @since 4.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Object>",
    "signature": "protected Object> getFlattenedMap(Map<String, Object> source)",
    "source_code": "\tprotected final Map<String, Object> getFlattenedMap(Map<String, Object> source) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tbuildFlattenedMap(result, source, null);\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getMostSpecific(a,b)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "MatchStatus",
    "signature": "public MatchStatus getMostSpecific(MatchStatus a, MatchStatus b)",
    "source_code": "\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#populateBean(beanName,mbd,bw)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param bw the BeanWrapper with bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1362
    },
    "return": "void",
    "signature": "protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)",
    "source_code": "\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (bw.getWrappedClass().isRecord()) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to a record\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for records since they are immutable.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\t\tif (hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#postProcessObjectFromFactoryBean(object,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Applies the {@code postProcessAfterInitialization} callback of all\n\t * registered BeanPostProcessors, giving them a chance to post-process the\n\t * object obtained from FactoryBeans (for example, to auto-proxy them).\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1889
    },
    "return": "Object",
    "signature": "protected Object postProcessObjectFromFactoryBean(Object object, String beanName)",
    "source_code": "\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n\t\treturn applyBeanPostProcessorsAfterInitialization(object, beanName);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerResolvableDependency(dependencyType,autowiredValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dependencyType",
      "autowiredValue"
    ],
    "position": {
      "column": 1,
      "line": 810
    },
    "return": "void",
    "signature": "public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue)",
    "source_code": "\tpublic void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {\n\t\tAssert.notNull(dependencyType, \"Dependency type must not be null\");\n\t\tif (autowiredValue != null) {\n\t\t\tif (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {\n\t\t\t\tthrow new IllegalArgumentException(\"Value [\" + autowiredValue +\n\t\t\t\t\t\t\"] does not implement specified dependency type [\" + dependencyType.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,beanName,containingBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\tparseMetaElements(ele, bd);\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElements(beanEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse property sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void parsePropertyElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n\t\t\t\tparsePropertyElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findConstructor(desc,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Constructor",
    "signature": "public Constructor findConstructor(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Constructor findConstructor(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tString className = desc.substring(0, lparen).trim();\n\t\t\treturn getClass(className, loader).getConstructor(parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1400
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 1221
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(property,nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the property.\n\t * <p>For example, if the property is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the property is a {@code List<List<String>>} and the nesting level\n\t * is 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the property is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the property is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param property the property\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Property property, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Property property, int nestingLevel) {\n\t\treturn nested(new TypeDescriptor(property), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#remove(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "void",
    "signature": "public void remove(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\t\tpublic void remove(Class<?> sourceType, Class<?> targetType) {\n\t\t\tthis.converters.remove(new ConvertiblePair(sourceType, targetType));\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@code AsynchronousFileChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\treturn readAsynchronousFileChannel(channelSupplier, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.format.support.<unknown>#matches(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn targetType.hasAnnotation(this.annotationType);\n\t\t}"
  },
  "org.springframework.http.<unknown>#createByteRange(firstBytePos,lastBytePos)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code HttpRange} from the given fist to last position.\n\t * @param firstBytePos the first byte position\n\t * @param lastBytePos the last byte position\n\t * @return a byte range that ranges from {@code firstPos} till {@code lastPos}\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7233#section-2.1\">Byte Ranges</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "firstBytePos",
      "lastBytePos"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HttpRange",
    "signature": "public HttpRange createByteRange(long firstBytePos, long lastBytePos)",
    "source_code": "\tpublic static HttpRange createByteRange(long firstBytePos, long lastBytePos) {\n\t\treturn new ByteRange(firstBytePos, lastBytePos);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1831
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.http.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1752
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part where the Object may be:\n\t * <ul>\n\t * <li>String -- form field\n\t * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n\t * <li>Object -- content to be encoded (e.g. to JSON)\n\t * <li>{@link HttpEntity} -- part content and headers although generally it's\n\t * easier to add headers through the returned builder\n\t * <li>{@link Part} -- a part from a server request\n\t * </ul>\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part)",
    "source_code": "\tpublic PartBuilder part(String name, Object part) {\n\t\treturn part(name, part, null);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "T",
    "signature": "public T query(final String sql, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL query [\" + sql + \"]\");\n\t\t}\n\n\t\t// Callback to execute the query.\n\t\tclass QueryStatementCallback implements StatementCallback<T>, SqlProvider {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\trs = stmt.executeQuery(sql);\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn execute(new QueryStatementCallback(), true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 905
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,pss,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (e.g. through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper) throws DataAccessException {\n\n\t\treturn result(execute(psc, ps -> {\n\t\t\tif (pss != null) {\n\t\t\t\tpss.setValues(ps);\n\t\t\t}\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tConnection con = ps.getConnection();\n\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t\tJdbcUtils.closeStatement(ps);\n\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t});\n\t\t}, false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 985
    },
    "return": "int",
    "signature": "public int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(generatedKeyHolder, \"KeyHolder must not be null\");\n\t\tlogger.debug(\"Executing SQL update and returning generated keys\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\tint rows = ps.executeUpdate();\n\t\t\tList<Map<String, Object>> generatedKeys = generatedKeyHolder.getKeyList();\n\t\t\tgeneratedKeys.clear();\n\t\t\tResultSet keys = ps.getGeneratedKeys();\n\t\t\tif (keys != null) {\n\t\t\t\ttry {\n\t\t\t\t\tRowMapperResultSetExtractor<Map<String, Object>> rse =\n\t\t\t\t\t\t\tnew RowMapperResultSetExtractor<>(getColumnMapRowMapper(), 1);\n\t\t\t\t\tgeneratedKeys.addAll(result(rse.extractData(keys)));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(keys);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows and returned \" + generatedKeys.size() + \" keys\");\n\t\t\t}\n\t\t\treturn rows;\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1019
    },
    "return": "int",
    "signature": "public int update(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic int update(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn update(sql, newArgTypePreparedStatementSetter(args, argTypes));\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(commentPrefix, \"'commentPrefix' must not be null or empty\");\n\t\tsplitSqlScript(resource, script, separator, new String[] { commentPrefix },\n\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter, statements);\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory ||\n\t\t\t\tbean instanceof JmsListenerEndpointRegistry) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, JmsListener.class)) {\n\t\t\tMap<Method, Set<JmsListener>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<JmsListener>>) method -> {\n\t\t\t\t\t\tSet<JmsListener> listenerMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, JmsListener.class, JmsListeners.class);\n\t\t\t\t\t\treturn (!listenerMethods.isEmpty() ? listenerMethods : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @JmsListener annotations found on bean type: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, listeners) ->\n\t\t\t\t\t\tlisteners.forEach(listener -> processJmsListener(listener, method, bean)));\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(annotatedMethods.size() + \" @JmsListener methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerEndpoint(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\treturn obtainTargetConnectionFactory().createConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queueName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 993
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destinationName,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 896
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doSendAndReceive(session, destination, messageCreator);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getResponseDestination(request,response,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a response destination for the given message.\n\t * <p>The default implementation first checks the JMS Reply-To\n\t * {@link Destination} of the supplied request; if that is not {@code null}\n\t * it is returned; if it is {@code null}, then the configured\n\t * {@link #resolveDefaultResponseDestination default response destination}\n\t * is returned; if this too is {@code null}, then an\n\t * {@link jakarta.jms.InvalidDestinationException} is thrown.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @param session the JMS Session to operate on\n\t * @return the response destination (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @throws jakarta.jms.InvalidDestinationException if no {@link Destination} can be determined\n\t * @see #setDefaultResponseDestination\n\t * @see jakarta.jms.Message#getJMSReplyTo()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Destination",
    "signature": "protected Destination getResponseDestination(Message request, Message response, Session session)",
    "source_code": "\tprotected Destination getResponseDestination(Message request, Message response, Session session)\n\t\t\tthrows JMSException {\n\n\t\tDestination replyTo = request.getJMSReplyTo();\n\t\tif (replyTo == null) {\n\t\t\treplyTo = resolveDefaultResponseDestination(session);\n\t\t\tif (replyTo == null) {\n\t\t\t\tthrow new InvalidDestinationException(\"Cannot determine response destination: \" +\n\t\t\t\t\t\t\"Request message does not contain reply-to destination, and no default response destination set.\");\n\t\t\t}\n\t\t}\n\t\treturn replyTo;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Object conversionHint)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Object conversionHint)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\treturn toMessage(object, session, getSerializationView(conversionHint));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>The content type will be determined by the given filename for\n\t * the attachment. Thus, any content source will be fine, including\n\t * temporary files with arbitrary filenames.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1070
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)\n\t\t\tthrows MessagingException {\n\n\t\tString contentType = getFileTypeMap().getContentType(attachmentFilename);\n\t\taddAttachment(attachmentFilename, inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.messaging.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\tpublic Object put(String key, Object value) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatInvokeError(text,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Endpoint [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSubscription(sessionId,subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterRemovedSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tString subscriptionId = subscription.getId();\n\t\t\t\tthis.destinationCache.forEach((destination, sessionIdToSubscriptionIds) -> {\n\t\t\t\t\tList<String> subscriptionIds = sessionIdToSubscriptionIds.get(sessionId);\n\t\t\t\t\tif (subscriptionIds != null && subscriptionIds.contains(subscriptionId)) {\n\t\t\t\t\t\tremoveInternal(destination, sessionId, subscriptionId);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveInternal(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#write(context,target,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value) {\n\t\t}"
  },
  "org.springframework.r2dbc.connection.lookup.<unknown>#setTargetConnectionFactories(Map<?,targetConnectionFactories)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target {@link ConnectionFactory ConnectionFactories},\n\t * with the lookup key as key. The mapped value can either be a corresponding\n\t * {@link ConnectionFactory} instance or a connection factory name String (to be\n\t * resolved via a {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the generic lookup\n\t * process only. The concrete key representation will be handled by\n\t * {@link #resolveSpecifiedLookupKey(Object)} and {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "targetConnectionFactories"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories)",
    "source_code": "\tpublic void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories) {\n\t\tthis.targetConnectionFactories = targetConnectionFactories;\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setFixedDelayTasks(Map<Runnable,fixedDelayTasks)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values.\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "fixedDelayTasks"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks)",
    "source_code": "\tpublic void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks) {\n\t\tthis.fixedDelayTasks = new ArrayList<>();\n\t\tfixedDelayTasks.forEach((task, delay) -> addFixedDelayTask(task, Duration.ofMillis(delay)));\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#setCalendars(Map<String,calendars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of Quartz Calendar objects with the Scheduler\n\t * that this FactoryBean creates, to be referenced by Triggers.\n\t * @param calendars a Map with calendar names as keys as Calendar\n\t * objects as values\n\t * @see org.quartz.Calendar\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "calendars"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setCalendars(Map<String, Calendar> calendars)",
    "source_code": "\tpublic void setCalendars(Map<String, Calendar> calendars) {\n\t\tthis.calendars = calendars;\n\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#evaluate(script,Map<String,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments) {\n\t\tGroovyShell groovyShell = new GroovyShell(\n\t\t\t\tthis.classLoader, new Binding(arguments), this.compilerConfiguration);\n\t\ttry {\n\t\t\tString filename = (script instanceof ResourceScriptSource resourceScriptSource ?\n\t\t\t\t\tresourceScriptSource.getResource().getFilename() : null);\n\t\t\tif (filename != null) {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString(), filename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access Groovy script\", ex);\n\t\t}\n\t\tcatch (GroovyRuntimeException ex) {\n\t\t\tthrow new ScriptCompilationException(script, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestMethod(testInstance,testMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>after</em> execution of <em>after</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * tearing down test fixtures, ending a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately after\n\t * framework-specific <em>after</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * For historical reasons, this method is named {@code afterTestMethod}. Since\n\t * the introduction of {@link #afterTestExecution}, a more suitable name for\n\t * this method might be something like {@code afterTestTearDown} or\n\t * {@code afterEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the test\n\t * method or by a TestExecutionListener, or {@code null} if none was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #beforeTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestMethod\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestMethodException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestMethodException == null) {\n\t\t\t\t\tafterTestMethodException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestMethodException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestMethodException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestMethodException);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestExecution(testInstance,testMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>immediately before</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called after framework-specific\n\t * <em>before</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void beforeTestExecution(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestExecution\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(\n\t\t\tHttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tRequestBuilder requestBuilder = adaptRequest(method, uri, requestCallback);\n\t\ttry {\n\t\t\tMvcResult mvcResult = this.mockMvc.perform(requestBuilder).andReturn();\n\t\t\tif (mvcResult.getRequest().isAsyncStarted()) {\n\t\t\t\tmvcResult.getAsyncResult();\n\t\t\t\tmvcResult = this.mockMvc.perform(asyncDispatch(mvcResult)).andReturn();\n\t\t\t}\n\t\t\treturn Mono.just(adaptResponse(mvcResult));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ResultMatcher attribute(String name, @Nullable Object value) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertEquals(\"Model attribute '\" + name + \"'\", value, mav.getModel().get(name));\n\t\t};\n\t}"
  },
  "org.springframework.util.<unknown>#addStringToArray(array,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given {@code String} to the given {@code String} array,\n\t * returning a new array consisting of the input array contents plus\n\t * the given {@code String}.\n\t * @param array the array to append to (can be {@code null})\n\t * @param str the {@code String} to append\n\t * @return the new array (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 974
    },
    "return": "String[]",
    "signature": "public String[] addStringToArray(@Nullable String[] array, String str)",
    "source_code": "\tpublic static String[] addStringToArray(@Nullable String[] array, String str) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tString[] newArr = new String[array.length + 1];\n\t\tSystem.arraycopy(array, 0, newArr, 0, array.length);\n\t\tnewArr[array.length] = str;\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#doWithFields(clazz,fc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void doWithFields(Class<?> clazz, FieldCallback fc)",
    "source_code": "\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\n\t\tdoWithFields(clazz, fc, null);\n\t}"
  },
  "org.springframework.util.<unknown>#uriDecode(source,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component value. Based on the following rules:\n\t * <ul>\n\t * <li>Alphanumeric characters {@code \"a\"} through {@code \"z\"}, {@code \"A\"} through {@code \"Z\"},\n\t * and {@code \"0\"} through {@code \"9\"} stay the same.</li>\n\t * <li>Special characters {@code \"-\"}, {@code \"_\"}, {@code \".\"}, and {@code \"*\"} stay the same.</li>\n\t * <li>A sequence \"{@code %<i>xy</i>}\" is interpreted as a hexadecimal representation of the character.</li>\n\t * </ul>\n\t * @param source the encoded String\n\t * @param charset the character set\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 802
    },
    "return": "String",
    "signature": "public String uriDecode(String source, Charset charset)",
    "source_code": "\tpublic static String uriDecode(String source, Charset charset) {\n\t\tint length = source.length();\n\t\tif (length == 0) {\n\t\t\treturn source;\n\t\t}\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n\t\tboolean changed = false;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tint ch = source.charAt(i);\n\t\t\tif (ch == '%') {\n\t\t\t\tif (i + 2 < length) {\n\t\t\t\t\tchar hex1 = source.charAt(i + 1);\n\t\t\t\t\tchar hex2 = source.charAt(i + 2);\n\t\t\t\t\tint u = Character.digit(hex1, 16);\n\t\t\t\t\tint l = Character.digit(hex2, 16);\n\t\t\t\t\tif (u == -1 || l == -1) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tbaos.write((char) ((u << 4) + l));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbaos.write(ch);\n\t\t\t}\n\t\t}\n\t\treturn (changed ? StreamUtils.copyToString(baos, charset) : source);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,field,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "field",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors,validationHints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "T",
    "signature": "public T patchForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T patchForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementTypeRef the type of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(\n\t\t\tT producer, ParameterizedTypeReference<?> elementTypeRef) {\n\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forType(elementTypeRef), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, Class<T> elementClass)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, elementClass);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handle(t,serverRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "serverRequest"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T handle(Throwable t, ServerRequest serverRequest)",
    "source_code": "\t\tpublic T handle(Throwable t, ServerRequest serverRequest) {\n\t\t\treturn this.responseProvider.apply(t, serverRequest);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected final ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tHandlerMethod handlerMethod = (handler instanceof HandlerMethod hm ? hm : null);\n\t\treturn doResolveHandlerMethodException(request, response, handlerMethod, ex);\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#afterCompletion(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getBindStatus(path,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#urlEncode(input,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * URL-encode the given input String with the given encoding scheme.\n\t * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.\n\t * @param input the unencoded input String\n\t * @param encodingScheme the encoding scheme\n\t * @return the encoded output String\n\t * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n\t * @see java.net.URLEncoder#encode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "String",
    "signature": "protected String urlEncode(String input, String encodingScheme)",
    "source_code": "\tprotected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n\t\treturn URLEncoder.encode(input, encodingScheme);\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#subProtocolWebSocketHandler(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler subProtocolWebSocketHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic WebSocketHandler subProtocolWebSocketHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\treturn new SubProtocolWebSocketHandler(clientInboundChannel, clientOutboundChannel);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleInitialRequest(request,response,frameFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the first request for receiving messages on a SockJS HTTP transport\n\t * based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing the open frame. Streaming-based transports (\"xhr_streaming\",\n\t * \"eventsource\", and \"htmlfile\") leave the response open longer for further\n\t * streaming of message frames but will also close it eventually after some\n\t * amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\ttry {\n\t\t\tthis.localAddress = request.getLocalAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\t\ttry {\n\t\t\tthis.remoteAddress = request.getRemoteAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\t// Let \"our\" handler know before sending the open frame to the remote handler\n\t\t\t\tdelegateConnectionEstablished();\n\t\t\t\thandleRequestInternal(request, response, true);\n\t\t\t\t// Request might have been reset (e.g. polling sessions do after writing)\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to open session\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(Map<String,parameters,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>This method will try to obtain a parameter value using the\n\t * following algorithm:\n\t * <ol>\n\t * <li>Try to get the parameter value using just the given <i>logical</i> name.\n\t * This handles parameters of the form {@code logicalName = value}. For normal\n\t * parameters, e.g. submitted using a hidden HTML form field, this will return\n\t * the requested value.</li>\n\t * <li>Try to obtain the parameter value from the parameter name, where the\n\t * parameter name in the request is of the form {@code logicalName_value = xyz}\n\t * with \"_\" being the configured delimiter. This deals with parameter values\n\t * submitted using an HTML form submit button.</li>\n\t * <li>If the value obtained in the previous step has a \".x\" or \".y\" suffix,\n\t * remove that. This handles cases where the value was submitted using an\n\t * HTML form image button. In this case the parameter in the request would\n\t * actually be of the form {@code logicalName_value.x = 123}.</li>\n\t * </ol>\n\t * @param parameters the available parameter map\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "parameters",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "String",
    "signature": "public String findParameterValue(Map<String, ?> parameters, String name)",
    "source_code": "\tpublic static String findParameterValue(Map<String, ?> parameters, String name) {\n\t\t// First try to get it as a normal name=value parameter\n\t\tObject value = parameters.get(name);\n\t\tif (value instanceof String[] values) {\n\t\t\treturn (values.length > 0 ? values[0] : null);\n\t\t}\n\t\telse if (value != null) {\n\t\t\treturn value.toString();\n\t\t}\n\t\t// If no value yet, try to get it as a name_value=xyz parameter\n\t\tString prefix = name + \"_\";\n\t\tfor (String paramName : parameters.keySet()) {\n\t\t\tif (paramName.startsWith(prefix)) {\n\t\t\t\t// Support images buttons, which would submit parameters as name_value.x=123\n\t\t\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\t\t\tif (paramName.endsWith(suffix)) {\n\t\t\t\t\t\treturn paramName.substring(prefix.length(), paramName.length() - suffix.length());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn paramName.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\t// We couldn't find the parameter value...\n\t\treturn null;\n\t}"
  }
}