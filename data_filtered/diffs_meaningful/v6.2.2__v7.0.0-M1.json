{
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn convertIfNecessary(null, value, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn convertIfNecessary(null, value, requiredType, typeDescriptor);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isAutowirable(parameter,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link Parameter} can <em>potentially</em> be\n\t * autowired from an {@link AutowireCapableBeanFactory}.\n\t * <p>Returns {@code true} if the supplied parameter is annotated or\n\t * meta-annotated with {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, or {@link Value @Value}.\n\t * <p>Note that {@link #resolveDependency} may still be able to resolve the\n\t * dependency for the supplied parameter even if this method returns {@code false}.\n\t * @param parameter the parameter whose dependency should be autowired\n\t * (must not be {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @see #resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean isAutowirable(Parameter parameter, int parameterIndex)",
    "source_code": "\tpublic static boolean isAutowirable(Parameter parameter, int parameterIndex) {\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\treturn (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class));\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn this.targetCache.get(key, valueLoader);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "public String getMessage(String code, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, locale);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedRepeatableAnnotations(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "Set<A>",
    "signature": "public Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn findMergedRepeatableAnnotations(element, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType,predicate,selector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "predicate",
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector) {\n\n\t\tMergedAnnotation<A> result = find(annotationType, predicate, selector);\n\t\treturn (result != null ? result : MergedAnnotation.missing());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getEnum(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "E",
    "signature": "public E getEnum(String attributeName, Class<E> type)",
    "source_code": "\tpublic <E extends Enum<E>> E getEnum(String attributeName, Class<E> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn getRequiredAttributeValue(attributeName, type);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getEnumArray(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "E[]",
    "signature": "public E[] getEnumArray(String attributeName, Class<E> type)",
    "source_code": "\tpublic <E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (E[]) getRequiredAttributeValue(attributeName, type.arrayType());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotation(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "A",
    "signature": "public A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMetaAnnotationTypes(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Set<String>",
    "signature": "public Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tif (annotation.annotationType().getName().equals(annotationName)) {\n\t\t\t\treturn getMetaAnnotationTypes(element, annotation);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Netty5DataBuffer",
    "signature": "public Netty5DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic Netty5DataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.buffer.readBytes(destination, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p><strong>Note</strong> that due to the lack of a {@code slice} method\n\t * in Netty 5's {@link Buffer}, this implementation returns a copy that\n\t * does <strong>not</strong> share its contents with this buffer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\tpublic DataBuffer slice(int index, int length) {\n\t\tBuffer copy = this.buffer.copy(index, length);\n\t\treturn new Netty5DataBuffer(copy, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#load(factoryType,argumentResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and the given argument resolver.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "argumentResolver"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\n\t\treturn load(factoryType, argumentResolver, null);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#load(factoryType,argumentResolver,failureHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\n\t * the given argument resolver, and custom failure handling provided by the given\n\t * failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler) {\n\n\t\tAssert.notNull(factoryType, \"'factoryType' must not be null\");\n\t\tList<String> implementationNames = loadFactoryNames(factoryType);\n\t\tlogger.trace(LogMessage.format(\"Loaded [%s] names: %s\", factoryType.getName(), implementationNames));\n\t\tList<T> result = new ArrayList<>(implementationNames.size());\n\t\tFailureHandler failureHandlerToUse = (failureHandler != null) ? failureHandler : THROWING_FAILURE_HANDLER;\n\t\tfor (String implementationName : implementationNames) {\n\t\t\tT factory = instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);\n\t\t\tif (factory != null) {\n\t\t\t\tresult.add(factory);\n\t\t\t}\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(result);\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#add(factoryType,factoryImplementations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory implementations to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryImplementations the implementation class names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementations"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void add(String factoryType, String... factoryImplementations)",
    "source_code": "\tpublic void add(String factoryType, String... factoryImplementations) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(\n\t\t\t\tfactoryType, key -> new ArrayList<>());\n\t\tCollections.addAll(implementations, factoryImplementations);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(context,rootObject,desiredResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tString value = getValue(context, rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), desiredResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValueTypeDescriptor(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#isWritable(context,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\treturn this.ast.isWritable(new ExpressionState(context, toTypedValue(rootObject), this.configuration));\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#setValue(context,rootObject,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tthis.ast.setValue(new ExpressionState(context, toTypedValue(rootObject), this.configuration), value);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#parse(text,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Duration",
    "signature": "public Duration parse(String text, Locale locale)",
    "source_code": "\tpublic Duration parse(String text, Locale locale) throws ParseException {\n\t\tif (this.defaultUnit == null) {\n\t\t\t//delegate to the style\n\t\t\treturn DurationFormatterUtils.parse(text, this.style);\n\t\t}\n\t\treturn DurationFormatterUtils.parse(text, this.style, this.defaultUnit);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1771
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tthis.headers.addAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all the given values under the given name.\n\t * <p>As values are represented as a {@code List}, duplicate values can be\n\t * introduced. See {@link #put(String, List)} to replace the list of values\n\t * instead.\n\t * @param headerName the header name\n\t * @param headerValues the values to add\n\t * @see #put(String, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1789
    },
    "return": "void",
    "signature": "public void addAll(String headerName, List<? extends String> headerValues)",
    "source_code": "\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tthis.headers.addAll(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.<unknown>#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 1837
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set header values for the given header name if that header name isn't\n\t * already present in this HttpHeaders and return {@code null}. If the\n\t * header is already present, returns the associated value list instead.\n\t * @param headerName the header name\n\t * @param headerValues the header values to set if header is not present\n\t * @return the previous value or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1954
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> putIfAbsent(String headerName, List<String> headerValues) {\n\t\treturn this.headers.putIfAbsent(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuffer map(byte[] b, int off, int len) {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(len);\n\t\t\tbyteBuffer.put(b, off, len);\n\t\t\tbyteBuffer.flip();\n\t\t\treturn byteBuffer;\n\t\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "T",
    "signature": "protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn read(ResolvableType.forClass(clazz), inputMessage, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#execute(sql,Map<String,paramMap,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(sql, new MapSqlParameterSource(paramMap), action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,Map<String,paramMap,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForList(sql, new MapSqlParameterSource(paramMap), elementType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,paramSource,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new SingleColumnRowMapper<>(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForMap(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramMap, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForMap(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramSource, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#setValues(ps,i)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#executeObject(returnType,Map<String,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "T",
    "signature": "public T executeObject(Class<T> returnType, Map<String, ?> args)",
    "source_code": "\tpublic <T> @Nullable T executeObject(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsAsciiStream(rs,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "InputStream",
    "signature": "public InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as ASCII stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getAsciiStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getAsciiStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getTimestamp(columnLabel,cal)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTimestamp(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#addSession(session,connection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given Session to this resource holder,\n\t * registered for a specific Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void addSession(Session session, @Nullable Connection connection)",
    "source_code": "\tpublic final void addSession(Session session, @Nullable Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Session because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tif (!this.sessions.contains(session)) {\n\t\t\tthis.sessions.add(session);\n\t\t\tif (connection != null) {\n\t\t\t\tDeque<Session> sessions =\n\t\t\t\t\t\tthis.sessionsPerConnection.computeIfAbsent(connection, k -> new ArrayDeque<>());\n\t\t\t\tsessions.add(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tMessage<?> message = doConvert(payload, headers, postProcessor);\n\t\tsend(destinationName, message);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destinationName,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void send(String destinationName, Message<?> message)",
    "source_code": "\tpublic void send(String destinationName, Message<?> message) throws MessagingException {\n\t\tdoSend(destinationName, message);\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#connectTcp(host,port)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "port"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Mono<RSocketRequester>",
    "signature": "public Mono<RSocketRequester> connectTcp(String host, int port)",
    "source_code": "\tpublic Mono<RSocketRequester> connectTcp(String host, int port) {\n\t\treturn connect(TcpClientTransport.create(host, port));\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getSessionId(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "String",
    "signature": "public String getSessionId(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getSessionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SESSION_ID_HEADER);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doExecute(action,enforceNativeSession)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "action",
      "enforceNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "T",
    "signature": "protected T doExecute(HibernateCallback<T> action, boolean enforceNativeSession)",
    "source_code": "\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id,lockMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#saveOrUpdate(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void saveOrUpdate(String entityName, Object entity)",
    "source_code": "\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.test.context.<unknown>#findMergedAnnotation(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied class, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy, and synthesize the result back\n\t * into an annotation of the specified {@code annotationType}.\n\t * <p>In the context of this method, the term \"above\" means within the\n\t * {@linkplain Class#getSuperclass() superclass} hierarchy or within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @see AnnotatedElementUtils#findMergedAnnotation(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "T",
    "signature": "public T findMergedAnnotation(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable T findMergedAnnotation(Class<?> clazz, Class<T> annotationType) {\n\t\treturn findMergedAnnotation(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass);\n\t}"
  },
  "org.springframework.test.context.<unknown>#hasAnnotation(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType} is\n\t * present or meta-present on the supplied {@link Class} according to the\n\t * search algorithm used in {@link #findMergedAnnotation(Class, Class)}.\n\t * <p>If this method returns {@code true}, then {@code findMergedAnnotation(...)}\n\t * will return a non-null value.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return {@code true} if a matching annotation is present\n\t * @since 5.3.3\n\t * @see #findMergedAnnotation(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.withEnclosingClasses(TestContextAnnotationUtils::searchEnclosingClass)\n\t\t\t\t.from(clazz)\n\t\t\t\t.isPresent(annotationType);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeMethod(target,name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method with the given {@code name} on the supplied target\n\t * object with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param target the target object on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "public T invokeMethod(Object target, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Object target, String name, Object... args) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\treturn invokeMethod(target, null, name, args);\n\t}"
  },
  "org.springframework.test.util.<unknown>#parseXmlByteArray(xml,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given XML content to a {@link Document}.\n\t * @param xml the content to parse\n\t * @param encoding optional content encoding, if provided as metadata (for example, in HTTP headers)\n\t * @return the parsed document\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xml",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "Document",
    "signature": "protected Document parseXmlByteArray(byte[] xml, @Nullable String encoding)",
    "source_code": "\tprotected Document parseXmlByteArray(byte[] xml, @Nullable String encoding) throws Exception {\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\tfactory.setNamespaceAware(this.hasNamespaces);\n\t\tDocumentBuilder documentBuilder = factory.newDocumentBuilder();\n\t\tInputSource inputSource = new InputSource(new ByteArrayInputStream(xml));\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\tinputSource.setEncoding(encoding);\n\t\t}\n\t\treturn documentBuilder.parse(inputSource);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic RequestBodySpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#map(source,targetType,configuration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType",
      "configuration"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "T",
    "signature": "public T map(Object source, TypeRef<T> targetType, Configuration configuration)",
    "source_code": "\tpublic <T> @Nullable T map(Object source, TypeRef<T> targetType, Configuration configuration) {\n\t\treturn mapToTargetType(source, ResolvableType.forType(targetType.getType()));\n\t}"
  },
  "org.springframework.util.<unknown>#addResourcePathToPackagePath(clazz,resourceName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "String",
    "signature": "public String addResourcePathToPackagePath(Class<?> clazz, String resourceName)",
    "source_code": "\tpublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n\t\tAssert.notNull(resourceName, \"Resource name must not be null\");\n\t\tif (!resourceName.startsWith(\"/\")) {\n\t\t\treturn classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\n\t\t}\n\t\treturn classPackageAsResourcePath(clazz) + resourceName;\n\t}"
  },
  "org.springframework.util.<unknown>#doesNotContain(textToSearch,substring,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, String message)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, String message) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#doesNotContain(textToSearch,substring,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">\n\t * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\n\t * </pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getMethod(clazz,methodName,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else throws an {@code IllegalStateException}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method (never {@code null})\n\t * @throws IllegalStateException if the method has not been found\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1227
    },
    "return": "Method",
    "signature": "public Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes)",
    "source_code": "\tpublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\ttry {\n\t\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\telse if (candidates.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getMostSpecificMethod(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\n\t * and the target class may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not</i> resolve bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable &mdash; for example, to obtain\n\t * metadata from the original method definition.\n\t * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\n\t * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\n\t * implementation will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1354
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tif (targetClass != null && targetClass != method.getDeclaringClass() &&\n\t\t\t\t(isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\n\t\t\ttry {\n\t\t\t\tif (Modifier.isPublic(method.getModifiers())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn targetClass.getMethod(method.getName(), method.getParameterTypes());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMethod specificMethod =\n\t\t\t\t\t\t\tReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t\t\treturn (specificMethod != null ? specificMethod : method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\t// Security settings are disallowing reflective access; fall back to 'method' below.\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.util.<unknown>#getQualifiedMethodName(method,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1146
    },
    "return": "String",
    "signature": "public String getQualifiedMethodName(Method method, @Nullable Class<?> clazz)",
    "source_code": "\tpublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n\t}"
  },
  "org.springframework.util.<unknown>#getStaticMethod(clazz,methodName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1563
    },
    "return": "Method",
    "signature": "public Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)",
    "source_code": "\tpublic static @Nullable Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\ttry {\n\t\t\tMethod method = clazz.getMethod(methodName, args);\n\t\t\treturn (Modifier.isStatic(method.getModifiers()) ? method : null);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasLength(text,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">\n\t * Assert.hasLength(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @since 5.0\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isVisible(clazz,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader == null) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getClassLoader() == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Visible if same Class can be loaded from given ClassLoader\n\t\treturn isLoadable(clazz, classLoader);\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(array,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Object @Nullable [] array, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Object @Nullable [] array, String message) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(array,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#simpleMatch(pattern,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(@Nullable String pattern, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\n\t\tif (pattern == null || str == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint firstIndex = pattern.indexOf('*');\n\t\tif (firstIndex == -1) {\n\t\t\treturn pattern.equals(str);\n\t\t}\n\n\t\tif (firstIndex == 0) {\n\t\t\tif (pattern.length() == 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tint nextIndex = pattern.indexOf('*', 1);\n\t\t\tif (nextIndex == -1) {\n\t\t\t\treturn str.endsWith(pattern.substring(1));\n\t\t\t}\n\t\t\tString part = pattern.substring(1, nextIndex);\n\t\t\tif (part.isEmpty()) {\n\t\t\t\treturn simpleMatch(pattern.substring(nextIndex), str);\n\t\t\t}\n\t\t\tint partIndex = str.indexOf(part);\n\t\t\twhile (partIndex != -1) {\n\t\t\t\tif (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpartIndex = str.indexOf(part, partIndex + 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (str.length() >= firstIndex &&\n\t\t\t\tpattern.startsWith(str.substring(0, firstIndex)) &&\n\t\t\t\tsimpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\n\t}"
  },
  "org.springframework.util.<unknown>#simpleMatch(patterns,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given patterns, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String is {@code null} or if the\n\t * supplied patterns array is {@code null} or empty.\n\t * @param patterns the patterns to match against\n\t * @param str the String to match\n\t * @return whether the String matches any of the given patterns\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(String @Nullable [] patterns, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(String @Nullable [] patterns, @Nullable String str) {\n\t\tif (patterns != null) {\n\t\t\tfor (String pattern : patterns) {\n\t\t\t\tif (simpleMatch(pattern, str)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#write(data,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void write(byte[] data, int offset, int length)",
    "source_code": "\tpublic void write(byte[] data, int offset, int length) throws IOException {\n\t\tif (offset < 0 || offset + length > data.length || length < 0) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\telse if (this.closed) {\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\t}\n\t\telse {\n\t\t\tif (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n\t\t\t\taddBuffer(length);\n\t\t\t}\n\t\t\tif (this.index + length > this.buffers.getLast().length) {\n\t\t\t\tint pos = offset;\n\t\t\t\tdo {\n\t\t\t\t\tif (this.index == this.buffers.getLast().length) {\n\t\t\t\t\t\taddBuffer(length);\n\t\t\t\t\t}\n\t\t\t\t\tint copyLength = this.buffers.getLast().length - this.index;\n\t\t\t\t\tif (length < copyLength) {\n\t\t\t\t\t\tcopyLength = length;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);\n\t\t\t\t\tpos += copyLength;\n\t\t\t\t\tthis.index += copyLength;\n\t\t\t\t\tlength -= copyLength;\n\t\t\t\t}\n\t\t\t\twhile (length > 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// copy in the sub-array\n\t\t\t\tSystem.arraycopy(data, offset, this.buffers.getLast(), this.index, length);\n\t\t\t\tthis.index += length;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#handle(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void handle(HttpRequest request, ClientHttpResponse response)",
    "source_code": "\tpublic void handle(HttpRequest request, ClientHttpResponse response) throws IOException {\n\t\tthis.errorHandler.handle(request, response);\n\t}"
  },
  "org.springframework.web.client.support.<unknown>#exchangeForEntity(values,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToMono(Function<ClientResponse,responseHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "Mono<V>",
    "signature": "public Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler) {\n\t\t\treturn exchange().flatMap(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.flatMap(value -> releaseIfNotConsumed(response).thenReturn(value))\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriFunction.apply(uriBuilder));\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(path,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.support.<unknown>#getLastModified(request,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#addStatusCode(viewName,statusCode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #setStatusCodes(Properties)} for use with\n\t * Java-based configuration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void addStatusCode(String viewName, int statusCode)",
    "source_code": "\tpublic void addStatusCode(String viewName, int statusCode) {\n\t\tthis.statusCodes.put(viewName, statusCode);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#buildLogMessage(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a log message for the given exception, occurred during processing the given request.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the log message to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "String",
    "signature": "protected String buildLogMessage(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected String buildLogMessage(Exception ex, HttpServletRequest request) {\n\t\treturn \"Resolved [\" + LogFormatUtils.formatValue(ex, -1, true) + \"]\";\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#preHandle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tString newLocale = request.getParameter(getParamName());\n\t\tif (newLocale != null) {\n\t\t\tif (checkHttpMethod(request.getMethod())) {\n\t\t\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\t\t\tif (localeResolver == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"No LocaleResolver found: not in a DispatcherServlet request?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlocaleResolver.setLocale(request, response, parseLocaleValue(newLocale));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (isIgnoreInvalidLocale()) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Ignoring invalid locale value [\" + newLocale + \"]: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Proceed in any case.\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(source,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #encode(String, Charset)} with a String charset.\n\t * @param source the String to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "public String encode(String source, String encoding)",
    "source_code": "\tpublic static String encode(String source, String encoding) {\n\t\treturn encode(source, encoding, HierarchicalUriComponents.Type.URI);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeHost(host,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded host\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "public String encodeHost(String host, Charset charset)",
    "source_code": "\tpublic static String encodeHost(String host, Charset charset) {\n\t\treturn encode(host, charset, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeHost(host,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded host\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String encodeHost(String host, String encoding)",
    "source_code": "\tpublic static String encodeHost(String host, String encoding) {\n\t\treturn encode(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePath(path,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded path\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "String",
    "signature": "public String encodePath(String path, Charset charset)",
    "source_code": "\tpublic static String encodePath(String path, Charset charset) {\n\t\treturn encode(path, charset, HierarchicalUriComponents.Type.PATH);\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParamIfPresent(name,value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\t\tpublic DefaultUriBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\t\tthis.uriComponentsBuilder.queryParamIfPresent(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParams(MultiValueMap<String,params)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "DefaultUriBuilder",
    "signature": "public DefaultUriBuilder replaceQueryParams(MultiValueMap<String, String> params)",
    "source_code": "\t\tpublic DefaultUriBuilder replaceQueryParams(MultiValueMap<String, String> params) {\n\t\t\tthis.uriComponentsBuilder.replaceQueryParams(params);\n\t\t\treturn this;\n\t\t}"
  }
}