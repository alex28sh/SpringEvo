{
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isAutowirable(parameter,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link Parameter} can <em>potentially</em> be\n\t * autowired from an {@link AutowireCapableBeanFactory}.\n\t * <p>Returns {@code true} if the supplied parameter is annotated or\n\t * meta-annotated with {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, or {@link Value @Value}.\n\t * <p>Note that {@link #resolveDependency} may still be able to resolve the\n\t * dependency for the supplied parameter even if this method returns {@code false}.\n\t * @param parameter the parameter whose dependency should be autowired\n\t * (must not be {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @see #resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean isAutowirable(Parameter parameter, int parameterIndex)",
    "source_code": "\tpublic static boolean isAutowirable(Parameter parameter, int parameterIndex) {\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\treturn (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#resolveDependency(parameter,parameterIndex,containingClass,beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the dependency for the supplied {@link Parameter} from the\n\t * supplied {@link AutowireCapableBeanFactory}.\n\t * <p>Provides comprehensive autowiring support for individual method parameters\n\t * on par with Spring's dependency injection facilities for autowired fields and\n\t * methods, including support for {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, and {@link Value @Value} with support for property\n\t * placeholders and SpEL expressions in {@code @Value} declarations.\n\t * <p>The dependency is required unless the parameter is annotated or meta-annotated\n\t * with {@link Autowired @Autowired} with the {@link Autowired#required required}\n\t * flag set to {@code false}.\n\t * <p>If an explicit <em>qualifier</em> is not declared, the name of the parameter\n\t * will be used as the qualifier for resolving ambiguities.\n\t * @param parameter the parameter whose dependency should be resolved (must not be\n\t * {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @param containingClass the concrete class that contains the parameter; this may\n\t * differ from the class that declares the parameter in that it may be a subclass\n\t * thereof, potentially substituting type variables (must not be {@code null})\n\t * @param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve\n\t * the dependency (must not be {@code null})\n\t * @return the resolved object, or {@code null} if none found\n\t * @throws BeansException if dependency resolution failed\n\t * @see #isAutowirable\n\t * @see Autowired#required\n\t * @see SynthesizingMethodParameter#forExecutable(Executable, int)\n\t * @see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex",
      "containingClass",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Object",
    "signature": "public Object resolveDependency(Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)",
    "source_code": "\tpublic static @Nullable Object resolveDependency(\n\t\t\tParameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAssert.notNull(containingClass, \"Containing class must not be null\");\n\t\tAssert.notNull(beanFactory, \"AutowireCapableBeanFactory must not be null\");\n\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\tAutowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class);\n\t\tboolean required = (autowired == null || autowired.required());\n\n\t\tMethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(\n\t\t\t\tparameter.getDeclaringExecutable(), parameterIndex);\n\t\tDependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required);\n\t\tdescriptor.setContainingClass(containingClass);\n\t\treturn beanFactory.resolveDependency(descriptor, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forRequiredMethod(methodName,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is required.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, true, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolve(registeredBean,action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field for the specified registered bean and provide it to the\n\t * given action.\n\t * @param registeredBean the registered bean\n\t * @param action the action to execute with the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action)",
    "source_code": "\tpublic <T> void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(action, \"'action' must not be null\");\n\t\tT resolved = resolve(registeredBean);\n\t\tif (resolved != null) {\n\t\t\taction.accept(resolved);\n\t\t}\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject existing = this.store.putIfAbsent(key, toStoreValue(value));\n\t\treturn toValueWrapper(existing);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#cacheException(exceptionCache,filter,cacheKey,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionCache",
      "filter",
      "cacheKey",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "protected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex)",
    "source_code": "\tprotected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {\n\t\tif (exceptionCache == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (filter.match(ex.getClass())) {\n\t\t\tdoPut(exceptionCache, cacheKey, ex);\n\t\t}\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#get(key,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "T",
    "signature": "public T get(Object key, @Nullable Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn this.targetCache.get(key, type);\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn this.targetCache.retrieve(key, valueLoader);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#forField(fieldName,resourceName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field and resource name.\n\t * @param fieldName the field name\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forField(String fieldName, String resourceName)",
    "source_code": "\tpublic static ResourceElementResolver forField(String fieldName, String resourceName) {\n\t\treturn new ResourceFieldResolver(resourceName, false, fieldName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAllMergedAnnotations(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within\n\t * a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 662
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn findAnnotations(element).stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedAnnotation(element,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within\n\t * a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "A",
    "signature": "public A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedRepeatableAnnotations(element,annotationType,containerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within\n\t * a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#plus(Class, Class) composed} to support\n\t * multiple repeatable annotation types &mdash; for example:\n\t * <pre class=\"code\">\n\t * RepeatableContainers.standardRepeatables()\n\t *     .plus(MyRepeatable1.class, MyContainer1.class)\n\t *     .plus(MyRepeatable2.class, MyContainer2.class);</pre>\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the repeatable annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the repeatable\n\t * annotations; may be {@code null} if the container type should be looked up\n\t * via {@link java.lang.annotation.Repeatable @Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "containerType"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "Set<A>",
    "signature": "public Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn getRepeatableAnnotations(element, annotationType, containerType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMetaAnnotationTypes(element,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Set<String>",
    "signature": "public Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tif (annotation.annotationType().getName().equals(annotationName)) {\n\t\t\t\treturn getMetaAnnotationTypes(element, annotation);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#of(repeatable,container)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RepeatableContainers} instance that searches for repeated\n\t * annotations by taking into account the supplied repeatable and container\n\t * annotation types.\n\t * <p><strong>WARNING</strong>: The {@code RepeatableContainers} instance\n\t * returned by this factory method does <strong>not</strong> respect Java's\n\t * {@link Repeatable @Repeatable} support. Use {@link #standardRepeatables()}\n\t * for standard {@code @Repeatable} support, optionally combined with\n\t * {@link #plus(Class, Class)}.\n\t * <p><strong>WARNING</strong>: The arguments supplied to this method are in\n\t * the reverse order of those supplied to {@link #and(Class, Class)}.\n\t * <p>If the supplied container annotation type is not {@code null}, it must\n\t * declare a {@code value} attribute returning an array of repeatable\n\t * annotations. If the supplied container annotation type is {@code null}, the\n\t * container will be deduced by inspecting the {@code @Repeatable} annotation\n\t * on the {@code repeatable} annotation type.\n\t * @param repeatable the repeatable annotation type\n\t * @param container the container annotation type or {@code null}\n\t * @return a {@code RepeatableContainers} instance that does not support\n\t * {@link Repeatable @Repeatable}\n\t * @throws IllegalArgumentException if the supplied container type is\n\t * {@code null} and the annotation type is not a repeatable annotation\n\t * @throws AnnotationConfigurationException if the supplied container type\n\t * is not a properly configured container for a repeatable annotation\n\t * @deprecated as of Spring Framework 7.0, in favor of {@link #explicitRepeatable(Class, Class)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "repeatable",
      "container"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers of(Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container)",
    "source_code": "\tpublic static RepeatableContainers of(\n\t\t\tClass<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\n\n\t\treturn explicitRepeatable(repeatable, container);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getRequiredProperty(key,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "T",
    "signature": "public T getRequiredProperty(String key, Class<T> targetType)",
    "source_code": "\tpublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key, targetType);\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#addInstance(factoryType,factoryInstances)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class\n\t * @param factoryInstances the implementation instances to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryInstances"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void addInstance(Class<T> factoryType, T... factoryInstances)",
    "source_code": "\tpublic <T> void addInstance(Class<T> factoryType, T... factoryInstances) {\n\t\taddInstance(factoryType.getName(), factoryInstances);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toByte(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a byte using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "byte",
    "signature": "public byte toByte(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static byte toByte(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Byte.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toFloat(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a float using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "float",
    "signature": "public float toFloat(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static float toFloat(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Float.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toInt(typeConverter,typedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to an int using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "int",
    "signature": "public int toInt(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static int toInt(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Integer.class);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(context,rootObject,expectedResultType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1766
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.addAll(key, values);\n\t}"
  },
  "org.springframework.http.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1827
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\trequest.getAttributes().forEach((key, value) -> delegate.getAttributes().put(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tlong contentLength = delegate.getHeaders().getContentLength();\n\t\t\t\t\tif (contentLength > -1 && contentLength != body.length) {\n\t\t\t\t\t\tdelegate.getHeaders().setContentLength(body.length);\n\t\t\t\t\t}\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\t\t\tStreamUtils.copy(body, outputStream);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#read(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\tObjects.checkFromIndexSize(off, len, b.length);\n\t\tif (len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!this.lock.tryLock()) {\n\t\t\tif (this.closed) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthrow new ConcurrentModificationException(\"concurrent access is disallowed\");\n\t\t}\n\n\t\ttry {\n\t\t\tfor (int j = 0; j < len;) {\n\t\t\t\tbyte[] next = getNextOrAwait();\n\n\t\t\t\tif (next == DONE) {\n\t\t\t\t\tcleanAndFinalize();\n\t\t\t\t\tif (this.error == null) {\n\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\treturn j == 0 ? -1 : j;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\t\tthrow Exceptions.propagate(this.error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (next == CLOSED) {\n\t\t\t\t\trequiredSubscriber().cancel();\n\t\t\t\t\tcleanAndFinalize();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tint i = this.position;\n\t\t\t\tfor (; i < next.length && j < len; i++, j++) {\n\t\t\t\t\tb[off + j] = next[i];\n\t\t\t\t}\n\t\t\t\tthis.position = i;\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthis.closed = true;\n\t\t\trequiredSubscriber().cancel();\n\t\t\tcleanAndFinalize();\n\t\t\tthrow Exceptions.propagate(ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.lock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getAnnotation(parameter,annotType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "annotType"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "A",
    "signature": "protected A getAnnotation(MethodParameter parameter, Class<A> annotType)",
    "source_code": "\tprotected abstract <A extends Annotation> @Nullable A getAnnotation(MethodParameter parameter, Class<A> annotType);"
  },
  "org.springframework.http.codec.<unknown>#getEncodeHints(actualType,elementType,mediaType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "Object>",
    "signature": "public Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn (actualType != null ? getHints(actualType) : Hints.none());\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,resolvableType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "resolvableType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, ResolvableType resolvableType, HttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected void writeInternal(Object object, ResolvableType resolvableType, HttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tJsonEncoding encoding = getJsonEncoding(contentType);\n\n\t\tClass<?> clazz = object.getClass();\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, contentType);\n\t\tAssert.state(objectMapper != null, () -> \"No ObjectMapper for \" + clazz.getName());\n\n\t\tOutputStream outputStream = StreamUtils.nonClosing(outputMessage.getBody());\n\t\tClass<?> jsonView = null;\n\t\tFilterProvider filters = null;\n\t\tJavaType javaType = null;\n\n\t\tType type = resolvableType.getType();\n\t\tif (TypeUtils.isAssignable(type, object.getClass())) {\n\t\t\tjavaType = getJavaType(type, null);\n\t\t}\n\t\tif (hints != null) {\n\t\t\tjsonView = (Class<?>) hints.get(JSON_VIEW_HINT);\n\t\t\tfilters = (FilterProvider) hints.get(FILTER_PROVIDER_HINT);\n\t\t}\n\n\t\tObjectWriter objectWriter = (jsonView != null ?\n\t\t\t\tobjectMapper.writerWithView(jsonView) : objectMapper.writer());\n\t\tif (filters != null) {\n\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t}\n\t\tif (javaType != null && (javaType.isContainerType() || javaType.isTypeOrSubTypeOf(Optional.class))) {\n\t\t\tobjectWriter = objectWriter.forType(javaType);\n\t\t}\n\t\tSerializationConfig config = objectWriter.getConfig();\n\t\tif (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &&\n\t\t\t\tconfig.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n\t\t\tobjectWriter = objectWriter.with(this.ssePrettyPrinter);\n\t\t}\n\t\tobjectWriter = customizeWriter(objectWriter, javaType, contentType);\n\n\t\ttry (JsonGenerator generator = objectWriter.createGenerator(outputStream, encoding)) {\n\t\t\twritePrefix(generator, object);\n\t\t\tobjectWriter.writeValue(generator, object);\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t\tcatch (InvalidDefinitionException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Type definition error: \" + ex.getType(), ex);\n\t\t}\n\t\tcatch (JacksonException ex) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not write JSON: \" + ex.getOriginalMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(AnnotationIntrospector,pairingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, for example, via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<@Nullable AnnotationIntrospector, @Nullable AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<@Nullable AnnotationIntrospector, @Nullable AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,Map<String,batchValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "batchValues"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, Map<String, ?>[] batchValues)",
    "source_code": "\tpublic int[] batchUpdate(String sql, Map<String, ?>[] batchValues) {\n\t\treturn batchUpdate(sql, SqlParameterSourceUtils.createBatch(batchValues));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,batchArgs,generatedKeyHolder,keyColumnNames)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString @Nullable [] keyColumnNames)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString @Nullable [] keyColumnNames) {\n\n\t\tif (batchArgs.length == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tSqlParameterSource paramSource = batchArgs[0];\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, paramSource);\n\t\tif (keyColumnNames != null) {\n\t\t\tpscf.setGeneratedKeysColumnNames(keyColumnNames);\n\t\t}\n\t\telse {\n\t\t\tpscf.setReturnGeneratedKeys(true);\n\t\t}\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, null);\n\t\tPreparedStatementCreator psc = pscf.newPreparedStatementCreator(params);\n\t\treturn getJdbcOperations().batchUpdate(psc, new BatchPreparedStatementSetter() {\n\t\t\t@Override\n\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getBatchSize() {\n\t\t\t\treturn batchArgs.length;\n\t\t\t}\n\t\t}, generatedKeyHolder);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getPreparedStatementCreator(sql,paramSource,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Used for the {@code update} variant with generated key handling, and also\n\t * delegated from {@link #getPreparedStatementCreator(String, SqlParameterSource)}.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @param customizer callback for setting further properties on the\n\t * {@link PreparedStatementCreatorFactory} in use, applied before the\n\t * actual {@code newPreparedStatementCreator} call\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @since 5.0.5\n\t * @see #getParsedSql(String)\n\t * @see PreparedStatementCreatorFactory#PreparedStatementCreatorFactory(String, List)\n\t * @see PreparedStatementCreatorFactory#newPreparedStatementCreator(Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sql",
      "paramSource",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,\n\t\t\t@Nullable Consumer<PreparedStatementCreatorFactory> customizer)",
    "source_code": "\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,\n\t\t\t@Nullable Consumer<PreparedStatementCreatorFactory> customizer) {\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, paramSource);\n\t\tif (customizer != null) {\n\t\t\tcustomizer.accept(pscf);\n\t\t}\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, null);\n\t\treturn pscf.newPreparedStatementCreator(params);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,paramSource,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, SqlParameterSource paramSource)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new ColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#update(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "int",
    "signature": "public int update(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic int update(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn update(sql, new MapSqlParameterSource(paramMap));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#update(sql,paramSource,generatedKeyHolder,keyColumnNames)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String @Nullable [] keyColumnNames)",
    "source_code": "\tpublic int update(\n\t\t\tString sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String @Nullable [] keyColumnNames)\n\t\t\tthrows DataAccessException {\n\n\t\tPreparedStatementCreator psc = getPreparedStatementCreator(sql, paramSource, pscf -> {\n\t\t\tif (keyColumnNames != null) {\n\t\t\t\tpscf.setGeneratedKeysColumnNames(keyColumnNames);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpscf.setReturnGeneratedKeys(true);\n\t\t\t}\n\t\t});\n\t\treturn getJdbcOperations().update(psc, generatedKeyHolder);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#execute(params,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Central execution method. All un-named parameter execution goes through this method.\n\t * @param params parameters, similar to JDO query parameters.\n\t * Primitive parameters must be represented by their Object wrapper type.\n\t * The ordering of parameters is significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "List<T>",
    "signature": "public List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateParameters(params);\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(params), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#executeByNamedParam(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "List<T>",
    "signature": "public List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap)",
    "source_code": "\tpublic List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap) throws DataAccessException {\n\t\treturn executeByNamedParam(paramMap, null);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#stream(Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to stream without parameters.\n\t * @param context the contextual information for object creation\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> stream(Map<?, ?> context)",
    "source_code": "\tpublic Stream<T> stream(Map<?, ?> context) throws DataAccessException {\n\t\treturn stream(null, context);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#stream(params,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Central stream method. All un-named parameter execution goes through this method.\n\t * @param params parameters, similar to JDO query parameters.\n\t * Primitive parameters must be represented by their Object wrapper type.\n\t * The ordering of parameters is significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a result Stream of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> stream(Object @Nullable [] params, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic Stream<T> stream(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateParameters(params);\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().queryForStream(newPreparedStatementCreator(params), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#streamByNamedParam(Map<String,paramMap,Map<?,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Central stream method. All named parameter execution goes through this method.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant since they are supplied in a\n\t * SqlParameterMap which is an implementation of the Map interface.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a Stream of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> streamByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic Stream<T> streamByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn queryByNamedParam(paramMap, context, getJdbcTemplate()::queryForStream);\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBinaryStream(pos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "InputStream",
    "signature": "public InputStream getBinaryStream(long pos, long length)",
    "source_code": "\tpublic InputStream getBinaryStream(long pos, long length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass) throws MessagingException {\n\n\t\treturn convertSendAndReceive(destinationName, request, headers, targetClass, null);\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\ttry {\n\t\t\tif (isSingleton(name)) {\n\t\t\t\treturn doGetSingleton(name, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lookup(name, requiredType);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException ex) {\n\t\t\tthrow new NoSuchBeanDefinitionException(name, \"not found in JNDI environment\");\n\t\t}\n\t\tcatch (TypeMismatchNamingException ex) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, ex.getRequiredType(), ex.getActualType());\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"JNDI environment\", name, \"JNDI lookup failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destination,request,Map<String,headers,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(\n\t\t\tD destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass) {\n\n\t\treturn convertSendAndReceive(destination, request, headers, targetClass, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(request,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(getRequiredDefaultDestination(), request, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#receiveAndConvert(destinationName,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "T",
    "signature": "public T receiveAndConvert(String destinationName, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) {\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.receiveAndConvert(destination, targetClass);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity,firstResult,maxResults)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(exampleEntity, \"Example entity must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria executableCriteria = (entityName != null ?\n\t\t\t\t\tsession.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass()));\n\t\t\texecutableCriteria.add(Example.create(exampleEntity));\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#merge(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entity,replicationMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void replicate(Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNodeList(content,encoding,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link NodeList},\n\t * and assert it with the given {@code Matcher<NodeList>}.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)",
    "source_code": "\tpublic void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)\n\t\t\tthrows Exception {\n\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\tNodeList nodeList = evaluateXpath(document, XPathConstants.NODESET, NodeList.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + getXpathExpression(), nodeList, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateXpath(content,encoding,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the XPath and return the resulting value.\n\t * @param content the content to evaluate against\n\t * @param encoding the encoding to use (optionally)\n\t * @param targetClass the target class, one of Number, String, Boolean,\n\t * org.w3c.Node, or NodeList\n\t * @throws Exception if content parsing or expression evaluation fails\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "T",
    "signature": "public T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass) throws Exception {\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\treturn evaluateXpath(document, toQName(targetClass), targetClass);\n\t}"
  },
  "org.springframework.test.util.<unknown>#getField(targetObject,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object from which to get the field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @see #getField(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object getField(Object targetObject, String name)",
    "source_code": "\tpublic static @Nullable Object getField(Object targetObject, String name) {\n\t\treturn getField(targetObject, null, name);\n\t}"
  },
  "org.springframework.test.util.<unknown>#getField(targetObject,targetClass,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}/{@code targetClass}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be retrieved from the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to get {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * @param targetObject the target object from which to get the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class from which to get the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t * @see #getField(Class, String)\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#getField(Field, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name)",
    "source_code": "\tpublic static @Nullable Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name) {\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\"Either targetObject or targetClass for the field must be specified\");\n\n\t\tif (targetObject != null && springAopPresent) {\n\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t}\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = targetObject.getClass();\n\t\t}\n\n\t\tField field = ReflectionUtils.findField(targetClass, name);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Could not find field '%s' on %s or target class [%s]\",\n\t\t\t\t\tname, safeToString(targetObject), targetClass));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Getting field '%s' from %s or target class [%s]\", name,\n\t\t\t\t\tsafeToString(targetObject), targetClass));\n\t\t}\n\t\tReflectionUtils.makeAccessible(field);\n\t\treturn ReflectionUtils.getField(field, targetObject);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeMethod(target,name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method with the given {@code name} on the supplied target\n\t * object with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param target the target object on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "public T invokeMethod(Object target, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Object target, String name, Object... args) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\treturn invokeMethod(target, null, name, args);\n\t}"
  },
  "org.springframework.util.<unknown>#doesNotContain(textToSearch,substring,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">\n\t * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\n\t * </pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getMethodIfAvailable(clazz,methodName,paramTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method, or {@code null} if not found\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1266
    },
    "return": "Method",
    "signature": "public Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes)",
    "source_code": "\tpublic static @Nullable Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\treturn getMethodOrNull(clazz, methodName, paramTypes);\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getStaticMethod(clazz,methodName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1564
    },
    "return": "Method",
    "signature": "public Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)",
    "source_code": "\tpublic static @Nullable Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\ttry {\n\t\t\tMethod method = clazz.getMethod(methodName, args);\n\t\t\treturn (Modifier.isStatic(method.getModifiers()) ? method : null);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasLength(text,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, String message)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasLength(text,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">\n\t * Assert.hasLength(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @since 5.0\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasText(text,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">\n\t * Assert.hasText(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @since 5.0\n\t * @see StringUtils#hasText\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "public void hasText(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasText(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#noNullElements(array,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#noNullElements(collection,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "public void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(Map<?,map,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\n\t * </pre>\n\t * @param map the map to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(array,messageSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#simpleMatch(pattern,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(@Nullable String pattern, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\n\t\treturn simpleMatch(pattern, str, false);\n\t}"
  },
  "org.springframework.util.<unknown>#split(toSplit,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1085
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.validation.<unknown>#reject(errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#rejectValue(field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.client.support.<unknown>#exchangeForBody(values,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "T",
    "signature": "public T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> @Nullable T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn this.restTemplate.exchange(newRequest(values), bodyType).getBody();\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#registerDeferredResultInterceptor(key,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link DeferredResultProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor)",
    "source_code": "\tpublic void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"DeferredResultProcessingInterceptor is required\");\n\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthentication(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication(String username, String password)",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getDepth(exceptionMapping,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the depth to the superclass matching.\n\t * <p>0 means ex matches exactly. Returns -1 if there's no match.\n\t * Otherwise, returns depth. Lowest depth wins.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionMapping",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "int",
    "signature": "protected int getDepth(String exceptionMapping, Exception ex)",
    "source_code": "\tprotected int getDepth(String exceptionMapping, Exception ex) {\n\t\treturn getDepth(exceptionMapping, ex.getClass(), 0);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#logException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Log the given exception at warn level, provided that warn logging has been\n\t * activated through the {@link #setWarnLogCategory \"warnLogCategory\"} property.\n\t * <p>Calls {@link #buildLogMessage} in order to determine the concrete message to log.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @see #setWarnLogCategory\n\t * @see #buildLogMessage\n\t * @see org.apache.commons.logging.Log#warn(Object, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(buildLogMessage(ex, request));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#getLastModified(request,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putIfAbsent(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> putIfAbsent(String headerName, List<String> headerValues) {\n\t\treturn this.headers.putIfAbsent(headerName, headerValues);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeHost(host,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded host\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String encodeHost(String host, String encoding)",
    "source_code": "\tpublic static String encodeHost(String host, String encoding) {\n\t\treturn encode(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePath(path,encoding)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String encodePath(String path, String encoding)",
    "source_code": "\tpublic static String encodePath(String path, String encoding) {\n\t\treturn encode(path, encoding, HierarchicalUriComponents.Type.PATH);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeUriVariables(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "String>",
    "signature": "public String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\tpublic static Map<String, String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tMap<String, String> result = CollectionUtils.newLinkedHashMap(uriVariables.size());\n\t\turiVariables.forEach((key, value) -> {\n\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\tresult.put(key, encode(stringValue, StandardCharsets.UTF_8));\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeUserInfo(userInfo,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded user info\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String encodeUserInfo(String userInfo, Charset charset)",
    "source_code": "\tpublic static String encodeUserInfo(String userInfo, Charset charset) {\n\t\treturn encode(userInfo, charset, HierarchicalUriComponents.Type.USER_INFO);\n\t}"
  }
}