{
  "org.springframework.aop.framework.<unknown>#addAdvisor(pos,advisor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advisor"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void addAdvisor(int pos, Advisor advisor)",
    "source_code": "\tpublic void addAdvisor(int pos, Advisor advisor) throws AopConfigException {\n\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t}\n\t\taddAdvisorInternal(pos, advisor);\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsProxiedInterfaces(a,b)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the proxied interfaces behind the given AdvisedSupport objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "boolean",
    "signature": "public boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces());\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getCacheKey(beanClass,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a cache key for the given bean class and bean name.\n\t * <p>Note: As of 4.2.3, this implementation does not return a concatenated\n\t * class/name String anymore but rather the most efficient cache key possible:\n\t * a plain bean name, prepended with {@link BeanFactory#FACTORY_BEAN_PREFIX}\n\t * in case of a {@code FactoryBean}; or if no bean name specified, then the\n\t * given bean {@code Class} as-is.\n\t * @param beanClass the bean class\n\t * @param beanName the bean name\n\t * @return the cache key for the given class and name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Class<?> beanClass, @Nullable String beanName)",
    "source_code": "\tprotected Object getCacheKey(Class<?> beanClass, @Nullable String beanName) {\n\t\tif (StringUtils.hasLength(beanName)) {\n\t\t\treturn (FactoryBean.class.isAssignableFrom(beanClass) ?\n\t\t\t\t\tBeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);\n\t\t}\n\t\telse {\n\t\t\treturn beanClass;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(cf1,cf2)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match all classes that <i>either</i> (or both) of the given ClassFilters matches.\n\t * @param cf1 the first ClassFilter\n\t * @param cf2 the second ClassFilter\n\t * @return a distinct ClassFilter that matches all classes that either\n\t * of the given ClassFilter matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf1",
      "cf2"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter union(ClassFilter cf1, ClassFilter cf2)",
    "source_code": "\tpublic static ClassFilter union(ClassFilter cf1, ClassFilter cf2) {\n\t\tAssert.notNull(cf1, \"First ClassFilter must not be null\");\n\t\tAssert.notNull(cf2, \"Second ClassFilter must not be null\");\n\t\treturn new UnionClassFilter(new ClassFilter[] {cf1, cf2});\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#toInvokeCodeBlock(argumentCodeGenerator,targetClassName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentCodeGenerator",
      "targetClassName"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator,\n\t\t\t@Nullable ClassName targetClassName)",
    "source_code": "\tpublic CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator,\n\t\t\t@Nullable ClassName targetClassName) {\n\t\tString methodName = this.method.name;\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tif (isStatic()) {\n\t\t\tAssert.state(this.declaringClass != null, \"static method reference must define a declaring class\");\n\t\t\tif (isSameDeclaringClass(targetClassName)) {\n\t\t\t\tcode.add(\"$L\", methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode.add(\"$T.$L\", this.declaringClass, methodName);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!isSameDeclaringClass(targetClassName)) {\n\t\t\t\tcode.add(instantiateDeclaringClass(this.declaringClass));\n\t\t\t}\n\t\t\tcode.add(\"$L\", methodName);\n\t\t}\n\t\tcode.add(\"(\");\n\t\taddArguments(code, argumentCodeGenerator);\n\t\tcode.add(\")\");\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.<unknown>#add(propertyName,propertyValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a PropertyValue object, replacing any existing one for the\n\t * corresponding property or getting merged with it (if applicable).\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue)",
    "source_code": "\tpublic MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfType(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 954
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"Autowiring\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Autowiring for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generateMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply the autowiring.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(generatedClass.getName(),\n\t\t\t\t\t\tgenerationContext.getRuntimeHints()));\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generateMethod.toMethodReference());\n\n\t\t\tif (this.candidateResolver != null) {\n\t\t\t\tregisterHints(generationContext.getRuntimeHints());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addGenericArgumentValue(value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a generic argument value to be matched by type.\n\t * <p>Note: A single generic argument value will just be used once,\n\t * rather than matched multiple times.\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addGenericArgumentValue(Object value, String type)",
    "source_code": "\tpublic void addGenericArgumentValue(Object value, String type) {\n\t\tthis.genericArgumentValues.add(new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#hasApplicableProcessors(bean,postProcessors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean has destruction-aware post-processors applying to it.\n\t * @param bean the bean instance\n\t * @param postProcessors the post-processor candidates\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "boolean",
    "signature": "public boolean hasApplicableProcessors(Object bean, List<DestructionAwareBeanPostProcessor> postProcessors)",
    "source_code": "\tpublic static boolean hasApplicableProcessors(Object bean, List<DestructionAwareBeanPostProcessor> postProcessors) {\n\t\tif (!CollectionUtils.isEmpty(postProcessors)) {\n\t\t\tfor (DestructionAwareBeanPostProcessor processor : postProcessors) {\n\t\t\t\tif (processor.requiresDestruction(bean)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 996
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\tif (beanDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\ttry {\n\t\t\t\tabd.validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n\t\tif (existingDefinition != null) {\n\t\t\tif (!isBeanDefinitionOverridable(beanName)) {\n\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\telse if (existingDefinition.getRole() < beanDefinition.getRole()) {\n\t\t\t\t// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Overriding user-defined bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a framework-generated bean definition: replacing [\" +\n\t\t\t\t\t\t\texistingDefinition + \"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!beanDefinition.equals(existingDefinition)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tif (isAlias(beanName)) {\n\t\t\t\tString aliasedName = canonicalName(beanName);\n\t\t\t\tif (!isBeanDefinitionOverridable(aliasedName)) {\n\t\t\t\t\tif (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(\n\t\t\t\t\t\t\t\tbeanName, beanDefinition, getBeanDefinition(aliasedName));\n\t\t\t\t\t}\n\t\t\t\t\telse {  // alias pointing to non-existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Cannot register bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\t\"' since there is already an alias for bean '\" + aliasedName + \"' bound.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tremoveAlias(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\n\t\tif (existingDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\telse if (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorate(node,definition,parserContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tif (node instanceof Attr attr) {\n\t\t\tString propertyName = parserContext.getDelegate().getLocalName(attr);\n\t\t\tString propertyValue = attr.getValue();\n\t\t\tMutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();\n\t\t\tif (pvs.contains(propertyName)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Property '\" + propertyName + \"' is already defined using \" +\n\t\t\t\t\t\t\"both <property> and inline syntax. Only one approach may be used per property.\", attr);\n\t\t\t}\n\t\t\tif (propertyName.endsWith(REF_SUFFIX)) {\n\t\t\t\tpropertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);\n\t\t\t}\n\t\t}\n\t\treturn definition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionAttributes(ele,beanName,containingBean,bd)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(clazz,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "protected void parse(Class<?> clazz, String beanName)",
    "source_code": "\tprotected final void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessAfterInstantiation(bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "boolean",
    "signature": "public boolean postProcessAfterInstantiation(Object bean, String beanName)",
    "source_code": "\tpublic boolean postProcessAfterInstantiation(Object bean, String beanName) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerAnnotationConfigProcessors(registry,source)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Set<BeanDefinitionHolder>",
    "signature": "public Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)",
    "source_code": "\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n\t\tif (beanFactory != null) {\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\tbeanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif ((jakartaAnnotationsPresent || jsr250Present) &&\n\t\t\t\t!registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n\t}"
  },
  "org.springframework.context.support.<unknown>#getDefaultMessage(resolvable,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a default message for the given {@code MessageSourceResolvable}.\n\t * <p>This implementation fully renders the default message if available,\n\t * or just returns the plain default message {@code String} if the primary\n\t * message code is being used as a default message.\n\t * @param resolvable the value object to resolve a default message for\n\t * @param locale the current locale\n\t * @return the default message, or {@code null} if none\n\t * @since 4.3.6\n\t * @see #renderDefaultMessage(String, Object[], Locale)\n\t * @see #getDefaultMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\tString defaultMessage = resolvable.getDefaultMessage();\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (defaultMessage != null) {\n\t\t\tif (resolvable instanceof DefaultMessageSourceResolvable defaultMessageSourceResolvable &&\n\t\t\t\t\t!defaultMessageSourceResolvable.shouldRenderDefaultMessage()) {\n\t\t\t\t// Given default message does not contain any argument placeholders\n\t\t\t\t// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {\n\t\t\t\t// Never format a code-as-default-message, even with alwaysUseMessageFormat=true\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\treturn renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);\n\t\t}\n\t\treturn (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link Class}, traversing its interfaces, annotations, and\n\t * superclasses if the annotation is not <em>directly present</em> on\n\t * the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\n\t * as meta-annotations and annotations on interfaces</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return it if found.\n\t * <li>Recursively search through all annotations that the given class declares.\n\t * <li>Recursively search through all interfaces that the given class declares.\n\t * <li>Recursively search through the superclass hierarchy of the given class.\n\t * </ol>\n\t * <p>Note: in this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current interface,\n\t * annotation, or superclass as the class to look for annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "A",
    "signature": "public A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\tA annotation = clazz.getDeclaredAnnotation(annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t\t// For backwards compatibility, perform a superclass search with plain annotations\n\t\t\t// even if not marked as @Inherited: e.g. a findAnnotation search for @Deprecated\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass == null || superclass == Object.class) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn findAnnotation(superclass, annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotatedElement,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\n\t * <em>meta-present</em> on the {@code AnnotatedElement}.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(AnnotatedElement, Class)} instead.\n\t * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "A",
    "signature": "public A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\n\n\t\treturn getAnnotationAttributes(annotatedElement, annotation, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationName the fully-qualified name of the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, String annotationName)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\n\t\tif (annotationName.startsWith(\"java.\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encodeValue(byteBuf,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuf",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\n\t\t\treturn nettyDataBufferFactory.wrap(byteBuf);\n\t\t}\n\t\tbyte[] bytes = new byte[byteBuf.readableBytes()];\n\t\tbyteBuf.readBytes(bytes);\n\t\tbyteBuf.release();\n\t\treturn bufferFactory.wrap(bytes);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#find(sourceType,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Find a {@link GenericConverter} given a source and target type.\n\t\t * <p>This method will attempt to match all possible converters by working\n\t\t * through the class and interface hierarchy of the types.\n\t\t * @param sourceType the source type\n\t\t * @param targetType the target type\n\t\t * @return a matching {@link GenericConverter}, or {@code null} if none found\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Search the full type hierarchy\n\t\t\tList<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());\n\t\t\tList<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());\n\t\t\tfor (Class<?> sourceCandidate : sourceCandidates) {\n\t\t\t\tfor (Class<?> targetCandidate : targetCandidates) {\n\t\t\t\t\tConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);\n\t\t\t\t\tGenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);\n\t\t\t\t\tif (converter != null) {\n\t\t\t\t\t\treturn converter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.dao.support.<unknown>#translateIfNecessary(rawException,pet)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a translated exception if this is appropriate,\n\t * otherwise return the given exception as-is.\n\t * @param rawException an exception that we may wish to translate\n\t * @param pet the PersistenceExceptionTranslator to use to perform the translation\n\t * @return a translated persistence exception if translation is possible,\n\t * or the raw exception if it is not\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawException",
      "pet"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "RuntimeException",
    "signature": "public RuntimeException translateIfNecessary(RuntimeException rawException, PersistenceExceptionTranslator pet)",
    "source_code": "\tpublic static RuntimeException translateIfNecessary(\n\t\t\tRuntimeException rawException, PersistenceExceptionTranslator pet) {\n\n\t\tAssert.notNull(pet, \"PersistenceExceptionTranslator must not be null\");\n\t\tDataAccessException dae = pet.translateExceptionIfPossible(rawException);\n\t\treturn (dae != null ? dae : rawException);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canRead(context,target,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 667
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}"
  },
  "org.springframework.http.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1734
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tthis.headers.addAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#setAll(Map<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1752
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.http.client.<unknown>#createHttpUriRequest(httpMethod,uri)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Commons HttpMethodBase object for the given HTTP method and URI specification.\n\t * @param httpMethod the HTTP method\n\t * @param uri the URI\n\t * @return the Commons HttpMethodBase object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpMethod",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "ClassicHttpRequest",
    "signature": "protected ClassicHttpRequest createHttpUriRequest(HttpMethod httpMethod, URI uri)",
    "source_code": "\tprotected ClassicHttpRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {\n\t\tif (HttpMethod.GET.equals(httpMethod)) {\n\t\t\treturn new HttpGet(uri);\n\t\t}\n\t\telse if (HttpMethod.HEAD.equals(httpMethod)) {\n\t\t\treturn new HttpHead(uri);\n\t\t}\n\t\telse if (HttpMethod.POST.equals(httpMethod)) {\n\t\t\treturn new HttpPost(uri);\n\t\t}\n\t\telse if (HttpMethod.PUT.equals(httpMethod)) {\n\t\t\treturn new HttpPut(uri);\n\t\t}\n\t\telse if (HttpMethod.PATCH.equals(httpMethod)) {\n\t\t\treturn new HttpPatch(uri);\n\t\t}\n\t\telse if (HttpMethod.DELETE.equals(httpMethod)) {\n\t\t\treturn new HttpDelete(uri);\n\t\t}\n\t\telse if (HttpMethod.OPTIONS.equals(httpMethod)) {\n\t\t\treturn new HttpOptions(uri);\n\t\t}\n\t\telse if (HttpMethod.TRACE.equals(httpMethod)) {\n\t\t\treturn new HttpTrace(uri);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid HTTP method: \" + httpMethod);\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,body)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\tif (!headers.isEmpty()) {\n\t\t\tthis.request.headers(httpFields -> {\n\t\t\t\theaders.forEach((headerName, headerValues) -> {\n\t\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\t\thttpFields.add(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tString contentType = null;\n\t\tif (headers.getContentType() != null) {\n\t\t\tcontentType = headers.getContentType().toString();\n\t\t}\n\t\ttry {\n\t\t\tInputStreamResponseListener responseListener = new InputStreamResponseListener();\n\t\t\tif (body != null) {\n\t\t\t\tOutputStreamRequestContent requestContent = new OutputStreamRequestContent(contentType);\n\t\t\t\tthis.request.body(requestContent)\n\t\t\t\t\t\t.send(responseListener);\n\t\t\t\ttry (OutputStream outputStream = requestContent.getOutputStream()) {\n\t\t\t\t\tbody.writeTo(StreamUtils.nonClosing(outputStream));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.request.send(responseListener);\n\t\t\t}\n\t\t\tResponse response = responseListener.get(this.readTimeout, TimeUnit.MILLISECONDS);\n\t\t\treturn new JettyClientHttpResponse(response, responseListener.getInputStream());\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\tthrow new IOException(\"Request was interrupted: \" + ex.getMessage(), ex);\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\tif (cause instanceof RuntimeException rtEx) {\n\t\t\t\tthrow rtEx;\n\t\t\t}\n\t\t\telse if (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(cause.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (TimeoutException ex) {\n\t\t\tthrow new IOException(\"Request timed out: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#setHttpContextFactory(BiFunction<HttpMethod,URI,httpContextFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a factory to pre-create the {@link HttpContext} for each request.\n\t * <p>This may be useful for example in mutual TLS authentication where a\n\t * different {@code RestTemplate} for each client certificate such that\n\t * all calls made through a given {@code RestTemplate} instance as associated\n\t * for the same client identity. {@link HttpClientContext#setUserToken(Object)}\n\t * can be used to specify a fixed user token for all requests.\n\t * @param httpContextFactory the context factory to use\n\t * @since 5.2.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<HttpMethod",
      "URI",
      "httpContextFactory"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory)",
    "source_code": "\tpublic void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory) {\n\t\tthis.httpContextFactory = httpContextFactory;\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,elementType,mediaType,message,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\treturn Mono.from(inputStream).flatMap(resource ->\n\t\t\t\twriteResource(resource, elementType, mediaType, message, hints));\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 5.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tlogger.debug(msg, cause);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#registerWithDefaultConfig(codec,configConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "configConsumer"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializersByType(Map<Class<?>,deserializers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers for the given types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#handleWarnings(stmt,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle warnings before propagating a primary {@code SQLException}\n\t * from executing the given statement.\n\t * <p>Calls regular {@link #handleWarnings(Statement)} but catches\n\t * {@link SQLWarningException} in order to chain the {@link SQLWarning}\n\t * into the primary exception instead.\n\t * @param stmt the current JDBC statement\n\t * @param ex the primary exception after failed statement execution\n\t * @since 5.3.29\n\t * @see #handleWarnings(Statement)\n\t * @see SQLException#setNextException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "stmt",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1514
    },
    "return": "void",
    "signature": "protected void handleWarnings(Statement stmt, SQLException ex)",
    "source_code": "\tprotected void handleWarnings(Statement stmt, SQLException ex) {\n\t\ttry {\n\t\t\thandleWarnings(stmt);\n\t\t}\n\t\tcatch (SQLWarningException nonIgnoredWarning) {\n\t\t\tex.setNextException(nonIgnoredWarning.getSQLWarning());\n\t\t}\n\t\tcatch (SQLException warningsEx) {\n\t\t\tlogger.debug(\"Failed to retrieve warnings\", warningsEx);\n\t\t}\n\t\tcatch (Throwable warningsEx) {\n\t\t\tlogger.debug(\"Failed to process warnings\", warningsEx);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createReturnResultSetParameter(parameterName,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a ReturnResultSetParameter/SqlOutParameter depending on the support provided\n\t * by the JDBC driver used for the database in use.\n\t * @param parameterName the name of the parameter (also used as the name of the List returned in the output)\n\t * @param rowMapper a RowMapper implementation used to map the data returned in the result set\n\t * @return the appropriate SqlParameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (provider.isReturnResultSetSupported()) {\n\t\t\treturn new SqlReturnResultSet(parameterName, rowMapper);\n\t\t}\n\t\telse {\n\t\t\tif (provider.isRefCursorSupported()) {\n\t\t\t\treturn new SqlOutParameter(parameterName, provider.getRefCursorSqlType(), rowMapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Return of a ResultSet from a stored procedure is not supported\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createConnection(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\treturn obtainTargetConnectionFactory().createConnection(username, password);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(action,startConnection)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * JMS Session. Generalized version of {@code execute(SessionCallback)},\n\t * allowing the JMS Connection to be started on the fly.\n\t * <p>Use {@code execute(SessionCallback)} for the general case.\n\t * Starting the JMS Connection is just necessary for receiving messages,\n\t * which is preferably achieved through the {@code receive} methods.\n\t * @param action callback object that exposes the Session\n\t * @param startConnection whether to start the Connection\n\t * @return the result object from working with the Session\n\t * @throws JmsException if there is any problem\n\t * @see #execute(SessionCallback)\n\t * @see #receive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "T",
    "signature": "public T execute(SessionCallback<T> action, boolean startConnection)",
    "source_code": "\tpublic <T> T execute(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, startConnection);\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tconToClose.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + sessionToUse);\n\t\t\t}\n\t\t\tif (micrometerCorePresent && this.observationRegistry != null) {\n\t\t\t\tsessionToUse = MicrometerInstrumentation.instrumentSession(sessionToUse, this.observationRegistry);\n\t\t\t}\n\t\t\treturn action.doInJms(sessionToUse);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadata(metadata,mimeType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec metadata(Object metadata, MimeType mimeType)",
    "source_code": "\t\tpublic RequestSpec metadata(Object metadata, MimeType mimeType) {\n\t\t\tthis.metadataEncoder.metadata(metadata, mimeType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.simp.<unknown>#compareTo(other,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "int",
    "signature": "public int compareTo(SimpMessageMappingInfo other, Message<?> message)",
    "source_code": "\tpublic int compareTo(SimpMessageMappingInfo other, Message<?> message) {\n\t\treturn this.delegate.compareTo(other.delegate, message);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#findSubscriptionsInternal(destination,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "String>",
    "signature": "protected String> findSubscriptionsInternal(String destination, Message<?> message)",
    "source_code": "\tprotected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n\t\tMultiValueMap<String, String> allMatches = this.destinationCache.getSubscriptions(destination);\n\t\tif (!this.selectorHeaderInUse) {\n\t\t\treturn allMatches;\n\t\t}\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n\t\tallMatches.forEach((sessionId, subscriptionIds) -> {\n\t\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\t\tif (info != null) {\n\t\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\t\tSubscription subscription = info.getSubscription(subscriptionId);\n\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelector(), message)) {\n\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#send(message,timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean send(Message<?> message, long timeout) {\n\t\tthis.messages.add(message);\n\t\ttrySend();\n\t\treturn true;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doResume(transaction,suspendedResources)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tSuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;\n\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\tobtainEntityManagerFactory(), resourcesHolder.getEntityManagerHolder());\n\t\tif (getDataSource() != null && resourcesHolder.getConnectionHolder() != null) {\n\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), resourcesHolder.getConnectionHolder());\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findPersistenceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of persistence dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliasesByType(Map<String,aliasesByType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the <em>aliases by type</em> map, consisting of string aliases mapped to classes.\n\t * <p>Any class that is assignable to this type will be aliased to the same name.\n\t * Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#aliasType(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliasesByType"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void setAliasesByType(Map<String, ?> aliasesByType)",
    "source_code": "\tpublic void setAliasesByType(Map<String, ?> aliasesByType) {\n\t\tthis.aliasesByType = aliasesByType;\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#translateException(task,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given R2DBC commit/rollback exception to a common Spring exception to propagate\n\t * from the {@link #commit}/{@link #rollback} call.\n\t * @param task the task description (commit or rollback).\n\t * @param ex the SQLException thrown from commit/rollback.\n\t * @return the translated exception to emit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, R2dbcException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, R2dbcException ex) {\n\t\treturn ConnectionFactoryUtils.convertR2dbcException(task, null, ex);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnection(Function<Connection,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> inConnection(Function<Connection, Mono<T>> action)",
    "source_code": "\tpublic <T> Mono<T> inConnection(Function<Connection, Mono<T>> action) {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Mono.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Mono.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnection\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"execute\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(Readable,mappingFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Readable",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(Function<? super Readable, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(Function<? super Readable, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#afterExecute(task,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An after-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param task the task that has been executed\n\t * @param ex the exception thrown during execution, if any\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#afterExecute(Runnable, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, @Nullable Throwable ex)",
    "source_code": "\tprotected void afterExecute(Runnable task, @Nullable Throwable ex) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.afterExecute();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertiesFilesToEnvironment(environment,resourceLoader,locations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations) {\n\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertySourcesToEnvironment(environment, resourceLoader,\n\t\t\t\tList.of(new PropertySourceDescriptor(locations)));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#dirtyContext(testContext,hierarchyMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Mark the {@linkplain ApplicationContext application context} of the supplied\n\t * {@linkplain TestContext test context} as\n\t * {@linkplain TestContext#markApplicationContextDirty(DirtiesContext.HierarchyMode) dirty}\n\t * and set {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE\n\t * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.\n\t * @param testContext the test context whose application context should\n\t * be marked as dirty\n\t * @param hierarchyMode the context cache clearing mode to be applied if the\n\t * context is part of a hierarchy; may be {@code null}\n\t * @since 3.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tprotected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode) {\n\t\ttestContext.markApplicationContextDirty(hierarchyMode);\n\t\ttestContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#resolveContextLoader(testClass,configAttributesList)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the\n\t * supplied list of {@link ContextConfigurationAttributes} and then instantiate\n\t * and return that {@code ContextLoader}.\n\t * <p>If the user has not explicitly declared which loader to use, the value\n\t * returned from {@link #getDefaultContextLoaderClass} will be used as the\n\t * default context loader class. For details on the class resolution process,\n\t * see {@link #resolveExplicitContextLoaderClass} and\n\t * {@link #getDefaultContextLoaderClass}.\n\t * @param testClass the test class for which the {@code ContextLoader} should be\n\t * resolved; must not be {@code null}\n\t * @param configAttributesList the list of configuration attributes to process; must\n\t * not be {@code null}; must be ordered <em>bottom-up</em>\n\t * (i.e., as if we were traversing up the class hierarchy and enclosing class hierarchy)\n\t * @return the resolved {@code ContextLoader} for the supplied {@code testClass}\n\t * (never {@code null})\n\t * @throws IllegalStateException if {@link #getDefaultContextLoaderClass(Class)}\n\t * returns {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testClass",
      "configAttributesList"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "ContextLoader",
    "signature": "protected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList)",
    "source_code": "\tprotected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList) {\n\n\t\tAssert.notNull(testClass, \"Class must not be null\");\n\t\tAssert.notNull(configAttributesList, \"ContextConfigurationAttributes list must not be null\");\n\n\t\tClass<? extends ContextLoader> contextLoaderClass = resolveExplicitContextLoaderClass(configAttributesList);\n\t\tif (contextLoaderClass == null) {\n\t\t\tcontextLoaderClass = getDefaultContextLoaderClass(testClass);\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Using ContextLoader class [%s] for test class [%s]\",\n\t\t\t\t\tcontextLoaderClass.getName(), testClass.getName()));\n\t\t}\n\t\treturn BeanUtils.instantiateClass(contextLoaderClass, ContextLoader.class);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(method,attr)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * @param method the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Method method, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Method method, TransactionAttribute attr) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tAssert.notNull(attr, \"TransactionAttribute must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + method + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.transactionAttributeMap.put(method, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\"\n\t * matches, as well as direct equality.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "public void addAll(K key, List<? extends V> values)",
    "source_code": "\tpublic void addAll(K key, List<? extends V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void addIfAbsent(K key, @Nullable V value)",
    "source_code": "\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#calculateShift(minimumValue,maximumValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate a shift value that can be used to create a power-of-two value between\n\t * the specified maximum and minimum values.\n\t * @param minimumValue the minimum value\n\t * @param maximumValue the maximum value\n\t * @return the calculated shift (use {@code 1 << shift} to obtain a value)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "minimumValue",
      "maximumValue"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "int",
    "signature": "protected int calculateShift(int minimumValue, int maximumValue)",
    "source_code": "\tprotected static int calculateShift(int minimumValue, int maximumValue) {\n\t\tint shift = 0;\n\t\tint value = 1;\n\t\twhile (value < minimumValue && value < maximumValue) {\n\t\t\tvalue <<= 1;\n\t\t\tshift++;\n\t\t}\n\t\treturn shift;\n\t}"
  },
  "org.springframework.util.<unknown>#deleteAny(inString,charsToDelete)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delete any character in a given {@code String}.\n\t * @param inString the original {@code String}\n\t * @param charsToDelete a set of characters to delete.\n\t * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "String",
    "signature": "public String deleteAny(String inString, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String deleteAny(String inString, @Nullable String charsToDelete) {\n\t\tif (!hasLength(inString) || !hasLength(charsToDelete)) {\n\t\t\treturn inString;\n\t\t}\n\n\t\tint lastCharIndex = 0;\n\t\tchar[] result = new char[inString.length()];\n\t\tfor (int i = 0; i < inString.length(); i++) {\n\t\t\tchar c = inString.charAt(i);\n\t\t\tif (charsToDelete.indexOf(c) == -1) {\n\t\t\t\tresult[lastCharIndex++] = c;\n\t\t\t}\n\t\t}\n\t\tif (lastCharIndex == inString.length()) {\n\t\t\treturn inString;\n\t\t}\n\t\treturn new String(result, 0, lastCharIndex);\n\t}"
  },
  "org.springframework.util.<unknown>#splitArrayElementsIntoProperties(array,delimiter,charsToDelete)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the\n\t * delimiter providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the\n\t * {@code Properties} instance.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @param charsToDelete one or more characters to remove from each element\n\t * prior to attempting the split operation (typically the quotation mark\n\t * symbol), or {@code null} if no removal should occur\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1102
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(\n\t\t\tString[] array, String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tProperties result = new Properties();\n\t\tfor (String element : array) {\n\t\t\tif (charsToDelete != null) {\n\t\t\t\telement = deleteAny(element, charsToDelete);\n\t\t\t}\n\t\t\tString[] splittedElement = split(element, delimiter);\n\t\t\tif (splittedElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.<unknown>#toArray(enumeration,array)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "A[]",
    "signature": "public A[] toArray(Enumeration<E> enumeration, A[] array)",
    "source_code": "\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#nodeNameEquals(node,desiredName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Namespace-aware equals comparison. Returns {@code true} if either\n\t * {@link Node#getLocalName} or {@link Node#getNodeName} equals\n\t * {@code desiredName}, otherwise returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "desiredName"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean nodeNameEquals(Node node, String desiredName)",
    "source_code": "\tpublic static boolean nodeNameEquals(Node node, String desiredName) {\n\t\tAssert.notNull(node, \"Node must not be null\");\n\t\tAssert.notNull(desiredName, \"Desired name must not be null\");\n\t\treturn nodeNameMatch(node, desiredName);\n\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.<unknown>#initDataBinder(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(MultiValueMap<String,formData)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formData"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(MultiValueMap<String, String> formData)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementClass the class of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass) {\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forClass(elementClass), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthenticationCredentials(username,password)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tif (info.getPatternsCondition().isEmptyPathMapping()) {\n\t\t\t\tinfo = info.mutate().paths(\"\", \"/\").options(this.config).build();\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Predicate<Class<?>>> entry : this.pathPrefixes.entrySet()) {\n\t\t\t\tif (entry.getValue().test(handlerType)) {\n\t\t\t\t\tString prefix = entry.getKey();\n\t\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\t\tprefix = this.embeddedValueResolver.resolveStringValue(prefix);\n\t\t\t\t\t}\n\t\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgumentValue(methodParameter,context,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter methodParameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Object resolveArgumentValue(\n\t\t\tMethodParameter methodParameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tClass<?> paramType = methodParameter.getParameterType();\n\t\tif (ServerWebExchange.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange;\n\t\t}\n\t\telse if (ServerHttpRequest.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getRequest();\n\t\t}\n\t\telse if (ServerHttpResponse.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getResponse();\n\t\t}\n\t\telse if (HttpMethod.class == paramType) {\n\t\t\treturn exchange.getRequest().getMethod();\n\t\t}\n\t\telse if (Locale.class == paramType) {\n\t\t\treturn exchange.getLocaleContext().getLocale();\n\t\t}\n\t\telse if (TimeZone.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone : TimeZone.getDefault());\n\t\t}\n\t\telse if (ZoneId.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault());\n\t\t}\n\t\telse if (UriBuilder.class == paramType || UriComponentsBuilder.class == paramType) {\n\t\t\tURI uri = exchange.getRequest().getURI();\n\t\t\tString contextPath = exchange.getRequest().getPath().contextPath().value();\n\t\t\treturn UriComponentsBuilder.fromUri(uri).replacePath(contextPath).replaceQuery(null);\n\t\t}\n\t\telse {\n\t\t\t// should never happen...\n\t\t\tthrow new IllegalArgumentException(\"Unknown parameter type: \" +\n\t\t\t\t\tparamType + \" in method: \" + methodParameter.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(resolvable,htmlEscape)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(resolvable, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.socket.<unknown>#create(code,reason)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a constant for the given code, or create a new instance if the\n\t * code does not match or there is a reason.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "CloseStatus",
    "signature": "public CloseStatus create(int code, @Nullable String reason)",
    "source_code": "\tpublic static CloseStatus create(int code, @Nullable String reason) {\n\t\tif (!StringUtils.hasText(reason)) {\n\t\t\treturn switch (code) {\n\t\t\t\tcase 1000 -> NORMAL;\n\t\t\t\tcase 1001 -> GOING_AWAY;\n\t\t\t\tcase 1002 -> PROTOCOL_ERROR;\n\t\t\t\tcase 1003 -> NOT_ACCEPTABLE;\n\t\t\t\tcase 1005 -> NO_STATUS_CODE;\n\t\t\t\tcase 1006 -> NO_CLOSE_FRAME;\n\t\t\t\tcase 1007 -> BAD_DATA;\n\t\t\t\tcase 1008 -> POLICY_VIOLATION;\n\t\t\t\tcase 1009 -> TOO_BIG_TO_PROCESS;\n\t\t\t\tcase 1010 -> REQUIRED_EXTENSION;\n\t\t\t\tcase 1011 -> SERVER_ERROR;\n\t\t\t\tcase 1012 -> SERVICE_RESTARTED;\n\t\t\t\tcase 1013 -> SERVICE_OVERLOAD;\n\t\t\t\tdefault -> new CloseStatus(code, reason);\n\t\t\t};\n\t\t}\n\t\treturn new CloseStatus(code, reason);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveHandlerMethodException(request,response,handlerMethod,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually resolve the given exception that got thrown during on handler execution,\n\t * returning a ModelAndView that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolved applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod the executed handler method, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to, or {@code null} for default processing\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex)",
    "source_code": "\tprotected abstract ModelAndView doResolveHandlerMethodException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex);\n\n}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMatchingMapping(mapping,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param request the current HTTP servlet request\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, HttpServletRequest request)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, HttpServletRequest request);"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotSupported(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMediaTypeNotSupportedException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotSupported(\n\t\t\tHttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingPathVariable(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingPathVariableException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingPathVariable(MissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingPathVariable(\n\t\t\tMissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter descriptor\n\t * @return {@code true} if the next method argument is not of type {@link Errors}\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#writeWithMessageConverters(value,returnType,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return value to the given web request. Delegates to\n\t * {@link #writeWithMessageConverters(Object, MethodParameter, ServletServerHttpRequest, ServletServerHttpResponse)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\t\twriteWithMessageConverters(value, returnType, inputMessage, outputMessage);\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMethodArgumentNotValidException(ex,request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an argument annotated with {@code @Valid} such as\n\t * an {@link RequestBody} or {@link RequestPart} argument fails validation.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#canHandle(viewName,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link org.springframework.web.servlet.ViewResolver} can\n\t * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will\n\t * return {@code null}. The default implementation checks against the configured\n\t * {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#queryProperties(Map<String,model)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine name-value pairs for query strings, which will be stringified,\n\t * URL-encoded and formatted by {@link #appendQueryProperties}.\n\t * <p>This implementation filters the model through checking\n\t * {@link #isEligibleProperty(String, Object)} for each element,\n\t * by default accepting Strings, primitives and primitive wrappers only.\n\t * @param model the original model Map\n\t * @return the filtered Map of eligible query properties\n\t * @see #isEligibleProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "Object>",
    "signature": "protected Object> queryProperties(Map<String, Object> model)",
    "source_code": "\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tmodel.forEach((name, value) -> {\n\t\t\tif (isEligibleProperty(name, value)) {\n\t\t\t\tresult.put(name, value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#onWriteInactivity(runnable,duration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "public void onWriteInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onWriteInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastWriteTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastWriteTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"WriteInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleRequest(servletRequest,servletResponse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, this.wsHandler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(servletRequest.getMethod() + \" \" + servletRequest.getRequestURI());\n\t\t\t}\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handshakeHandler.doHandshake(request, response, this.wsHandler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\n\t\t\t\t\t\"Uncaught failure for request \" + request.getURI() + \" - \" + ex.getMessage(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tresponse.close();\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRawWebSocketRequest(request,response,webSocketHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected abstract void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler) throws IOException;\n\n\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */\n\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  }
}