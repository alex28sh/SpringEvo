{
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#add(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void add(String name, Lifecycle bean)",
    "source_code": "\t\tpublic void add(String name, Lifecycle bean) {\n\t\t\tthis.members.add(new LifecycleGroupMember(name, bean));\n\t\t\tif (bean instanceof SmartLifecycle) {\n\t\t\t\tthis.smartMemberCount++;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#calculateAllFilenames(basename,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate all filenames for the given bundle basename and Locale.\n\t * Will calculate filenames for the given Locale, the system Locale\n\t * (if applicable), and the default file.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t * @see #setFallbackToSystemLocale\n\t * @see #calculateFilenamesForLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateAllFilenames(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateAllFilenames(String basename, Locale locale) {\n\t\tMap<Locale, List<String>> localeMap = this.cachedFilenames.get(basename);\n\t\tif (localeMap != null) {\n\t\t\tList<String> filenames = localeMap.get(locale);\n\t\t\tif (filenames != null) {\n\t\t\t\treturn filenames;\n\t\t\t}\n\t\t}\n\n\t\t// Filenames for given Locale\n\t\tList<String> filenames = new ArrayList<>(7);\n\t\tfilenames.addAll(calculateFilenamesForLocale(basename, locale));\n\n\t\t// Filenames for default Locale, if any\n\t\tLocale defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale != null && !defaultLocale.equals(locale)) {\n\t\t\tList<String> fallbackFilenames = calculateFilenamesForLocale(basename, defaultLocale);\n\t\t\tfor (String fallbackFilename : fallbackFilenames) {\n\t\t\t\tif (!filenames.contains(fallbackFilename)) {\n\t\t\t\t\t// Entry for fallback locale that isn't already in filenames list.\n\t\t\t\t\tfilenames.add(fallbackFilename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filename for default bundle file\n\t\tfilenames.add(basename);\n\n\t\tif (localeMap == null) {\n\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\tMap<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap);\n\t\t\tif (existing != null) {\n\t\t\t\tlocaleMap = existing;\n\t\t\t}\n\t\t}\n\t\tlocaleMap.put(locale, filenames);\n\t\treturn filenames;\n\t}"
  },
  "org.springframework.context.support.<unknown>#calculateFilenamesForLocale(basename,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate the filenames for the given bundle basename and Locale,\n\t * appending language code, country code, and variant code.\n\t * <p>For example, basename \"messages\", Locale \"de_AT_oo\" &rarr; \"messages_de_AT_OO\",\n\t * \"messages_de_AT\", \"messages_de\".\n\t * <p>Follows the rules defined by {@link java.util.Locale#toString()}.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateFilenamesForLocale(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateFilenamesForLocale(String basename, Locale locale) {\n\t\tList<String> result = new ArrayList<>(3);\n\t\tString language = locale.getLanguage();\n\t\tString country = locale.getCountry();\n\t\tString variant = locale.getVariant();\n\t\tStringBuilder temp = new StringBuilder(basename);\n\n\t\ttemp.append('_');\n\t\tif (language.length() > 0) {\n\t\t\ttemp.append(language);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\ttemp.append('_');\n\t\tif (country.length() > 0) {\n\t\t\ttemp.append(country);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\tif (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {\n\t\t\ttemp.append('_').append(variant);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.context.support.<unknown>#getDefaultMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a default message for the given {@code MessageSourceResolvable}.\n\t * <p>This implementation fully renders the default message if available,\n\t * or just returns the plain default message {@code String} if the primary\n\t * message code is being used as a default message.\n\t * @param resolvable the value object to resolve a default message for\n\t * @param locale the current locale\n\t * @return the default message, or {@code null} if none\n\t * @since 4.3.6\n\t * @see #renderDefaultMessage(String, Object[], Locale)\n\t * @see #getDefaultMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\tString defaultMessage = resolvable.getDefaultMessage();\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (defaultMessage != null) {\n\t\t\tif (resolvable instanceof DefaultMessageSourceResolvable defaultMessageSourceResolvable &&\n\t\t\t\t\t!defaultMessageSourceResolvable.shouldRenderDefaultMessage()) {\n\t\t\t\t// Given default message does not contain any argument placeholders\n\t\t\t\t// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {\n\t\t\t\t// Never format a code-as-default-message, even with alwaysUseMessageFormat=true\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\treturn renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);\n\t\t}\n\t\treturn (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageFormat(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "MessageFormat",
    "signature": "public MessageFormat getMessageFormat(String code, Locale locale)",
    "source_code": "\t\tpublic MessageFormat getMessageFormat(String code, Locale locale) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<Locale, MessageFormat> localeMap = this.cachedMessageFormats.get(code);\n\t\t\tif (localeMap != null) {\n\t\t\t\tMessageFormat result = localeMap.get(locale);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString msg = this.properties.getProperty(code);\n\t\t\tif (msg != null) {\n\t\t\t\tif (localeMap == null) {\n\t\t\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\t\t\tMap<Locale, MessageFormat> existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tlocaleMap = existing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessageFormat result = createMessageFormat(msg, locale);\n\t\t\t\tlocaleMap.put(locale, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageFromParent(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Try to retrieve the given message from the parent {@code MessageSource}, if any.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getParentMessageSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale) {\n\t\tMessageSource parent = getParentMessageSource();\n\t\tif (parent != null) {\n\t\t\tif (parent instanceof AbstractMessageSource abstractMessageSource) {\n\t\t\t\t// Call internal method to avoid getting the default code back\n\t\t\t\t// in case of \"useCodeAsDefaultMessage\" being activated.\n\t\t\t\treturn abstractMessageSource.getMessageInternal(code, args, locale);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check parent MessageSource, returning null if not found there.\n\t\t\t\t// Covers custom MessageSource impls and DelegatingMessageSource.\n\t\t\t\treturn parent.getMessage(code, args, null, locale);\n\t\t\t}\n\t\t}\n\t\t// Not found in parent either.\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageInternal(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given code and arguments as message in the given Locale,\n\t * returning {@code null} if not found. Does <i>not</i> fall back to\n\t * the code as default message. Invoked by {@code getMessage} methods.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getMessage(String, Object[], String, Locale)\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see #setUseCodeAsDefaultMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "String",
    "signature": "protected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale)",
    "source_code": "\tprotected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale) {\n\t\tif (code == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (locale == null) {\n\t\t\tlocale = Locale.getDefault();\n\t\t}\n\t\tObject[] argsToUse = args;\n\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\t// Optimized resolution: no arguments to apply,\n\t\t\t// therefore no MessageFormat needs to be involved.\n\t\t\t// Note that the default implementation still uses MessageFormat;\n\t\t\t// this can be overridden in specific subclasses.\n\t\t\tString message = resolveCodeWithoutArguments(code, locale);\n\t\t\tif (message != null) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resolve arguments eagerly, for the case where the message\n\t\t\t// is defined in a parent MessageSource but resolvable arguments\n\t\t\t// are defined in the child MessageSource.\n\t\t\targsToUse = resolveArguments(args, locale);\n\n\t\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\t\tif (messageFormat != null) {\n\t\t\t\tsynchronized (messageFormat) {\n\t\t\t\t\treturn messageFormat.format(argsToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check locale-independent common messages for the given message code.\n\t\tProperties commonMessages = getCommonMessages();\n\t\tif (commonMessages != null) {\n\t\t\tString commonMessage = commonMessages.getProperty(code);\n\t\t\tif (commonMessage != null) {\n\t\t\t\treturn formatMessage(commonMessage, args, locale);\n\t\t\t}\n\t\t}\n\n\t\t// Not found -> check parent, if any.\n\t\treturn getMessageFromParent(code, argsToUse, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#invokeMethod(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\tpublic Object invokeMethod(String name, Object args) {\n\t\treturn this.metaClass.invokeMethod(this, name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#load(relativeClass,resourceNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeClass",
      "resourceNames"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void load(Class<?> relativeClass, String... resourceNames)",
    "source_code": "\tpublic void load(Class<?> relativeClass, String... resourceNames) {\n\t\tResource[] resources = new Resource[resourceNames.length];\n\t\tfor (int i = 0; i < resourceNames.length; i++) {\n\t\t\tresources[i] = new ClassPathResource(resourceNames[i], relativeClass);\n\t\t}\n\t\tload(resources);\n\t}"
  },
  "org.springframework.context.support.<unknown>#loadProperties(resource,filename)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the properties from the given resource.\n\t * @param resource the resource to load from\n\t * @param filename the original bundle filename (basename + Locale)\n\t * @return the populated Properties instance\n\t * @throws IOException if properties loading failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "Properties",
    "signature": "protected Properties loadProperties(Resource resource, String filename)",
    "source_code": "\tprotected Properties loadProperties(Resource resource, String filename) throws IOException {\n\t\tProperties props = newProperties();\n\t\ttry (InputStream is = resource.getInputStream()) {\n\t\t\tString resourceFilename = resource.getFilename();\n\t\t\tif (resourceFilename != null && resourceFilename.endsWith(XML_SUFFIX)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.propertiesPersister.loadFromXml(props, is);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString encoding = null;\n\t\t\t\tif (this.fileEncodings != null) {\n\t\t\t\t\tencoding = this.fileEncodings.getProperty(filename);\n\t\t\t\t}\n\t\t\t\tif (encoding == null) {\n\t\t\t\t\tencoding = getDefaultEncoding();\n\t\t\t\t}\n\t\t\t\tif (encoding != null) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, new InputStreamReader(is, encoding));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, is);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn props;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tif (bean instanceof ApplicationListener<?> applicationListener) {\n\t\t\ttry {\n\t\t\t\tApplicationEventMulticaster multicaster = this.applicationContext.getApplicationEventMulticaster();\n\t\t\t\tmulticaster.removeApplicationListener(applicationListener);\n\t\t\t\tmulticaster.removeApplicationListenerBean(beanName);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t// ApplicationEventMulticaster not initialized yet - no need to remove a listener\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tif (ApplicationListener.class.isAssignableFrom(beanType)) {\n\t\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#refreshProperties(filename,propHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the PropertiesHolder for the given bundle filename.\n\t * The holder can be {@code null} if not cached before, or a timed-out cache entry\n\t * (potentially getting re-validated against the current last-modified timestamp).\n\t * @param filename the bundle filename (basename + Locale)\n\t * @param propHolder the current PropertiesHolder for the bundle\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename",
      "propHolder"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder)",
    "source_code": "\tprotected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {\n\t\tlong refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis());\n\n\t\tResource resource = this.resourceLoader.getResource(filename + PROPERTIES_SUFFIX);\n\t\tif (!resource.exists()) {\n\t\t\tresource = this.resourceLoader.getResource(filename + XML_SUFFIX);\n\t\t}\n\n\t\tif (resource.exists()) {\n\t\t\tlong fileTimestamp = -1;\n\t\t\tif (getCacheMillis() >= 0) {\n\t\t\t\t// Last-modified timestamp of file will just be read if caching with timeout.\n\t\t\t\ttry {\n\t\t\t\t\tfileTimestamp = resource.lastModified();\n\t\t\t\t\tif (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Re-caching properties for filename [\" + filename + \"] - file hasn't been modified\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\t\t\t\t\treturn propHolder;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// Probably a class path resource: cache it forever.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(resource + \" could not be resolved in the file system - assuming that it hasn't changed\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tfileTimestamp = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tProperties props = loadProperties(resource, filename);\n\t\t\t\tpropHolder = new PropertiesHolder(props, fileTimestamp);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Could not parse properties file [\" + resource.getFilename() + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Empty holder representing \"not valid\".\n\t\t\t\tpropHolder = new PropertiesHolder();\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resource does not exist.\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No properties file found for [\" + filename + \"] - neither plain properties nor XML\");\n\t\t\t}\n\t\t\t// Empty holder representing \"not found\".\n\t\t\tpropHolder = new PropertiesHolder();\n\t\t}\n\n\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\tthis.cachedProperties.put(filename, propHolder);\n\t\treturn propHolder;\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerAlias(beanName,alias)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void registerAlias(String beanName, String alias)",
    "source_code": "\tpublic void registerAlias(String beanName, String alias) {\n\t\tthis.beanFactory.registerAlias(beanName, alias);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,constructorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(null, beanClass, constructorArgs);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\t\tregisterBean(null, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\tClass<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(null, beanClass, supplier, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,constructorArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(beanName, beanClass, (Supplier<T>) null,\n\t\t\t\tbd -> {\n\t\t\t\t\tfor (Object arg : constructorArgs) {\n\t\t\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\t@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(beanName, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * <p>This method can be overridden to adapt the registration mechanism for\n\t * all {@code registerBean} methods (since they all delegate to this one).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean (in case\n\t * of {@code null}, resolving a public constructor to be autowired instead)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tClassDerivedBeanDefinition beanDefinition = new ClassDerivedBeanDefinition(beanClass);\n\t\tif (supplier != null) {\n\t\t\tbeanDefinition.setInstanceSupplier(supplier);\n\t\t}\n\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\tcustomizer.customize(beanDefinition);\n\t\t}\n\n\t\tString nameToUse = (beanName != null ? beanName : beanClass.getName());\n\t\tregisterBeanDefinition(nameToUse, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tthis.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveArguments(args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Searches through the given array of objects, finds any MessageSourceResolvable\n\t * objects and resolves them.\n\t * <p>Allows for messages to have MessageSourceResolvables as arguments.\n\t * @param args array of arguments for a message\n\t * @param locale the locale to resolve through\n\t * @return an array of arguments with any MessageSourceResolvables resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {\n\t\tif (ObjectUtils.isEmpty(args)) {\n\t\t\treturn super.resolveArguments(args, locale);\n\t\t}\n\t\tList<Object> resolvedArgs = new ArrayList<>(args.length);\n\t\tfor (Object arg : args) {\n\t\t\tif (arg instanceof MessageSourceResolvable messageSourceResolvable) {\n\t\t\t\tresolvedArgs.add(getMessage(messageSourceResolvable, locale));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvedArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs.toArray();\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveCode(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to resolve a message.\n\t * <p>Returns a MessageFormat instance rather than a message String,\n\t * to allow for appropriate caching of MessageFormats in subclasses.\n\t * <p><b>Subclasses are encouraged to provide optimized resolution\n\t * for messages without arguments, not involving MessageFormat.</b>\n\t * See the {@link #resolveCodeWithoutArguments} javadoc for details.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the MessageFormat for the message, or {@code null} if not found\n\t * @see #resolveCodeWithoutArguments(String, java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat resolveCode(String code, Locale locale)",
    "source_code": "\tprotected abstract MessageFormat resolveCode(String code, Locale locale);"
  },
  "org.springframework.context.support.<unknown>#resolveCodeWithoutArguments(code,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to resolve a message without arguments\n\t * in an optimized fashion, i.e. to resolve without involving a MessageFormat.\n\t * <p>The default implementation <i>does</i> use MessageFormat, through\n\t * delegating to the {@link #resolveCode} method. Subclasses are encouraged\n\t * to replace this with optimized resolution.\n\t * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented\n\t * in an efficient fashion. In particular, it does not detect that a message\n\t * pattern doesn't contain argument placeholders in the first place. Therefore,\n\t * it is advisable to circumvent MessageFormat for messages without arguments.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the message String, or {@code null} if not found\n\t * @see #resolveCode\n\t * @see java.text.MessageFormat\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "String",
    "signature": "protected String resolveCodeWithoutArguments(String code, Locale locale)",
    "source_code": "\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\tif (messageFormat != null) {\n\t\t\tsynchronized (messageFormat) {\n\t\t\t\treturn messageFormat.format(new Object[0]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.<unknown>#setProperty(property,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer read(byte[] destination, int offset, int length) {\n\t\tAssert.notNull(destination, \"Byte array must not be null\");\n\t\tassertIndex(this.readPosition <= this.writePosition - length,\n\t\t\t\t\"readPosition %d and length %d should be smaller than writePosition %d\",\n\t\t\t\tthis.readPosition, length, this.writePosition);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.readPosition + length;\n\t\ttmp.clear().position(this.readPosition).limit(limit);\n\t\ttmp.get(destination, offset, length);\n\n\t\tthis.readPosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer slice(int index, int length)",
    "source_code": "\tpublic DefaultDataBuffer slice(int index, int length) {\n\t\tcheckIndex(index, length);\n\t\tint oldPosition = this.byteBuffer.position();\n\t\ttry {\n\t\t\tthis.byteBuffer.position(index);\n\t\t\tByteBuffer slice = this.byteBuffer.slice();\n\t\t\tslice.limit(length);\n\t\t\treturn new SlicedDefaultDataBuffer(slice, this.dataBufferFactory, length);\n\t\t}\n\t\tfinally {\n\t\t\tthis.byteBuffer.position(oldPosition);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer write(byte[] source, int offset, int length) {\n\t\tAssert.notNull(source, \"Byte array must not be null\");\n\t\tensureWritable(length);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.writePosition + length;\n\t\ttmp.clear().position(this.writePosition).limit(limit);\n\t\ttmp.put(source, offset, length);\n\n\t\tthis.writePosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#completed(Message<HttpResponse,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Message<HttpResponse",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void completed(Message<HttpResponse, Publisher<ByteBuffer>> result)",
    "source_code": "\t\tpublic void completed(Message<HttpResponse, Publisher<ByteBuffer>> result) {\n\t\t\tHttpComponentsClientHttpResponse response =\n\t\t\t\t\tnew HttpComponentsClientHttpResponse(this.dataBufferFactory, result, this.context);\n\t\t\tthis.sink.success(response);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tHttpClientContext context = this.contextProvider.apply(method, uri);\n\n\t\tif (context.getCookieStore() == null) {\n\t\t\tcontext.setCookieStore(new BasicCookieStore());\n\t\t}\n\n\t\tHttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,\n\t\t\t\tcontext, this.dataBufferFactory);\n\n\t\treturn requestCallback.apply(request).then(Mono.defer(() -> execute(request, context)));\n\t}"
  },
  "org.springframework.http.codec.<unknown>#addHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\tHttpHeaders headers = message.getHeaders();\n\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\theaders.setContentType(resourceMediaType);\n\n\t\tif (headers.getContentLength() < 0) {\n\t\t\tlong length = lengthOf(resource);\n\t\t\tif (length != -1) {\n\t\t\t\theaders.setContentLength(length);\n\t\t\t}\n\t\t}\n\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t// server side\n\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canRead(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.decoder.canDecode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getReadHints(actualType,elementType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the decoder if it is an instance of {@link HttpMessageDecoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.decoder instanceof HttpMessageDecoder<?> httpMessageDecoder) {\n\t\t\treturn httpMessageDecoder.getDecodeHints(actualType, elementType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getReadHints(elementType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding based on the input HTTP message.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message) {\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getWriteHints(streamType,elementType,mediaType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for encoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the encoder if it is an instance of {@link HttpMessageEncoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "streamType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "Object>",
    "signature": "protected Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.encoder instanceof HttpMessageEncoder<?> httpMessageEncoder) {\n\t\t\treturn httpMessageEncoder.getEncodeHints(streamType, elementType, mediaType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(actualType,elementType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn read(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decode(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(actualType,elementType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn readMono(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decodeToMono(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetEncodeHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(input, elementType, mediaType, response, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,elementType,mediaType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tmediaType = (mediaType != null && mediaType.getCharset() != null ? mediaType : DEFAULT_MEDIA_TYPE);\n\t\tDataBufferFactory bufferFactory = message.bufferFactory();\n\n\t\tmessage.getHeaders().setContentType(mediaType);\n\t\treturn message.writeAndFlushWith(encode(input, elementType, mediaType, bufferFactory, hints));\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, @Nullable ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tHttpHeaders headers = response.getHeaders();\n\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\n\t\tList<HttpRange> ranges;\n\t\ttry {\n\t\t\tranges = request.getHeaders().getRange();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tresponse.setStatusCode(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE);\n\t\t\treturn response.setComplete();\n\t\t}\n\n\t\treturn Mono.from(inputStream).flatMap(resource -> {\n\t\t\tif (ranges.isEmpty()) {\n\t\t\t\treturn writeResource(resource, elementType, mediaType, response, hints);\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.PARTIAL_CONTENT);\n\t\t\tList<ResourceRegion> regions = HttpRange.toResourceRegions(ranges, resource);\n\t\t\tMediaType resourceMediaType = getResourceMediaType(mediaType, resource, hints);\n\t\t\tif (regions.size() == 1){\n\t\t\t\tResourceRegion region = regions.get(0);\n\t\t\t\theaders.setContentType(resourceMediaType);\n\t\t\t\tlong contentLength = lengthOf(resource);\n\t\t\t\tif (contentLength != -1) {\n\t\t\t\t\tlong start = region.getPosition();\n\t\t\t\t\tlong end = start + region.getCount() - 1;\n\t\t\t\t\tend = Math.min(end, contentLength - 1);\n\t\t\t\t\theaders.add(\"Content-Range\", \"bytes \" + start + '-' + end + '/' + contentLength);\n\t\t\t\t\theaders.setContentLength(end - start + 1);\n\t\t\t\t}\n\t\t\t\treturn writeSingleRegion(region, response, hints);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString boundary = MimeTypeUtils.generateMultipartBoundaryString();\n\t\t\t\tMediaType multipartType = MediaType.parseMediaType(\"multipart/byteranges;boundary=\" + boundary);\n\t\t\t\theaders.setContentType(multipartType);\n\t\t\t\tMap<String, Object> allHints = Hints.merge(hints, ResourceRegionEncoder.BOUNDARY_STRING_HINT, boundary);\n\t\t\t\treturn encodeAndWriteRegions(Flux.fromIterable(regions), resourceMediaType, response, allHints);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,elementType,mediaType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Resource> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\treturn Mono.from(inputStream).flatMap(resource ->\n\t\t\t\twriteResource(resource, elementType, mediaType, message, hints));\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#canDecode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = mapper.constructType(elementType.getType());\n\t\t// Skip String: CharSequenceDecoder + \"*/*\" comes after\n\t\tif (CharSequence.class.isAssignableFrom(elementType.toClass()) || !supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canDeserialize(javaType);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canDeserialize(javaType, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeReader(reader,elementType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param elementType the target type of element values to read to\n\t * @param hints a map with serialization hints;\n\t * the Reactor Context, when available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectReader} to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectReader customizeReader(\n\t\t\tObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn reader;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decode(dataBuffer,targetType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "targetType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "public Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {\n\n\t\tObjectMapper mapper = selectObjectMapper(targetType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + targetType);\n\t\t}\n\n\t\ttry {\n\t\t\tObjectReader objectReader = createObjectReader(mapper, targetType, hints);\n\t\t\tObject value = objectReader.readValue(dataBuffer.asInputStream());\n\t\t\tlogValue(value, hints);\n\t\t\treturn value;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow processException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decode(input,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Flux<Object>",
    "signature": "public Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn Flux.error(new IllegalStateException(\"No ObjectMapper for \" + elementType));\n\t\t}\n\n\t\tboolean forceUseOfBigDecimal = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n\t\tif (BigDecimal.class.equals(elementType.getType())) {\n\t\t\tforceUseOfBigDecimal = true;\n\t\t}\n\n\t\tFlux<DataBuffer> processed = processInput(input, elementType, mimeType, hints);\n\t\tFlux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(processed, mapper.getFactory(), mapper,\n\t\t\t\ttrue, forceUseOfBigDecimal, getMaxInMemorySize());\n\n\t\treturn Flux.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\tObjectReader reader = createObjectReader(mapper, elementType, hintsToUse);\n\n\t\t\treturn tokens.handle((tokenBuffer, sink) -> {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = reader.readValue(tokenBuffer.asParser(mapper));\n\t\t\t\t\tlogValue(value, hints);\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tsink.next(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tsink.error(processException(ex));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decodeToMono(input,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Mono.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\treturn DataBufferUtils.join(input, this.maxInMemorySize).flatMap(dataBuffer ->\n\t\t\t\t\tMono.justOrEmpty(decode(dataBuffer, elementType, mimeType, hintsToUse)));\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getDecodeHints(actualType,elementType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Object>",
    "signature": "public Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn getHints(actualType);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getJavaType(type,contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 5.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tlogger.debug(msg, cause);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#processInput(input,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the input publisher into a flux. Default implementation returns\n\t * {@link Flux#from(Publisher)}, but subclasses can choose to customize\n\t * this behavior.\n\t * @param input the {@code DataBuffer} input stream to process\n\t * @param elementType the expected type of elements in the output stream\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do encode\n\t * @return the processed flux\n\t * @since 5.1.14\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(input);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MimeType,registrar)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and supported\n\t * {@link #getMimeTypes() MimeTypes} for the given class. Therefore it is\n\t * important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MimeType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MimeType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#selectObjectMapper(targetType,targetMimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Select an ObjectMapper to use, either the main ObjectMapper or another\n\t * if the handling for the given Class has been customized through\n\t * {@link #registerObjectMappersForType(Class, Consumer)}.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetType",
      "targetMimeType"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "ObjectMapper",
    "signature": "protected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType)",
    "source_code": "\tprotected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType) {\n\t\tif (targetMimeType == null || CollectionUtils.isEmpty(this.objectMapperRegistrations)) {\n\t\t\treturn this.defaultObjectMapper;\n\t\t}\n\t\tClass<?> targetClass = targetType.toClass();\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> typeEntry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (typeEntry.getKey().isAssignableFrom(targetClass)) {\n\t\t\t\tfor (Map.Entry<MimeType, ObjectMapper> objectMapperEntry : typeEntry.getValue().entrySet()) {\n\t\t\t\t\tif (objectMapperEntry.getKey().includes(targetMimeType)) {\n\t\t\t\t\t\treturn objectMapperEntry.getValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// No matching registrations\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// No registrations\n\t\treturn this.defaultObjectMapper;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#canRead(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (MULTIPART_VALUE_TYPE.isAssignableFrom(elementType)) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : MIME_TYPES) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#read(elementType,message,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Part>>",
    "signature": "public Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<MultiValueMap<String, Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints) {\n\n\t\treturn Flux.from(readMono(elementType, message, hints));\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#readMono(elementType,inputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Part>>",
    "signature": "public Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<MultiValueMap<String, Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {\n\n\n\t\tMap<String, Object> allHints = Hints.merge(hints, Hints.SUPPRESS_LOGGING_HINT, true);\n\n\t\treturn this.partReader.read(elementType, inputMessage, allHints)\n\t\t\t\t.collectMultimap(Part::name)\n\t\t\t\t.doOnNext(map ->\n\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + \"Parsed \" +\n\t\t\t\t\t\t\t(isEnableLoggingRequestDetails() ?\n\t\t\t\t\t\t\t\t\tLogFormatUtils.formatValue(map, !traceOn) :\n\t\t\t\t\t\t\t\t\t\"parts \" + map.keySet() + \" (content masked)\"))\n\t\t\t\t)\n\t\t\t\t.map(this::toMultiValueMap);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#write(parts,elementType,mediaType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parts",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\tbyte[] boundary = generateMultipartBoundary();\n\n\t\tmediaType = getMultipartMediaType(mediaType, boundary);\n\t\toutputMessage.getHeaders().setContentType(mediaType);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Encoding Publisher<Part>\");\n\t\t}\n\n\t\tFlux<DataBuffer> body = Flux.from(parts)\n\t\t\t\t.concatMap(part -> encodePart(boundary, part, outputMessage.bufferFactory()))\n\t\t\t\t.concatWith(generateLastLine(boundary, outputMessage.bufferFactory()))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\n\t\treturn outputMessage.writeWith(body);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#addCodec(codecs,codec)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a codec and add it to the List.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "codecs",
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "void",
    "signature": "protected void addCodec(List<T> codecs, T codec)",
    "source_code": "\tprotected <T> void addCodec(List<T> codecs, T codec) {\n\t\tinitCodec(codec);\n\t\tcodecs.add(codec);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#registerWithDefaultConfig(codec,configConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "configConsumer"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "BufferedImage",
    "signature": "public BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tImageInputStream imageInputStream = null;\n\t\tImageReader imageReader = null;\n\t\t// We cannot use try-with-resources here for the ImageInputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\timageInputStream = createImageInputStream(inputMessage.getBody());\n\t\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\t\tif (contentType == null) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"No Content-Type header\", inputMessage);\n\t\t\t}\n\t\t\tIterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(contentType.toString());\n\t\t\tif (imageReaders.hasNext()) {\n\t\t\t\timageReader = imageReaders.next();\n\t\t\t\tImageReadParam irp = imageReader.getDefaultReadParam();\n\t\t\t\tprocess(irp);\n\t\t\t\timageReader.setInput(imageInputStream, true);\n\t\t\t\treturn imageReader.read(0, irp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\"Could not find javax.imageio.ImageReader for Content-Type [\" + contentType + \"]\",\n\t\t\t\t\t\tinputMessage);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (imageReader != null) {\n\t\t\t\timageReader.dispose();\n\t\t\t}\n\t\t\tif (imageInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\timageInputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, e.g. via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<AnnotationIntrospector, AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#create(defaultUseWrapper,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultUseWrapper",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 927
    },
    "return": "ObjectMapper",
    "signature": "public ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory)",
    "source_code": "\t\tpublic ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory) {\n\t\t\tJacksonXmlModule module = new JacksonXmlModule();\n\t\t\tmodule.setDefaultUseWrapper(defaultUseWrapper);\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory, module);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(new XmlFactory(StaxUtils.createDefensiveInputFactory()), module);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializerByType(type,deserializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom deserializer for the given type.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "deserializer"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer) {\n\t\tthis.deserializers.put(type, deserializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializersByType(Map<Class<?>,deserializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers for the given types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIn(target,mixinSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param target class (or interface) whose annotations to effectively override\n\t * @param mixinSource class (or interface) whose annotations are to be \"added\"\n\t * to target's annotations as value\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "mixinSource"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource) {\n\t\tthis.mixIns.put(target, mixinSource);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#serializerByType(type,serializer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom serializer for the given type.\n\t * @since 4.1.2\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "serializer"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer) {\n\t\tthis.serializers.put(type, serializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#serializersByType(Map<Class<?>,serializers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom serializers for the given types.\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "serializers"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers) {\n\t\tthis.serializers.putAll(serializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#visibility(accessor,visibility)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessor",
      "visibility"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalStateException(\"No handler for return value type: \" + returnType.getParameterType());\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing return value with \" + handler);\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#isAsyncReturnValue(returnValue,returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "boolean",
    "signature": "public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType)",
    "source_code": "\tpublic boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\treturn (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\tasyncHandler.isAsyncReturnValue(returnValue, returnType));\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#createScheduler(schedulerFactory,schedulerName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the Scheduler instance for the given factory and scheduler name.\n\t * Called by {@link #afterPropertiesSet}.\n\t * <p>The default implementation invokes SchedulerFactory's {@code getScheduler}\n\t * method. Can be overridden for custom Scheduler creation.\n\t * @param schedulerFactory the factory to create the Scheduler with\n\t * @param schedulerName the name of the scheduler to create\n\t * @return the Scheduler instance\n\t * @throws SchedulerException if thrown by Quartz methods\n\t * @see #afterPropertiesSet\n\t * @see org.quartz.SchedulerFactory#getScheduler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "schedulerFactory",
      "schedulerName"
    ],
    "position": {
      "column": 1,
      "line": 664
    },
    "return": "Scheduler",
    "signature": "protected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)",
    "source_code": "\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)\n\t\t\tthrows SchedulerException {\n\n\t\t// Override thread context ClassLoader to work around naive Quartz ClassLoadHelper loading.\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tboolean overrideClassLoader = (this.resourceLoader != null &&\n\t\t\t\tthis.resourceLoader.getClassLoader() != threadContextClassLoader);\n\t\tif (overrideClassLoader) {\n\t\t\tcurrentThread.setContextClassLoader(this.resourceLoader.getClassLoader());\n\t\t}\n\t\ttry {\n\t\t\tSchedulerRepository repository = SchedulerRepository.getInstance();\n\t\t\tsynchronized (repository) {\n\t\t\t\tScheduler existingScheduler = (schedulerName != null ? repository.lookup(schedulerName) : null);\n\t\t\t\tScheduler newScheduler = schedulerFactory.getScheduler();\n\t\t\t\tif (newScheduler == existingScheduler) {\n\t\t\t\t\tthrow new IllegalStateException(\"Active Scheduler of name '\" + schedulerName + \"' already registered \" +\n\t\t\t\t\t\t\t\"in Quartz SchedulerRepository. Cannot create a new Spring-managed Scheduler of the same name!\");\n\t\t\t\t}\n\t\t\t\tif (!this.exposeSchedulerInRepository) {\n\t\t\t\t\t// Need to remove it in this case, since Quartz shares the Scheduler instance by default!\n\t\t\t\t\tSchedulerRepository.getInstance().remove(newScheduler.getSchedulerName());\n\t\t\t\t}\n\t\t\t\treturn newScheduler;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (overrideClassLoader) {\n\t\t\t\t// Reset original thread context ClassLoader.\n\t\t\t\tcurrentThread.setContextClassLoader(threadContextClassLoader);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#setSchedulerContextAsMap(Map<String,schedulerContextAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register objects in the Scheduler context via a given Map.\n\t * These objects will be available to any Job that runs in this Scheduler.\n\t * <p>Note: When using persistent Jobs whose JobDetail will be kept in the\n\t * database, do not put Spring-managed beans or an ApplicationContext\n\t * reference into the JobDataMap but rather into the SchedulerContext.\n\t * @param schedulerContextAsMap a Map with String keys and any objects as\n\t * values (for example Spring-managed beans)\n\t * @see JobDetailFactoryBean#setJobDataAsMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "schedulerContextAsMap"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap)",
    "source_code": "\tpublic void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap) {\n\t\tthis.schedulerContextMap = schedulerContextAsMap;\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#startScheduler(scheduler,startupDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Start the Quartz Scheduler, respecting the \"startupDelay\" setting.\n\t * @param scheduler the Scheduler to start\n\t * @param startupDelay the number of seconds to wait before starting\n\t * the Scheduler asynchronously\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduler",
      "startupDelay"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "protected void startScheduler(final Scheduler scheduler, final int startupDelay)",
    "source_code": "\tprotected void startScheduler(final Scheduler scheduler, final int startupDelay) throws SchedulerException {\n\t\tif (startupDelay <= 0) {\n\t\t\tlogger.info(\"Starting Quartz Scheduler now\");\n\t\t\tscheduler.start();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Will start Quartz Scheduler [\" + scheduler.getSchedulerName() +\n\t\t\t\t\t\t\"] in \" + startupDelay + \" seconds\");\n\t\t\t}\n\t\t\t// Not using the Quartz startDelayed method since we explicitly want a daemon\n\t\t\t// thread here, not keeping the JVM alive in case of all other threads ending.\n\t\t\tThread schedulerThread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t// simply proceed\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tscheduler.start();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tschedulerThread.setName(\"Quartz Scheduler [\" + scheduler.getSchedulerName() + \"]\");\n\t\t\tschedulerThread.setDaemon(true);\n\t\t\tschedulerThread.start();\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addBean(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beanFactory.addBean(name, bean);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\t\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck) {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#configureBean(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object configureBean(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException{\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\treturn this.beanFactory.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#initializeBean(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object initializeBean(Object existingBean, String beanName) throws BeansException {\n\t\t\tif (existingBean instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\tapplicationContextAware.setApplicationContext(StubWebApplicationContext.this);\n\t\t\t}\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveBeanByName(name,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\t\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.web.bind.support.<unknown>#addBindValue(Map<String,params,key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "params",
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "protected void addBindValue(Map<String, Object> params, String key, List<?> values)",
    "source_code": "\tprotected static void addBindValue(Map<String, Object> params, String key, List<?> values) {\n\t\tif (!CollectionUtils.isEmpty(values)) {\n\t\t\tvalues = values.stream()\n\t\t\t\t\t.map(value -> value instanceof FormFieldPart formFieldPart ? formFieldPart.value() : value)\n\t\t\t\t\t.toList();\n\t\t\tparams.put(key, values.size() == 1 ? values.get(0) : values);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#getWebApplicationContext(sc,attrName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a custom {@code WebApplicationContext} for this web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @param attrName the name of the ServletContext attribute to look for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "attrName"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName)",
    "source_code": "\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n\t\tAssert.notNull(sc, \"ServletContext must not be null\");\n\t\tObject attr = sc.getAttribute(attrName);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (attr instanceof Exception exception) {\n\t\t\tthrow new IllegalStateException(exception);\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(propertySources,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,\n\t * ServletContext, ServletConfig)} that always provides {@code null} for the\n\t * {@link ServletConfig} parameter.\n\t * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertySources",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {\n\t\tinitServletPropertySources(propertySources, servletContext, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(sources,servletContext,servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with\n\t * actual instances populated with the given {@code servletContext} and\n\t * {@code servletConfig} objects.\n\t * <p>This method is idempotent with respect to the fact it may be called any number\n\t * of times but will perform replacement of stub property sources with their\n\t * corresponding actual property sources once and only once.\n\t * @param sources the {@link MutablePropertySources} to initialize (must not\n\t * be {@code null})\n\t * @param servletContext the current {@link ServletContext} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME\n\t * servlet context property source} has already been initialized)\n\t * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME\n\t * servlet config property source} has already been initialized)\n\t * @see org.springframework.core.env.PropertySource.StubPropertySource\n\t * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sources",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tAssert.notNull(sources, \"'propertySources' must not be null\");\n\t\tString name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;\n\t\tif (servletContext != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletContextPropertySource(name, servletContext));\n\t\t}\n\t\tname = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;\n\t\tif (servletConfig != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletConfigPropertySource(name, servletConfig));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (getServletContext() != null && bean instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(getServletContext());\n\t\t}\n\t\tif (getServletConfig() != null && bean instanceof ServletConfigAware servletConfigAware) {\n\t\t\tservletConfigAware.setServletConfig(getServletConfig());\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,servletContext,servletConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tif (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);\n\t\t}\n\n\t\tif (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {\n\t\t\tMap<String, String> parameterMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletContext.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletContext.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (servletConfig != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletConfig.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletConfig.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(parameterMap));\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {\n\t\t\tMap<String, Object> attributeMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> attrNameEnum = servletContext.getAttributeNames();\n\t\t\t\twhile (attrNameEnum.hasMoreElements()) {\n\t\t\t\t\tString attrName = (String) attrNameEnum.nextElement();\n\t\t\t\t\tattributeMap.put(attrName, servletContext.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(attributeMap));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerWebApplicationScopes(beanFactory,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\", \"application\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc) {\n\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope());\n\t\tif (sc != null) {\n\t\t\tServletContextScope appScope = new ServletContextScope(sc);\n\t\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);\n\t\t\t// Register as ServletContext attribute, for ContextCleanupListener to detect it.\n\t\t\tsc.setAttribute(ServletContextScope.class.getName(), appScope);\n\t\t}\n\n\t\tbeanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());\n\t\tif (jsfPresent) {\n\t\t\tFacesDependencyRegistrar.registerFacesDependencies(beanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#bindRequestParameters(binder,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tClass<?> paramType = parameter.getNestedParameterType();\n\t\tif (Map.class.isAssignableFrom(paramType) || MultipartFile.class == paramType || Part.class == paramType) {\n\t\t\treturn;\n\t\t}\n\n\t\tRequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);\n\t\tString name = (requestParam != null && StringUtils.hasLength(requestParam.name()) ?\n\t\t\t\trequestParam.name() : parameter.getParameterName());\n\t\tAssert.state(name != null, \"Unresolvable parameter name\");\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tif (value instanceof Optional<?> optional) {\n\t\t\tvalue = optional.orElse(null);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tif (requestParam != null &&\n\t\t\t\t\t(!requestParam.required() || !requestParam.defaultValue().equals(ValueConstants.DEFAULT_NONE))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuilder.queryParam(name);\n\t\t}\n\t\telse if (value instanceof Collection<?> elements) {\n\t\t\tfor (Object element : elements) {\n\t\t\t\telement = formatUriValue(conversionService, TypeDescriptor.nested(parameter, 1), element);\n\t\t\t\tbuilder.queryParam(name, element);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbuilder.queryParam(name, formatUriValue(conversionService, new TypeDescriptor(parameter), value));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#formatUriValue(cs,sourceType,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value)",
    "source_code": "\tprotected String formatUriValue(\n\t\t\t@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value) {\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (value instanceof String string) {\n\t\t\treturn string;\n\t\t}\n\t\telse if (cs != null) {\n\t\t\treturn (String) cs.convert(value, sourceType, STRING_TYPE_DESCRIPTOR);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValue(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\thandleMissingValueInternal(name, parameter, request, false);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValueAfterConversion(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\n\t\thandleMissingValueInternal(name, parameter, request, true);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValueInternal(name,parameter,request,missingAfterConversion)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request",
      "missingAfterConversion"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "protected void handleMissingValueInternal(String name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)",
    "source_code": "\tprotected void handleMissingValueInternal(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)\n\t\t\tthrows Exception {\n\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\tif (MultipartResolutionDelegate.isMultipartArgument(parameter)) {\n\t\t\tif (servletRequest == null || !MultipartResolutionDelegate.isMultipartRequest(servletRequest)) {\n\t\t\t\tthrow new MultipartException(\"Current request is not a multipart request\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MissingServletRequestPartException(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new MissingServletRequestParameterException(name,\n\t\t\t\t\tparameter.getNestedParameterType().getSimpleName(), missingAfterConversion);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue instanceof Map map) {\n\t\t\tmavContainer.addAllAttributes(map);\n\t\t}\n\t\telse if (returnValue != null) {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type [\" +\n\t\t\t\t\treturnType.getParameterType().getName() + \"] in method: \" + returnType.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAndViewContainer is required for model exposure\");\n\t\treturn mavContainer.getModel();\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveName(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\n\t\tif (servletRequest != null) {\n\t\t\tObject mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);\n\t\t\tif (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {\n\t\t\t\treturn mpArg;\n\t\t\t}\n\t\t}\n\n\t\tObject arg = null;\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(name);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\targ = (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\tif (arg == null) {\n\t\t\tString[] paramValues = request.getParameterValues(name);\n\t\t\tif (paramValues != null) {\n\t\t\t\targ = (paramValues.length == 1 ? paramValues[0] : paramValues);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateIfApplicable(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(String, Object)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ModelAndViewContainer addAttribute(String name, @Nullable Object value) {\n\t\tgetModel().addAttribute(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#getMethodArgumentValues(request,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current request, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#invokeForRequest(request,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given request.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution. Examples of provided argument values include a\n\t * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.\n\t * Provided argument values are checked before argument resolvers.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param request the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Object",
    "signature": "public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#mergeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy attributes in the supplied {@code Map} with existing objects of\n\t * the same name taking precedence (i.e. not getting replaced).\n\t * A shortcut for {@code getModel().mergeAttributes(Map<String, ?>)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().mergeAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#removeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the given attributes from the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tfor (String key : attributes.keySet()) {\n\t\t\t\tgetModel().remove(key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#setBinding(attributeName,enabled)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register whether data binding should occur for a corresponding model attribute,\n\t * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.\n\t * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},\n\t * a hard {@link #setBindingDisabled} declaration will always override it.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "enabled"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setBinding(String attributeName, boolean enabled)",
    "source_code": "\tpublic void setBinding(String attributeName, boolean enabled) {\n\t\tif (!enabled) {\n\t\t\tthis.noBinding.add(attributeName);\n\t\t}\n\t\telse {\n\t\t\tthis.noBinding.remove(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#httpHandlerDecorator(Function<HttpHandler,handlerDecorator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpHandler",
      "handlerDecorator"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator)",
    "source_code": "\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#build(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI build(Map<String, ?> uriVariables) {\n\t\treturn buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();\n\t}"
  },
  "org.springframework.web.util.<unknown>#buildAndExpand(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code UriComponents} instance and replaces URI template variables\n\t * with the values from a map. This is a shortcut method which combines\n\t * calls to {@link #build()} and then {@link UriComponents#expand(Map)}.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI components with expanded values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "UriComponents",
    "signature": "public UriComponents buildAndExpand(Map<String, ?> uriVariables)",
    "source_code": "\tpublic UriComponents buildAndExpand(Map<String, ?> uriVariables) {\n\t\treturn build().expand(uriVariables);\n\t}"
  },
  "org.springframework.web.util.<unknown>#parseForwardedFor(request,remoteAddress)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7239#section-5.2\">RFC 7239, Section 5.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor(\n\t\t\tHttpRequest request, @Nullable InetSocketAddress remoteAddress) {\n\n\t\tint port = (remoteAddress != null ?\n\t\t\t\tremoteAddress.getPort() : \"https\".equals(request.getURI().getScheme()) ? 443 : 80);\n\n\t\tString forwardedHeader = request.getHeaders().getFirst(\"Forwarded\");\n\t\tif (StringUtils.hasText(forwardedHeader)) {\n\t\t\tString forwardedToUse = StringUtils.tokenizeToStringArray(forwardedHeader, \",\")[0];\n\t\t\tMatcher matcher = FORWARDED_FOR_PATTERN.matcher(forwardedToUse);\n\t\t\tif (matcher.find()) {\n\t\t\t\tString value = matcher.group(1).trim();\n\t\t\t\tString host = value;\n\t\t\t\tint portSeparatorIdx = value.lastIndexOf(':');\n\t\t\t\tint squareBracketIdx = value.lastIndexOf(']');\n\t\t\t\tif (portSeparatorIdx > squareBracketIdx) {\n\t\t\t\t\tif (squareBracketIdx == -1 && value.indexOf(':') != portSeparatorIdx) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid IPv4 address: \" + value);\n\t\t\t\t\t}\n\t\t\t\t\thost = value.substring(0, portSeparatorIdx);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tport = Integer.parseInt(value, portSeparatorIdx + 1, value.length(), 10);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Failed to parse a port from \\\"forwarded\\\"-type header value: \" + value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn InetSocketAddress.createUnresolved(host, port);\n\t\t\t}\n\t\t}\n\n\t\tString forHeader = request.getHeaders().getFirst(\"X-Forwarded-For\");\n\t\tif (StringUtils.hasText(forHeader)) {\n\t\t\tString host = StringUtils.tokenizeToStringArray(forHeader, \",\")[0];\n\t\t\treturn InetSocketAddress.createUnresolved(host, port);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\treturn queryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParamIfPresent(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\tpublic UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\tvalue.ifPresent(v -> {\n\t\t\tif (v instanceof Collection<?> values) {\n\t\t\t\tqueryParam(name, values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueryParam(name, v);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tthis.queryParams.addAll(params);\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\treturn replaceQueryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tthis.queryParams.clear();\n\t\tif (params != null) {\n\t\t\tthis.queryParams.putAll(params);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#setParsedRequestPath(requestPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the cached, parsed {@code RequestPath} to the given value.\n\t * @param requestPath the value to set to, or if {@code null} the cache\n\t * value is cleared.\n\t * @param request the current request\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request)",
    "source_code": "\tpublic static void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request) {\n\t\tif (requestPath != null) {\n\t\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\t}\n\t\telse {\n\t\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#uriVariables(Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure URI variables to be expanded at build time.\n\t * <p>The provided variables may be a subset of all required ones. At build\n\t * time, the available ones are expanded, while unresolved URI placeholders\n\t * are left in place and can still be expanded later.\n\t * <p>In contrast to {@link UriComponents#expand(Map)} or\n\t * {@link #buildAndExpand(Map)}, this method is useful when you need to\n\t * supply URI variables without building the {@link UriComponents} instance\n\t * just yet, or perhaps pre-expand some shared default values such as host\n\t * and port.\n\t * @param uriVariables the URI variables to use\n\t * @return this UriComponentsBuilder\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uriVariables(Map<String, Object> uriVariables)",
    "source_code": "\tpublic UriComponentsBuilder uriVariables(Map<String, Object> uriVariables) {\n\t\tthis.uriVariables.putAll(uriVariables);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#matches(pathIndex,matchingContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathIndex",
      "matchingContext"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(int pathIndex, MatchingContext matchingContext)",
    "source_code": "\tpublic boolean matches(int pathIndex, MatchingContext matchingContext) {\n\t\t// No need to handle 'match start' checking as this captures everything\n\t\t// anyway and cannot be followed by anything else\n\t\t// assert next == null\n\n\t\t// If there is more data, it must start with the separator\n\t\tif (pathIndex < matchingContext.pathLength && !matchingContext.isSeparator(pathIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (matchingContext.determineRemainingPath) {\n\t\t\tmatchingContext.remainingPathIndex = matchingContext.pathLength;\n\t\t}\n\t\tif (matchingContext.extractingVariables) {\n\t\t\t// Collect the parameters from all the remaining segments\n\t\t\tMultiValueMap<String,String> parametersCollector = null;\n\t\t\tfor (int i = pathIndex; i < matchingContext.pathLength; i++) {\n\t\t\t\tElement element = matchingContext.pathElements.get(i);\n\t\t\t\tif (element instanceof PathSegment pathSegment) {\n\t\t\t\t\tMultiValueMap<String, String> parameters = pathSegment.parameters();\n\t\t\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\t\t\tif (parametersCollector == null) {\n\t\t\t\t\t\t\tparametersCollector = new LinkedMultiValueMap<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparametersCollector.addAll(parameters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmatchingContext.set(this.variableName, pathToString(pathIndex, matchingContext.pathElements),\n\t\t\t\t\tparametersCollector == null?NO_PARAMETERS:parametersCollector);\n\t\t}\n\t\treturn true;\n\t}"
  }
}