{
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getAdvicesAndAdvisorsForBean(beanClass,beanName,customTargetSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the given bean is to be proxied, what additional\n\t * advices (for example, AOP Alliance interceptors) and advisors to apply.\n\t * @param beanClass the class of the bean to advise\n\t * @param beanName the name of the bean\n\t * @param customTargetSource the TargetSource returned by the\n\t * {@link #getCustomTargetSource} method: may be ignored.\n\t * Will be {@code null} if no custom target source is in use.\n\t * @return an array of additional interceptors for the particular bean;\n\t * or an empty array if no additional interceptors but just the common ones;\n\t * or {@code null} if no proxy at all, not even with the common interceptors.\n\t * See constants DO_NOT_PROXY and PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS.\n\t * @throws BeansException in case of errors\n\t * @see #DO_NOT_PROXY\n\t * @see #PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "customTargetSource"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource)",
    "source_code": "\tprotected abstract Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource) throws BeansException;\n\n}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getAdvicesAndAdvisorsForBean(beanClass,beanName,targetSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "targetSource"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, @Nullable TargetSource targetSource)",
    "source_code": "\tprotected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n\n\t\tList<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n\t\tif (advisors.isEmpty()) {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t\treturn advisors.toArray();\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#isMatch(beanName,mappedName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given bean name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param beanName the bean name to check\n\t * @param mappedName the name in the configured list of names\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String beanName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String beanName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, beanName);\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(writer,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void write(BasicJsonWriter writer, ReflectionHints hints)",
    "source_code": "\tpublic void write(BasicJsonWriter writer, ReflectionHints hints) {\n\t\twriter.writeArray(hints.typeHints()\n\t\t\t\t.sorted(Comparator.comparing(TypeHint::getType))\n\t\t\t\t.map(this::toAttributes).toList());\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn convertIfNecessary(null, value, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn convertIfNecessary((field != null ? field.getName() : null), value, requiredType,\n\t\t\t\t(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType,methodParam)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException {\n\n\t\treturn convertIfNecessary((methodParam != null ? methodParam.getParameterName() : null), value, requiredType,\n\t\t\t\t(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> @Nullable T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn convertIfNecessary(null, value, requiredType, typeDescriptor);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isAutowirable(parameter,parameterIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link Parameter} can <em>potentially</em> be\n\t * autowired from an {@link AutowireCapableBeanFactory}.\n\t * <p>Returns {@code true} if the supplied parameter is annotated or\n\t * meta-annotated with {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, or {@link Value @Value}.\n\t * <p>Note that {@link #resolveDependency} may still be able to resolve the\n\t * dependency for the supplied parameter even if this method returns {@code false}.\n\t * @param parameter the parameter whose dependency should be autowired\n\t * (must not be {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @see #resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean isAutowirable(Parameter parameter, int parameterIndex)",
    "source_code": "\tpublic static boolean isAutowirable(Parameter parameter, int parameterIndex) {\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\treturn (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||\n\t\t\t\tAnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#resolveDependency(parameter,parameterIndex,containingClass,beanFactory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the dependency for the supplied {@link Parameter} from the\n\t * supplied {@link AutowireCapableBeanFactory}.\n\t * <p>Provides comprehensive autowiring support for individual method parameters\n\t * on par with Spring's dependency injection facilities for autowired fields and\n\t * methods, including support for {@link Autowired @Autowired},\n\t * {@link Qualifier @Qualifier}, and {@link Value @Value} with support for property\n\t * placeholders and SpEL expressions in {@code @Value} declarations.\n\t * <p>The dependency is required unless the parameter is annotated or meta-annotated\n\t * with {@link Autowired @Autowired} with the {@link Autowired#required required}\n\t * flag set to {@code false}.\n\t * <p>If an explicit <em>qualifier</em> is not declared, the name of the parameter\n\t * will be used as the qualifier for resolving ambiguities.\n\t * @param parameter the parameter whose dependency should be resolved (must not be\n\t * {@code null})\n\t * @param parameterIndex the index of the parameter in the constructor or method\n\t * that declares the parameter\n\t * @param containingClass the concrete class that contains the parameter; this may\n\t * differ from the class that declares the parameter in that it may be a subclass\n\t * thereof, potentially substituting type variables (must not be {@code null})\n\t * @param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve\n\t * the dependency (must not be {@code null})\n\t * @return the resolved object, or {@code null} if none found\n\t * @throws BeansException if dependency resolution failed\n\t * @see #isAutowirable\n\t * @see Autowired#required\n\t * @see SynthesizingMethodParameter#forExecutable(Executable, int)\n\t * @see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "parameterIndex",
      "containingClass",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Object",
    "signature": "public Object resolveDependency(Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)",
    "source_code": "\tpublic static @Nullable Object resolveDependency(\n\t\t\tParameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(parameter, \"Parameter must not be null\");\n\t\tAssert.notNull(containingClass, \"Containing class must not be null\");\n\t\tAssert.notNull(beanFactory, \"AutowireCapableBeanFactory must not be null\");\n\n\t\tAnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex);\n\t\tAutowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class);\n\t\tboolean required = (autowired == null || autowired.required());\n\n\t\tMethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(\n\t\t\t\tparameter.getDeclaringExecutable(), parameterIndex);\n\t\tDependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required);\n\t\tdescriptor.setContainingClass(containingClass);\n\t\treturn beanFactory.resolveDependency(descriptor, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forMethod(methodName,parameterTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is optional.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredMethodArgumentsResolver forMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, false, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forRequiredMethod(methodName,parameterTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredMethodArgumentsResolver} for the specified\n\t * method where injection is required.\n\t * @param methodName the method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredFieldValueResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "AutowiredMethodArgumentsResolver",
    "signature": "public AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredMethodArgumentsResolver forRequiredMethod(String methodName, Class<?>... parameterTypes) {\n\t\treturn new AutowiredMethodArgumentsResolver(methodName, parameterTypes, true, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolve(registeredBean,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field for the specified registered bean and provide it to the\n\t * given action.\n\t * @param registeredBean the registered bean\n\t * @param action the action to execute with the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action)",
    "source_code": "\tpublic <T> void resolve(RegisteredBean registeredBean, ThrowingConsumer<T> action) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(action, \"'action' must not be null\");\n\t\tT resolved = resolve(registeredBean);\n\t\tif (resolved != null) {\n\t\t\taction.accept(resolved);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolve(registeredBean,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field value for the specified registered bean.\n\t * @param registeredBean the registered bean\n\t * @param requiredType the required type\n\t * @return the resolved field value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "T",
    "signature": "public T resolve(RegisteredBean registeredBean, Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T resolve(RegisteredBean registeredBean, Class<T> requiredType) {\n\t\tObject value = resolveObject(registeredBean);\n\t\tAssert.isInstanceOf(requiredType, value);\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolveAndInvoke(registeredBean,instance)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the method arguments for the specified registered bean and invoke\n\t * the method using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void resolveAndInvoke(RegisteredBean registeredBean, Object instance)",
    "source_code": "\tpublic void resolveAndInvoke(RegisteredBean registeredBean, Object instance) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\tMethod method = getMethod(registeredBean);\n\t\tAutowiredArguments resolved = resolveArguments(registeredBean, method);\n\t\tif (resolved != null) {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved.toArray());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolveAndSet(registeredBean,instance)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the field value for the specified registered bean and set it\n\t * using reflection.\n\t * @param registeredBean the registered bean\n\t * @param instance the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void resolveAndSet(RegisteredBean registeredBean, Object instance)",
    "source_code": "\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\tField field = getField(registeredBean);\n\t\tObject resolved = resolveValue(registeredBean, field);\n\t\tif (resolved != null) {\n\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\tReflectionUtils.setField(field, instance, resolved);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#setCustomEditors(Map<Class<?>,customEditors)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the custom editors to register via a {@link Map}, using the\n\t * class name of the required type as the key and the class name of the\n\t * associated {@link PropertyEditor} as value.\n\t * @see ConfigurableListableBeanFactory#registerCustomEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "customEditors"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setCustomEditors(Map<Class<?>, Class<? extends PropertyEditor>> customEditors)",
    "source_code": "\tpublic void setCustomEditors(Map<Class<?>, Class<? extends PropertyEditor>> customEditors) {\n\t\tthis.customEditors = customEditors;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#bean(name,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "T",
    "signature": "public T bean(String name, Class<T> requiredType)",
    "source_code": "\t\tpublic <T> T bean(String name, Class<T> requiredType) throws BeansException {\n\t\t\treturn this.beanFactory.getBean(name, requiredType);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluate(candidate,paramCount)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidate",
      "paramCount"
    ],
    "position": {
      "column": 1,
      "line": 1405
    },
    "return": "String[]",
    "signature": "public String[] evaluate(Constructor<?> candidate, int paramCount)",
    "source_code": "\t\tpublic static String[] evaluate(Constructor<?> candidate, int paramCount) {\n\t\t\tConstructorProperties cp = candidate.getAnnotation(ConstructorProperties.class);\n\t\t\tif (cp != null) {\n\t\t\t\tString[] names = cp.value();\n\t\t\t\tif (names.length != paramCount) {\n\t\t\t\t\tthrow new IllegalStateException(\"Constructor annotated with @ConstructorProperties but not \" +\n\t\t\t\t\t\t\t\"corresponding to actual number of parameters (\" + paramCount + \"): \" + candidate);\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#orderedStream(customFilter,includeNonSingletons)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customFilter",
      "includeNonSingletons"
    ],
    "position": {
      "column": 1,
      "line": 2556
    },
    "return": "Stream<Object>",
    "signature": "public Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons)",
    "source_code": "\t\tpublic Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {\n\t\t\tString[] beanNames = beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true);\n\t\t\tif (beanNames.length == 0) {\n\t\t\t\treturn Stream.empty();\n\t\t\t}\n\t\t\tMap<String, Object> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tif (AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, beanName) &&\n\t\t\t\t\t\tcustomFilter.test(getType(beanName))) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBean(beanClass,customizer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "public String registerBean(Class<T> beanClass, Consumer<Spec<T>> customizer)",
    "source_code": "\tpublic <T> String registerBean(Class<T> beanClass, Consumer<Spec<T>> customizer) {\n\t\tString beanName = BeanDefinitionReaderUtils.uniqueBeanName(beanClass.getName(), this.beanRegistry);\n\t\tregisterBean(beanName, beanClass, customizer);\n\t\treturn beanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBean(name,beanClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "beanClass"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void registerBean(String name, Class<T> beanClass)",
    "source_code": "\tpublic <T> void registerBean(String name, Class<T> beanClass) {\n\t\tBeanRegistrarBeanDefinition beanDefinition = new BeanRegistrarBeanDefinition(beanClass, this.beanRegistrarClass);\n\t\tif (this.customizers != null && this.customizers.containsKey(name)) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : this.customizers.get(name)) {\n\t\t\t\tcustomizer.customize(beanDefinition);\n\t\t\t}\n\t\t}\n\t\tthis.beanRegistry.registerBeanDefinition(name, beanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBean(name,beanClass,spec)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "beanClass",
      "spec"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void registerBean(String name, Class<T> beanClass, Consumer<Spec<T>> spec)",
    "source_code": "\tpublic <T> void registerBean(String name, Class<T> beanClass, Consumer<Spec<T>> spec) {\n\t\tBeanRegistrarBeanDefinition beanDefinition = new BeanRegistrarBeanDefinition(beanClass, this.beanRegistrarClass);\n\t\tspec.accept(new BeanSpecAdapter<>(beanDefinition, this.beanFactory));\n\t\tif (this.customizers != null && this.customizers.containsKey(name)) {\n\t\t\tfor (BeanDefinitionCustomizer customizer : this.customizers.get(name)) {\n\t\t\t\tcustomizer.customize(beanDefinition);\n\t\t\t}\n\t\t}\n\t\tthis.beanRegistry.registerBeanDefinition(name, beanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#stream(customFilter,includeNonSingletons)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customFilter",
      "includeNonSingletons"
    ],
    "position": {
      "column": 1,
      "line": 2547
    },
    "return": "Stream<Object>",
    "signature": "public Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons)",
    "source_code": "\t\tpublic Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {\n\t\t\treturn Arrays.stream(beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true))\n\t\t\t\t\t.filter(name -> AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, name))\n\t\t\t\t\t.filter(name -> customFilter.test(getType(name)))\n\t\t\t\t\t.map(name -> getBean(name))\n\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#supplier(Function<SupplierContext,supplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<SupplierContext",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Spec<T>",
    "signature": "public Spec<T> supplier(Function<SupplierContext, T> supplier)",
    "source_code": "\t\tpublic Spec<T> supplier(Function<SupplierContext, T> supplier) {\n\t\t\tthis.beanDefinition.setInstanceSupplier(() ->\n\t\t\t\t\tsupplier.apply(new SupplierContextAdapter(this.beanFactory)));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.cache.annotation.<unknown>#adapt(Function<CachingConfigurer,provider)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Adapt the {@link CachingConfigurer} supplier to another supplier\n\t\t * provided by the specified mapping function. If the underlying\n\t\t * {@link CachingConfigurer} is {@code null}, {@code null} is returned\n\t\t * and the mapping function is not invoked.\n\t\t * @param provider the provider to use to adapt the supplier\n\t\t * @param <T> the type of the supplier\n\t\t * @return another supplier mapped by the specified function\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<CachingConfigurer",
      "provider"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "T>",
    "signature": "public T> adapt(Function<CachingConfigurer, @Nullable T> provider)",
    "source_code": "\t\tpublic <T> Supplier<@Nullable T> adapt(Function<CachingConfigurer, @Nullable T> provider) {\n\t\t\treturn () -> {\n\t\t\t\tCachingConfigurer cachingConfigurer = this.supplier.get();\n\t\t\t\treturn (cachingConfigurer != null ? provider.apply(cachingConfigurer) : null);\n\t\t\t};\n\t\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#get(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.store.computeIfAbsent(key, k -> {\n\t\t\ttry {\n\t\t\t\treturn toStoreValue(valueLoader.call());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.store.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject existing = this.store.putIfAbsent(key, toStoreValue(value));\n\t\treturn toValueWrapper(existing);\n\t}"
  },
  "org.springframework.cache.concurrent.<unknown>#retrieve(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn CompletableFuture.supplyAsync(() ->\n\t\t\t\t(T) fromStoreValue(this.store.computeIfAbsent(key, k -> toStoreValue(valueLoader.get().join()))));\n\t}"
  },
  "org.springframework.cache.config.<unknown>#doParse(element,parserContext,builder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "parserContext",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)",
    "source_code": "\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tbuilder.addPropertyReference(\"cacheManager\", CacheNamespaceHandler.extractCacheManager(element));\n\t\tCacheNamespaceHandler.parseKeyGenerator(element, builder.getBeanDefinition());\n\n\t\tList<Element> cacheDefs = DomUtils.getChildElementsByTagName(element, DEFS_ELEMENT);\n\t\tif (!cacheDefs.isEmpty()) {\n\t\t\t// Using attributes source.\n\t\t\tList<RootBeanDefinition> attributeSourceDefinitions = parseDefinitionsSources(cacheDefs, parserContext);\n\t\t\tbuilder.addPropertyValue(\"cacheOperationSources\", attributeSourceDefinitions);\n\t\t}\n\t\telse {\n\t\t\t// Assume annotations source.\n\t\t\tbuilder.addPropertyValue(\"cacheOperationSources\",\n\t\t\t\t\tnew RootBeanDefinition(\"org.springframework.cache.annotation.AnnotationCacheOperationSource\"));\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doClear(cache,immediate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#clear()} on the specified {@link Cache} and\n\t * invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "immediate"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "protected void doClear(Cache cache, boolean immediate)",
    "source_code": "\tprotected void doClear(Cache cache, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.invalidate();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheClearError(ex, cache);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doEvict(cache,key,immediate)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#evict(Object)}/{@link Cache#evictIfPresent(Object)} on the\n\t * specified {@link Cache} and invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "immediate"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "protected void doEvict(Cache cache, Object key, boolean immediate)",
    "source_code": "\tprotected void doEvict(Cache cache, Object key, boolean immediate) {\n\t\ttry {\n\t\t\tif (immediate) {\n\t\t\t\tcache.evictIfPresent(key);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcache.evict(key);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheEvictError(ex, cache, key);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doGet(cache,key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#get(Object, Callable)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#get(Object, Callable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "T",
    "signature": "protected T doGet(Cache cache, Object key, Callable<T> valueLoader)",
    "source_code": "\tprotected <T> @Nullable T doGet(Cache cache, Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.get(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\ttry {\n\t\t\t\treturn valueLoader.call();\n\t\t\t}\n\t\t\tcatch (Exception ex2) {\n\t\t\t\tthrow new RuntimeException(ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doPut(cache,key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#put(Object, Object)} on the specified {@link Cache}\n\t * and invoke the error handler if an exception occurs.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "protected void doPut(Cache cache, Object key, @Nullable Object value)",
    "source_code": "\tprotected void doPut(Cache cache, Object key, @Nullable Object value) {\n\t\ttry {\n\t\t\tcache.put(key, value);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCachePutError(ex, cache, key, value);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#doRetrieve(cache,key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute {@link Cache#retrieve(Object, Supplier)} on the specified\n\t * {@link Cache} and invoke the error handler if an exception occurs.\n\t * Invokes the {@code valueLoader} if the handler does not throw any\n\t * exception, which simulates a cache read-through in case of error.\n\t * @since 6.2\n\t * @see Cache#retrieve(Object, Supplier)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cache",
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "CompletableFuture<T>",
    "signature": "protected CompletableFuture<T> doRetrieve(Cache cache, Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tprotected <T> CompletableFuture<T> doRetrieve(Cache cache, Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\ttry {\n\t\t\treturn cache.retrieve(key, valueLoader);\n\t\t}\n\t\tcatch (Cache.ValueRetrievalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tgetErrorHandler().handleCacheGetError(ex, cache, key);\n\t\t\treturn valueLoader.get();\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.<unknown>#get(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn (T) this.cache.invoke(key, this.valueLoaderEntryProcessor, valueLoader);\n\t\t}\n\t\tcatch (EntryProcessorException ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex.getCause());\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.<unknown>#process(MutableEntry<Object,entry,arguments)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MutableEntry<Object",
      "entry",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "Object",
    "signature": "public Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments)",
    "source_code": "\t\tpublic @Nullable Object process(MutableEntry<Object, @Nullable Object> entry, @Nullable Object... arguments) throws EntryProcessorException {\n\t\t\tCallable<Object> valueLoader = (Callable<Object>) arguments[0];\n\t\t\tif (entry.exists()) {\n\t\t\t\treturn this.fromStoreValue.apply(Objects.requireNonNull(entry.getValue()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject value;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = Objects.requireNonNull(valueLoader).call();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new EntryProcessorException(\"Value loader '\" + valueLoader + \"' failed \" +\n\t\t\t\t\t\t\t\"to compute value for key '\" + entry.getKey() + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tentry.setValue(this.toStoreValue.apply(value));\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cache.jcache.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.jcache.<unknown>#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tObject previous = this.cache.invoke(key, PutIfAbsentEntryProcessor.INSTANCE, toStoreValue(value));\n\t\treturn (previous != null ? toValueWrapper(previous) : null);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#cacheException(exceptionCache,filter,cacheKey,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionCache",
      "filter",
      "cacheKey",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "protected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex)",
    "source_code": "\tprotected void cacheException(@Nullable Cache exceptionCache, ExceptionTypeFilter filter, Object cacheKey, Throwable ex) {\n\t\tif (exceptionCache == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (filter.match(ex.getClass())) {\n\t\t\tdoPut(exceptionCache, cacheKey, ex);\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#checkForCachedException(exceptionCache,cacheKey)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a cached exception. If the exception is found, throw it directly.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionCache",
      "cacheKey"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "protected void checkForCachedException(@Nullable Cache exceptionCache, Object cacheKey)",
    "source_code": "\tprotected void checkForCachedException(@Nullable Cache exceptionCache, Object cacheKey) {\n\t\tif (exceptionCache == null) {\n\t\t\treturn;\n\t\t}\n\t\tCache.ValueWrapper result = doGet(exceptionCache, cacheKey);\n\t\tif (result != null) {\n\t\t\tThrowable ex = (Throwable) result.get();\n\t\t\tAssert.state(ex != null, \"No exception in cache\");\n\t\t\tthrow rewriteCallStack(ex, getClass().getName(), \"invoke\");\n\t\t}\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#invoke(context,invoker)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "invoker"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "Object",
    "signature": "protected Object invoke(CacheOperationInvocationContext<CacheResultOperation> context, CacheOperationInvoker invoker)",
    "source_code": "\tprotected @Nullable Object invoke(\n\t\t\tCacheOperationInvocationContext<CacheResultOperation> context, CacheOperationInvoker invoker) {\n\n\t\tCacheResultOperation operation = context.getOperation();\n\t\tObject cacheKey = generateKey(context);\n\n\t\tCache cache = resolveCache(context);\n\t\tCache exceptionCache = resolveExceptionCache(context);\n\n\t\tif (!operation.isAlwaysInvoked()) {\n\t\t\tCache.ValueWrapper cachedValue = doGet(cache, cacheKey);\n\t\t\tif (cachedValue != null) {\n\t\t\t\treturn cachedValue.get();\n\t\t\t}\n\t\t\tcheckForCachedException(exceptionCache, cacheKey);\n\t\t}\n\n\t\ttry {\n\t\t\tObject invocationResult = invoker.invoke();\n\t\t\tdoPut(cache, cacheKey, invocationResult);\n\t\t\treturn invocationResult;\n\t\t}\n\t\tcatch (CacheOperationInvoker.ThrowableWrapper ex) {\n\t\t\tThrowable original = ex.getOriginal();\n\t\t\tcacheException(exceptionCache, operation.getExceptionTypeFilter(), cacheKey, original);\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.cache.support.<unknown>#get(key,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "T",
    "signature": "public T get(Object key, @Nullable Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.cache.support.<unknown>#get(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\ttry {\n\t\t\treturn valueLoader.call();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ValueRetrievalException(key, valueLoader, ex);\n\t\t}\n\t}"
  },
  "org.springframework.cache.support.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t}"
  },
  "org.springframework.cache.support.<unknown>#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.cache.support.<unknown>#retrieve(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn valueLoader.get();\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#get(key,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "T",
    "signature": "public T get(Object key, @Nullable Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, @Nullable Class<T> type) {\n\t\treturn this.targetCache.get(key, type);\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#get(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> @Nullable T get(Object key, Callable<T> valueLoader) {\n\t\treturn this.targetCache.get(key, valueLoader);\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void put(final Object key, final @Nullable Object value)",
    "source_code": "\tpublic void put(final Object key, final @Nullable Object value) {\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {\n\t\t\t\t@Override\n\t\t\t\tpublic void afterCommit() {\n\t\t\t\t\tTransactionAwareCacheDecorator.this.targetCache.put(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.targetCache.put(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#putIfAbsent(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic @Nullable ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\treturn this.targetCache.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.cache.transaction.<unknown>#retrieve(key,valueLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn this.targetCache.retrieve(key, valueLoader);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#forField(fieldName,resourceName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceFieldResolver} for the specified field and resource name.\n\t * @param fieldName the field name\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceFieldResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldName",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forField(String fieldName, String resourceName)",
    "source_code": "\tpublic static ResourceElementResolver forField(String fieldName, String resourceName) {\n\t\treturn new ResourceFieldResolver(resourceName, false, fieldName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#forMethod(methodName,parameterType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceMethodResolver} for the specified method\n\t * using a resource name that infers from the method name.\n\t * @param methodName the method name\n\t * @param parameterType the parameter type.\n\t * @return a new {@link ResourceMethodResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forMethod(String methodName, Class<?> parameterType)",
    "source_code": "\tpublic static ResourceElementResolver forMethod(String methodName, Class<?> parameterType) {\n\t\treturn new ResourceMethodResolver(defaultResourceNameForMethod(methodName), true,\n\t\t\t\tmethodName, parameterType);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#forMethod(methodName,parameterType,resourceName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ResourceMethodResolver} for the specified method\n\t * and resource name.\n\t * @param methodName the method name\n\t * @param parameterType the parameter type\n\t * @param resourceName the resource name\n\t * @return a new {@link ResourceMethodResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "parameterType",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "ResourceElementResolver",
    "signature": "public ResourceElementResolver forMethod(String methodName, Class<?> parameterType, String resourceName)",
    "source_code": "\tpublic static ResourceElementResolver forMethod(String methodName, Class<?> parameterType, String resourceName) {\n\t\treturn new ResourceMethodResolver(resourceName, false, methodName, parameterType);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#matches(context,metadata)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "boolean",
    "signature": "public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)",
    "source_code": "\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tMultiValueMap<String, @Nullable Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n\t\tif (attrs != null) {\n\t\t\tfor (Object value : attrs.get(\"value\")) {\n\t\t\t\tif (context.getEnvironment().matchesProfiles((String[]) value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#resolveAndSet(registeredBean,instance)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instance"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "public void resolveAndSet(RegisteredBean registeredBean, Object instance)",
    "source_code": "\t\tpublic void resolveAndSet(RegisteredBean registeredBean, Object instance) {\n\t\t\tAssert.notNull(registeredBean, \"'registeredBean' must not be null\");\n\t\t\tAssert.notNull(instance, \"'instance' must not be null\");\n\t\t\tMethod method = getMethod(registeredBean);\n\t\t\tObject resolved = resolve(registeredBean);\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\tReflectionUtils.invokeMethod(method, instance, resolved);\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#createMessageFormat(msg,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code MessageFormat} for the given message and Locale.\n\t * @param msg the message to create a {@code MessageFormat} for\n\t * @param locale the Locale to create a {@code MessageFormat} for\n\t * @return the {@code MessageFormat} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "msg",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat createMessageFormat(String msg, Locale locale)",
    "source_code": "\tprotected MessageFormat createMessageFormat(String msg, Locale locale) {\n\t\treturn new MessageFormat(msg, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#formatMessage(msg,args,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Format the given message String, using cached MessageFormats.\n\t * By default invoked for passed-in default messages, to resolve\n\t * any argument placeholders found in them.\n\t * @param msg the message to format\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none\n\t * @param locale the Locale used for formatting\n\t * @return the formatted message (with resolved arguments)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "msg",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String",
    "signature": "protected String formatMessage(String msg, Object @Nullable [] args, Locale locale)",
    "source_code": "\tprotected String formatMessage(String msg, Object @Nullable [] args, Locale locale) {\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\treturn msg;\n\t\t}\n\t\tMap<Locale, MessageFormat> messageFormatsPerLocale = this.messageFormatsPerMessage\n\t\t\t\t.computeIfAbsent(msg, key -> new ConcurrentHashMap<>());\n\t\tMessageFormat messageFormat = messageFormatsPerLocale.computeIfAbsent(locale, key -> {\n\t\t\ttry {\n\t\t\t\treturn createMessageFormat(msg, locale);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid message format - probably not intended for formatting,\n\t\t\t\t// rather using a message structure with no arguments involved...\n\t\t\t\tif (isAlwaysUseMessageFormat()) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Silently proceed with raw message if format not enforced...\n\t\t\t\treturn INVALID_MESSAGE_FORMAT;\n\t\t\t}\n\t\t});\n\t\tif (messageFormat == INVALID_MESSAGE_FORMAT) {\n\t\t\treturn msg;\n\t\t}\n\t\tsynchronized (messageFormat) {\n\t\t\treturn messageFormat.format(resolveArguments(args, locale));\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, getDefaultLocale());\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "String",
    "signature": "public String getMessage(String code, Object @Nullable [] args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, Object @Nullable [] args, String defaultMessage) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, getDefaultLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the default Locale.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\tString msg = this.messageSource.getMessage(code, null, defaultMessage, getDefaultLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,defaultMessage,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage, Locale locale) {\n\t\tString msg = this.messageSource.getMessage(code, null, defaultMessage, locale);\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code and the given Locale.\n\t * @param code the code of the message\n\t * @param locale the Locale in which to do lookup\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "public String getMessage(String code, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, null, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#renderDefaultMessage(defaultMessage,args,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Render the given default message String. The default message is\n\t * passed in as specified by the caller and can be rendered into\n\t * a fully formatted default message shown to the user.\n\t * <p>The default implementation passes the String to {@code formatMessage},\n\t * resolving any argument placeholders found in them. Subclasses may override\n\t * this method to plug in custom processing of default messages.\n\t * @param defaultMessage the passed-in default message String\n\t * @param args array of arguments that will be filled in for params within\n\t * the message, or {@code null} if none.\n\t * @param locale the Locale used for formatting\n\t * @return the rendered default message (with resolved arguments)\n\t * @see #formatMessage(String, Object[], java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "defaultMessage",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "String",
    "signature": "protected String renderDefaultMessage(String defaultMessage, Object @Nullable [] args, Locale locale)",
    "source_code": "\tprotected String renderDefaultMessage(String defaultMessage, Object @Nullable [] args, Locale locale) {\n\t\treturn formatMessage(defaultMessage, args, locale);\n\t}"
  },
  "org.springframework.core.<unknown>#forParameter(executable,parameterIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "Nullness",
    "signature": "public Nullness forParameter(Executable executable, int parameterIndex)",
    "source_code": "\t\tpublic static Nullness forParameter(Executable executable, int parameterIndex) {\n\t\t\tKFunction<?> function;\n\t\t\tPredicate<KParameter> predicate;\n\t\t\tif (executable instanceof Method method) {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tpredicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction((Constructor<?>) executable);\n\t\t\t\tpredicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||\n\t\t\t\t\t\tKParameter.Kind.INSTANCE.equals(p.getKind()));\n\t\t\t}\n\t\t\tif (function == null) {\n\t\t\t\treturn Nullness.UNSPECIFIED;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\tif (predicate.test(kParameter) && parameterIndex == i++) {\n\t\t\t\t\treturn (kParameter.getType().isMarkedNullable() ? Nullness.NULLABLE : Nullness.NON_NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Nullness.UNSPECIFIED;\n\t\t}"
  },
  "org.springframework.core.<unknown>#transformIfNecessary(name,bytes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Transformation hook to be implemented by subclasses.\n\t * <p>The default implementation simply returns the given bytes as-is.\n\t * @param name the fully-qualified name of the class being transformed\n\t * @param bytes the raw bytes of the class\n\t * @return the transformed bytes (never {@code null};\n\t * same as the input bytes if the transformation produced no changes)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "byte[]",
    "signature": "protected byte[] transformIfNecessary(String name, byte[] bytes)",
    "source_code": "\tprotected byte[] transformIfNecessary(String name, byte[] bytes) {\n\t\treturn bytes;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#and(container,repeatable)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an additional explicit relationship between a container and\n\t * repeatable annotation.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #of(Class, Class)}.\n\t * @param container the container annotation type\n\t * @param repeatable the repeatable annotation type\n\t * @return a new {@link RepeatableContainers} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "container",
      "repeatable"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers and(Class<? extends Annotation> container,\n\t\t\tClass<? extends Annotation> repeatable)",
    "source_code": "\tpublic RepeatableContainers and(Class<? extends Annotation> container,\n\t\t\tClass<? extends Annotation> repeatable) {\n\n\t\treturn new ExplicitRepeatableContainer(this, repeatable, container);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#doWithAggregate(context,aggregateIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "aggregateIndex"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex)",
    "source_code": "\t\tpublic @Nullable MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {\n\t\t\treturn this.result;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#doWithAnnotations(criteria,aggregateIndex,source,annotations)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "criteria",
      "aggregateIndex",
      "source",
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "List<Aggregate>",
    "signature": "public List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations)",
    "source_code": "\t\tpublic @Nullable List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations) {\n\n\t\t\tthis.aggregates.add(createAggregate(aggregateIndex, source, annotations));\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#doWithAnnotations(requiredType,aggregateIndex,source,annotations)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "aggregateIndex",
      "source",
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Boolean",
    "signature": "public Boolean doWithAnnotations(Object requiredType, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations)",
    "source_code": "\t\tpublic @Nullable Boolean doWithAnnotations(Object requiredType, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations) {\n\n\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\tif (annotation != null) {\n\t\t\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\t\t\tif (type != null && !this.annotationFilter.matches(type)) {\n\t\t\t\t\t\tif (type == requiredType || type.getName().equals(requiredType)) {\n\t\t\t\t\t\t\treturn Boolean.TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAnnotation[] repeatedAnnotations =\n\t\t\t\t\t\t\t\tthis.repeatableContainers.findRepeatedAnnotations(annotation);\n\t\t\t\t\t\tif (repeatedAnnotations != null) {\n\t\t\t\t\t\t\tBoolean result = doWithAnnotations(\n\t\t\t\t\t\t\t\t\trequiredType, aggregateIndex, source, repeatedAnnotations);\n\t\t\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this.directOnly) {\n\t\t\t\t\t\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(type);\n\t\t\t\t\t\t\tfor (int i = 0; i < mappings.size(); i++) {\n\t\t\t\t\t\t\t\tAnnotationTypeMapping mapping = mappings.get(i);\n\t\t\t\t\t\t\t\tif (isMappingForType(mapping, this.annotationFilter, requiredType)) {\n\t\t\t\t\t\t\t\t\treturn Boolean.TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#doWithAnnotations(type,aggregateIndex,source,annotations)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "aggregateIndex",
      "source",
      "annotations"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations)",
    "source_code": "\t\tpublic @Nullable MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations) {\n\n\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\tif (annotation != null && !annotationFilter.matches(annotation)) {\n\t\t\t\t\tMergedAnnotation<A> result = process(type, aggregateIndex, source, annotation);\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAllMergedAnnotations(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn findAnnotations(element).stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAllMergedAnnotations(element,annotationTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 687
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\n\t\treturn findAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedAnnotation(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "A",
    "signature": "public A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\n\t * algorithm used by this method will stop searching the annotation\n\t * hierarchy once the first annotation of the specified\n\t * {@code annotationName} has been found. As a consequence, additional\n\t * annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = findAnnotations(element)\n\t\t\t\t.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedAnnotationAttributes(element,annotationType,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\n\t * used by this method will stop searching the annotation hierarchy once the\n\t * first annotation of the specified {@code annotationType} has been found.\n\t * As a consequence, additional annotations of the specified\n\t * {@code annotationType} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into\n\t * Strings or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedRepeatableAnnotations(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "Set<A>",
    "signature": "public Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn findMergedRepeatableAnnotations(element, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findMergedRepeatableAnnotations(element,annotationType,containerType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "containerType"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "Set<A>",
    "signature": "public Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn findRepeatableAnnotations(element, containerType, annotationType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType,predicate)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate) {\n\n\t\treturn get(annotationType, predicate, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#get(annotationType,predicate,selector)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "predicate",
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "MergedAnnotation<A>",
    "signature": "public MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector)",
    "source_code": "\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector) {\n\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn MergedAnnotation.missing();\n\t\t}\n\t\tMergedAnnotation<A> result = scan(annotationType,\n\t\t\t\tnew MergedAnnotationFinder<>(annotationType, predicate, selector));\n\t\treturn (result != null ? result : MergedAnnotation.missing());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllAnnotationAttributes(element,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of the specified\n\t * {@code annotationName} in the annotation hierarchy above the supplied\n\t * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(\n\t\t\tAnnotatedElement element, String annotationName) {\n\n\t\treturn getAllAnnotationAttributes(element, annotationName, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of\n\t * the specified {@code annotationName} in the annotation hierarchy above\n\t * the supplied {@link AnnotatedElement} and store the results in a\n\t * {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn getAnnotations(element).stream(annotationName)\n\t\t\t\t.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllMergedAnnotations(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "Set<A>",
    "signature": "public Set<A> getAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getAllMergedAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType) {\n\n\t\treturn getAnnotations(element).stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAllMergedAnnotations(element,annotationTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "Set<Annotation>",
    "signature": "public Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes) {\n\n\t\treturn getAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getEnum(attributeName,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "E",
    "signature": "public E getEnum(String attributeName, Class<E> type)",
    "source_code": "\tpublic <E extends Enum<E>> E getEnum(String attributeName, Class<E> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn getRequiredAttributeValue(attributeName, type);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getEnumArray(attributeName,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "E[]",
    "signature": "public E[] getEnumArray(String attributeName, Class<E> type)",
    "source_code": "\tpublic <E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (E[]) getRequiredAttributeValue(attributeName, type.arrayType());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotation(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "A",
    "signature": "public A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> @Nullable A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotationAttributes(element,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\n\t * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName) {\n\n\t\treturn getMergedAnnotationAttributes(element, annotationName, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override attributes\n\t * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\n\t * fully supported, both within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\n\t * this method will stop searching the annotation hierarchy once the first annotation\n\t * of the specified {@code annotationName} has been found. As a consequence,\n\t * additional annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\n\t * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedAnnotationAttributes(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(\n\t\t\tAnnotatedElement element, Class<? extends Annotation> annotationType) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedRepeatableAnnotations(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "Set<A>",
    "signature": "public Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType) {\n\n\t\treturn getMergedRepeatableAnnotations(element, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMergedRepeatableAnnotations(element,annotationType,containerType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType",
      "containerType"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "Set<A>",
    "signature": "public Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn getRepeatableAnnotations(element, containerType, annotationType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMetaAnnotationTypes(element,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Set<String>",
    "signature": "public Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tif (annotation.annotationType().getName().equals(annotationName)) {\n\t\t\t\treturn getMetaAnnotationTypes(element, annotation);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getMetaAnnotationTypes(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the fully qualified class names of all meta-annotation types\n\t * <em>present</em> on the annotation (of the specified {@code annotationType})\n\t * on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if not found\n\t * @since 4.2\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, String)\n\t * @see #hasMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Set<String>",
    "signature": "public Set<String> getMetaAnnotationTypes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType)",
    "source_code": "\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\treturn getMetaAnnotationTypes(element, element.getAnnotation(annotationType));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getValue(attributeName,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> getValue(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T> Optional<T> getValue(String attributeName, Class<T> type) {\n\t\treturn Optional.ofNullable(getAttributeValue(attributeName, type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#hasAnnotation(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>available</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.3\n\t * @see #isAnnotated(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "boolean",
    "signature": "public boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element).isPresent(annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#hasMetaAnnotationTypes(element,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with a\n\t * <em>composed annotation</em> that is meta-annotated with an annotation\n\t * of the specified {@code annotationName}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the\n\t * meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @see #getMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "boolean",
    "signature": "public boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#hasMetaAnnotationTypes(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with\n\t * a <em>composed annotation</em> that is meta-annotated with an\n\t * annotation of the specified {@code annotationType}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @since 4.2.3\n\t * @see #getMetaAnnotationTypes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "boolean",
    "signature": "public boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotated(element,annotationName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationName} is\n\t * <em>present</em> on the supplied {@link AnnotatedElement} or within the\n\t * annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "boolean",
    "signature": "public boolean isAnnotated(AnnotatedElement element, String annotationName)",
    "source_code": "\tpublic static boolean isAnnotated(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).isPresent(annotationName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotated(element,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.2.3\n\t * @see #hasAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "boolean",
    "signature": "public boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element).isPresent(annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#of(repeatable,container)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RepeatableContainers} instance that uses predefined\n\t * repeatable and container types.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #and(Class, Class)}.\n\t * @param repeatable the repeatable annotation type\n\t * @param container the container annotation type or {@code null}. If specified,\n\t * this annotation must declare a {@code value} attribute returning an array\n\t * of repeatable annotations. If not specified, the container will be\n\t * deduced by inspecting the {@code @Repeatable} annotation on\n\t * {@code repeatable}.\n\t * @return a {@link RepeatableContainers} instance\n\t * @throws IllegalArgumentException if the supplied container type is\n\t * {@code null} and the annotation type is not a repeatable annotation\n\t * @throws AnnotationConfigurationException if the supplied container type\n\t * is not a properly configured container for a repeatable annotation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "repeatable",
      "container"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "RepeatableContainers",
    "signature": "public RepeatableContainers of(Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container)",
    "source_code": "\tpublic static RepeatableContainers of(\n\t\t\tClass<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\n\n\t\treturn new ExplicitRepeatableContainer(null, repeatable, container);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encodeValue(buffer,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffer",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Buffer buffer, DataBufferFactory bufferFactory, ResolvableType valueType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Buffer buffer, DataBufferFactory bufferFactory, ResolvableType valueType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + buffer.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof Netty5DataBufferFactory netty5DataBufferFactory) {\n\t\t\treturn netty5DataBufferFactory.wrap(buffer);\n\t\t}\n\t\tbyte[] bytes = new byte[buffer.readableBytes()];\n\t\tbuffer.readBytes(bytes, 0, bytes.length);\n\t\tbuffer.close();\n\t\treturn bufferFactory.wrap(bytes);\n\t}"
  },
  "org.springframework.core.env.<unknown>#convertValueIfNecessary(value,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given value to the specified target type, if necessary.\n\t * @param value the original property value\n\t * @param targetType the specified target type for property retrieval\n\t * @return the converted value, or the original value if no conversion\n\t * is necessary\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "T",
    "signature": "protected T convertValueIfNecessary(Object value, @Nullable Class<T> targetType)",
    "source_code": "\tprotected <T> @Nullable T convertValueIfNecessary(Object value, @Nullable Class<T> targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tConversionService conversionServiceToUse = this.conversionService;\n\t\tif (conversionServiceToUse == null) {\n\t\t\t// Avoid initialization of shared DefaultConversionService if\n\t\t\t// no standard type conversion is needed in the first place...\n\t\t\tif (ClassUtils.isAssignableValue(targetType, value)) {\n\t\t\t\treturn (T) value;\n\t\t\t}\n\t\t\tconversionServiceToUse = DefaultConversionService.getSharedInstance();\n\t\t}\n\t\treturn conversionServiceToUse.convert(value, targetType);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,defaultValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "String",
    "signature": "public String getProperty(String key, String defaultValue)",
    "source_code": "\tpublic String getProperty(String key, String defaultValue) {\n\t\tString value = getProperty(key);\n\t\treturn (value != null ? value : defaultValue);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetType)",
    "source_code": "\tpublic <T> @Nullable T getProperty(String key, Class<T> targetType) {\n\t\treturn this.propertyResolver.getProperty(key, targetType);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetType,defaultValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetType, T defaultValue)",
    "source_code": "\tpublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n\t\tT value = getProperty(key, targetType);\n\t\treturn (value != null ? value : defaultValue);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getRequiredProperty(key,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "T",
    "signature": "public T getRequiredProperty(String key, Class<T> targetType)",
    "source_code": "\tpublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key, targetType);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getRequiredProperty(key,valueType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "T",
    "signature": "public T getRequiredProperty(String key, Class<T> valueType)",
    "source_code": "\tpublic <T> T getRequiredProperty(String key, Class<T> valueType) throws IllegalStateException {\n\t\tT value = getProperty(key, valueType);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\"Required key '\" + key + \"' not found\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#forResourceLocation(resourceLocation,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the given class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @param classLoader the ClassLoader to use for loading resources;\n\t * can be {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLocation",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "SpringFactoriesLoader",
    "signature": "public SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader) {\n\t\tAssert.hasText(resourceLocation, \"'resourceLocation' must not be empty\");\n\t\tClassLoader resourceClassLoader = (classLoader != null ? classLoader :\n\t\t\t\tSpringFactoriesLoader.class.getClassLoader());\n\t\tMap<String, SpringFactoriesLoader> loaders = cache.computeIfAbsent(\n\t\t\t\tresourceClassLoader, key -> new ConcurrentReferenceHashMap<>());\n\t\treturn loaders.computeIfAbsent(resourceLocation, key ->\n\t\t\t\tnew SpringFactoriesLoader(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#instantiateFactory(implementationName,type,argumentResolver,failureHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "implementationName",
      "type",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "T",
    "signature": "protected T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler)",
    "source_code": "\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\n\n\t\ttry {\n\t\t\tClass<?> factoryImplementationClass = ClassUtils.forName(implementationName, this.classLoader);\n\t\t\tAssert.isTrue(type.isAssignableFrom(factoryImplementationClass), () ->\n\t\t\t\t\t\"Class [%s] is not assignable to factory type [%s]\".formatted(implementationName, type.getName()));\n\t\t\tFactoryInstantiator<T> factoryInstantiator = FactoryInstantiator.forClass(factoryImplementationClass);\n\t\t\treturn factoryInstantiator.instantiate(argumentResolver);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureHandler.handleFailure(type, implementationName, ex);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#load(factoryType,argumentResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and the given argument resolver.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "argumentResolver"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\n\t\treturn load(factoryType, argumentResolver, null);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#load(factoryType,argumentResolver,failureHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\n\t * the given argument resolver, and custom failure handling provided by the given\n\t * failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler) {\n\n\t\tAssert.notNull(factoryType, \"'factoryType' must not be null\");\n\t\tList<String> implementationNames = loadFactoryNames(factoryType);\n\t\tlogger.trace(LogMessage.format(\"Loaded [%s] names: %s\", factoryType.getName(), implementationNames));\n\t\tList<T> result = new ArrayList<>(implementationNames.size());\n\t\tFailureHandler failureHandlerToUse = (failureHandler != null) ? failureHandler : THROWING_FAILURE_HANDLER;\n\t\tfor (String implementationName : implementationNames) {\n\t\t\tT factory = instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);\n\t\t\tif (factory != null) {\n\t\t\t\tresult.add(factory);\n\t\t\t}\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(result);\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#load(factoryType,failureHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * with custom failure handling provided by the given failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "List<T>",
    "signature": "public List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler)",
    "source_code": "\tpublic <T> List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler) {\n\t\treturn load(factoryType, null, failureHandler);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#loadFactories(factoryType,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For more advanced factory loading with {@link ArgumentResolver} or\n\t * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\n\t * to obtain a {@link SpringFactoriesLoader} instance.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null}\n\t * to use the default)\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "List<T>",
    "signature": "public List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).load(factoryType);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#loadFactoriesResource(classLoader,resourceLocation)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader",
      "resourceLocation"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "List<String>>",
    "signature": "protected List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation)",
    "source_code": "\tprotected static Map<String, List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\n\t\tMap<String, List<String>> result = new LinkedHashMap<>();\n\t\ttry {\n\t\t\tEnumeration<URL> urls = classLoader.getResources(resourceLocation);\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tUrlResource resource = new UrlResource(urls.nextElement());\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tproperties.forEach((name, value) -> {\n\t\t\t\t\tString[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) value);\n\t\t\t\t\tList<String> implementations = result.computeIfAbsent(((String) name).trim(),\n\t\t\t\t\t\t\tkey -> new ArrayList<>(factoryImplementationNames.length));\n\t\t\t\t\tArrays.stream(factoryImplementationNames).map(String::trim).forEach(implementations::add);\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult.replaceAll(SpringFactoriesLoader::toDistinctUnmodifiableList);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" + resourceLocation + \"]\", ex);\n\t\t}\n\t\treturn Collections.unmodifiableMap(result);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#loadFactoryNames(factoryType,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Load the fully qualified class names of factory implementations of the\n\t * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\n\t * class loader.\n\t * <p>As of Spring Framework 5.3, if a particular implementation class name\n\t * is discovered more than once for the given factory type, duplicates will\n\t * be ignored.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @throws IllegalArgumentException if an error occurs while loading factory names\n\t * @see #loadFactories\n\t * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "List<String>",
    "signature": "public List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).loadFactoryNames(factoryType);\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#add(factoryType,factoryImplementations)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory implementations to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryImplementations the implementation class names\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementations"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void add(String factoryType, String... factoryImplementations)",
    "source_code": "\tpublic void add(String factoryType, String... factoryImplementations) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(\n\t\t\t\tfactoryType, key -> new ArrayList<>());\n\t\tCollections.addAll(implementations, factoryImplementations);\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#addInstance(factoryType,factoryInstance)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class name\n\t * @param factoryInstance the implementation instances to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryInstance"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void addInstance(String factoryType, T... factoryInstance)",
    "source_code": "\tpublic <T> void addInstance(String factoryType, T... factoryInstance) {\n\t\tList<String> implementations = this.factories.computeIfAbsent(factoryType, key -> new ArrayList<>());\n\t\tfor (T factoryImplementation : factoryInstance) {\n\t\t\tString reference = \"!\" + factoryType + \":\" + factoryImplementation.getClass().getName()\n\t\t\t\t\t+ this.sequence.getAndIncrement();\n\t\t\timplementations.add(reference);\n\t\t\tthis.implementations.put(reference, factoryImplementation);\n\t\t}\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#addInstance(factoryType,factoryInstances)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add factory instances to this instance.\n\t * @param factoryType the factory type class\n\t * @param factoryInstances the implementation instances to add\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryInstances"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void addInstance(Class<T> factoryType, T... factoryInstances)",
    "source_code": "\tpublic <T> void addInstance(Class<T> factoryType, T... factoryInstances) {\n\t\taddInstance(factoryType.getName(), factoryInstances);\n\t}"
  },
  "org.springframework.core.test.io.support.<unknown>#instantiateFactory(implementationName,type,argumentResolver,failureHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "implementationName",
      "type",
      "argumentResolver",
      "failureHandler"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "T",
    "signature": "protected T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler)",
    "source_code": "\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\n\t\tif (implementationName.startsWith(\"!\")) {\n\t\t\tObject implementation = this.implementations.get(implementationName);\n\t\t\tif (implementation != null) {\n\t\t\t\treturn (T) implementation;\n\t\t\t}\n\t\t}\n\t\treturn super.instantiateFactory(implementationName, type, argumentResolver, failureHandler);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#convertTypedValue(context,typedValue,targetType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determines if there is a type converter available in the specified context and\n\t * attempts to use it to convert the supplied value to the specified type. Throws an\n\t * exception if conversion is not possible.\n\t * @param context the evaluation context that may define a type converter\n\t * @param typedValue the value to convert and a type descriptor describing it\n\t * @param targetType the type to attempt conversion to\n\t * @return the converted value\n\t * @throws EvaluationException if there is a problem during conversion or conversion\n\t * of the value to the specified type is not supported\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "typedValue",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "T",
    "signature": "public T convertTypedValue(@Nullable EvaluationContext context, TypedValue typedValue, @Nullable Class<T> targetType)",
    "source_code": "\tpublic static <T> @Nullable T convertTypedValue(\n\t\t\t@Nullable EvaluationContext context, TypedValue typedValue, @Nullable Class<T> targetType) {\n\n\t\tObject value = typedValue.getValue();\n\t\tif (targetType == null) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tif (context != null) {\n\t\t\treturn (T) context.getTypeConverter().convertValue(\n\t\t\t\t\tvalue, typedValue.getTypeDescriptor(), TypeDescriptor.valueOf(targetType));\n\t\t}\n\t\tif (ClassUtils.isAssignableValue(targetType, value)) {\n\t\t\treturn (T) value;\n\t\t}\n\t\tthrow new EvaluationException(\"Cannot convert value '\" + value + \"' to type '\" + targetType.getName() + \"'\");\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(context,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tString value = getValue(context);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), expectedResultType);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "String",
    "signature": "public String getValue(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic String getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn this.literalValue;\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(context,rootObject,desiredResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> desiredResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tString value = getValue(context, rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(value), desiredResultType);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValue(rootObject,desiredResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "desiredResultType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> desiredResultType) throws EvaluationException {\n\t\tString value = getValue(rootObject);\n\t\treturn ExpressionUtils.convertTypedValue(null, new TypedValue(value), desiredResultType);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#getValueTypeDescriptor(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn TypeDescriptor.valueOf(String.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#isWritable(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.common.<unknown>#setValue(context,rootObject,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.<unknown>#setValue(context,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.<unknown>#setValue(rootObject,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthrow new EvaluationException(this.literalValue, \"Cannot call setValue() on a LiteralExpression\");\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toBoolean(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a boolean using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "boolean",
    "signature": "public boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static boolean toBoolean(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Boolean.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toByte(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a byte using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "byte",
    "signature": "public byte toByte(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static byte toByte(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Byte.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toChar(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a char using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "char",
    "signature": "public char toChar(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static char toChar(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Character.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toDouble(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a double using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "double",
    "signature": "public double toDouble(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static double toDouble(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Double.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toFloat(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a float using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "float",
    "signature": "public float toFloat(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static float toFloat(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Float.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toInt(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to an int using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "int",
    "signature": "public int toInt(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static int toInt(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Integer.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toLong(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a long using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "long",
    "signature": "public long toLong(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static long toLong(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Long.class);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#toShort(typeConverter,typedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to convert a typed value to a short using the supplied type converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "typeConverter",
      "typedValue"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "short",
    "signature": "public short toShort(TypeConverter typeConverter, TypedValue typedValue)",
    "source_code": "\tpublic static short toShort(TypeConverter typeConverter, TypedValue typedValue) {\n\t\treturn convertValue(typeConverter, typedValue, Short.class);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isSuitable(target,targetType,argumentTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "targetType",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "boolean",
    "signature": "public boolean isSuitable(Object target, @Nullable TypeDescriptor targetType, List<TypeDescriptor> argumentTypes)",
    "source_code": "\t\tpublic boolean isSuitable(Object target, @Nullable TypeDescriptor targetType, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == target) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.targetType, targetType) && this.argumentTypes.equals(argumentTypes));\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isSuitable(value,target,argumentTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "target",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "boolean",
    "signature": "public boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes)",
    "source_code": "\t\tpublic boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == value) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes));\n\t\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#doParseExpression(expressionString,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "expressionString",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "SpelExpression",
    "signature": "protected SpelExpression doParseExpression(String expressionString, @Nullable ParserContext context)",
    "source_code": "\tprotected SpelExpression doParseExpression(String expressionString, @Nullable ParserContext context)\n\t\t\tthrows ParseException {\n\n\t\tcheckExpressionLength(expressionString);\n\n\t\ttry {\n\t\t\tthis.expressionString = expressionString;\n\t\t\tTokenizer tokenizer = new Tokenizer(expressionString);\n\t\t\tthis.tokenStream = tokenizer.process();\n\t\t\tthis.tokenStreamLength = this.tokenStream.size();\n\t\t\tthis.tokenStreamPointer = 0;\n\t\t\tthis.constructedNodes.clear();\n\t\t\tSpelNodeImpl ast = eatExpression();\n\t\t\tif (ast == null) {\n\t\t\t\tthrow new SpelParseException(this.expressionString, 0, SpelMessage.OOD);\n\t\t\t}\n\t\t\tToken t = peekToken();\n\t\t\tif (t != null) {\n\t\t\t\tthrow new SpelParseException(this.expressionString, t.startPos, SpelMessage.MORE_INPUT, toString(nextToken()));\n\t\t\t}\n\t\t\treturn new SpelExpression(expressionString, ast, this.configuration);\n\t\t}\n\t\tcatch (InternalParseException ex) {\n\t\t\tthrow ex.getCause();\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(context,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(context.getRootObject().getValue(), context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object",
    "signature": "public Object getValue(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable Object getValue(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\treturn compiledAst.getValue(rootObject, context);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tObject result = this.ast.getValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(context,rootObject,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "T",
    "signature": "public T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Class<T> expectedResultType)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, context);\n\t\t\t\tif (expectedResultType != null) {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValue(rootObject,expectedResultType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "expectedResultType"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "T",
    "signature": "public T getValue(@Nullable Object rootObject, @Nullable Class<T> expectedResultType)",
    "source_code": "\tpublic <T> @Nullable T getValue(@Nullable Object rootObject, @Nullable Class<T> expectedResultType) throws EvaluationException {\n\t\tCompiledExpression compiledAst = this.compiledAst;\n\t\tif (compiledAst != null) {\n\t\t\ttry {\n\t\t\t\tObject result = compiledAst.getValue(rootObject, getEvaluationContext());\n\t\t\t\tif (expectedResultType == null) {\n\t\t\t\t\treturn (T)result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\t\t\t\tgetEvaluationContext(), new TypedValue(result), expectedResultType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// If running in mixed mode, revert to interpreted\n\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.MIXED) {\n\t\t\t\t\tthis.compiledAst = null;\n\t\t\t\t\tthis.interpretedCount.set(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n\t\t\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tExpressionState expressionState =\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n\t\tcheckCompile(expressionState);\n\t\treturn ExpressionUtils.convertTypedValue(\n\t\t\t\texpressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#getValueTypeDescriptor(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic @Nullable TypeDescriptor getValueTypeDescriptor(EvaluationContext context, @Nullable Object rootObject)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n\t\treturn this.ast.getValueInternal(expressionState).getTypeDescriptor();\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#isWritable(context,rootObject)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "boolean",
    "signature": "public boolean isWritable(EvaluationContext context, @Nullable Object rootObject)",
    "source_code": "\tpublic boolean isWritable(EvaluationContext context, @Nullable Object rootObject) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\treturn this.ast.isWritable(new ExpressionState(context, toTypedValue(rootObject), this.configuration));\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#setValue(context,rootObject,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object rootObject, @Nullable Object value)\n\t\t\tthrows EvaluationException {\n\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tthis.ast.setValue(new ExpressionState(context, toTypedValue(rootObject), this.configuration), value);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#setValue(context,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "void",
    "signature": "public void setValue(EvaluationContext context, @Nullable Object value)",
    "source_code": "\tpublic void setValue(EvaluationContext context, @Nullable Object value) throws EvaluationException {\n\t\tAssert.notNull(context, \"EvaluationContext must not be null\");\n\t\tthis.ast.setValue(new ExpressionState(context, this.configuration), value);\n\t}"
  },
  "org.springframework.expression.spel.standard.<unknown>#setValue(rootObject,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootObject",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "void",
    "signature": "public void setValue(@Nullable Object rootObject, @Nullable Object value)",
    "source_code": "\tpublic void setValue(@Nullable Object rootObject, @Nullable Object value) throws EvaluationException {\n\t\tthis.ast.setValue(\n\t\t\t\tnew ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration), value);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#parse(text,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "TemporalAccessor",
    "signature": "public TemporalAccessor parse(String text, Locale locale)",
    "source_code": "\tpublic TemporalAccessor parse(String text, Locale locale) throws ParseException {\n\t\ttry {\n\t\t\treturn doParse(text, locale, this.formatter);\n\t\t}\n\t\tcatch (DateTimeParseException ex) {\n\t\t\tif (!ObjectUtils.isEmpty(this.fallbackPatterns)) {\n\t\t\t\tfor (String pattern : this.fallbackPatterns) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDateTimeFormatter fallbackFormatter = DateTimeFormatterUtils.createStrictDateTimeFormatter(pattern);\n\t\t\t\t\t\treturn doParse(text, locale, fallbackFormatter);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DateTimeParseException ignoredException) {\n\t\t\t\t\t\t// Ignore fallback parsing exceptions since the exception thrown below\n\t\t\t\t\t\t// will include information from the \"source\" if available -- for example,\n\t\t\t\t\t\t// the toString() of a @DateTimeFormat annotation.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Fallback to ISO-based default java.time type parsing\n\t\t\t\ttry {\n\t\t\t\t\treturn defaultParse(text);\n\t\t\t\t}\n\t\t\t\tcatch (DateTimeParseException ignoredException) {\n\t\t\t\t\t// Ignore fallback parsing exception like above\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.source != null) {\n\t\t\t\tthrow new DateTimeParseException(\n\t\t\t\t\t\tString.format(\"Unable to parse date time value \\\"%s\\\" using configuration from %s\", text, this.source),\n\t\t\t\t\t\ttext, ex.getErrorIndex(), ex);\n\t\t\t}\n\t\t\t// else rethrow original exception\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#print(object,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "String",
    "signature": "public String print(Duration object, Locale locale)",
    "source_code": "\tpublic String print(Duration object, Locale locale) {\n\t\tif (this.defaultUnit == null) {\n\t\t\t//delegate the ultimate of the default unit to the style\n\t\t\treturn DurationFormatterUtils.print(object, this.style);\n\t\t}\n\t\treturn DurationFormatterUtils.print(object, this.style, this.defaultUnit);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1771
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tthis.headers.addAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all the given values under the given name.\n\t * <p>As values are represented as a {@code List}, duplicate values can be\n\t * introduced. See {@link #put(String, List)} to replace the list of values\n\t * instead.\n\t * @param headerName the header name\n\t * @param headerValues the values to add\n\t * @see #put(String, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1797
    },
    "return": "void",
    "signature": "public void addAll(String headerName, List<? extends String> headerValues)",
    "source_code": "\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tthis.headers.addAll(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1766
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.addAll(key, values);\n\t}"
  },
  "org.springframework.http.<unknown>#compareParameters(mediaType1,mediaType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mediaType1",
      "mediaType2"
    ],
    "position": {
      "column": 1,
      "line": 976
    },
    "return": "int",
    "signature": "protected int compareParameters(MediaType mediaType1, MediaType mediaType2)",
    "source_code": "\t\tprotected int compareParameters(MediaType mediaType1, MediaType mediaType2) {\n\t\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\t\tif (qualityComparison != 0) {\n\t\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t\t}\n\t\t\treturn super.compareParameters(mediaType1, mediaType2);\n\t\t}"
  },
  "org.springframework.http.<unknown>#containsHeaderValue(headerName,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this HttpHeaders contains the given header and\n\t * its list of values contains the given value.\n\t * @param headerName the header name\n\t * @param value the value expected to be in the list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1923
    },
    "return": "boolean",
    "signature": "public boolean containsHeaderValue(String headerName, String value)",
    "source_code": "\tpublic boolean containsHeaderValue(String headerName, String value) {\n\t\tfinal List<String> values = this.headers.get(headerName);\n\t\tif (values == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn values.contains(value);\n\t}"
  },
  "org.springframework.http.<unknown>#copyOf(MultiValueMap<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code HttpHeaders} mutable instance and copy all header values given as a parameter.\n\t * @param headers the headers to copy\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders copyOf(MultiValueMap<String, String> headers)",
    "source_code": "\tpublic static HttpHeaders copyOf(MultiValueMap<String, String> headers) {\n\t\tHttpHeaders httpHeadersCopy = new HttpHeaders();\n\t\theaders.forEach((key, values) -> httpHeadersCopy.put(key, new ArrayList<>(values)));\n\t\treturn httpHeadersCopy;\n\t}"
  },
  "org.springframework.http.<unknown>#getOrDefault(headerName,defaultValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the list of header values for the given header name, or the given\n\t * default list of values if the header is not present.\n\t * @param headerName the header name\n\t * @param defaultValue the fallback list if header is not present\n\t * @return the list of header values, or a default list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "List<String>",
    "signature": "public List<String> getOrDefault(String headerName, List<String> defaultValue)",
    "source_code": "\tpublic List<String> getOrDefault(String headerName, List<String> defaultValue) {\n\t\tList<String> values = get(headerName);\n\t\treturn (values != null ? values : defaultValue);\n\t}"
  },
  "org.springframework.http.<unknown>#hasHeaderValues(headerName,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if this HttpHeaders contains exactly the given list\n\t * of values for the given header name.\n\t * @param headerName the header name\n\t * @param values the expected list of values\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1912
    },
    "return": "boolean",
    "signature": "public boolean hasHeaderValues(String headerName, List<String> values)",
    "source_code": "\tpublic boolean hasHeaderValues(String headerName, List<String> values) {\n\t\treturn ObjectUtils.nullSafeEquals(this.headers.get(headerName), values);\n\t}"
  },
  "org.springframework.http.<unknown>#put(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the list of values associated with the given header name. Returns the\n\t * previous list of values, or {@code null} if the header was not present.\n\t * @param headerName the header name\n\t * @param headerValues the new values\n\t * @return the old values for the given header name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1950
    },
    "return": "List<String>",
    "signature": "public List<String> put(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> put(String headerName, List<String> headerValues) {\n\t\treturn this.headers.put(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1827
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.http.<unknown>#putAll(String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Put all the entries from the given {@code MultiValueMap} into this\n\t * HttpHeaders.\n\t * @param headers the given headers\n\t * @see #put(String, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1982
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> headers)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> headers) {\n\t\tthis.headers.putAll(headers);\n\t}"
  },
  "org.springframework.http.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 1837
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set header values for the given header name if that header name isn't\n\t * already present in this HttpHeaders and return {@code null}. If the\n\t * header is already present, returns the associated value list instead.\n\t * @param headerName the header name\n\t * @param headerValues the header values to set if header is not present\n\t * @return the previous value or {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 1962
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> putIfAbsent(String headerName, List<String> headerValues) {\n\t\treturn this.headers.putIfAbsent(headerName, headerValues);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1847
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\trequest.getAttributes().forEach((key, value) -> delegate.getAttributes().put(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tlong contentLength = delegate.getHeaders().getContentLength();\n\t\t\t\t\tif (contentLength > -1 && contentLength != body.length) {\n\t\t\t\t\t\tdelegate.getHeaders().setContentLength(body.length);\n\t\t\t\t\t}\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\t\t\tStreamUtils.copy(body, outputStream);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#executeWithRequest(request,bufferedOutput,bufferResponse)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute with the given request and body.\n\t * @param request the request to execute with\n\t * @param bufferedOutput the body to write\n\t * @param bufferResponse whether to buffer the response\n\t * @return the resulting response\n\t * @throws IOException in case of I/O errors from execution\n\t * @since 7.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "bufferedOutput",
      "bufferResponse"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeWithRequest(ClientHttpRequest request, byte[] bufferedOutput, boolean bufferResponse)",
    "source_code": "\tprotected ClientHttpResponse executeWithRequest(\n\t\t\tClientHttpRequest request, byte[] bufferedOutput, boolean bufferResponse) throws IOException {\n\n\t\tif (bufferedOutput.length > 0) {\n\t\t\tlong contentLength = request.getHeaders().getContentLength();\n\t\t\tif (contentLength > -1 && contentLength != bufferedOutput.length) {\n\t\t\t\trequest.getHeaders().setContentLength(bufferedOutput.length);\n\t\t\t}\n\t\t\tif (request instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\tstreamingOutputMessage.setBody(bufferedOutput);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStreamUtils.copy(bufferedOutput, request.getBody());\n\t\t\t}\n\t\t}\n\n\t\tClientHttpResponse response = request.execute();\n\t\treturn (bufferResponse ? new BufferingClientHttpResponseWrapper(response) : response);\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuf map(byte[] b, int off, int len) {\n\t\t\tByteBuf buf = this.allocator.buffer(len);\n\t\t\tbuf.writeBytes(b, off, len);\n\t\t\treturn buf;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#read(b,off,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\tObjects.checkFromIndexSize(off, len, b.length);\n\t\tif (len == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!this.lock.tryLock()) {\n\t\t\tif (this.closed) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthrow new ConcurrentModificationException(\"concurrent access is disallowed\");\n\t\t}\n\n\t\ttry {\n\t\t\tfor (int j = 0; j < len;) {\n\t\t\t\tbyte[] next = getNextOrAwait();\n\n\t\t\t\tif (next == DONE) {\n\t\t\t\t\tcleanAndFinalize();\n\t\t\t\t\tif (this.error == null) {\n\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\treturn j == 0 ? -1 : j;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tthis.closed = true;\n\t\t\t\t\t\t\tthrow Exceptions.propagate(this.error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (next == CLOSED) {\n\t\t\t\t\trequiredSubscriber().cancel();\n\t\t\t\t\tcleanAndFinalize();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tint i = this.position;\n\t\t\t\tfor (; i < next.length && j < len; i++, j++) {\n\t\t\t\t\tb[off + j] = next[i];\n\t\t\t\t}\n\t\t\t\tthis.position = i;\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthis.closed = true;\n\t\t\trequiredSubscriber().cancel();\n\t\t\tcleanAndFinalize();\n\t\t\tthrow Exceptions.propagate(ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.lock.unlock();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(AnnotationIntrospector,pairingFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, for example, via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<@Nullable AnnotationIntrospector, @Nullable AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<@Nullable AnnotationIntrospector, @Nullable AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, for example, via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<AnnotationIntrospector, AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.protobuf.<unknown>#merge(input,charset,contentType,extensionRegistry,builder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "charset",
      "contentType",
      "extensionRegistry",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void merge(InputStream input, Charset charset, MediaType contentType,\n\t\t\t\tExtensionRegistry extensionRegistry, Message.Builder builder)",
    "source_code": "\t\tpublic void merge(InputStream input, Charset charset, MediaType contentType,\n\t\t\t\tExtensionRegistry extensionRegistry, Message.Builder builder)\n\t\t\t\tthrows IOException, HttpMessageConversionException {\n\n\t\t\tif (contentType.isCompatibleWith(APPLICATION_JSON)) {\n\t\t\t\tInputStreamReader reader = new InputStreamReader(input, charset);\n\t\t\t\tthis.parser.merge(reader, builder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageConversionException(\n\t\t\t\t\t\t\"protobuf-java-util does not support parsing \" + contentType);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.protobuf.<unknown>#print(message,output,contentType,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "output",
      "contentType",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void print(Message message, OutputStream output, MediaType contentType, Charset charset)",
    "source_code": "\t\tpublic void print(Message message, OutputStream output, MediaType contentType, Charset charset)\n\t\t\t\tthrows IOException, HttpMessageConversionException {\n\n\t\t\tif (contentType.isCompatibleWith(APPLICATION_JSON)) {\n\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(output, charset);\n\t\t\t\tthis.printer.appendTo(message, writer);\n\t\t\t\twriter.flush();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageConversionException(\n\t\t\t\t\t\t\"protobuf-java-util does not support printing \" + contentType);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.protobuf.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Message",
    "signature": "protected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = PROTOBUF;\n\t\t}\n\t\tCharset charset = contentType.getCharset();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\tMessage.Builder builder = getMessageBuilder(clazz);\n\t\tif (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tbuilder.mergeFrom(inputMessage.getBody(), this.extensionRegistry);\n\t\t}\n\t\telse if (TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tInputStreamReader reader = new InputStreamReader(inputMessage.getBody(), charset);\n\t\t\tTextFormat.merge(reader, this.extensionRegistry, builder);\n\t\t}\n\t\telse if (this.protobufFormatSupport != null) {\n\t\t\tthis.protobufFormatSupport.merge(\n\t\t\t\t\tinputMessage.getBody(), charset, contentType, this.extensionRegistry, builder);\n\t\t}\n\t\treturn builder.build();\n\t}"
  },
  "org.springframework.http.converter.protobuf.<unknown>#writeInternal(message,outputMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "protected void writeInternal(Message message, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Message message, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = getDefaultContentType(message);\n\t\t\tAssert.state(contentType != null, \"No content type\");\n\t\t}\n\t\tCharset charset = contentType.getCharset();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\tif (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tsetProtoHeader(outputMessage, message);\n\t\t\tCodedOutputStream codedOutputStream = CodedOutputStream.newInstance(outputMessage.getBody());\n\t\t\tmessage.writeTo(codedOutputStream);\n\t\t\tcodedOutputStream.flush();\n\t\t}\n\t\telse if (TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tOutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tTextFormat.printer().print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t\telse if (this.protobufFormatSupport != null) {\n\t\t\tthis.protobufFormatSupport.print(message, outputMessage.getBody(), contentType, charset);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,context,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "context",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new Jetty12ServerHttpResponse(\n\t\t\t\tresponse, context, getDataBufferFactory(), getBufferSize(), request);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#processRow(rs,rowNum)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses may override this to perform custom extraction\n\t * or processing. This class's implementation does nothing.\n\t * @param rs the ResultSet to extract data from. This method is\n\t * invoked for each row\n\t * @param rowNum number of the current row (starting from 0)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "protected void processRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected void processRow(ResultSet rs, int rowNum) throws SQLException {\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,Map<String,batchValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "batchValues"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, Map<String, ?>[] batchValues)",
    "source_code": "\tpublic int[] batchUpdate(String sql, Map<String, ?>[] batchValues) {\n\t\treturn batchUpdate(sql, SqlParameterSourceUtils.createBatch(batchValues));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,batchArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs) {\n\t\tif (batchArgs.length == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, batchArgs[0]);\n\n\t\treturn getJdbcOperations().batchUpdate(\n\t\t\t\tpscf.getSql(),\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.length;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,batchArgs,generatedKeyHolder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder) {\n\t\treturn batchUpdate(sql, batchArgs, generatedKeyHolder, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#batchUpdate(sql,batchArgs,generatedKeyHolder,keyColumnNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString @Nullable [] keyColumnNames)",
    "source_code": "\tpublic int[] batchUpdate(String sql, SqlParameterSource[] batchArgs, KeyHolder generatedKeyHolder,\n\t\t\tString @Nullable [] keyColumnNames) {\n\n\t\tif (batchArgs.length == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tSqlParameterSource paramSource = batchArgs[0];\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, paramSource);\n\t\tif (keyColumnNames != null) {\n\t\t\tpscf.setGeneratedKeysColumnNames(keyColumnNames);\n\t\t}\n\t\telse {\n\t\t\tpscf.setReturnGeneratedKeys(true);\n\t\t}\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, null);\n\t\tPreparedStatementCreator psc = pscf.newPreparedStatementCreator(params);\n\t\treturn getJdbcOperations().batchUpdate(psc, new BatchPreparedStatementSetter() {\n\t\t\t@Override\n\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getBatchSize() {\n\t\t\t\treturn batchArgs.length;\n\t\t\t}\n\t\t}, generatedKeyHolder);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#execute(sql,Map<String,paramMap,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(sql, new MapSqlParameterSource(paramMap), action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#execute(sql,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "T",
    "signature": "public T execute(String sql, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(sql, EmptySqlParameterSource.INSTANCE, action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#execute(sql,paramSource,action)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "T",
    "signature": "public T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> @Nullable T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().execute(getPreparedStatementCreator(sql, paramSource), action);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getPreparedStatementCreator(sql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Directly called from all {@code query} variants. Delegates to the common\n\t * {@link #getPreparedStatementCreator(String, SqlParameterSource, Consumer)} method.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource)",
    "source_code": "\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource) {\n\t\treturn getPreparedStatementCreator(sql, paramSource, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getPreparedStatementCreator(sql,paramSource,customizer)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreator} based on the given SQL and named parameters.\n\t * <p>Note: Used for the {@code update} variant with generated key handling, and also\n\t * delegated from {@link #getPreparedStatementCreator(String, SqlParameterSource)}.\n\t * @param sql the SQL statement to execute\n\t * @param paramSource container of arguments to bind\n\t * @param customizer callback for setting further properties on the\n\t * {@link PreparedStatementCreatorFactory} in use, applied before the\n\t * actual {@code newPreparedStatementCreator} call\n\t * @return the corresponding {@link PreparedStatementCreator}\n\t * @since 5.0.5\n\t * @see #getParsedSql(String)\n\t * @see PreparedStatementCreatorFactory#PreparedStatementCreatorFactory(String, List)\n\t * @see PreparedStatementCreatorFactory#newPreparedStatementCreator(Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sql",
      "paramSource",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,\n\t\t\t@Nullable Consumer<PreparedStatementCreatorFactory> customizer)",
    "source_code": "\tprotected PreparedStatementCreator getPreparedStatementCreator(String sql, SqlParameterSource paramSource,\n\t\t\t@Nullable Consumer<PreparedStatementCreatorFactory> customizer) {\n\n\t\tParsedSql parsedSql = getParsedSql(sql);\n\t\tPreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, paramSource);\n\t\tif (customizer != null) {\n\t\t\tcustomizer.accept(pscf);\n\t\t}\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, null);\n\t\treturn pscf.newPreparedStatementCreator(params);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getPreparedStatementCreatorFactory(parsedSql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link PreparedStatementCreatorFactory} based on the given SQL and named parameters.\n\t * @param parsedSql parsed representation of the given SQL statement\n\t * @param paramSource container of arguments to bind\n\t * @return the corresponding {@link PreparedStatementCreatorFactory}\n\t * @since 5.1.3\n\t * @see #getPreparedStatementCreator(String, SqlParameterSource, Consumer)\n\t * @see #getParsedSql(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "PreparedStatementCreatorFactory",
    "signature": "protected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tprotected PreparedStatementCreatorFactory getPreparedStatementCreatorFactory(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource) {\n\n\t\tString sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\n\t\tList<SqlParameter> declaredParameters = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);\n\t\treturn new PreparedStatementCreatorFactory(sqlToUse, declaredParameters);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,Map<String,paramMap,rch)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)\n\t\t\tthrows DataAccessException {\n\n\t\tquery(sql, new MapSqlParameterSource(paramMap), rch);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,Map<String,paramMap,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,Map<String,paramMap,rse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "T",
    "signature": "public T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, new MapSqlParameterSource(paramMap), rse);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,paramSource,rch)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "void",
    "signature": "public void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)\n\t\t\tthrows DataAccessException {\n\n\t\tgetJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rch);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,paramSource,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,paramSource,rse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "T",
    "signature": "public T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rse);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,rch)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, EmptySqlParameterSource.INSTANCE, rch);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#query(sql,rse)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "T",
    "signature": "public T query(String sql, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> @Nullable T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, EmptySqlParameterSource.INSTANCE, rse);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,Map<String,paramMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, Map<String, ?> paramMap)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForList(sql, new MapSqlParameterSource(paramMap));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,Map<String,paramMap,elementType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForList(sql, new MapSqlParameterSource(paramMap), elementType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, SqlParameterSource paramSource)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new ColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForList(sql,paramSource,elementType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, SqlParameterSource paramSource, Class<T> elementType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn query(sql, paramSource, new SingleColumnRowMapper<>(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForMap(sql,Map<String,paramMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramMap, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForMap(sql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tMap<String, Object> result = queryForObject(sql, paramSource, new ColumnMapRowMapper());\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForObject(sql,Map<String,paramMap,RowMapper<T>rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "RowMapper<T>rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, RowMapper<T>rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForObject(sql,Map<String,paramMap,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, paramMap, new SingleColumnRowMapper<>(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForObject(sql,paramSource,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, paramSource, new SingleColumnRowMapper<>(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForObject(sql,paramSource,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> @Nullable T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\tList<T> results = getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForRowSet(sql,Map<String,paramMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn queryForRowSet(sql, new MapSqlParameterSource(paramMap));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForRowSet(sql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\tSqlRowSet result = getJdbcOperations().query(\n\t\t\t\tgetPreparedStatementCreator(sql, paramSource), new SqlRowSetResultSetExtractor());\n\t\tAssert.state(result != null, \"No result\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForStream(sql,Map<String,paramMap,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForStream(sql, new MapSqlParameterSource(paramMap), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#queryForStream(sql,paramSource,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\treturn getJdbcOperations().queryForStream(getPreparedStatementCreator(sql, paramSource), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#setValues(ps,i)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t@Nullable Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n\t\t\t\tpscf.newPreparedStatementSetter(values).setValues(ps);\n\t\t\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#update(sql,Map<String,paramMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "int",
    "signature": "public int update(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic int update(String sql, Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn update(sql, new MapSqlParameterSource(paramMap));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#update(sql,paramSource)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic int update(String sql, SqlParameterSource paramSource) throws DataAccessException {\n\t\treturn getJdbcOperations().update(getPreparedStatementCreator(sql, paramSource));\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#update(sql,paramSource,generatedKeyHolder)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException {\n\n\t\treturn update(sql, paramSource, generatedKeyHolder, null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#update(sql,paramSource,generatedKeyHolder,keyColumnNames)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource",
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "int",
    "signature": "public int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String @Nullable [] keyColumnNames)",
    "source_code": "\tpublic int update(\n\t\t\tString sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder, String @Nullable [] keyColumnNames)\n\t\t\tthrows DataAccessException {\n\n\t\tPreparedStatementCreator psc = getPreparedStatementCreator(sql, paramSource, pscf -> {\n\t\t\tif (keyColumnNames != null) {\n\t\t\t\tpscf.setGeneratedKeysColumnNames(keyColumnNames);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpscf.setReturnGeneratedKeys(true);\n\t\t\t}\n\t\t});\n\t\treturn getJdbcOperations().update(psc, generatedKeyHolder);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#doExecute(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method that executes the insert using the passed-in Map of parameters.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the number of rows affected\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "int",
    "signature": "protected int doExecute(Map<String, ?> args)",
    "source_code": "\tprotected int doExecute(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#doExecuteAndReturnKey(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * Map of parameters and returning a generated key.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the key generated by the insert\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "Number",
    "signature": "protected Number doExecuteAndReturnKey(Map<String, ?> args)",
    "source_code": "\tprotected Number doExecuteAndReturnKey(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertAndReturnKeyInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#doExecuteAndReturnKeyHolder(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Method that provides execution of the insert using the passed-in\n\t * Map of parameters and returning all generated keys.\n\t * @param args a Map with parameter names and values to be used in insert\n\t * @return the KeyHolder containing keys generated by the insert\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "KeyHolder",
    "signature": "protected KeyHolder doExecuteAndReturnKeyHolder(Map<String, ?> args)",
    "source_code": "\tprotected KeyHolder doExecuteAndReturnKeyHolder(Map<String, ?> args) {\n\t\tcheckCompiled();\n\t\tList<Object> values = matchInParameterValuesWithInsertColumns(args);\n\t\treturn executeInsertAndReturnKeyHolderInternal(values);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#doExecuteBatch(Map<String,batch)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate method that executes a batch insert using the passed-in Maps of parameters.\n\t * @param batch maps with parameter names and values to be used in the batch insert\n\t * @return an array of number of rows affected\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "batch"
    ],
    "position": {
      "column": 1,
      "line": 567
    },
    "return": "int[]",
    "signature": "protected int[] doExecuteBatch(Map<String, ?>... batch)",
    "source_code": "\tprotected int[] doExecuteBatch(Map<String, ?>... batch) {\n\t\tcheckCompiled();\n\t\tList<List<Object>> batchValues = new ArrayList<>(batch.length);\n\t\tfor (Map<String, ?> args : batch) {\n\t\t\tbatchValues.add(matchInParameterValuesWithInsertColumns(args));\n\t\t}\n\t\treturn executeBatchInternal(batchValues);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#execute(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object>",
    "signature": "public Object> execute(Map<String, ?> args)",
    "source_code": "\tpublic Map<String, Object> execute(Map<String, ?> args) {\n\t\treturn doExecute(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#executeFunction(returnType,Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "T",
    "signature": "public T executeFunction(Class<T> returnType, Map<String, ?> args)",
    "source_code": "\tpublic <T> @Nullable T executeFunction(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#executeFunction(returnType,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "T",
    "signature": "public T executeFunction(Class<T> returnType, SqlParameterSource args)",
    "source_code": "\tpublic <T> @Nullable T executeFunction(Class<T> returnType, SqlParameterSource args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#executeObject(returnType,Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "T",
    "signature": "public T executeObject(Class<T> returnType, Map<String, ?> args)",
    "source_code": "\tpublic <T> @Nullable T executeObject(Class<T> returnType, Map<String, ?> args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#executeObject(returnType,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "T",
    "signature": "public T executeObject(Class<T> returnType, SqlParameterSource args)",
    "source_code": "\tpublic <T> @Nullable T executeObject(Class<T> returnType, SqlParameterSource args) {\n\t\treturn (T) doExecute(args).get(getScalarOutParameterName());\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#matchInParameterValuesWithInsertColumns(Map<String,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the provided in parameter values with registered parameters and parameters\n\t * defined via meta-data processing.\n\t * @param args the parameter values provided as a Map\n\t * @return a List of values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 647
    },
    "return": "List<Object>",
    "signature": "protected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args)",
    "source_code": "\tprotected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args) {\n\t\treturn this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#returningResultSet(parameterName,rowMapper)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "SimpleJdbcCall",
    "signature": "public SimpleJdbcCall returningResultSet(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SimpleJdbcCall returningResultSet(String parameterName, RowMapper<?> rowMapper) {\n\t\taddDeclaredRowMapper(parameterName, rowMapper);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#setValues(ps,i)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tsetParameterValues(ps, batchValues.get(i), getInsertTypes());\n\t\t\t\t\t}"
  },
  "org.springframework.jdbc.object.<unknown>#execute(Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without parameters.\n\t * @param context the contextual information for object creation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "List<T>",
    "signature": "public List<T> execute(Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(Map<?, ?> context) throws DataAccessException {\n\t\treturn execute((Object[]) null, context);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#execute(p1,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with a single String parameter and context.\n\t * @param p1 single String parameter\n\t * @param context the contextual information for object creation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "List<T>",
    "signature": "public List<T> execute(String p1, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(String p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1}, context);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#execute(p1,p2)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with two int parameters.\n\t * @param p1 first int parameter\n\t * @param p2 second int parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "List<T>",
    "signature": "public List<T> execute(int p1, int p2)",
    "source_code": "\tpublic List<T> execute(int p1, int p2) throws DataAccessException {\n\t\treturn execute(p1, p2, null);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#execute(p1,p2,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute with two int parameters and context.\n\t * @param p1 first int parameter\n\t * @param p2 second int parameter\n\t * @param context the contextual information for object creation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<T>",
    "signature": "public List<T> execute(int p1, int p2, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn execute(new Object[] {p1, p2}, context);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#execute(params,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Central execution method. All un-named parameter execution goes through this method.\n\t * @param params parameters, similar to JDO query parameters.\n\t * Primitive parameters must be represented by their Object wrapper type.\n\t * The ordering of parameters is significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "List<T>",
    "signature": "public List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> execute(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateParameters(params);\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(params), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#executeByNamedParam(Map<String,paramMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "List<T>",
    "signature": "public List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap)",
    "source_code": "\tpublic List<T> executeByNamedParam(Map<String, ? extends @Nullable Object> paramMap) throws DataAccessException {\n\t\treturn executeByNamedParam(paramMap, null);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#executeByNamedParam(Map<String,paramMap,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Central execution method. All named parameter execution goes through this method.\n\t * @param paramMap parameters associated with the name specified while declaring\n\t * the SqlParameters. Primitive parameters must be represented by their Object wrapper\n\t * type. The ordering of parameters is not significant since they are supplied in a\n\t * SqlParameterMap which is an implementation of the Map interface.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "List<T>",
    "signature": "public List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tvalidateNamedParameters(paramMap);\n\t\tParsedSql parsedSql = getParsedSql();\n\t\tMapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap);\n\t\tString sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\n\t\t@Nullable Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters());\n\t\tRowMapper<T> rowMapper = newRowMapper(params, context);\n\t\treturn getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, params), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#findObject(p1,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given a single String parameter\n\t * and a context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "T",
    "signature": "public T findObject(String p1, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObject(String p1, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1}, context);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#findObject(p1,p2)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given two int parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "T",
    "signature": "public T findObject(int p1, int p2)",
    "source_code": "\tpublic @Nullable T findObject(int p1, int p2) throws DataAccessException {\n\t\treturn findObject(p1, p2, null);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#findObject(p1,p2,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to find a single object given two int parameters\n\t * and a context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "p1",
      "p2",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "T",
    "signature": "public T findObject(int p1, int p2, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObject(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\treturn findObject(new Object[] {p1, p2}, context);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#findObject(params,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generic object finder method, used by all other {@code findObject} methods.\n\t * Object finder methods are like EJB entity bean finders, in that it is\n\t * considered an error if they return more than one result.\n\t * @return the result object, or {@code null} if not found. Subclasses may\n\t * choose to treat this as an error and throw an exception.\n\t * @see org.springframework.dao.support.DataAccessUtils#singleResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "params",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "T",
    "signature": "public T findObject(Object @Nullable [] params, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObject(Object @Nullable [] params, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = execute(params, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#findObjectByNamedParam(Map<String,paramMap)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient method to execute without context.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "T",
    "signature": "public T findObjectByNamedParam(Map<String, ?> paramMap)",
    "source_code": "\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap) throws DataAccessException {\n\t\treturn findObjectByNamedParam(paramMap, null);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#findObjectByNamedParam(Map<String,paramMap,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Generic object finder method for named parameters.\n\t * @param paramMap a Map of parameter name to parameter object,\n\t * matching named parameters specified in the SQL statement.\n\t * Ordering is not significant.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @return a List of objects, one per row of the ResultSet. Normally all these\n\t * will be of the same class, although it is possible to use different types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "T",
    "signature": "public T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context)",
    "source_code": "\tpublic @Nullable T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {\n\t\tList<T> results = executeByNamedParam(paramMap, context);\n\t\treturn DataAccessUtils.singleResult(results);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#mapRow(rs,rowNum,parameters,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to convert each row\n\t * of the ResultSet into an object of the result type.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @param parameters to the query (passed to the execute() method).\n\t * Subclasses are rarely interested in these.\n\t * It can be {@code null} if there are no parameters.\n\t * @param context passed to the execute() method.\n\t * It can be {@code null} if no contextual information is need.\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error extracting data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum",
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected abstract @Nullable T mapRow(ResultSet rs, int rowNum, @Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)\n\t\t\tthrows SQLException;\n\n\n\t/**\n\t * Implementation of RowMapper that calls the enclosing\n\t * class's {@code mapRow} method for each row."
  },
  "org.springframework.jdbc.object.<unknown>#newPreparedStatementCreator(sqlToUse,params)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a PreparedStatementCreator to perform an operation\n\t * with the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sqlToUse",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "PreparedStatementCreator",
    "signature": "protected PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object @Nullable [] params)",
    "source_code": "\tprotected final PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object @Nullable [] params) {\n\t\tAssert.state(this.preparedStatementFactory != null, \"No PreparedStatementFactory available\");\n\t\treturn this.preparedStatementFactory.newPreparedStatementCreator(sqlToUse, params);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#newRowMapper(parameters,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to extract an object per row, to be\n\t * returned by the {@code execute} method as an aggregated {@link List}.\n\t * @param parameters the parameters to the {@code execute()} method,\n\t * in case subclass is interested; may be {@code null} if there\n\t * were no parameters.\n\t * @param context the contextual information passed to the {@code mapRow}\n\t * callback method. The JDBC operation itself doesn't rely on this parameter,\n\t * but it can be useful for creating the objects of the result list.\n\t * @see #execute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameters",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "RowMapper<T>",
    "signature": "protected RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected abstract RowMapper<T> newRowMapper(@Nullable Object @Nullable [] parameters, @Nullable Map<?, ?> context);"
  },
  "org.springframework.jdbc.object.<unknown>#updateRow(rs,rowNum,Map<?,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to update each row of the\n\t * ResultSet and optionally create object of the result type.\n\t * @param rs the ResultSet we're working through\n\t * @param rowNum row number (from 0) we're up to\n\t * @param context passed to the {@code execute()} method.\n\t * It can be {@code null} if no contextual information is need.  If you\n\t * need to pass in data for each row, you can pass in a HashMap with\n\t * the primary key of the row being the key for the HashMap.  That way\n\t * it is easy to locate the updates for each row\n\t * @return an object of the result type\n\t * @throws SQLException if there's an error updating data.\n\t * Subclasses can simply not catch SQLExceptions, relying on the\n\t * framework to clean up.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum",
      "Map<?",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "T",
    "signature": "protected T updateRow(ResultSet rs, int rowNum, @Nullable Map<?, ?> context)",
    "source_code": "\tprotected abstract T updateRow(ResultSet rs, int rowNum, @Nullable Map<?, ?> context) throws SQLException;"
  },
  "org.springframework.jdbc.object.<unknown>#validateNamedParameters(Map<String,parameters)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the named parameters passed to an execute method based on declared parameters.\n\t * Subclasses should invoke this method before every {@code executeQuery()} or\n\t * {@code update()} method.\n\t * @param parameters parameter Map supplied (may be {@code null})\n\t * @throws InvalidDataAccessApiUsageException if the parameters are invalid\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void validateNamedParameters(@Nullable Map<String, ?> parameters)",
    "source_code": "\tprotected void validateNamedParameters(@Nullable Map<String, ?> parameters) throws InvalidDataAccessApiUsageException {\n\t\tcheckCompiled();\n\t\tMap<String, ?> paramsToUse = (parameters != null ? parameters : Collections.<String, Object> emptyMap());\n\t\tint declaredInParameters = 0;\n\t\tfor (SqlParameter param : this.declaredParameters) {\n\t\t\tif (param.isInputValueProvided()) {\n\t\t\t\tif (!supportsLobParameters() &&\n\t\t\t\t\t\t(param.getSqlType() == Types.BLOB || param.getSqlType() == Types.CLOB)) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\t\"BLOB or CLOB parameters are not allowed for this kind of operation\");\n\t\t\t\t}\n\t\t\t\tif (param.getName() != null && !paramsToUse.containsKey(param.getName())) {\n\t\t\t\t\tthrow new InvalidDataAccessApiUsageException(\"The parameter named '\" + param.getName() +\n\t\t\t\t\t\t\t\"' was not among the parameters supplied: \" + paramsToUse.keySet());\n\t\t\t\t}\n\t\t\t\tdeclaredInParameters++;\n\t\t\t}\n\t\t}\n\t\tvalidateParameterCount(paramsToUse.size(), declaredInParameters);\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBinaryStream(pos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "InputStream",
    "signature": "public InputStream getBinaryStream(long pos, long length)",
    "source_code": "\tpublic InputStream getBinaryStream(long pos, long length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBlobAsBinaryStream(rs,columnIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "InputStream",
    "signature": "public InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic @Nullable InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning BLOB as binary stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tBlob blob = rs.getBlob(columnIndex);\n\t\t\treturn blob.getBinaryStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getBinaryStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBlobAsBinaryStream(rs,columnName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "InputStream",
    "signature": "public InputStream getBlobAsBinaryStream(ResultSet rs, String columnName)",
    "source_code": "\tpublic @Nullable InputStream getBlobAsBinaryStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getBlobAsBinaryStream(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getBytes(pos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "byte[]",
    "signature": "public byte[] getBytes(long pos, int length)",
    "source_code": "\tpublic byte[] getBytes(long pos, int length) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsAsciiStream(rs,columnIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "InputStream",
    "signature": "public InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as ASCII stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getAsciiStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getAsciiStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsAsciiStream(rs,columnName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "InputStream",
    "signature": "public InputStream getClobAsAsciiStream(ResultSet rs, String columnName)",
    "source_code": "\tpublic @Nullable InputStream getClobAsAsciiStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsAsciiStream(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsCharacterStream(rs,columnIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Reader",
    "signature": "public Reader getClobAsCharacterStream(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as character stream\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getCharacterStream();\n\t\t}\n\t\telse {\n\t\t\treturn rs.getCharacterStream(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsCharacterStream(rs,columnName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "Reader",
    "signature": "public Reader getClobAsCharacterStream(ResultSet rs, String columnName)",
    "source_code": "\tpublic Reader getClobAsCharacterStream(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsCharacterStream(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsString(rs,columnIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String",
    "signature": "public String getClobAsString(ResultSet rs, int columnIndex)",
    "source_code": "\tpublic @Nullable String getClobAsString(ResultSet rs, int columnIndex) throws SQLException {\n\t\tlogger.debug(\"Returning CLOB as string\");\n\t\tif (this.wrapAsLob) {\n\t\t\tClob clob = rs.getClob(columnIndex);\n\t\t\treturn clob.getSubString(1, (int) clob.length());\n\t\t}\n\t\telse {\n\t\t\treturn rs.getString(columnIndex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#getClobAsString(rs,columnName)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "columnName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "String",
    "signature": "public String getClobAsString(ResultSet rs, String columnName)",
    "source_code": "\tpublic @Nullable String getClobAsString(ResultSet rs, String columnName) throws SQLException {\n\t\treturn getClobAsString(rs, rs.findColumn(columnName));\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#position(pattern,start)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "start"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "long",
    "signature": "public long position(Blob pattern, long start)",
    "source_code": "\tpublic long position(Blob pattern, long start) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBlobAsBinaryStream(ps,paramIndex,binaryStream,contentLength)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "binaryStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setBlobAsBinaryStream(PreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)",
    "source_code": "\tpublic void setBlobAsBinaryStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)\n\t\t\tthrows SQLException {\n\n\t\tif (binaryStream != null) {\n\t\t\tBlob blob = ps.getConnection().createBlob();\n\t\t\ttry {\n\t\t\t\tFileCopyUtils.copy(binaryStream, blob.setBinaryStream(1));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not copy into LOB stream\", ex);\n\t\t\t}\n\t\t\tthis.temporaryBlobs.add(blob);\n\t\t\tps.setBlob(paramIndex, blob);\n\t\t}\n\t\telse {\n\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(binaryStream != null ?\n\t\t\t\t\t\"Copied binary stream into temporary BLOB with length \" + contentLength :\n\t\t\t\t\t\"Set BLOB to null\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBlobAsBytes(ps,paramIndex,content)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)",
    "source_code": "\tpublic void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte @Nullable [] content)\n\t\t\tthrows SQLException {\n\n\t\tif (content != null) {\n\t\t\tBlob blob = ps.getConnection().createBlob();\n\t\t\tblob.setBytes(1, content);\n\t\t\tthis.temporaryBlobs.add(blob);\n\t\t\tps.setBlob(paramIndex, blob);\n\t\t}\n\t\telse {\n\t\t\tps.setBlob(paramIndex, (Blob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(content != null ? \"Copied bytes into temporary BLOB with length \" + content.length :\n\t\t\t\t\t\"Set BLOB to null\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setBytes(pos,bytes,offset,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "bytes",
      "offset",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "int",
    "signature": "public int setBytes(long pos, byte[] bytes, int offset, int len)",
    "source_code": "\tpublic int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setClobAsAsciiStream(ps,paramIndex,asciiStream,contentLength)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "asciiStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "void",
    "signature": "public void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)",
    "source_code": "\tpublic void setClobAsAsciiStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)\n\t\t\tthrows SQLException {\n\n\t\tif (asciiStream != null) {\n\t\t\tClob clob = ps.getConnection().createClob();\n\t\t\ttry {\n\t\t\t\tFileCopyUtils.copy(asciiStream, clob.setAsciiStream(1));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not copy into LOB stream\", ex);\n\t\t\t}\n\t\t\tthis.temporaryClobs.add(clob);\n\t\t\tps.setClob(paramIndex, clob);\n\t\t}\n\t\telse {\n\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(asciiStream != null ?\n\t\t\t\t\t\"Copied ASCII stream into temporary CLOB with length \" + contentLength :\n\t\t\t\t\t\"Set CLOB to null\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setClobAsCharacterStream(ps,paramIndex,characterStream,contentLength)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "characterStream",
      "contentLength"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void setClobAsCharacterStream(PreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)",
    "source_code": "\tpublic void setClobAsCharacterStream(\n\t\t\tPreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)\n\t\t\tthrows SQLException {\n\n\t\tif (characterStream != null) {\n\t\t\tClob clob = ps.getConnection().createClob();\n\t\t\ttry {\n\t\t\t\tFileCopyUtils.copy(characterStream, clob.setCharacterStream(1));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new DataAccessResourceFailureException(\"Could not copy into LOB stream\", ex);\n\t\t\t}\n\t\t\tthis.temporaryClobs.add(clob);\n\t\t\tps.setClob(paramIndex, clob);\n\t\t}\n\t\telse {\n\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(characterStream != null ?\n\t\t\t\t\t\"Copied character stream into temporary CLOB with length \" + contentLength :\n\t\t\t\t\t\"Set CLOB to null\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.lob.<unknown>#setClobAsString(ps,paramIndex,content)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)",
    "source_code": "\tpublic void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)\n\t\t\tthrows SQLException {\n\n\t\tif (content != null) {\n\t\t\tClob clob = ps.getConnection().createClob();\n\t\t\tclob.setString(1, content);\n\t\t\tthis.temporaryClobs.add(clob);\n\t\t\tps.setClob(paramIndex, clob);\n\t\t}\n\t\telse {\n\t\t\tps.setClob(paramIndex, (Clob) null);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(content != null ? \"Copied string into temporary CLOB with length \" + content.length() :\n\t\t\t\t\t\"Set CLOB to null\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getDate(columnIndex,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Date",
    "signature": "public Date getDate(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Date getDate(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getDate(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getDate(columnLabel,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getDate(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "Date",
    "signature": "public Date getDate(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Date getDate(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getDate(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getObject(columnIndex,Map<String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(int, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "Object",
    "signature": "public Object getObject(int columnIndex, Map<String, Class<?>> map)",
    "source_code": "\tpublic @Nullable Object getObject(int columnIndex, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, map);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getObject(columnIndex,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "T",
    "signature": "public T getObject(int columnIndex, Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T getObject(int columnIndex, Class<T> type) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getObject(columnIndex, type);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getObject(columnLabel,Map<String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(String, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "Object",
    "signature": "public Object getObject(String columnLabel, Map<String, Class<?>> map)",
    "source_code": "\tpublic @Nullable Object getObject(String columnLabel, Map<String, Class<?>> map) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel), map);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getObject(columnLabel,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getObject(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "T",
    "signature": "public T getObject(String columnLabel, Class<T> type)",
    "source_code": "\tpublic <T> @Nullable T getObject(String columnLabel, Class<T> type) throws InvalidResultSetAccessException {\n\t\treturn getObject(findColumn(columnLabel), type);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getTime(columnIndex,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTime(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "Time",
    "signature": "public Time getTime(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Time getTime(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTime(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getTime(columnLabel,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTime(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "Time",
    "signature": "public Time getTime(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Time getTime(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTime(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getTimestamp(columnIndex,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(int, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnIndex",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(int columnIndex, Calendar cal)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(int columnIndex, Calendar cal) throws InvalidResultSetAccessException {\n\t\ttry {\n\t\t\treturn this.resultSet.getTimestamp(columnIndex, cal);\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\tthrow new InvalidResultSetAccessException(se);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.rowset.<unknown>#getTimestamp(columnLabel,cal)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * @see java.sql.ResultSet#getTimestamp(String, Calendar)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "columnLabel",
      "cal"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Timestamp",
    "signature": "public Timestamp getTimestamp(String columnLabel, Calendar cal)",
    "source_code": "\tpublic @Nullable Timestamp getTimestamp(String columnLabel, Calendar cal) throws InvalidResultSetAccessException {\n\t\treturn getTimestamp(findColumn(columnLabel), cal);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#addSession(session,connection)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given Session to this resource holder,\n\t * registered for a specific Connection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "public void addSession(Session session, @Nullable Connection connection)",
    "source_code": "\tpublic final void addSession(Session session, @Nullable Connection connection) {\n\t\tAssert.isTrue(!this.frozen, \"Cannot add Session because JmsResourceHolder is frozen\");\n\t\tAssert.notNull(session, \"Session must not be null\");\n\t\tif (!this.sessions.contains(session)) {\n\t\t\tthis.sessions.add(session);\n\t\t\tif (connection != null) {\n\t\t\t\tDeque<Session> sessions =\n\t\t\t\t\t\tthis.sessionsPerConnection.computeIfAbsent(connection, k -> new ArrayDeque<>());\n\t\t\t\tsessions.add(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,payload)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload) throws MessagingException {\n\t\tconvertAndSend(destinationName, payload, (Map<String, Object>) null);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,payload,Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destinationName, payload, headers, null);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,payload,Map<String,headers,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tMessage<?> message = doConvert(payload, headers, postProcessor);\n\t\tsend(destinationName, message);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,payload,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(String destinationName, Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destinationName, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(payload,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, payload, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), payload, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass) throws MessagingException {\n\n\t\treturn convertSendAndReceive(destinationName, request, headers, targetClass, null);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor postProcessor) {\n\n\t\tMessage<?> requestMessage = doConvert(request, headers, postProcessor);\n\t\tMessage<?> replyMessage = sendAndReceive(destinationName, requestMessage);\n\t\treturn (replyMessage != null ? (T) getMessageConverter().fromMessage(replyMessage, targetClass) : null);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(destinationName,request,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 285
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)\n\t\t\tthrows MessagingException {\n\n\t\treturn convertSendAndReceive(destinationName, request, null, targetClass);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(destinationName,request,targetClass,requestPostProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass",
      "requestPostProcessor"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor requestPostProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor requestPostProcessor) throws MessagingException {\n\n\t\treturn convertSendAndReceive(destinationName, request, null, targetClass, requestPostProcessor);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(request,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(request, targetClass, null);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertSendAndReceive(request,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor) {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\treturn convertSendAndReceive(defaultDestination, request, targetClass, postProcessor);\n\t\t}\n\t\telse {\n\t\t\treturn convertSendAndReceive(getRequiredDefaultDestinationName(), request, targetClass, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(destination,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "protected void doSend(Destination destination, Message<?> message)",
    "source_code": "\tprotected void doSend(Destination destination, Message<?> message) {\n\t\ttry {\n\t\t\tobtainJmsTemplate().send(destination, createMessageCreator(message));\n\t\t}\n\t\tcatch (JmsException ex) {\n\t\t\tthrow convertJmsException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(destinationName,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "protected void doSend(String destinationName, Message<?> message)",
    "source_code": "\tprotected void doSend(String destinationName, Message<?> message) {\n\t\ttry {\n\t\t\tobtainJmsTemplate().send(destinationName, createMessageCreator(message));\n\t\t}\n\t\tcatch (JmsException ex) {\n\t\t\tthrow convertJmsException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveAndConvert(destinationName,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "T",
    "signature": "public T receiveAndConvert(String destinationName, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) throws MessagingException {\n\t\tMessage<?> message = doReceive(destinationName);\n\t\tif (message != null) {\n\t\t\treturn doConvert(message, targetClass);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destinationName,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void send(String destinationName, Message<?> message)",
    "source_code": "\tpublic void send(String destinationName, Message<?> message) throws MessagingException {\n\t\tdoSend(destinationName, message);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#includeOperation(method,beanKey)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check to see if the {@code Method} is declared in\n\t * one of the configured interfaces and that it is public.\n\t * @param method the operation {@code Method}.\n\t * @param beanKey the key associated with the MBean in the\n\t * {@code beans} {@code Map}.\n\t * @return {@code true} if the {@code Method} is declared in one of the\n\t * configured interfaces, otherwise {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "boolean",
    "signature": "protected boolean includeOperation(Method method, String beanKey)",
    "source_code": "\tprotected boolean includeOperation(Method method, String beanKey) {\n\t\treturn isPublicInInterface(method, beanKey);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#includeReadAttribute(method,beanKey)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check to see if the {@code Method} is declared in\n\t * one of the configured interfaces and that it is public.\n\t * @param method the accessor {@code Method}.\n\t * @param beanKey the key associated with the MBean in the\n\t * {@code beans} {@code Map}.\n\t * @return {@code true} if the {@code Method} is declared in one of the\n\t * configured interfaces, otherwise {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "protected boolean includeReadAttribute(Method method, String beanKey)",
    "source_code": "\tprotected boolean includeReadAttribute(Method method, String beanKey) {\n\t\treturn isPublicInInterface(method, beanKey);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#includeWriteAttribute(method,beanKey)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check to see if the {@code Method} is declared in\n\t * one of the configured interfaces and that it is public.\n\t * @param method the mutator {@code Method}.\n\t * @param beanKey the key associated with the MBean in the\n\t * {@code beans} {@code Map}.\n\t * @return {@code true} if the {@code Method} is declared in one of the\n\t * configured interfaces, otherwise {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "boolean",
    "signature": "protected boolean includeWriteAttribute(Method method, String beanKey)",
    "source_code": "\tprotected boolean includeWriteAttribute(Method method, String beanKey) {\n\t\treturn isPublicInInterface(method, beanKey);\n\t}"
  },
  "org.springframework.jmx.export.naming.<unknown>#getObjectName(managedBean,beanKey)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempts to retrieve the {@code ObjectName} via the given key, trying to\n\t * find a mapped value in the mappings first.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedBean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "ObjectName",
    "signature": "public ObjectName getObjectName(Object managedBean, @Nullable String beanKey)",
    "source_code": "\tpublic ObjectName getObjectName(Object managedBean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tAssert.notNull(beanKey, \"KeyNamingStrategy requires bean key\");\n\t\tString objectName = null;\n\t\tif (this.mergedMappings != null) {\n\t\t\tobjectName = this.mergedMappings.getProperty(beanKey);\n\t\t}\n\t\tif (objectName == null) {\n\t\t\tobjectName = beanKey;\n\t\t}\n\t\treturn ObjectNameManager.getInstance(objectName);\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#appendIdentityToObjectName(objectName,managedResource)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append an additional key/value pair to an existing {@link ObjectName} with the key being\n\t * the static value {@code identity} and the value being the identity hash code of the\n\t * managed resource being exposed on the supplied {@link ObjectName}. This can be used to\n\t * provide a unique {@link ObjectName} for each distinct instance of a particular bean or\n\t * class. Useful when generating {@link ObjectName ObjectNames} at runtime for a set of\n\t * managed resources based on the template value supplied by a\n\t * {@link org.springframework.jmx.export.naming.ObjectNamingStrategy}.\n\t * @param objectName the original JMX ObjectName\n\t * @param managedResource the MBean instance\n\t * @return an ObjectName with the MBean identity added\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see org.springframework.util.ObjectUtils#getIdentityHexString(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "objectName",
      "managedResource"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ObjectName",
    "signature": "public ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)",
    "source_code": "\tpublic static ObjectName appendIdentityToObjectName(ObjectName objectName, Object managedResource)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\tHashtable<String, String> keyProperties = objectName.getKeyPropertyList();\n\t\tkeyProperties.put(IDENTITY_OBJECT_NAME_KEY, ObjectUtils.getIdentityHexString(managedResource));\n\t\treturn ObjectNameManager.getInstance(objectName.getDomain(), keyProperties);\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#getAttributeName(property,useStrictCasing)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the JMX attribute name to use for the given JavaBeans property.\n\t * <p>When using strict casing, a JavaBean property with a getter method\n\t * such as {@code getFoo()} translates to an attribute called\n\t * {@code Foo}. With strict casing disabled, {@code getFoo()}\n\t * would translate to just {@code foo}.\n\t * @param property the JavaBeans property descriptor\n\t * @param useStrictCasing whether to use strict casing\n\t * @return the JMX attribute name to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "useStrictCasing"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "String",
    "signature": "public String getAttributeName(PropertyDescriptor property, boolean useStrictCasing)",
    "source_code": "\tpublic static String getAttributeName(PropertyDescriptor property, boolean useStrictCasing) {\n\t\tif (useStrictCasing) {\n\t\t\treturn StringUtils.capitalize(property.getName());\n\t\t}\n\t\telse {\n\t\t\treturn property.getName();\n\t\t}\n\t}"
  },
  "org.springframework.jndi.<unknown>#bind(name,object)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Bind the given object to the current JNDI context, using the given name.\n\t * @param name the JNDI name of the object\n\t * @param object the object to bind\n\t * @throws NamingException thrown by JNDI, mostly name already bound\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "public void bind(final String name, final Object object)",
    "source_code": "\tpublic void bind(final String name, final Object object) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Binding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.bind(name, object);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.jndi.<unknown>#lookup(name,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the object with the given name in the current JNDI context.\n\t * @param name the JNDI name of the object\n\t * @param requiredType type the JNDI object must match. Can be an interface or\n\t * superclass of the actual class, or {@code null} for any match. For example,\n\t * if the value is {@code Object.class}, this method will succeed whatever\n\t * the class of the returned instance.\n\t * @return object found (cannot be {@code null}; if a not so well-behaved\n\t * JNDI implementations returns null, a NamingException gets thrown)\n\t * @throws NamingException if there is no object with the given\n\t * name bound to JNDI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "T",
    "signature": "public T lookup(String name, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T lookup(String name, @Nullable Class<T> requiredType) throws NamingException {\n\t\tObject jndiObject = lookup(name);\n\t\tif (requiredType != null && !requiredType.isInstance(jndiObject)) {\n\t\t\tthrow new TypeMismatchNamingException(name, requiredType, jndiObject.getClass());\n\t\t}\n\t\treturn (T) jndiObject;\n\t}"
  },
  "org.springframework.jndi.<unknown>#rebind(name,object)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Rebind the given object to the current JNDI context, using the given name.\n\t * Overwrites any existing binding.\n\t * @param name the JNDI name of the object\n\t * @param object the object to rebind\n\t * @throws NamingException thrown by JNDI\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void rebind(final String name, final Object object)",
    "source_code": "\tpublic void rebind(final String name, final Object object) throws NamingException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rebinding JNDI object with name [\" + name + \"]\");\n\t\t}\n\t\texecute(ctx -> {\n\t\t\tctx.rebind(name, object);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#getBean(name,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object",
    "signature": "public Object getBean(String name, @Nullable Object @Nullable ... args)",
    "source_code": "\tpublic Object getBean(String name, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(name);\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#getBean(name,requiredType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\ttry {\n\t\t\tif (isSingleton(name)) {\n\t\t\t\treturn doGetSingleton(name, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn lookup(name, requiredType);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException ex) {\n\t\t\tthrow new NoSuchBeanDefinitionException(name, \"not found in JNDI environment\");\n\t\t}\n\t\tcatch (TypeMismatchNamingException ex) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, ex.getRequiredType(), ex.getActualType());\n\t\t}\n\t\tcatch (NamingException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"JNDI environment\", name, \"JNDI lookup failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#getBean(requiredType,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, @Nullable Object @Nullable ... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object @Nullable ... args) throws BeansException {\n\t\tif (args != null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"SimpleJndiBeanFactory does not support explicit bean creation arguments\");\n\t\t}\n\t\treturn getBean(requiredType);\n\t}"
  },
  "org.springframework.jndi.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tClass<?> type = getType(name);\n\t\treturn (typeToMatch == null || (type != null && typeToMatch.isAssignableFrom(type)));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createFileTypeMap(mappingLocation,mappings)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Compile a {@link FileTypeMap} from the mappings in the given mapping file\n\t * and the given mapping entries.\n\t * <p>The default implementation creates an Activation Framework {@link MimetypesFileTypeMap},\n\t * passing in an InputStream from the mapping resource (if any) and registering\n\t * the mapping lines programmatically.\n\t * @param mappingLocation a {@code mime.types} mapping resource (can be {@code null})\n\t * @param mappings an array of MIME type mapping lines (can be {@code null})\n\t * @return the compiled FileTypeMap\n\t * @throws IOException if resource access failed\n\t * @see jakarta.activation.MimetypesFileTypeMap#MimetypesFileTypeMap(java.io.InputStream)\n\t * @see jakarta.activation.MimetypesFileTypeMap#addMimeTypes(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappingLocation",
      "mappings"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "FileTypeMap",
    "signature": "protected FileTypeMap createFileTypeMap(@Nullable Resource mappingLocation, String @Nullable [] mappings)",
    "source_code": "\tprotected FileTypeMap createFileTypeMap(@Nullable Resource mappingLocation, String @Nullable [] mappings) throws IOException {\n\t\tMimetypesFileTypeMap fileTypeMap = null;\n\t\tif (mappingLocation != null) {\n\t\t\ttry (InputStream is = mappingLocation.getInputStream()) {\n\t\t\t\tfileTypeMap = new MimetypesFileTypeMap(is);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfileTypeMap = new MimetypesFileTypeMap();\n\t\t}\n\t\tif (mappings != null) {\n\t\t\tfor (String mapping : mappings) {\n\t\t\t\tfileTypeMap.addMimeTypes(mapping);\n\t\t\t}\n\t\t}\n\t\treturn fileTypeMap;\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#doSend(mimeMessages,originalMessages)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually send the given array of MimeMessages via JavaMail.\n\t * @param mimeMessages the MimeMessage objects to send\n\t * @param originalMessages corresponding original message objects\n\t * that the MimeMessages have been created from (with same array\n\t * length and indices as the \"mimeMessages\" array), if any\n\t * @throws org.springframework.mail.MailAuthenticationException\n\t * in case of authentication failure\n\t * @throws org.springframework.mail.MailSendException\n\t * in case of failure when sending a message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeMessages",
      "originalMessages"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "void",
    "signature": "protected void doSend(MimeMessage[] mimeMessages, Object @Nullable [] originalMessages)",
    "source_code": "\tprotected void doSend(MimeMessage[] mimeMessages, Object @Nullable [] originalMessages) throws MailException {\n\t\tMap<Object, Exception> failedMessages = new LinkedHashMap<>();\n\t\tTransport transport = null;\n\n\t\ttry {\n\t\t\tfor (int i = 0; i < mimeMessages.length; i++) {\n\n\t\t\t\t// Check transport connection first...\n\t\t\t\tif (transport == null || !transport.isConnected()) {\n\t\t\t\t\tif (transport != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttransport.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t// Ignore - we're reconnecting anyway\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransport = null;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttransport = connectTransport();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (AuthenticationFailedException ex) {\n\t\t\t\t\t\tthrow new MailAuthenticationException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// Effectively, all remaining messages failed...\n\t\t\t\t\t\tfor (int j = i; j < mimeMessages.length; j++) {\n\t\t\t\t\t\t\tObject original = (originalMessages != null ? originalMessages[j] : mimeMessages[j]);\n\t\t\t\t\t\t\tfailedMessages.put(original, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MailSendException(\"Mail server connection failed\", ex, failedMessages);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Send message via current transport...\n\t\t\t\tMimeMessage mimeMessage = mimeMessages[i];\n\t\t\t\ttry {\n\t\t\t\t\tif (mimeMessage.getSentDate() == null) {\n\t\t\t\t\t\tmimeMessage.setSentDate(new Date());\n\t\t\t\t\t}\n\t\t\t\t\tString messageId = mimeMessage.getMessageID();\n\t\t\t\t\tmimeMessage.saveChanges();\n\t\t\t\t\tif (messageId != null) {\n\t\t\t\t\t\t// Preserve explicitly specified message id...\n\t\t\t\t\t\tmimeMessage.setHeader(HEADER_MESSAGE_ID, messageId);\n\t\t\t\t\t}\n\t\t\t\t\tAddress[] addresses = mimeMessage.getAllRecipients();\n\t\t\t\t\ttransport.sendMessage(mimeMessage, (addresses != null ? addresses : new Address[0]));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tObject original = (originalMessages != null ? originalMessages[i] : mimeMessage);\n\t\t\t\t\tfailedMessages.put(original, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (transport != null) {\n\t\t\t\t\ttransport.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (!failedMessages.isEmpty()) {\n\t\t\t\t\tthrow new MailSendException(\"Failed to close server connection after message failures\", ex,\n\t\t\t\t\t\t\tfailedMessages);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MailSendException(\"Failed to close server connection after message sending\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!failedMessages.isEmpty()) {\n\t\t\tthrow new MailSendException(failedMessages);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destinationName,payload)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload) {\n\t\tconvertAndSend(destinationName, payload, null, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destinationName,payload,Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload, @Nullable Map<String, Object> headers) {\n\t\tconvertAndSend(destinationName, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destinationName,payload,Map<String,headers,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor) {\n\n\t\tD destination = resolveDestination(destinationName);\n\t\tsuper.convertAndSend(destination, payload, headers, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destinationName,payload,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, T payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> void convertAndSend(String destinationName, T payload, @Nullable MessagePostProcessor postProcessor) {\n\t\tconvertAndSend(destinationName, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destination,request,Map<String,headers,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(\n\t\t\tD destination, Object request, @Nullable Map<String, Object> headers, Class<T> targetClass) {\n\n\t\treturn convertSendAndReceive(destination, request, headers, targetClass, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destination,request,Map<String,headers,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "Map<String",
      "headers",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, @Nullable Map<String, Object> headers,\n\t\t\tClass<T> targetClass, @Nullable MessagePostProcessor postProcessor) {\n\n\t\tMessage<?> requestMessage = doConvert(request, headers, postProcessor);\n\t\tMessage<?> replyMessage = sendAndReceive(destination, requestMessage);\n\t\treturn (replyMessage != null ? (T) getMessageConverter().fromMessage(replyMessage, targetClass) : null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destination,request,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(destination, request, null, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destination,request,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(D destination, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(D destination, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor) {\n\n\t\treturn convertSendAndReceive(destination, request, null, targetClass, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass) {\n\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.convertSendAndReceive(destination, request, headers, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destinationName,request,Map<String,headers,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "Map<String",
      "headers",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request,\n\t\t\t@Nullable Map<String, Object> headers, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor) {\n\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.convertSendAndReceive(destination, request, headers, targetClass, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destinationName,request,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass) {\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.convertSendAndReceive(destination, request, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(destinationName,request,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(String destinationName, Object request, Class<T> targetClass,\n\t\t\t@Nullable MessagePostProcessor postProcessor) {\n\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.convertSendAndReceive(destination, request, targetClass, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(request,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(Object request, Class<T> targetClass) {\n\t\treturn convertSendAndReceive(getRequiredDefaultDestination(), request, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertSendAndReceive(request,targetClass,postProcessor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "targetClass",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "T",
    "signature": "public T convertSendAndReceive(Object request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic <T> @Nullable T convertSendAndReceive(\n\t\t\tObject request, Class<T> targetClass, @Nullable MessagePostProcessor postProcessor) {\n\n\t\treturn convertSendAndReceive(getRequiredDefaultDestination(), request, targetClass, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doConvert(message,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert from the given message to the given target class.\n\t * @param message the message to convert\n\t * @param targetClass the target class to convert the payload to\n\t * @return the converted payload of the reply message (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "T",
    "signature": "protected T doConvert(Message<?> message, Class<T> targetClass)",
    "source_code": "\tprotected <T> @Nullable T doConvert(Message<?> message, Class<T> targetClass) {\n\t\tMessageConverter messageConverter = getMessageConverter();\n\t\tT value = (T) messageConverter.fromMessage(message, targetClass);\n\t\tif (value == null) {\n\t\t\tthrow new MessageConversionException(message, \"Unable to convert payload [\" + message.getPayload() +\n\t\t\t\t\t\"] to type [\" + targetClass + \"] using converter [\" + messageConverter + \"]\");\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#receiveAndConvert(destination,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "T",
    "signature": "public T receiveAndConvert(D destination, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(D destination, Class<T> targetClass) {\n\t\tMessage<?> message = doReceive(destination);\n\t\tif (message != null) {\n\t\t\treturn doConvert(message, targetClass);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#receiveAndConvert(destinationName,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "T",
    "signature": "public T receiveAndConvert(String destinationName, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T receiveAndConvert(String destinationName, Class<T> targetClass) {\n\t\tD destination = resolveDestination(destinationName);\n\t\treturn super.receiveAndConvert(destination, targetClass);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#send(destinationName,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void send(String destinationName, Message<?> message)",
    "source_code": "\tpublic void send(String destinationName, Message<?> message) {\n\t\tD destination = resolveDestination(destinationName);\n\t\tdoSend(destination, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleEncodedContent(encodedContent,returnType,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses implement this method to handle encoded values in some way\n\t * such as creating and sending messages.\n\t * @param encodedContent the encoded content; each {@code DataBuffer}\n\t * represents the fully-aggregated, encoded content for one value\n\t * (i.e. payload) returned from the HandlerMethod.\n\t * @param returnType return type of the handler method that produced the data\n\t * @param message the input message handled by the handler method\n\t * @return completion {@code Mono<Void>} for the handling\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "encodedContent",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleEncodedContent(Flux<DataBuffer> encodedContent, MethodParameter returnType, Message<?> message)",
    "source_code": "\tprotected abstract Mono<Void> handleEncodedContent(\n\t\t\tFlux<DataBuffer> encodedContent, MethodParameter returnType, Message<?> message);\n\n\t/**\n\t * Invoked for a {@code null} return value, which could mean a void method"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleNoContent(returnType,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked for a {@code null} return value, which could mean a void method\n\t * or method returning an async type parameterized by void.\n\t * @param returnType return type of the handler method that produced the data\n\t * @param message the input message handled by the handler method\n\t * @return completion {@code Mono<Void>} for the handling\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message)",
    "source_code": "\tprotected abstract Mono<Void> handleNoContent(MethodParameter returnType, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic Mono<Void> handleReturnValue(\n\t\t\t@Nullable Object returnValue, MethodParameter returnType, Message<?> message) {\n\n\t\tif (returnValue == null) {\n\t\t\treturn handleNoContent(returnType, message);\n\t\t}\n\n\t\tDataBufferFactory bufferFactory = (DataBufferFactory) message.getHeaders()\n\t\t\t\t.getOrDefault(HandlerMethodReturnValueHandler.DATA_BUFFER_FACTORY_HEADER,\n\t\t\t\t\t\tDefaultDataBufferFactory.sharedInstance);\n\n\t\tMimeType mimeType = (MimeType) message.getHeaders().get(MessageHeaders.CONTENT_TYPE);\n\t\tFlux<DataBuffer> encodedContent = encodeContent(\n\t\t\t\treturnValue, returnType, bufferFactory, mimeType, Collections.emptyMap());\n\n\t\treturn new ChannelSendOperator<>(encodedContent, publisher ->\n\t\t\t\thandleEncodedContent(Flux.from(publisher), returnType, message));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#connectTcp(host,port)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "port"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Mono<RSocketRequester>",
    "signature": "public Mono<RSocketRequester> connectTcp(String host, int port)",
    "source_code": "\tpublic Mono<RSocketRequester> connectTcp(String host, int port) {\n\t\treturn connect(TcpClientTransport.create(host, port));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#tcp(host,port)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "port"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester tcp(String host, int port)",
    "source_code": "\tpublic RSocketRequester tcp(String host, int port) {\n\t\treturn transport(TcpClientTransport.create(host, port));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#transports(targetPublisher,loadbalanceStrategy)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetPublisher",
      "loadbalanceStrategy"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "RSocketRequester",
    "signature": "public RSocketRequester transports(Publisher<List<LoadbalanceTarget>> targetPublisher, LoadbalanceStrategy loadbalanceStrategy)",
    "source_code": "\tpublic RSocketRequester transports(\n\t\t\tPublisher<List<LoadbalanceTarget>> targetPublisher, LoadbalanceStrategy loadbalanceStrategy) {\n\n\t\tRSocketStrategies strategies = getRSocketStrategies();\n\t\tMimeType metaMimeType = getMetadataMimeType();\n\t\tMimeType dataMimeType = getDataMimeType(strategies);\n\n\t\tRSocketConnector connector = initConnector(\n\t\t\t\tthis.rsocketConnectorConfigurers, metaMimeType, dataMimeType, strategies);\n\n\t\tLoadbalanceRSocketClient client = LoadbalanceRSocketClient.builder(targetPublisher)\n\t\t\t\t.connector(connector)\n\t\t\t\t.loadbalanceStrategy(loadbalanceStrategy)\n\t\t\t\t.build();\n\n\t\treturn new DefaultRSocketRequester(client, null, dataMimeType, metaMimeType, strategies);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getDestination(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String getDestination(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getDestination(Map<String, Object> headers) {\n\t\treturn (String) headers.get(DESTINATION_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getMessageType(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "SimpMessageType",
    "signature": "public SimpMessageType getMessageType(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable SimpMessageType getMessageType(Map<String, Object> headers) {\n\t\treturn (SimpMessageType) headers.get(MESSAGE_TYPE_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getSessionAttributes(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "Object>",
    "signature": "public Object> getSessionAttributes(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable Map<String, Object> getSessionAttributes(Map<String, Object> headers) {\n\t\treturn (Map<String, Object>) headers.get(SESSION_ATTRIBUTES);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getSessionId(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "String",
    "signature": "public String getSessionId(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getSessionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SESSION_ID_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getSubscriptionId(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String",
    "signature": "public String getSubscriptionId(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable String getSubscriptionId(Map<String, Object> headers) {\n\t\treturn (String) headers.get(SUBSCRIPTION_ID_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#getUser(Map<String,headers)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "Principal",
    "signature": "public Principal getUser(Map<String, Object> headers)",
    "source_code": "\tpublic static @Nullable Principal getUser(Map<String, Object> headers) {\n\t\treturn (Principal) headers.get(USER_HEADER);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#setSessionAttributes(Map<String,attributes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * A static alternative for access to the session attributes header.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void setSessionAttributes(@Nullable Map<String, Object> attributes)",
    "source_code": "\tpublic void setSessionAttributes(@Nullable Map<String, Object> attributes) {\n\t\tsetHeader(SESSION_ATTRIBUTES, attributes);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#decode(byteBuffer,MultiValueMap<String,partialMessageHeaders)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Decodes one or more STOMP frames from the given {@code buffer} and returns\n\t * a list of {@link Message Messages}.\n\t * <p>If the given ByteBuffer contains only partial STOMP frame content and no\n\t * complete STOMP frames, an empty list is returned, and the buffer is reset\n\t * to where it was.\n\t * <p>If the buffer contains one or more STOMP frames, those are returned, and\n\t * the buffer is reset to point to the beginning of the unused partial content.\n\t * <p>The {@code partialMessageHeaders} map is used to store successfully parsed\n\t * headers in case of partial content. The caller can then check if a\n\t * \"content-length\" header was read, which helps to determine how much more\n\t * content is needed before the next attempt to decode.\n\t * @param byteBuffer the buffer to decode the STOMP frame from\n\t * @param partialMessageHeaders an empty output map that will store the last\n\t * successfully parsed partial message headers in case of partial message content\n\t * in cases where the partial buffer ended with a partial STOMP frame\n\t * @return the decoded messages, or an empty list if none\n\t * @throws StompConversionException in case of decoding issues\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer",
      "MultiValueMap<String",
      "partialMessageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "List<Message<byte[]>>",
    "signature": "public List<Message<byte[]>> decode(ByteBuffer byteBuffer,\n\t\t\t@Nullable MultiValueMap<String, String> partialMessageHeaders)",
    "source_code": "\tpublic List<Message<byte[]>> decode(ByteBuffer byteBuffer,\n\t\t\t@Nullable MultiValueMap<String, String> partialMessageHeaders) {\n\n\t\tList<Message<byte[]>> messages = new ArrayList<>();\n\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\tMessage<byte[]> message = decodeMessage(byteBuffer, partialMessageHeaders);\n\t\t\tif (message != null) {\n\t\t\t\tmessages.add(message);\n\t\t\t\tskipEol(byteBuffer);\n\t\t\t\tif (!byteBuffer.hasRemaining()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn messages;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getHeaderIfAvailable(Map<String,headers,name,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the header value, or {@code null} if it does not exist\n\t * or does not match the requested {@code type}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers",
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "V",
    "signature": "protected V getHeaderIfAvailable(Map<String, Object> headers, String name, Class<V> type)",
    "source_code": "\tprotected <V> @Nullable V getHeaderIfAvailable(Map<String, Object> headers, String name, Class<V> type) {\n\t\tObject value = headers.get(name);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Skipping header '\" + name + \"': expected type [\" + type + \"], but got [\" +\n\t\t\t\t\t\tvalue.getClass() + \"]\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn type.cast(value);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#sendInternal(message,timeout)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t\t}\n\t\t\t\tcatch (RejectedExecutionException ex) {\n\t\t\t\t\t// Probably on shutdown -> run send task locally instead\n\t\t\t\t\tsendTask.run();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No executor configured -> always run send tasks locally\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#applyNamedParameterToQuery(queryObject,paramName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject",
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1116
    },
    "return": "void",
    "signature": "protected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)",
    "source_code": "\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)\n\t\t\tthrows HibernateException {\n\n\t\tif (value instanceof Collection<?> collection) {\n\t\t\tqueryObject.setParameterList(paramName, collection);\n\t\t}\n\t\telse if (value instanceof Object[] array) {\n\t\t\tqueryObject.setParameterList(paramName, array);\n\t\t}\n\t\telse {\n\t\t\tqueryObject.setParameter(paramName, value);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#bulkUpdate(queryString,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryString",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1015
    },
    "return": "int",
    "signature": "public int bulkUpdate(String queryString, @Nullable Object... values)",
    "source_code": "\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void delete(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\tsession.delete(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doExecute(action,enforceNativeSession)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "action",
      "enforceNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "T",
    "signature": "protected T doExecute(HibernateCallback<T> action, boolean enforceNativeSession)",
    "source_code": "\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(String entityName, T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(exampleEntity, \"Example entity must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria executableCriteria = (entityName != null ?\n\t\t\t\t\tsession.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass()));\n\t\t\texecutableCriteria.add(Example.create(exampleEntity));\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id)",
    "source_code": "\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entity,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void load(Object entity, Serializable id)",
    "source_code": "\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityClass, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id)",
    "source_code": "\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void lock(Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void lock(String entityName, Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(String entityName, Object entity, LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#merge(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#persist(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "public void persist(String entityName, Object entity)",
    "source_code": "\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#refresh(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void refresh(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entity,replicationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void replicate(Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entityName,entity,replicationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void replicate(String entityName, Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entityName, entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#save(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "Serializable",
    "signature": "public Serializable save(String entityName, Object entity)",
    "source_code": "\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#saveOrUpdate(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void saveOrUpdate(String entityName, Object entity)",
    "source_code": "\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void update(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entityName, entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.jpa.persistenceunit.<unknown>#setDataSources(Map<String,dataSources)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the JDBC DataSources that the JPA persistence provider is supposed\n\t * to use for accessing the database, resolving data source names in\n\t * {@code persistence.xml} against Spring-managed DataSources.\n\t * <p>The specified Map needs to define data source names for specific DataSource\n\t * objects, matching the data source names used in {@code persistence.xml}.\n\t * If not specified, data source names will be resolved as JNDI names instead\n\t * (as defined by standard JPA).\n\t * @see org.springframework.jdbc.datasource.lookup.MapDataSourceLookup\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "dataSources"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void setDataSources(Map<String, DataSource> dataSources)",
    "source_code": "\tpublic void setDataSources(Map<String, DataSource> dataSources) {\n\t\tthis.dataSourceLookup = new MapDataSourceLookup(dataSources);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#addCallback(successCallback,failureCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "successCallback",
      "failureCallback"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback)",
    "source_code": "\tpublic void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback) {\n\t\ttry {\n\t\t\tif (this.executionException != null) {\n\t\t\t\tfailureCallback.onFailure(exposedException(this.executionException));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccessCallback.onSuccess(this.value);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#configure(executor,exceptionHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this post-processor with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<? extends @Nullable Executor> executor,\n\t\t\t@Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tpublic void configure(@Nullable Supplier<? extends @Nullable Executor> executor,\n\t\t\t@Nullable Supplier<? extends @Nullable AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tthis.executor = executor;\n\t\tthis.exceptionHandler = exceptionHandler;\n\t}"
  },
  "org.springframework.test.context.<unknown>#findAnnotationDescriptor(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}\n\t * on the supplied {@link Class}, traversing its annotations, interfaces,\n\t * superclasses, and enclosing classes if no annotation can be found on the\n\t * given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return a corresponding\n\t * {@code AnnotationDescriptor} if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the corresponding annotation descriptor if the annotation was found;\n\t * otherwise {@code null}\n\t * @see #findAnnotationDescriptorForTypes(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "AnnotationDescriptor<T>",
    "signature": "public AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable AnnotationDescriptor<T> findAnnotationDescriptor(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\tAssert.notNull(annotationType, \"Annotation type must not be null\");\n\t\treturn findAnnotationDescriptor(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass,\n\t\t\tnew HashSet<>());\n\t}"
  },
  "org.springframework.test.context.<unknown>#findAnnotationDescriptorForTypes(clazz,annotationTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}\n\t * in the inheritance hierarchy of the specified {@code clazz} (including\n\t * the specified {@code clazz} itself) which declares at least one of the\n\t * specified {@code annotationTypes}.\n\t * <p>This method traverses the annotations, interfaces, superclasses, and\n\t * enclosing classes of the specified {@code clazz} if no annotation can be\n\t * found on the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as\n\t * well as meta-annotations</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for a local declaration of one of the annotation types on the\n\t * given class and return a corresponding {@code UntypedAnnotationDescriptor}\n\t * if found.\n\t * <li>Recursively search through all annotations that the given class declares.</li>\n\t * <li>Recursively search through all interfaces implemented by the given class.</li>\n\t * <li>Recursively search through the superclass hierarchy of the given class.</li>\n\t * <li>Recursively search through the enclosing class hierarchy of the given class\n\t * if appropriate according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.</li>\n\t * </ol>\n\t * <p>In this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current annotation,\n\t * interface, superclass, or enclosing class as the class to look for\n\t * annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationTypes the types of annotations to look for\n\t * @return the corresponding annotation descriptor if one of the annotations\n\t * was found; otherwise {@code null}\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "UntypedAnnotationDescriptor",
    "signature": "public UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, Class<? extends Annotation>... annotationTypes)",
    "source_code": "\tpublic static @Nullable UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(\n\t\t\tClass<?> clazz, Class<? extends Annotation>... annotationTypes) {\n\n\t\tassertNonEmptyAnnotationTypeArray(annotationTypes, \"The list of annotation types must not be empty\");\n\t\treturn findAnnotationDescriptorForTypes(clazz, annotationTypes, new HashSet<>());\n\t}"
  },
  "org.springframework.test.context.<unknown>#findMergedAnnotation(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied class, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy, and synthesize the result back\n\t * into an annotation of the specified {@code annotationType}.\n\t * <p>In the context of this method, the term \"above\" means within the\n\t * {@linkplain Class#getSuperclass() superclass} hierarchy or within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @see AnnotatedElementUtils#findMergedAnnotation(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #findAnnotationDescriptor(Class, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "T",
    "signature": "public T findMergedAnnotation(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> @Nullable T findMergedAnnotation(Class<?> clazz, Class<T> annotationType) {\n\t\treturn findMergedAnnotation(clazz, annotationType, TestContextAnnotationUtils::searchEnclosingClass);\n\t}"
  },
  "org.springframework.test.context.<unknown>#getMergedRepeatableAnnotations(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied class; and for\n\t * each annotation found, merge that annotation's attributes with <em>matching</em>\n\t * attributes from annotations in lower levels of the annotation hierarchy and\n\t * synthesize the results back into an annotation of the specified {@code annotationType}.\n\t * <p>This method will find {@link java.lang.annotation.Inherited @Inherited}\n\t * annotations declared on superclasses if the supplied class does not have\n\t * any local declarations of the repeatable annotation. If no inherited\n\t * annotations are found, this method will search within the\n\t * {@linkplain Class#getEnclosingClass() enclosing class} hierarchy of the\n\t * supplied class. The enclosing class hierarchy will only be searched\n\t * according to {@link NestedTestConfiguration @NestedTestConfiguration}\n\t * semantics.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param clazz the class on which to search for annotations (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable annotations found, or an empty set\n\t * if none were found\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(java.lang.reflect.AnnotatedElement, Class)\n\t * @see #searchEnclosingClass(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Set<T>",
    "signature": "public Set<T> getMergedRepeatableAnnotations(Class<?> clazz, Class<T> annotationType)",
    "source_code": "\tpublic static <T extends Annotation> Set<T> getMergedRepeatableAnnotations(\n\t\t\tClass<?> clazz, Class<T> annotationType) {\n\n\t\t// Present (via @Inherited semantics), directly present, or meta-present?\n\t\tSet<T> mergedAnnotations = MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\n\t\tif (!mergedAnnotations.isEmpty()) {\n\t\t\treturn mergedAnnotations;\n\t\t}\n\n\t\t// Declared on an enclosing class of an inner class?\n\t\tif (searchEnclosingClass(clazz)) {\n\t\t\t// Then mimic @Inherited semantics within the enclosing class hierarchy.\n\t\t\treturn getMergedRepeatableAnnotations(clazz.getEnclosingClass(), annotationType);\n\t\t}\n\n\t\treturn Collections.emptySet();\n\t}"
  },
  "org.springframework.test.context.<unknown>#hasAnnotation(clazz,annotationType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of the specified {@code annotationType} is\n\t * present or meta-present on the supplied {@link Class} according to the\n\t * search algorithm used in {@link #findMergedAnnotation(Class, Class)}.\n\t * <p>If this method returns {@code true}, then {@code findMergedAnnotation(...)}\n\t * will return a non-null value.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return {@code true} if a matching annotation is present\n\t * @since 5.3.3\n\t * @see #findMergedAnnotation(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "boolean",
    "signature": "public boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean hasAnnotation(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.withEnclosingClasses(TestContextAnnotationUtils::searchEnclosingClass)\n\t\t\t\t.from(clazz)\n\t\t\t\t.isPresent(annotationType);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertBoolean(content,encoding,expectedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Boolean.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue)",
    "source_code": "\tpublic void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, Boolean.parseBoolean(actual));\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNode(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link Node},\n\t * and assert it with the given {@code Matcher<Node>}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)",
    "source_code": "\tpublic void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)\n\t\t\tthrows Exception {\n\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, node, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNodeCount(content,encoding,expectedCount)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as an integer.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount)",
    "source_code": "\tpublic void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount) throws Exception {\n\t\tNodeList nodeList = evaluateXpath(content, encoding, NodeList.class);\n\t\tAssertionErrors.assertEquals(\"nodeCount for XPath \" + this.expression, expectedCount,\n\t\t\t\t(nodeList != null ? nodeList.getLength() : 0));\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNodeCount(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<? super Integer> matcher)",
    "source_code": "\tpublic void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<? super Integer> matcher)\n\t\t\tthrows Exception {\n\n\t\tNodeList nodeList = evaluateXpath(content, encoding, NodeList.class);\n\t\tString reason = \"nodeCount for XPath \" + this.expression;\n\t\tMatcherAssert.assertThat(reason, nodeList != null ? nodeList.getLength() : 0, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNodeList(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the content, evaluate the XPath expression as a {@link NodeList},\n\t * and assert it with the given {@code Matcher<NodeList>}.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)",
    "source_code": "\tpublic void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)\n\t\t\tthrows Exception {\n\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\tNodeList nodeList = evaluateXpath(document, XPathConstants.NODESET, NodeList.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + getXpathExpression(), nodeList, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNumber(content,encoding,expectedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a Double.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue)",
    "source_code": "\tpublic void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertNumber(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher)",
    "source_code": "\tpublic void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher) throws Exception {\n\t\tDouble actual = evaluateXpath(content, encoding, Double.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, actual, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertString(content,encoding,expectedValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content as a String.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void assertString(byte[] content, @Nullable String encoding, String expectedValue)",
    "source_code": "\tpublic void assertString(byte[] content, @Nullable String encoding, String expectedValue) throws Exception {\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tAssertionErrors.assertEquals(\"XPath \" + this.expression, expectedValue, actual);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertString(content,encoding,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content with the\n\t * given Hamcrest matcher.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)",
    "source_code": "\tpublic void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)\n\t\t\tthrows Exception {\n\n\t\tString actual = evaluateXpath(content, encoding, String.class);\n\t\tMatcherAssert.assertThat(\"XPath \" + this.expression, actual, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#doesNotExist(content,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content does not exist.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void doesNotExist(byte[] content, @Nullable String encoding)",
    "source_code": "\tpublic void doesNotExist(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNull(\"XPath \" + this.expression + \" exists\", node);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateXpath(content,encoding,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the XPath and return the resulting value.\n\t * @param content the content to evaluate against\n\t * @param encoding the encoding to use (optionally)\n\t * @param targetClass the target class, one of Number, String, Boolean,\n\t * org.w3c.Node, or NodeList\n\t * @throws Exception if content parsing or expression evaluation fails\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "T",
    "signature": "public T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass)",
    "source_code": "\tpublic <T> @Nullable T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass) throws Exception {\n\t\tDocument document = parseXmlByteArray(content, encoding);\n\t\treturn evaluateXpath(document, toQName(targetClass), targetClass);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateXpath(document,evaluationType,expectedClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression to given document.\n\t * @throws XPathExpressionException if expression evaluation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "document",
      "evaluationType",
      "expectedClass"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "T",
    "signature": "protected T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass)",
    "source_code": "\tprotected <T> @Nullable T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass)\n\t\t\tthrows XPathExpressionException {\n\n\t\treturn (T) getXpathExpression().evaluate(document, evaluationType);\n\t}"
  },
  "org.springframework.test.util.<unknown>#exists(content,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the XPath expression and assert the resulting content exists.\n\t * @throws Exception if content parsing or expression evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void exists(byte[] content, @Nullable String encoding)",
    "source_code": "\tpublic void exists(byte[] content, @Nullable String encoding) throws Exception {\n\t\tNode node = evaluateXpath(content, encoding, Node.class);\n\t\tAssertionErrors.assertNotNull(\"XPath \" + this.expression + \" does not exist\", node);\n\t}"
  },
  "org.springframework.test.util.<unknown>#getField(targetClass,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the static {@linkplain Field field} with the given\n\t * {@code name} from the provided {@code targetClass}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class from which to get the static field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Object",
    "signature": "public Object getField(Class<?> targetClass, String name)",
    "source_code": "\tpublic static @Nullable Object getField(Class<?> targetClass, String name) {\n\t\treturn getField(null, targetClass, name);\n\t}"
  },
  "org.springframework.test.util.<unknown>#getField(targetObject,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}.\n\t * <p>This method delegates to {@link #getField(Object, Class, String)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object from which to get the field;\n\t * never {@code null}\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @see #getField(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object getField(Object targetObject, String name)",
    "source_code": "\tpublic static @Nullable Object getField(Object targetObject, String name) {\n\t\treturn getField(targetObject, null, name);\n\t}"
  },
  "org.springframework.test.util.<unknown>#getField(targetObject,targetClass,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of the {@linkplain Field field} with the given {@code name}\n\t * from the provided {@code targetObject}/{@code targetClass}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be retrieved from the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to get {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * @param targetObject the target object from which to get the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class from which to get the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to get; never {@code null}\n\t * @return the field's current value\n\t * @since 4.2\n\t * @see #getField(Object, String)\n\t * @see #getField(Class, String)\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#getField(Field, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name)",
    "source_code": "\tpublic static @Nullable Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name) {\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\"Either targetObject or targetClass for the field must be specified\");\n\n\t\tif (targetObject != null && springAopPresent) {\n\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t}\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = targetObject.getClass();\n\t\t}\n\n\t\tField field = ReflectionUtils.findField(targetClass, name);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Could not find field '%s' on %s or target class [%s]\",\n\t\t\t\t\tname, safeToString(targetObject), targetClass));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Getting field '%s' from %s or target class [%s]\", name,\n\t\t\t\t\tsafeToString(targetObject), targetClass));\n\t\t}\n\t\tReflectionUtils.makeAccessible(field);\n\t\treturn ReflectionUtils.getField(field, targetObject);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeGetterMethod(target,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the getter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> getter methods.\n\t * <p>This method also supports JavaBean-style <em>property</em> names. For\n\t * example, if you wish to get the {@code name} property on the target object,\n\t * you may pass either {@code \"name\"} or {@code \"getName\"} as the method name.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the getter method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * getter method to be invoked directly on the ultimate target of the proxy.\n\t * @param target the target object on which to invoke the specified getter\n\t * method\n\t * @param name the name of the getter method to invoke or the corresponding\n\t * property name\n\t * @return the value returned from the invocation\n\t * @see ReflectionUtils#findMethod(Class, String, Class[])\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#invokeMethod(Method, Object, Object[])\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Object",
    "signature": "public Object invokeGetterMethod(Object target, String name)",
    "source_code": "\tpublic static @Nullable Object invokeGetterMethod(Object target, String name) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\n\t\tString getterMethodName = name;\n\t\tif (!name.startsWith(GETTER_PREFIX)) {\n\t\t\tgetterMethodName = GETTER_PREFIX + StringUtils.capitalize(name);\n\t\t}\n\t\tMethod method = ReflectionUtils.findMethod(target.getClass(), getterMethodName);\n\t\tif (method == null && !getterMethodName.equals(name)) {\n\t\t\tgetterMethodName = name;\n\t\t\tmethod = ReflectionUtils.findMethod(target.getClass(), getterMethodName);\n\t\t}\n\t\tif (method == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find getter method '%s' on %s\", getterMethodName, safeToString(target)));\n\t\t}\n\n\t\tif (springAopPresent) {\n\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t// method on the ultimate target.\n\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(target, method)) {\n\t\t\t\ttarget = AopTestUtils.getUltimateTargetObject(target);\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Invoking getter method '%s' on %s\", getterMethodName, safeToString(target)));\n\t\t}\n\t\tReflectionUtils.makeAccessible(method);\n\t\treturn ReflectionUtils.invokeMethod(method, target);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeMethod(target,name,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method with the given {@code name} on the supplied target\n\t * object with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param target the target object on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "public T invokeMethod(Object target, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Object target, String name, Object... args) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\treturn invokeMethod(target, null, name, args);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeMethod(targetClass,name,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the static method with the given {@code name} on the supplied target\n\t * class with the supplied arguments.\n\t * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * @param targetClass the target class on which to invoke the specified method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Object, Class, String, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "T",
    "signature": "public T invokeMethod(Class<?> targetClass, String name, Object... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(Class<?> targetClass, String name, Object... args) {\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\treturn invokeMethod(null, targetClass, name, args);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeMethod(targetObject,targetClass,name,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method with the given {@code name} on the provided\n\t * {@code targetObject}/{@code targetClass} with the supplied arguments.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> methods.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * method to be invoked directly on the ultimate target of the proxy.\n\t * @param targetObject the target object on which to invoke the method; may\n\t * be {@code null} if the method is static\n\t * @param targetClass the target class on which to invoke the method; may\n\t * be {@code null} if the method is an instance method\n\t * @param name the name of the method to invoke\n\t * @param args the arguments to provide to the method\n\t * @return the invocation result, if any\n\t * @since 5.2\n\t * @see #invokeMethod(Object, String, Object...)\n\t * @see #invokeMethod(Class, String, Object...)\n\t * @see MethodInvoker\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#handleReflectionException(Exception)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "T",
    "signature": "public T invokeMethod(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name,\n\t\t\tObject... args)",
    "source_code": "\tpublic static <T> @Nullable T invokeMethod(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name,\n\t\t\tObject... args) {\n\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\t\"Either 'targetObject' or 'targetClass' for the method must be specified\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(targetObject);\n\t\t\tif (targetClass != null) {\n\t\t\t\tmethodInvoker.setTargetClass(targetClass);\n\t\t\t}\n\t\t\tmethodInvoker.setTargetMethod(name);\n\t\t\tmethodInvoker.setArguments(args);\n\t\t\tmethodInvoker.prepare();\n\n\t\t\tif (targetObject != null && springAopPresent) {\n\t\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t\t// method on the ultimate target.\n\t\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(targetObject, methodInvoker.getPreparedMethod())) {\n\t\t\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t\t\t\tmethodInvoker.setTargetObject(targetObject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(String.format(\"Invoking method '%s' on %s or %s with arguments %s\", name,\n\t\t\t\t\t\tsafeToString(targetObject), safeToString(targetClass), ObjectUtils.nullSafeToString(args)));\n\t\t\t}\n\n\t\t\treturn (T) methodInvoker.invoke();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tReflectionUtils.handleReflectionException(ex);\n\t\t\tthrow new IllegalStateException(\"Should never get here\");\n\t\t}\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeSetterMethod(target,name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the setter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method delegates to\n\t * {@link #invokeSetterMethod(Object, String, Object, Class)}, supplying\n\t * {@code null} for the parameter type.\n\t * @param target the target object on which to invoke the specified setter\n\t * method\n\t * @param name the name of the setter method to invoke or the corresponding\n\t * property name\n\t * @param value the value to provide to the setter method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "void",
    "signature": "public void invokeSetterMethod(Object target, String name, Object value)",
    "source_code": "\tpublic static void invokeSetterMethod(Object target, String name, Object value) {\n\t\tinvokeSetterMethod(target, name, value, null);\n\t}"
  },
  "org.springframework.test.util.<unknown>#invokeSetterMethod(target,name,value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the setter method with the given {@code name} on the supplied\n\t * target object with the supplied {@code value}.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * method. In addition, an attempt will be made to make non-{@code public}\n\t * methods <em>accessible</em>, thus allowing one to invoke {@code protected},\n\t * {@code private}, and <em>package-private</em> setter methods.\n\t * <p>This method also supports JavaBean-style <em>property</em> names. For\n\t * example, if you wish to set the {@code name} property on the target object,\n\t * you may pass either {@code \"name\"} or {@code \"setName\"} as the method name.\n\t * <p>As of Spring Framework 6.2, if the supplied target object is a CGLIB\n\t * proxy which does not intercept the setter method, the proxy will be\n\t * {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing the\n\t * setter method to be invoked directly on the ultimate target of the proxy.\n\t * @param target the target object on which to invoke the specified setter\n\t * method\n\t * @param name the name of the setter method to invoke or the corresponding\n\t * property name\n\t * @param value the value to provide to the setter method\n\t * @param type the formal parameter type declared by the setter method\n\t * (may be {@code null} to indicate any type)\n\t * @see ReflectionUtils#findMethod(Class, String, Class[])\n\t * @see ReflectionUtils#makeAccessible(Method)\n\t * @see ReflectionUtils#invokeMethod(Method, Object, Object[])\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "void",
    "signature": "public void invokeSetterMethod(Object target, String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void invokeSetterMethod(Object target, String name, @Nullable Object value, @Nullable Class<?> type) {\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.hasText(name, \"Method name must not be empty\");\n\t\tClass<?>[] paramTypes = (type != null ? new Class<?>[] {type} : null);\n\n\t\tString setterMethodName = name;\n\t\tif (!name.startsWith(SETTER_PREFIX)) {\n\t\t\tsetterMethodName = SETTER_PREFIX + StringUtils.capitalize(name);\n\t\t}\n\n\t\tMethod method = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);\n\t\tif (method == null && !setterMethodName.equals(name)) {\n\t\t\tsetterMethodName = name;\n\t\t\tmethod = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);\n\t\t}\n\t\tif (method == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find setter method '%s' on %s with parameter type [%s]\", setterMethodName,\n\t\t\t\t\tsafeToString(target), type));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Invoking setter method '%s' on %s with value [%s]\", setterMethodName,\n\t\t\t\t\tsafeToString(target), value));\n\t\t}\n\n\t\tif (springAopPresent) {\n\t\t\t// If the target is a CGLIB proxy which does not intercept the method, invoke the\n\t\t\t// method on the ultimate target.\n\t\t\tif (isCglibProxyThatDoesNotInterceptMethod(target, method)) {\n\t\t\t\ttarget = AopTestUtils.getUltimateTargetObject(target);\n\t\t\t}\n\t\t}\n\n\t\tReflectionUtils.makeAccessible(method);\n\t\tReflectionUtils.invokeMethod(method, target, value);\n\t}"
  },
  "org.springframework.test.util.<unknown>#parseXmlByteArray(xml,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given XML content to a {@link Document}.\n\t * @param xml the content to parse\n\t * @param encoding optional content encoding, if provided as metadata (for example, in HTTP headers)\n\t * @return the parsed document\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xml",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "Document",
    "signature": "protected Document parseXmlByteArray(byte[] xml, @Nullable String encoding)",
    "source_code": "\tprotected Document parseXmlByteArray(byte[] xml, @Nullable String encoding) throws Exception {\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\tfactory.setNamespaceAware(this.hasNamespaces);\n\t\tDocumentBuilder documentBuilder = factory.newDocumentBuilder();\n\t\tInputSource inputSource = new InputSource(new ByteArrayInputStream(xml));\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\tinputSource.setEncoding(encoding);\n\t\t}\n\t\treturn documentBuilder.parse(inputSource);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetClass,name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the static {@linkplain Field field} with the given {@code name} on\n\t * the provided {@code targetClass} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} and {@code type} arguments.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void setField(Class<?> targetClass, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Class<?> targetClass, String name, @Nullable Object value) {\n\t\tsetField(null, targetClass, name, value, null);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetClass,name,value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the static {@linkplain Field field} with the given\n\t * {@code name}/{@code type} on the provided {@code targetClass} to\n\t * the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetObject} argument.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetClass the target class on which to set the static field;\n\t * never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setField(Class<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField(\n\t\t\tClass<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\n\t\tsetField(null, targetClass, name, value, type);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetObject,name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name} on the\n\t * provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, String, Object, Class)},\n\t * supplying {@code null} for the {@code type} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; never {@code null}\n\t * @param value the value to set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void setField(Object targetObject, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Object targetObject, String name, @Nullable Object value) {\n\t\tsetField(targetObject, name, value, null);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetObject,name,value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name}/{@code type}\n\t * on the provided {@code targetObject} to the supplied {@code value}.\n\t * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},\n\t * supplying {@code null} for the {@code targetClass} argument.\n\t * @param targetObject the target object on which to set the field; never {@code null}\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setField(Object targetObject, @Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField(Object targetObject, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\t\tsetField(targetObject, null, name, value, type);\n\t}"
  },
  "org.springframework.test.util.<unknown>#setField(targetObject,targetClass,name,value,type)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@linkplain Field field} with the given {@code name}/{@code type}\n\t * on the provided {@code targetObject}/{@code targetClass} to the supplied\n\t * {@code value}.\n\t * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will\n\t * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing\n\t * the field to be set on the ultimate target of the proxy.\n\t * <p>This method traverses the class hierarchy in search of the desired\n\t * field. In addition, an attempt will be made to make non-{@code public}\n\t * fields <em>accessible</em>, thus allowing one to set {@code protected},\n\t * {@code private}, and <em>package-private</em> fields.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * @param targetObject the target object on which to set the field; may be\n\t * {@code null} if the field is static\n\t * @param targetClass the target class on which to set the field; may\n\t * be {@code null} if the field is an instance field\n\t * @param name the name of the field to set; may be {@code null} if\n\t * {@code type} is specified\n\t * @param value the value to set\n\t * @param type the type of the field to set; may be {@code null} if\n\t * {@code name} is specified\n\t * @since 4.2\n\t * @see ReflectionUtils#findField(Class, String, Class)\n\t * @see ReflectionUtils#makeAccessible(Field)\n\t * @see ReflectionUtils#setField(Field, Object, Object)\n\t * @see AopTestUtils#getUltimateTargetObject(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetObject",
      "targetClass",
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void setField(@Nullable Object targetObject, @Nullable Class<?> targetClass,\n\t\t\t@Nullable String name, @Nullable Object value, @Nullable Class<?> type)",
    "source_code": "\tpublic static void setField(@Nullable Object targetObject, @Nullable Class<?> targetClass,\n\t\t\t@Nullable String name, @Nullable Object value, @Nullable Class<?> type) {\n\n\t\tAssert.isTrue(targetObject != null || targetClass != null,\n\t\t\t\t\"Either targetObject or targetClass for the field must be specified\");\n\n\t\tif (targetObject != null && springAopPresent) {\n\t\t\ttargetObject = AopTestUtils.getUltimateTargetObject(targetObject);\n\t\t}\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = targetObject.getClass();\n\t\t}\n\n\t\tField field = ReflectionUtils.findField(targetClass, name, type);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Could not find field '%s' of type [%s] on %s or target class [%s]\", name, type,\n\t\t\t\t\tsafeToString(targetObject), targetClass));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\n\t\t\t\t\t\"Setting field '%s' of type [%s] on %s or target class [%s] to value [%s]\", name, type,\n\t\t\t\t\tsafeToString(targetObject), targetClass, value));\n\t\t}\n\t\tReflectionUtils.makeAccessible(field);\n\t\tReflectionUtils.setField(field, targetObject, value);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#attribute(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#cookie(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec cookie(String name, String value)",
    "source_code": "\t\tpublic RequestBodySpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#header(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic RequestBodySpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(expectedJson,comparator)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJson",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 670
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String expectedJson, JsonComparator comparator)",
    "source_code": "\t\tpublic BodyContentSpec json(String expectedJson, JsonComparator comparator) {\n\t\t\tthis.result.assertWithDiagnostics(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tcomparator.assertIsMatch(expectedJson, getBodyAsString());\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AssertionError(\"JSON parsing error\", ex);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(expectedJson,compareMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJson",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String expectedJson, JsonCompareMode compareMode)",
    "source_code": "\t\tpublic BodyContentSpec json(String expectedJson, JsonCompareMode compareMode) {\n\t\t\treturn json(expectedJson, JsonAssert.comparator(compareMode));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#json(json,strict)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "json",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "BodyContentSpec",
    "signature": "public BodyContentSpec json(String json, boolean strict)",
    "source_code": "\t\tpublic BodyContentSpec json(String json, boolean strict) {\n\t\t\tJsonCompareMode compareMode = (strict ? JsonCompareMode.STRICT : JsonCompareMode.LENIENT);\n\t\t\treturn json(json, compareMode);\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#map(source,targetType,configuration)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType",
      "configuration"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "T",
    "signature": "public T map(Object source, TypeRef<T> targetType, Configuration configuration)",
    "source_code": "\tpublic <T> @Nullable T map(Object source, TypeRef<T> targetType, Configuration configuration) {\n\t\treturn mapToTargetType(source, ResolvableType.forType(targetType.getType()));\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\tthis.uriTemplate = null;\n\t\t\treturn uri(uriFunction.apply(DefaultWebTestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ? extends @Nullable Object> uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultWebTestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\t\tthis.uriTemplate = uriTemplate;\n\t\t\treturn uri(DefaultWebTestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#value(B,bodyMapper,matcher)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "B",
      "bodyMapper",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "T",
    "signature": "public T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher)",
    "source_code": "\t\tpublic <T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher) {\n\t\t\tthis.result.assertWithDiagnostics(() -> {\n\t\t\t\tB body = this.result.getResponseBody();\n\t\t\t\tMatcherAssert.assertThat(bodyMapper.apply(body), matcher);\n\t\t\t});\n\t\t\treturn self();\n\t\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#xpath(expression,Map<String,namespaces,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "Map<String",
      "namespaces",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "XpathAssertions",
    "signature": "public XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args)",
    "source_code": "\t\tpublic XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args) {\n\t\t\treturn new XpathAssertions(this, expression, namespaces, args);\n\t\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#mappedInterceptors(pathPatterns,interceptors)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec mappedInterceptors(String @Nullable [] pathPatterns, HandlerInterceptor... interceptors)",
    "source_code": "\tpublic StandaloneMockMvcSpec mappedInterceptors(\n\t\t\tString @Nullable [] pathPatterns, HandlerInterceptor... interceptors) {\n\n\t\tthis.mockMvcBuilder.addMappedInterceptors(pathPatterns, interceptors);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#placeholderValue(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "StandaloneMockMvcSpec",
    "signature": "public StandaloneMockMvcSpec placeholderValue(String name, String value)",
    "source_code": "\tpublic StandaloneMockMvcSpec placeholderValue(String name, String value) {\n\t\tthis.mockMvcBuilder.addPlaceholderValue(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.util.<unknown>#addResourcePathToPackagePath(clazz,resourceName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "String",
    "signature": "public String addResourcePathToPackagePath(Class<?> clazz, String resourceName)",
    "source_code": "\tpublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n\t\tAssert.notNull(resourceName, \"Resource name must not be null\");\n\t\tif (!resourceName.startsWith(\"/\")) {\n\t\t\treturn classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\n\t\t}\n\t\treturn classPackageAsResourcePath(clazz) + resourceName;\n\t}"
  },
  "org.springframework.util.<unknown>#compare(mimeType1,mimeType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 709
    },
    "return": "int",
    "signature": "public int compare(T mimeType1, T mimeType2)",
    "source_code": "\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#compareParameters(mimeType1,mimeType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "int",
    "signature": "protected int compareParameters(T mimeType1, T mimeType2)",
    "source_code": "\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}"
  },
  "org.springframework.util.<unknown>#concatenateStringArrays(array1,array2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array1",
      "array2"
    ],
    "position": {
      "column": 1,
      "line": 1013
    },
    "return": "String[]",
    "signature": "public String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2)",
    "source_code": "\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#doesNotContain(textToSearch,substring,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, String message)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, String message) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#doesNotContain(textToSearch,substring,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">\n\t * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\n\t * </pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "textToSearch",
      "substring",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "public void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\n\t\tif (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&\n\t\t\t\ttextToSearch.contains(substring)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getConstructorIfAvailable(clazz,paramTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public constructor with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return the constructor, or {@code null} if not found\n\t * @see Class#getConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1172
    },
    "return": "Constructor<T>",
    "signature": "public Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)",
    "source_code": "\tpublic static <T> @Nullable Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\treturn clazz.getConstructor(paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getInterfaceMethodIfPossible(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.3.16\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1407
    },
    "return": "Method",
    "signature": "public Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\treturn getInterfaceMethodIfPossible(method, targetClass, false);\n\t}"
  },
  "org.springframework.util.<unknown>#getMethod(clazz,methodName,paramTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else throws an {@code IllegalStateException}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method (never {@code null})\n\t * @throws IllegalStateException if the method has not been found\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1227
    },
    "return": "Method",
    "signature": "public Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes)",
    "source_code": "\tpublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\ttry {\n\t\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\telse if (candidates.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getMethodCountForName(clazz,methodName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the number of methods with a given name (with any argument types),\n\t * for the given class and/or its superclasses. Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return the number of methods with the given name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 1287
    },
    "return": "int",
    "signature": "public int getMethodCountForName(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static int getMethodCountForName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tint count = 0;\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tcount += getMethodCountForName(ifc, methodName);\n\t\t}\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tcount += getMethodCountForName(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.<unknown>#getMethodIfAvailable(clazz,methodName,paramTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method, or {@code null} if not found\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1265
    },
    "return": "Method",
    "signature": "public Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes)",
    "source_code": "\tpublic static @Nullable Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\treturn getMethodOrNull(clazz, methodName, paramTypes);\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getMostSpecificMethod(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\n\t * and the target class may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not</i> resolve bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable &mdash; for example, to obtain\n\t * metadata from the original method definition.\n\t * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\n\t * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\n\t * implementation will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1354
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tif (targetClass != null && targetClass != method.getDeclaringClass() &&\n\t\t\t\t(isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\n\t\t\ttry {\n\t\t\t\tif (Modifier.isPublic(method.getModifiers())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn targetClass.getMethod(method.getName(), method.getParameterTypes());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMethod specificMethod =\n\t\t\t\t\t\t\tReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t\t\treturn (specificMethod != null ? specificMethod : method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\t// Security settings are disallowing reflective access; fall back to 'method' below.\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.util.<unknown>#getPubliclyAccessibleMethodIfPossible(method,targetClass)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the first publicly accessible method in the supplied method's type hierarchy that\n\t * has a method signature equivalent to the supplied method, if possible.\n\t * <p>If the supplied method is {@code public} and declared in a {@code public} type,\n\t * the supplied method will be returned.\n\t * <p>Otherwise, this method recursively searches the class hierarchy and implemented\n\t * interfaces for an equivalent method that is {@code public} and declared in a\n\t * {@code public} type.\n\t * <p>If a publicly accessible equivalent method cannot be found, the supplied method\n\t * will be returned, indicating that no such equivalent method exists. Consequently,\n\t * callers of this method must manually validate the accessibility of the returned method\n\t * if public access is a requirement.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning. This is also useful for invoking methods via a public API in bytecode\n\t * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\n\t * For example, if a non-public class overrides {@code toString()}, this method will\n\t * traverse up the type hierarchy to find the first public type that declares the method\n\t * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding publicly accessible method, or the original method if none found\n\t * @since 6.2\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 1482
    },
    "return": "Method",
    "signature": "public Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\t// If the method is not public, we can abort the search immediately; or if the method's\n\t\t// declaring class is public, the method is already publicly accessible.\n\t\tif (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\treturn method;\n\t\t}\n\n\t\tMethod interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\n\t\t// If we found a method in a public interface, return the interface method.\n\t\tif (!interfaceMethod.equals(method)) {\n\t\t\treturn interfaceMethod;\n\t\t}\n\n\t\tMethod result = publiclyAccessibleMethodCache.computeIfAbsent(method,\n\t\t\t\tkey -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\n\t\treturn (result != null ? result : method);\n\t}"
  },
  "org.springframework.util.<unknown>#getQualifiedMethodName(method,clazz)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 1146
    },
    "return": "String",
    "signature": "public String getQualifiedMethodName(Method method, @Nullable Class<?> clazz)",
    "source_code": "\tpublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n\t}"
  },
  "org.springframework.util.<unknown>#getStaticMethod(clazz,methodName,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1563
    },
    "return": "Method",
    "signature": "public Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)",
    "source_code": "\tpublic static @Nullable Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\ttry {\n\t\t\tMethod method = clazz.getMethod(methodName, args);\n\t\t\treturn (Modifier.isStatic(method.getModifiers()) ? method : null);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#getTypeDifferenceWeight(paramTypes,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Algorithm that judges the match between the declared parameter types of a candidate method\n\t * and a specific list of arguments that this method is supposed to be invoked with.\n\t * <p>Determines a weight that represents the class hierarchy difference between types and\n\t * arguments. A direct match, i.e. type Integer &rarr; arg of class Integer, does not increase\n\t * the result - all direct matches means weight 0. A match between type Object and arg of\n\t * class Integer would increase the weight by 2, due to the superclass 2 steps up in the\n\t * hierarchy (i.e. Object) being the last one that still matches the required type Object.\n\t * Type Number and class Integer would increase the weight by 1 accordingly, due to the\n\t * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.\n\t * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a\n\t * constructor (Number) which would in turn be preferred to a constructor (Object).\n\t * All argument weights get accumulated.\n\t * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm\n\t * used for constructor and factory method selection in Spring's bean container (in case\n\t * of lenient constructor resolution which is the default for regular bean definitions).\n\t * @param paramTypes the parameter types to match\n\t * @param args the arguments to match\n\t * @return the accumulated weight for all arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "int",
    "signature": "public int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args)",
    "source_code": "\tpublic static int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {\n\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t}\n\t\t\tif (args[i] != null) {\n\t\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\t\tClass<?> superClass = args[i].getClass().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramType.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramType, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramType.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.<unknown>#hasAtLeastOneMethodWithName(clazz,methodName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the given class or one of its superclasses at least have one or more\n\t * methods with the supplied name (with any argument types)?\n\t * Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return whether there is at least one method with the given name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 1315
    },
    "return": "boolean",
    "signature": "public boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tif (hasAtLeastOneMethodWithName(ifc, methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n\t}"
  },
  "org.springframework.util.<unknown>#hasConstructor(clazz,paramTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public constructor with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding constructor\n\t * @see Class#getConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "boolean",
    "signature": "public boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)",
    "source_code": "\tpublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n\t\treturn (getConstructorIfAvailable(clazz, paramTypes) != null);\n\t}"
  },
  "org.springframework.util.<unknown>#hasLength(text,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, String message)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasLength(text,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">\n\t * Assert.hasLength(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @since 5.0\n\t * @see StringUtils#hasLength\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void hasLength(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasLength(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasMethod(clazz,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * @param clazz the clazz to analyze\n\t * @param method the method to look for\n\t * @return whether the class has a corresponding method\n\t * @since 5.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 1189
    },
    "return": "boolean",
    "signature": "public boolean hasMethod(Class<?> clazz, Method method)",
    "source_code": "\tpublic static boolean hasMethod(Class<?> clazz, Method method) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tif (clazz == method.getDeclaringClass()) {\n\t\t\treturn true;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tClass<?>[] paramTypes = method.getParameterTypes();\n\t\treturn getMethodOrNull(clazz, methodName, paramTypes) != null;\n\t}"
  },
  "org.springframework.util.<unknown>#hasMethod(clazz,methodName,paramTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding method\n\t * @see Class#getMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "boolean",
    "signature": "public boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)",
    "source_code": "\tpublic static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\treturn (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n\t}"
  },
  "org.springframework.util.<unknown>#hasText(text,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">Assert.hasText(name, \"'name' must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @see StringUtils#hasText\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void hasText(@Nullable String text, String message)",
    "source_code": "\tpublic static void hasText(@Nullable String text, String message) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#hasText(text,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">\n\t * Assert.hasText(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @since 5.0\n\t * @see StringUtils#hasText\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "public void hasText(@Nullable String text, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void hasText(@Nullable String text, Supplier<String> messageSupplier) {\n\t\tif (!StringUtils.hasText(text)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(superType,subType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass);</pre>\n\t * @param superType the supertype to check\n\t * @param subType the subtype to check\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType) {\n\t\tisAssignable(superType, subType, \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(superType,subType,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending subtype\n\t * will be appended. In any other case, a \":\" with a space and the name of the\n\t * offending subtype will be appended.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(superType,subType,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">\n\t * Assert.isAssignable(Number.class, myClass, () -&gt; \"Processing \" + myAttributeName + \":\");\n\t * </pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isAssignable(Class, Class, String)} for details.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superType",
      "subType",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier) {\n\t\tnotNull(superType, \"Supertype to check against must not be null\");\n\t\tif (subType == null || !superType.isAssignableFrom(subType)) {\n\t\t\tassignableCheckFailed(superType, subType, nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignableValue(type,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given type is assignable from the given value,\n\t * assuming setting by reflection. Considers primitive wrapper classes\n\t * as assignable to the corresponding primitive types.\n\t * @param type the target type\n\t * @param value the value that should be assigned to the type\n\t * @return if the type is assignable from the value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "boolean",
    "signature": "public boolean isAssignableValue(Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic static boolean isAssignableValue(Class<?> type, @Nullable Object value) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n\t}"
  },
  "org.springframework.util.<unknown>#isCacheSafe(clazz,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is cache-safe in the given context,\n\t * i.e. whether it is loaded by the given ClassLoader or a parent of it.\n\t * @param clazz the class to analyze\n\t * @param classLoader the ClassLoader to potentially cache metadata in\n\t * (can be {@code null} which indicates the system class loader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 413
    },
    "return": "boolean",
    "signature": "public boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tClassLoader target = clazz.getClassLoader();\n\t\t\t// Common cases\n\t\t\tif (target == classLoader || target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (classLoader == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Check for match in ancestors -> positive\n\t\t\tClassLoader current = classLoader;\n\t\t\twhile (current != null) {\n\t\t\t\tcurrent = current.getParent();\n\t\t\t\tif (current == target) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for match in children -> negative\n\t\t\twhile (target != null) {\n\t\t\t\ttarget = target.getParent();\n\t\t\t\tif (target == classLoader) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Fallback for ClassLoaders without parent/child relationship:\n\t\t// safe if same Class can be loaded from given ClassLoader\n\t\treturn (classLoader != null && isLoadable(clazz, classLoader));\n\t}"
  },
  "org.springframework.util.<unknown>#isInstanceOf(type,obj)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo);</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void isInstanceOf(Class<?> type, @Nullable Object obj)",
    "source_code": "\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj) {\n\t\tisInstanceOf(type, obj, \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#isInstanceOf(type,obj,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo, \"Foo expected\");</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending object's\n\t * type will be appended. In any other case, a \":\" with a space and the name\n\t * of the offending object's type will be appended.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "obj",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "void",
    "signature": "public void isInstanceOf(Class<?> type, @Nullable Object obj, String message)",
    "source_code": "\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj, String message) {\n\t\tnotNull(type, \"Type to check against must not be null\");\n\t\tif (!type.isInstance(obj)) {\n\t\t\tinstanceCheckFailed(type, obj, message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isInstanceOf(type,obj,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">\n\t * Assert.instanceOf(Foo.class, foo, () -&gt; \"Processing \" + Foo.class.getSimpleName() + \":\");\n\t * </pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "obj",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier) {\n\t\tnotNull(type, \"Type to check against must not be null\");\n\t\tif (!type.isInstance(obj)) {\n\t\t\tinstanceCheckFailed(type, obj, nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isNull(object,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">Assert.isNull(value, \"The value must be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void isNull(@Nullable Object object, String message)",
    "source_code": "\tpublic static void isNull(@Nullable Object object, String message) {\n\t\tif (object != null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isNull(object,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.isNull(value, () -&gt; \"The value '\" + value + \"' must be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void isNull(@Nullable Object object, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object != null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isPresent(className,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the {@link Class} identified by the supplied name is present\n\t * and can be loaded. Will return {@code false} if either the class or\n\t * one of its dependencies is not present or cannot be loaded.\n\t * @param className the name of the class to check\n\t * @param classLoader the class loader to use\n\t * (can be {@code null} which indicates the default class loader)\n\t * @return whether the specified class is present (including all of its\n\t * superclasses and interfaces)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be checked here)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "boolean",
    "signature": "public boolean isPresent(String className, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) {\n\t\ttry {\n\t\t\tforName(className, classLoader);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalAccessError err) {\n\t\t\tthrow new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" +\n\t\t\t\t\tclassName + \"]: \" + err.getMessage(), err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Typically ClassNotFoundException or NoClassDefFoundError...\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isTrue(expression,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void isTrue(boolean expression, String message)",
    "source_code": "\tpublic static void isTrue(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isTrue(expression,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">\n\t * Assert.isTrue(i &gt; 0, () -&gt; \"The value '\" + i + \"' must be greater than zero\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void isTrue(boolean expression, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void isTrue(boolean expression, Supplier<String> messageSupplier) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#isVisible(clazz,classLoader)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader == null) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getClassLoader() == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Visible if same Class can be loaded from given ClassLoader\n\t\treturn isLoadable(clazz, classLoader);\n\t}"
  },
  "org.springframework.util.<unknown>#matchesTypeName(clazz,typeName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given class matches the user-specified type name.\n\t * @param clazz the class to check\n\t * @param typeName the type name to match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 1032
    },
    "return": "boolean",
    "signature": "public boolean matchesTypeName(Class<?> clazz, @Nullable String typeName)",
    "source_code": "\tpublic static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {\n\t\treturn (typeName != null &&\n\t\t\t\t(typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));\n\t}"
  },
  "org.springframework.util.<unknown>#noNullElements(array,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">Assert.noNullElements(array, \"The array must contain non-null elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void noNullElements(Object @Nullable [] array, String message)",
    "source_code": "\tpublic static void noNullElements(Object @Nullable [] array, String message) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#noNullElements(array,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "void",
    "signature": "public void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (array != null) {\n\t\t\tfor (Object element : array) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#noNullElements(collection,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">Assert.noNullElements(collection, \"Collection must contain non-null elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void noNullElements(@Nullable Collection<?> collection, String message)",
    "source_code": "\tpublic static void noNullElements(@Nullable Collection<?> collection, String message) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#noNullElements(collection,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "public void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (collection != null) {\n\t\t\tfor (Object element : collection) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(Map<?,map,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\n\t * @param map the map to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Map<?, ?> map, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Map<?, ?> map, String message) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(Map<?,map,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\n\t * </pre>\n\t * @param map the map to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(map)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(array,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Object @Nullable [] array, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Object @Nullable [] array, String message) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(array,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(collection,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(collection, \"Collection must contain elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Collection<?> collection, String message)",
    "source_code": "\tpublic static void notEmpty(@Nullable Collection<?> collection, String message) {\n\t\tif (CollectionUtils.isEmpty(collection)) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notEmpty(collection,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(collection, () -&gt; \"The \" + collectionType + \" collection must contain elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "void",
    "signature": "public void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\n\t\tif (CollectionUtils.isEmpty(collection)) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notNull(object,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, String message)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, String message) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#notNull(object,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.notNull(entity.getId(),\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void notNull(@Nullable Object object, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#read(b,off,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\t\tpublic int read(byte[] b, int off, int len) {\n\t\t\tif (off < 0 || len < 0 || len > b.length - off) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\telse if (len == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\t\tint bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\t\tSystem.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);\n\t\t\t\t\t\tthis.totalBytesRead += bytesToCopy;\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToCopy;\n\t\t\t\t\t\tint remaining = read(b, off + bytesToCopy, len - bytesToCopy);\n\t\t\t\t\t\treturn bytesToCopy + Math.max(remaining, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read(b, off, len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#simpleMatch(pattern,str)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pattern",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(@Nullable String pattern, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\n\t\tif (pattern == null || str == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint firstIndex = pattern.indexOf('*');\n\t\tif (firstIndex == -1) {\n\t\t\treturn pattern.equals(str);\n\t\t}\n\n\t\tif (firstIndex == 0) {\n\t\t\tif (pattern.length() == 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tint nextIndex = pattern.indexOf('*', 1);\n\t\t\tif (nextIndex == -1) {\n\t\t\t\treturn str.endsWith(pattern.substring(1));\n\t\t\t}\n\t\t\tString part = pattern.substring(1, nextIndex);\n\t\t\tif (part.isEmpty()) {\n\t\t\t\treturn simpleMatch(pattern.substring(nextIndex), str);\n\t\t\t}\n\t\t\tint partIndex = str.indexOf(part);\n\t\t\twhile (partIndex != -1) {\n\t\t\t\tif (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tpartIndex = str.indexOf(part, partIndex + 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (str.length() >= firstIndex &&\n\t\t\t\tpattern.startsWith(str.substring(0, firstIndex)) &&\n\t\t\t\tsimpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\n\t}"
  },
  "org.springframework.util.<unknown>#simpleMatch(patterns,str)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match a String against the given patterns, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String is {@code null} or if the\n\t * supplied patterns array is {@code null} or empty.\n\t * @param patterns the patterns to match against\n\t * @param str the String to match\n\t * @return whether the String matches any of the given patterns\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean simpleMatch(String @Nullable [] patterns, @Nullable String str)",
    "source_code": "\tpublic static boolean simpleMatch(String @Nullable [] patterns, @Nullable String str) {\n\t\tif (patterns != null) {\n\t\t\tfor (String pattern : patterns) {\n\t\t\t\tif (simpleMatch(pattern, str)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#split(toSplit,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1085
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.util.<unknown>#state(expression,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void state(boolean expression, String message)",
    "source_code": "\tpublic static void state(boolean expression, String message) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(message);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#state(expression,messageSupplier)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">\n\t * Assert.state(entity.getId() == null,\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not already be initialized\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "messageSupplier"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void state(boolean expression, Supplier<String> messageSupplier)",
    "source_code": "\tpublic static void state(boolean expression, Supplier<String> messageSupplier) {\n\t\tif (!expression) {\n\t\t\tthrow new IllegalStateException(nullSafeGet(messageSupplier));\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#updateMessageDigest(messageDigest,len)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Update the message digest with the next len bytes in this stream.\n\t\t * Avoids creating new byte arrays and use internal buffers for performance.\n\t\t * @param messageDigest the message digest to update\n\t\t * @param len how many bytes to read from this stream and use to update the message digest\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageDigest",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "void",
    "signature": "public void updateMessageDigest(MessageDigest messageDigest, int len)",
    "source_code": "\t\tpublic void updateMessageDigest(MessageDigest messageDigest, int len) {\n\t\t\tif (this.currentBuffer == null) {\n\t\t\t\t// This stream doesn't have any data in it...\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (len == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (len < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"len must be 0 or greater: \" + len);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\n\t\t\t\t\tint bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\n\t\t\t\t\tmessageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);\n\t\t\t\t\tthis.nextIndexInCurrentBuffer += bytesToCopy;\n\t\t\t\t\tupdateMessageDigest(messageDigest, len - bytesToCopy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.buffersIterator.hasNext()) {\n\t\t\t\t\t\tthis.currentBuffer = this.buffersIterator.next();\n\t\t\t\t\t\tupdateCurrentBufferLength();\n\t\t\t\t\t\tthis.nextIndexInCurrentBuffer = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.currentBuffer = null;\n\t\t\t\t\t}\n\t\t\t\t\tupdateMessageDigest(messageDigest, len);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#write(data,offset,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void write(byte[] data, int offset, int length)",
    "source_code": "\tpublic void write(byte[] data, int offset, int length) throws IOException {\n\t\tif (offset < 0 || offset + length > data.length || length < 0) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\telse if (this.closed) {\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\t}\n\t\telse {\n\t\t\tif (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n\t\t\t\taddBuffer(length);\n\t\t\t}\n\t\t\tif (this.index + length > this.buffers.getLast().length) {\n\t\t\t\tint pos = offset;\n\t\t\t\tdo {\n\t\t\t\t\tif (this.index == this.buffers.getLast().length) {\n\t\t\t\t\t\taddBuffer(length);\n\t\t\t\t\t}\n\t\t\t\t\tint copyLength = this.buffers.getLast().length - this.index;\n\t\t\t\t\tif (length < copyLength) {\n\t\t\t\t\t\tcopyLength = length;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);\n\t\t\t\t\tpos += copyLength;\n\t\t\t\t\tthis.index += copyLength;\n\t\t\t\t\tlength -= copyLength;\n\t\t\t\t}\n\t\t\t\twhile (length > 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// copy in the sub-array\n\t\t\t\tSystem.arraycopy(data, offset, this.buffers.getLast(), this.index, length);\n\t\t\t\tthis.index += length;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#reject(errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#setValidationPropertyMap(Map<String,validationProperties)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify bean validation properties to be passed to the validation provider as a Map.\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @see jakarta.validation.Configuration#addProperty(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "validationProperties"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void setValidationPropertyMap(@Nullable Map<String, String> validationProperties)",
    "source_code": "\tpublic void setValidationPropertyMap(@Nullable Map<String, String> validationProperties) {\n\t\tif (validationProperties != null) {\n\t\t\tthis.validationPropertyMap.putAll(validationProperties);\n\t\t}\n\t}"
  },
  "org.springframework.validation.method.<unknown>#reject(errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.errors.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.errors.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#rejectValue(field,errorCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.errors.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.errors.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.validation.method.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\n\t\tthis.errors.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#findEditor(field,valueType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType)",
    "source_code": "\tpublic @Nullable PropertyEditor findEditor(@Nullable String field, @Nullable Class valueType) {\n\t\treturn this.bindingResult.findEditor(field, valueType);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#getDetailMessageArguments(source,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource source, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource source, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\tBindErrorUtils.resolveAndJoin(getGlobalErrors(), source, locale),\n\t\t\t\tBindErrorUtils.resolveAndJoin(getFieldErrors(), source, locale)};\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#recordFieldValue(field,type,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void recordFieldValue(String field, Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.bindingResult.recordFieldValue(field, type, value);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#reject(errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, Object @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.bindingResult.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#rejectValue(field,errorCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.bindingResult.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.bindingResult.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\tObject @Nullable [] errorArgs, @Nullable String defaultMessage) {\n\n\t\tthis.bindingResult.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#resolveMessageCodes(errorCode,field)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode, String field)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode, String field) {\n\t\treturn this.bindingResult.resolveMessageCodes(errorCode, field);\n\t}"
  },
  "org.springframework.web.client.<unknown>#doExecute(url,method,requestCallback,responseExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t * @deprecated in favor of {@link #doExecute(URI, String, HttpMethod, RequestCallback, ResponseExtractor)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\treturn doExecute(url, null, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#handle(request,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void handle(HttpRequest request, ClientHttpResponse response)",
    "source_code": "\tpublic void handle(HttpRequest request, ClientHttpResponse response) throws IOException {\n\t\tthis.errorHandler.handle(request, response);\n\t}"
  },
  "org.springframework.web.client.<unknown>#of(predicate,errorHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "StatusHandler",
    "signature": "public StatusHandler of(Predicate<HttpStatusCode> predicate,\n\t\t\tRestClient.ResponseSpec.ErrorHandler errorHandler)",
    "source_code": "\tpublic static StatusHandler of(Predicate<HttpStatusCode> predicate,\n\t\t\tRestClient.ResponseSpec.ErrorHandler errorHandler) {\n\t\tAssert.notNull(predicate, \"Predicate must not be null\");\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\treturn new StatusHandler(response -> predicate.test(response.getStatusCode()), errorHandler);\n\t}"
  },
  "org.springframework.web.client.<unknown>#setBodyConvertFunction(Function<ResolvableType,bodyConvertFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a function to use to decode the response error content\n\t * via {@link #getResponseBodyAs(Class)}.\n\t * @param bodyConvertFunction the function to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ResolvableType",
      "bodyConvertFunction"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction)",
    "source_code": "\tpublic void setBodyConvertFunction(Function<ResolvableType, ? extends @Nullable Object> bodyConvertFunction) {\n\t\tthis.bodyConvertFunction = bodyConvertFunction;\n\t}"
  },
  "org.springframework.web.client.support.<unknown>#exchangeForBody(values,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> @Nullable T exchangeForBody(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().body(bodyType);\n\t}"
  },
  "org.springframework.web.client.support.<unknown>#exchangeForEntity(values,bodyType)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "values",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchangeForEntity(HttpRequestValues values, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(values).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.context.request.<unknown>#checkNotModified(etag,lastModifiedTimestamp)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "etag",
      "lastModifiedTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String etag, long lastModifiedTimestamp) {\n\t\tif (this.notModified) {\n\t\t\treturn true;\n\t\t}\n\n\t\tHttpServletResponse response = getResponse();\n\t\tif (response != null && HttpStatus.OK.value() != response.getStatus()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\tif (validateIfMatch(etag)) {\n\t\t\tupdateResponseStateChanging(etag, lastModifiedTimestamp);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\tif (validateIfUnmodifiedSince(lastModifiedTimestamp)) {\n\t\t\tupdateResponseStateChanging(etag, lastModifiedTimestamp);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(etag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModifiedTimestamp);\n\t\t}\n\t\tupdateResponseIdempotent(etag, lastModifiedTimestamp);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#registerCallableInterceptor(key,interceptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link CallableProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor)",
    "source_code": "\tpublic void registerCallableInterceptor(Object key, CallableProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"CallableProcessingInterceptor is required\");\n\t\tthis.callableInterceptors.put(key, interceptor);\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#registerDeferredResultInterceptor(key,interceptor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link DeferredResultProcessingInterceptor} under the given key.\n\t * @param key the key\n\t * @param interceptor the interceptor to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor)",
    "source_code": "\tpublic void registerDeferredResultInterceptor(Object key, DeferredResultProcessingInterceptor interceptor) {\n\t\tAssert.notNull(key, \"Key is required\");\n\t\tAssert.notNull(interceptor, \"DeferredResultProcessingInterceptor is required\");\n\t\tthis.deferredResultInterceptors.put(key, interceptor);\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#startCallableProcessing(callable,processingContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Start concurrent request processing and execute the given task with an\n\t * {@link #setTaskExecutor(AsyncTaskExecutor) AsyncTaskExecutor}. The result\n\t * from the task execution is saved and the request dispatched in order to\n\t * resume processing of that result. If the task raises an Exception then\n\t * the saved result will be the raised Exception.\n\t * @param callable a unit of work to be executed asynchronously\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t * @see #getConcurrentResult()\n\t * @see #getConcurrentResultContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callable",
      "processingContext"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void startCallableProcessing(Callable<?> callable, Object... processingContext)",
    "source_code": "\tpublic void startCallableProcessing(Callable<?> callable, Object... processingContext) throws Exception {\n\t\tAssert.notNull(callable, \"Callable must not be null\");\n\t\tstartCallableProcessing(new WebAsyncTask(callable), processingContext);\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#startCallableProcessing(webAsyncTask,processingContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Use the given {@link WebAsyncTask} to configure the task executor as well as\n\t * the timeout value of the {@code AsyncWebRequest} before delegating to\n\t * {@link #startCallableProcessing(Callable, Object...)}.\n\t * @param webAsyncTask a WebAsyncTask containing the target {@code Callable}\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webAsyncTask",
      "processingContext"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "public void startCallableProcessing(final WebAsyncTask<?> webAsyncTask, Object... processingContext)",
    "source_code": "\tpublic void startCallableProcessing(final WebAsyncTask<?> webAsyncTask, Object... processingContext)\n\t\t\tthrows Exception {\n\n\t\tAssert.notNull(webAsyncTask, \"WebAsyncTask must not be null\");\n\t\tAssert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\");\n\n\t\tif (!this.state.compareAndSet(State.NOT_STARTED, State.ASYNC_PROCESSING)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unexpected call to startCallableProcessing: [\" + this.state.get() + \"]\");\n\t\t}\n\n\t\tLong timeout = webAsyncTask.getTimeout();\n\t\tif (timeout != null) {\n\t\t\tthis.asyncWebRequest.setTimeout(timeout);\n\t\t}\n\n\t\tAsyncTaskExecutor executor = webAsyncTask.getExecutor();\n\t\tif (executor != null) {\n\t\t\tthis.taskExecutor = executor;\n\t\t}\n\n\t\tList<CallableProcessingInterceptor> interceptors = new ArrayList<>();\n\t\tinterceptors.add(webAsyncTask.getInterceptor());\n\t\tinterceptors.addAll(this.callableInterceptors.values());\n\t\tinterceptors.add(timeoutCallableInterceptor);\n\n\t\tfinal Callable<?> callable = webAsyncTask.getCallable();\n\t\tfinal CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors);\n\n\t\tthis.asyncWebRequest.addTimeoutHandler(() -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container timeout notification for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\tObject result = interceptorChain.triggerAfterTimeout(this.asyncWebRequest, callable);\n\t\t\tif (result != CallableProcessingInterceptor.RESULT_NONE) {\n\t\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t\t}\n\t\t});\n\n\t\tthis.asyncWebRequest.addErrorHandler(ex -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container error notification for \" + formatUri(this.asyncWebRequest) + \": \" + ex);\n\t\t\t}\n\t\t\tif (ex instanceof IOException) {\n\t\t\t\tex = new AsyncRequestNotUsableException(\n\t\t\t\t\t\t\"Servlet container error notification for disconnected client\", ex);\n\t\t\t}\n\t\t\tObject result = interceptorChain.triggerAfterError(this.asyncWebRequest, callable, ex);\n\t\t\tresult = (result != CallableProcessingInterceptor.RESULT_NONE ? result : ex);\n\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t});\n\n\t\tthis.asyncWebRequest.addCompletionHandler(() ->\n\t\t\t\tinterceptorChain.triggerAfterCompletion(this.asyncWebRequest, callable));\n\n\t\tinterceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, callable);\n\t\tstartAsyncProcessing(processingContext);\n\t\ttry {\n\t\t\tFuture<?> future = this.taskExecutor.submit(() -> {\n\t\t\t\tObject result = null;\n\t\t\t\ttry {\n\t\t\t\t\tinterceptorChain.applyPreProcess(this.asyncWebRequest, callable);\n\t\t\t\t\tresult = callable.call();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tresult = ex;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tresult = interceptorChain.applyPostProcess(this.asyncWebRequest, callable, result);\n\t\t\t\t}\n\t\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t\t});\n\t\t\tinterceptorChain.setTaskFuture(future);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tObject result = interceptorChain.applyPostProcess(this.asyncWebRequest, callable, ex);\n\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#startDeferredResultProcessing(deferredResult,processingContext)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Start concurrent request processing and initialize the given\n\t * {@link DeferredResult} with a {@link DeferredResultHandler} that saves\n\t * the result and dispatches the request to resume processing of that\n\t * result. The {@code AsyncWebRequest} is also updated with a completion\n\t * handler that expires the {@code DeferredResult} and a timeout handler\n\t * assuming the {@code DeferredResult} has a default timeout result.\n\t * @param deferredResult the DeferredResult instance to initialize\n\t * @param processingContext additional context to save that can be accessed\n\t * via {@link #getConcurrentResultContext()}\n\t * @throws Exception if concurrent processing failed to start\n\t * @see #getConcurrentResult()\n\t * @see #getConcurrentResultContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "deferredResult",
      "processingContext"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void startDeferredResultProcessing(final DeferredResult<?> deferredResult, Object... processingContext)",
    "source_code": "\tpublic void startDeferredResultProcessing(\n\t\t\tfinal DeferredResult<?> deferredResult, Object... processingContext) throws Exception {\n\n\t\tAssert.notNull(deferredResult, \"DeferredResult must not be null\");\n\t\tAssert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\");\n\n\t\tif (!this.state.compareAndSet(State.NOT_STARTED, State.ASYNC_PROCESSING)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unexpected call to startDeferredResultProcessing: [\" + this.state.get() + \"]\");\n\t\t}\n\n\t\tLong timeout = deferredResult.getTimeoutValue();\n\t\tif (timeout != null) {\n\t\t\tthis.asyncWebRequest.setTimeout(timeout);\n\t\t}\n\n\t\tList<DeferredResultProcessingInterceptor> interceptors = new ArrayList<>();\n\t\tinterceptors.add(deferredResult.getLifecycleInterceptor());\n\t\tinterceptors.addAll(this.deferredResultInterceptors.values());\n\t\tinterceptors.add(timeoutDeferredResultInterceptor);\n\n\t\tfinal DeferredResultInterceptorChain interceptorChain = new DeferredResultInterceptorChain(interceptors);\n\n\t\tthis.asyncWebRequest.addTimeoutHandler(() -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container timeout notification for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinterceptorChain.triggerAfterTimeout(this.asyncWebRequest, deferredResult);\n\t\t\t\tsynchronized (WebAsyncManager.this) {\n\t\t\t\t\t// If application thread set the DeferredResult first in a race,\n\t\t\t\t\t// we must still not return until setConcurrentResultAndDispatch is done\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tsetConcurrentResultAndDispatch(ex);\n\t\t\t}\n\t\t});\n\n\t\tthis.asyncWebRequest.addErrorHandler(ex -> {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Servlet container error notification for \" + formatUri(this.asyncWebRequest));\n\t\t\t}\n\t\t\tif (ex instanceof IOException) {\n\t\t\t\tex = new AsyncRequestNotUsableException(\n\t\t\t\t\t\t\"Servlet container error notification for disconnected client\", ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinterceptorChain.triggerAfterError(this.asyncWebRequest, deferredResult, ex);\n\t\t\t\tsynchronized (WebAsyncManager.this) {\n\t\t\t\t\t// If application thread set the DeferredResult first in a race,\n\t\t\t\t\t// we must still not return until setConcurrentResultAndDispatch is done\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable interceptorEx) {\n\t\t\t\tsetConcurrentResultAndDispatch(interceptorEx);\n\t\t\t}\n\t\t});\n\n\t\tthis.asyncWebRequest.addCompletionHandler(() ->\n\t\t\t\tinterceptorChain.triggerAfterCompletion(this.asyncWebRequest, deferredResult));\n\n\t\tinterceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, deferredResult);\n\t\tstartAsyncProcessing(processingContext);\n\n\t\ttry {\n\t\t\tinterceptorChain.applyPreProcess(this.asyncWebRequest, deferredResult);\n\t\t\tdeferredResult.setResultHandler(result -> {\n\t\t\t\tresult = interceptorChain.applyPostProcess(this.asyncWebRequest, deferredResult, result);\n\t\t\t\tsetConcurrentResultAndDispatch(result);\n\t\t\t});\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tsetConcurrentResultAndDispatch(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#getFeatureDescriptors(elContext,base)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Iterator<FeatureDescriptor>",
    "signature": "public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base)",
    "source_code": "\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attribute(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthentication(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication(String username, String password)",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthenticationCredentials(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookie(name,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToFlux(Function<ClientResponse,responseHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 407
    },
    "return": "Flux<V>",
    "signature": "public Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler) {\n\t\t\treturn exchange().flatMapMany(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.concatWith(Flux.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToMono(Function<ClientResponse,responseHandler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "Mono<V>",
    "signature": "public Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler) {\n\t\t\treturn exchange().flatMap(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.flatMap(value -> releaseIfNotConsumed(response).thenReturn(value))\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#filter(request,next)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "Mono<ClientResponse>",
    "signature": "public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next)",
    "source_code": "\t\tpublic Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {\n\t\t\treturn next.exchange(request).doOnNext(this.observationContext::setResponse);\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#header(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onRawStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onRawStatus(IntPredicate statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onRawStatus(IntPredicate statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\treturn onStatus(toStatusCodePredicate(statusCodePredicate), exceptionFunction);\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\tAssert.notNull(statusCodePredicate, \"StatusCodePredicate must not be null\");\n\t\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\t\t\tint index = this.statusHandlers.size() - this.defaultStatusHandlerCount;  // Default handlers always last\n\t\t\tthis.statusHandlers.add(index, new StatusHandler(statusCodePredicate, exceptionFunction));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#statusError(statusPredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function to create the exception\n\t * @return the filter to generate an error signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction)",
    "source_code": "\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction) {\n\n\t\tAssert.notNull(statusPredicate, \"Predicate must not be null\");\n\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\n\t\treturn ExchangeFilterFunction.ofResponseProcessor(\n\t\t\t\tresponse -> (statusPredicate.test(response.statusCode()) ?\n\t\t\t\t\t\tMono.error(exceptionFunction.apply(response)) : Mono.just(response)));\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntityFlux(BodyExtractor<Flux<T>,bodyExtractor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<Flux<T>",
      "bodyExtractor"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.body(bodyExtractor)));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriFunction.apply(uriBuilder));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, @Nullable Object... uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#checkResource(resource,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (ResourceHandlerUtils.isResourceUnderLocation(location, resource)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (ResourceHandlerUtils.isResourceUnderLocation(current, resource)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getResource(resourcePath,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tResource resource = ResourceHandlerUtils.createRelativeResource(location, resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(path,locations,chain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.condition.<unknown>#compareTo(other,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int compareTo(ProducesRequestCondition other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(ProducesRequestCondition other, ServerWebExchange exchange) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(exchange);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (NotAcceptableStatusException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#readBody(bodyParam,actualParam,isBodyRequired,bindingContext,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the body from a method argument with {@link HttpMessageReader}.\n\t * @param bodyParam represents the element type for the body\n\t * @param actualParam the actual method argument type; possibly different\n\t * from {@code bodyParam}, for example, for an {@code HttpEntity} argument\n\t * @param isBodyRequired true if the body is required\n\t * @param bindingContext the binding context to use\n\t * @param exchange the current exchange\n\t * @return a Mono with the value to use for the method argument\n\t * @since 5.0.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyParam",
      "actualParam",
      "isBodyRequired",
      "bindingContext",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam,\n\t\t\tboolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Object> readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam,\n\t\t\tboolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\tResolvableType bodyType = ResolvableType.forMethodParameter(bodyParam);\n\t\tResolvableType actualType = (actualParam != null ? ResolvableType.forMethodParameter(actualParam) : bodyType);\n\t\tClass<?> resolvedType = bodyType.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType elementType = (adapter != null ? bodyType.getGeneric() : bodyType);\n\t\tisBodyRequired = isBodyRequired || (adapter != null && !adapter.supportsEmpty());\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tServerHttpResponse response = exchange.getResponse();\n\n\t\tMediaType contentType;\n\t\tHttpHeaders headers = request.getHeaders();\n\t\ttry {\n\t\t\tcontentType = headers.getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new UnsupportedMediaTypeStatusException(\n\t\t\t\t\t\"Can't parse Content-Type [\" + headers.getFirst(\"Content-Type\") + \"]: \" + ex.getMessage(),\n\t\t\t\t\tgetSupportedMediaTypes(elementType));\n\t\t}\n\n\t\tMediaType mediaType = (contentType != null ? contentType : MediaType.APPLICATION_OCTET_STREAM);\n\t\tObject[] hints = extractValidationHints(bodyParam);\n\n\t\tif (mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Form data is accessed via ServerWebExchange.getFormData() in WebFlux.\");\n\t\t\t}\n\t\t\treturn Mono.error(new ResponseStatusException(HttpStatus.UNSUPPORTED_MEDIA_TYPE));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(exchange.getLogPrefix() + (contentType != null ?\n\t\t\t\t\t\"Content-Type:\" + contentType :\n\t\t\t\t\t\"No Content-Type, using \" + MediaType.APPLICATION_OCTET_STREAM));\n\t\t}\n\n\t\tfor (HttpMessageReader<?> reader : getMessageReaders()) {\n\t\t\tif (reader.canRead(elementType, mediaType)) {\n\t\t\t\tMap<String, Object> readHints = Hints.from(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix());\n\t\t\t\tif (adapter != null && adapter.isMultiValue()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"0..N [\" + elementType + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tFlux<?> flux = reader.read(actualType, elementType, request, response, readHints);\n\t\t\t\t\tflux = flux.onErrorMap(ex -> handleReadError(bodyParam, ex));\n\t\t\t\t\tif (isBodyRequired) {\n\t\t\t\t\t\tflux = flux.switchIfEmpty(Flux.error(() -> handleMissingBody(bodyParam)));\n\t\t\t\t\t}\n\t\t\t\t\tif (hints != null) {\n\t\t\t\t\t\tflux = flux.doOnNext(target ->\n\t\t\t\t\t\t\t\tvalidate(target, hints, bodyParam, bindingContext, exchange));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.just(adapter.fromPublisher(flux));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Single-value (with or without reactive type wrapper)\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"0..1 [\" + elementType + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tMono<?> mono = reader.readMono(actualType, elementType, request, response, readHints);\n\t\t\t\t\tmono = mono.onErrorMap(ex -> handleReadError(bodyParam, ex));\n\t\t\t\t\tif (isBodyRequired) {\n\t\t\t\t\t\tmono = mono.switchIfEmpty(Mono.error(() -> handleMissingBody(bodyParam)));\n\t\t\t\t\t}\n\t\t\t\t\tif (hints != null) {\n\t\t\t\t\t\tmono = mono.doOnNext(target ->\n\t\t\t\t\t\t\t\tvalidate(target, hints, bodyParam, bindingContext, exchange));\n\t\t\t\t\t}\n\t\t\t\t\treturn (adapter != null ? Mono.just(adapter.fromPublisher(mono)) : Mono.from(mono));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No compatible reader but body may be empty.\n\n\t\tHttpMethod method = request.getMethod();\n\t\tif (contentType == null && SUPPORTED_METHODS.contains(method)) {\n\t\t\tFlux<DataBuffer> body = request.getBody().doOnNext(buffer -> {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t// Body not empty, back to HTTP 415\n\t\t\t\tthrow new UnsupportedMediaTypeStatusException(\n\t\t\t\t\t\tmediaType, getSupportedMediaTypes(elementType), elementType);\n\t\t\t});\n\t\t\tif (isBodyRequired) {\n\t\t\t\tbody = body.switchIfEmpty(Mono.error(() -> handleMissingBody(bodyParam)));\n\t\t\t}\n\t\t\treturn (adapter != null ? Mono.just(adapter.fromPublisher(body)) : Mono.from(body));\n\t\t}\n\n\t\treturn Mono.error(new UnsupportedMediaTypeStatusException(\n\t\t\t\tmediaType, getSupportedMediaTypes(elementType), elementType));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#readBody(bodyParameter,isBodyRequired,bindingContext,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the body from a method argument with {@link HttpMessageReader}.\n\t * @param bodyParameter the {@link MethodParameter} to read\n\t * @param isBodyRequired true if the body is required\n\t * @param bindingContext the binding context to use\n\t * @param exchange the current exchange\n\t * @return the body\n\t * @see #readBody(MethodParameter, MethodParameter, boolean, BindingContext, ServerWebExchange)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyParameter",
      "isBodyRequired",
      "bindingContext",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,\n\t\t\tBindingContext bindingContext, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Object> readBody(MethodParameter bodyParameter, boolean isBodyRequired,\n\t\t\tBindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\treturn this.readBody(bodyParameter, null, isBodyRequired, bindingContext, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#appendCurrentRequestQuery(targetUrl,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the query of the current request to the target redirect URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder appendCurrentRequestQuery(String targetUrl, ServerHttpRequest request)",
    "source_code": "\tprotected StringBuilder appendCurrentRequestQuery(String targetUrl, ServerHttpRequest request) {\n\t\tString query = request.getURI().getRawQuery();\n\t\tif (!StringUtils.hasText(query)) {\n\t\t\treturn new StringBuilder(targetUrl);\n\t\t}\n\n\t\tint index = targetUrl.indexOf('#');\n\t\tString fragment = (index > -1 ? targetUrl.substring(index) : null);\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tresult.append(index != -1 ? targetUrl.substring(0, index) : targetUrl);\n\t\tresult.append(targetUrl.indexOf('?') < 0 ? '?' : '&').append(query);\n\n\t\tif (fragment != null) {\n\t\t\tresult.append(fragment);\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#createTargetUrl(Map<String,model,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL and, if necessary, pre-pend the contextPath, expand\n\t * URI template variables, append the current request query, and apply the\n\t * configured {@link #getRequestDataValueProcessor()\n\t * RequestDataValueProcessor}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, ServerWebExchange exchange)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, ServerWebExchange exchange) {\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tServerHttpRequest request = exchange.getRequest();\n\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tif (isContextRelative() && url.startsWith(\"/\")) {\n\t\t\ttargetUrl.append(request.getPath().contextPath().value());\n\t\t}\n\t\ttargetUrl.append(url);\n\n\t\tif (StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> uriVars = getCurrentUriVariables(exchange);\n\t\t\ttargetUrl = expandTargetUrlTemplate(targetUrl.toString(), model, uriVars);\n\t\t}\n\n\t\tif (isPropagateQuery()) {\n\t\t\ttargetUrl = appendCurrentRequestQuery(targetUrl.toString(), request);\n\t\t}\n\n\t\tString result = targetUrl.toString();\n\n\t\tRequestDataValueProcessor processor = getRequestDataValueProcessor();\n\t\treturn (processor != null ? processor.processUrl(exchange, result) : result);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#expandTargetUrlTemplate(targetUrl,Map<String,model,Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Expand URI template variables in the target URL with either model\n\t * attribute values or as a fallback with URI variable values from the\n\t * current request. Values are encoded.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder expandTargetUrlTemplate(String targetUrl,\n\t\t\tMap<String, Object> model, Map<String, String> uriVariables)",
    "source_code": "\tprotected StringBuilder expandTargetUrlTemplate(String targetUrl,\n\t\t\tMap<String, Object> model, Map<String, String> uriVariables) {\n\n\t\tMatcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl);\n\t\tboolean found = matcher.find();\n\t\tif (!found) {\n\t\t\treturn new StringBuilder(targetUrl);\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint endLastMatch = 0;\n\t\twhile (found) {\n\t\t\tString name = matcher.group(1);\n\t\t\tObject value = (model.containsKey(name) ? model.get(name) : uriVariables.get(name));\n\t\t\tAssert.notNull(value, () -> \"No value for URI variable '\" + name + \"'\");\n\t\t\tresult.append(targetUrl, endLastMatch, matcher.start());\n\t\t\tresult.append(encodeUriVariable(value.toString()));\n\t\t\tendLastMatch = matcher.end();\n\t\t\tfound = matcher.find();\n\t\t}\n\t\tresult.append(targetUrl, endLastMatch, targetUrl.length());\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#renderInternal(Map<String,model,contentType,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "contentType",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> renderInternal(\n\t\t\tMap<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange) {\n\n\t\tString targetUrl = createTargetUrl(model, exchange);\n\t\treturn sendRedirect(targetUrl, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#sendRedirect(targetUrl,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param targetUrl the target URL to redirect to\n\t * @param exchange current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> sendRedirect(String targetUrl, ServerWebExchange exchange) {\n\t\tString transformedUrl = (isRemoteHost(targetUrl) ? targetUrl : exchange.transformUrl(targetUrl));\n\t\tServerHttpResponse response = exchange.getResponse();\n\t\tresponse.getHeaders().setLocation(URI.create(transformedUrl));\n\t\tresponse.setStatusCode(getStatusCode());\n\t\treturn Mono.empty();\n\t}"
  },
  "org.springframework.web.reactive.result.view.script.<unknown>#renderInternal(Map<String,model,contentType,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "contentType",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> renderInternal(Map<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> renderInternal(\n\t\t\tMap<String, Object> model, @Nullable MediaType contentType, ServerWebExchange exchange) {\n\n\t\treturn exchange.getResponse().writeWith(Mono.fromCallable(() -> {\n\t\t\ttry {\n\t\t\t\tScriptEngine engine = getEngine();\n\t\t\t\tString url = getUrl();\n\t\t\t\tAssert.state(url != null, \"'url' not set\");\n\t\t\t\tString template = getTemplate(url);\n\n\t\t\t\tFunction<String, String> templateLoader = path -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn getTemplate(path);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\t\t\t\tRenderingContext context = new RenderingContext(\n\t\t\t\t\t\tobtainApplicationContext(), locale, templateLoader, url);\n\n\t\t\t\tObject html;\n\t\t\t\tif (this.renderFunction == null) {\n\t\t\t\t\tSimpleBindings bindings = new SimpleBindings();\n\t\t\t\t\tbindings.putAll(model);\n\t\t\t\t\tmodel.put(\"renderingContext\", context);\n\t\t\t\t\thtml = engine.eval(template, bindings);\n\t\t\t\t}\n\t\t\t\telse if (this.renderObject != null) {\n\t\t\t\t\tObject thiz = engine.eval(this.renderObject);\n\t\t\t\t\thtml = ((Invocable) engine).invokeMethod(thiz, this.renderFunction, template, model, context);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thtml = ((Invocable) engine).invokeFunction(this.renderFunction, template, model, context);\n\t\t\t\t}\n\n\t\t\t\tbyte[] bytes = String.valueOf(html).getBytes(StandardCharsets.UTF_8);\n\t\t\t\treturn exchange.getResponse().bufferFactory().wrap(bytes); // just wrapping, no allocation\n\t\t\t}\n\t\t\tcatch (ScriptException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to render script template\", new StandardScriptEvalException(ex));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to render script template\", ex);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.web.server.<unknown>#updateAndGetBody(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail updateAndGetBody(@Nullable MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic ProblemDetail updateAndGetBody(@Nullable MessageSource messageSource, Locale locale) {\n\t\tsuper.updateAndGetBody(messageSource, locale);\n\n\t\t// The reason may be a code (consistent with ResponseStatusExceptionResolver)\n\n\t\tif (messageSource != null && getReason() != null && getReason().equals(getBody().getDetail())) {\n\t\t\tObject[] arguments = getDetailMessageArguments(messageSource, locale);\n\t\t\tString resolved = messageSource.getMessage(getReason(), arguments, null, locale);\n\t\t\tif (resolved != null) {\n\t\t\t\tgetBody().setDetail(resolved);\n\t\t\t}\n\t\t}\n\n\t\treturn getBody();\n\t}"
  },
  "org.springframework.web.servlet.function.support.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#addStatusCode(viewName,statusCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #setStatusCodes(Properties)} for use with\n\t * Java-based configuration.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void addStatusCode(String viewName, int statusCode)",
    "source_code": "\tpublic void addStatusCode(String viewName, int statusCode) {\n\t\tthis.statusCodes.put(viewName, statusCode);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#applyStatusCodeIfPossible(request,response,statusCode)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the specified HTTP status code to the given response, if possible (that is,\n\t * if not executing within an include request).\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param statusCode the status code to apply\n\t * @see #determineStatusCode\n\t * @see #setDefaultStatusCode\n\t * @see HttpServletResponse#setStatus\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "statusCode"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "protected void applyStatusCodeIfPossible(HttpServletRequest request, HttpServletResponse response, int statusCode)",
    "source_code": "\tprotected void applyStatusCodeIfPossible(HttpServletRequest request, HttpServletResponse response, int statusCode) {\n\t\tif (!WebUtils.isIncludeRequest(request)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Applying HTTP status \" + statusCode);\n\t\t\t}\n\t\t\tresponse.setStatus(statusCode);\n\t\t\trequest.setAttribute(WebUtils.ERROR_STATUS_CODE_ATTRIBUTE, statusCode);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#buildLogMessage(ex,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a log message for the given exception, occurred during processing the given request.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the log message to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "String",
    "signature": "protected String buildLogMessage(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected String buildLogMessage(Exception ex, HttpServletRequest request) {\n\t\treturn \"Resolved [\" + LogFormatUtils.formatValue(ex, -1, true) + \"]\";\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#determineStatusCode(request,viewName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the HTTP status code to apply for the given error view.\n\t * <p>The default implementation returns the status code for the given view name (specified through the\n\t * {@link #setStatusCodes(Properties) statusCodes} property), or falls back to the\n\t * {@link #setDefaultStatusCode defaultStatusCode} if there is no match.\n\t * <p>Override this in a custom subclass to customize this behavior.\n\t * @param request current HTTP request\n\t * @param viewName the name of the error view\n\t * @return the HTTP status code to use, or {@code null} for the servlet container's default\n\t * (200 in case of a standard error view)\n\t * @see #setDefaultStatusCode\n\t * @see #applyStatusCodeIfPossible\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "viewName"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Integer",
    "signature": "protected Integer determineStatusCode(HttpServletRequest request, String viewName)",
    "source_code": "\tprotected @Nullable Integer determineStatusCode(HttpServletRequest request, String viewName) {\n\t\tif (this.statusCodes.containsKey(viewName)) {\n\t\t\treturn this.statusCodes.get(viewName);\n\t\t}\n\t\treturn this.defaultStatusCode;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#determineViewName(ex,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the view name for the given exception, first checking against the\n\t * {@link #setExcludedExceptions(Class[]) \"excludedExecptions\"}, then searching the\n\t * {@link #setExceptionMappings \"exceptionMappings\"}, and finally using the\n\t * {@link #setDefaultErrorView \"defaultErrorView\"} as a fallback.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the resolved view name, or {@code null} if excluded or none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "String",
    "signature": "protected String determineViewName(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected @Nullable String determineViewName(Exception ex, HttpServletRequest request) {\n\t\tString viewName = null;\n\t\tif (this.excludedExceptions != null) {\n\t\t\tfor (Class<?> excludedEx : this.excludedExceptions) {\n\t\t\t\tif (excludedEx.equals(ex.getClass())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check for specific exception mappings.\n\t\tif (this.exceptionMappings != null) {\n\t\t\tviewName = findMatchingViewName(this.exceptionMappings, ex);\n\t\t}\n\t\t// Return default error view else, if defined.\n\t\tif (viewName == null && this.defaultErrorView != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Resolving to default view '\" + this.defaultErrorView + \"'\");\n\t\t\t}\n\t\t\tviewName = this.defaultErrorView;\n\t\t}\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#findMatchingViewName(exceptionMappings,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a matching view name in the given exception mappings.\n\t * @param exceptionMappings mappings between exception class names and error view names\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the view name, or {@code null} if none found\n\t * @see #setExceptionMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionMappings",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "String",
    "signature": "protected String findMatchingViewName(Properties exceptionMappings, Exception ex)",
    "source_code": "\tprotected @Nullable String findMatchingViewName(Properties exceptionMappings, Exception ex) {\n\t\tString viewName = null;\n\t\tString dominantMapping = null;\n\t\tint deepest = Integer.MAX_VALUE;\n\t\tfor (Enumeration<?> names = exceptionMappings.propertyNames(); names.hasMoreElements();) {\n\t\t\tString exceptionMapping = (String) names.nextElement();\n\t\t\tint depth = getDepth(exceptionMapping, ex);\n\t\t\tif (depth >= 0 && (depth < deepest || (depth == deepest &&\n\t\t\t\t\tdominantMapping != null && exceptionMapping.length() > dominantMapping.length()))) {\n\t\t\t\tdeepest = depth;\n\t\t\t\tdominantMapping = exceptionMapping;\n\t\t\t\tviewName = exceptionMappings.getProperty(exceptionMapping);\n\t\t\t}\n\t\t}\n\t\tif (viewName != null && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Resolving to view '\" + viewName + \"' based on mapping [\" + dominantMapping + \"]\");\n\t\t}\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getDepth(exceptionMapping,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the depth to the superclass matching.\n\t * <p>0 means ex matches exactly. Returns -1 if there's no match.\n\t * Otherwise, returns depth. Lowest depth wins.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionMapping",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "int",
    "signature": "protected int getDepth(String exceptionMapping, Exception ex)",
    "source_code": "\tprotected int getDepth(String exceptionMapping, Exception ex) {\n\t\treturn getDepth(exceptionMapping, ex.getClass(), 0);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getModelAndView(viewName,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView for the given view name and exception.\n\t * <p>The default implementation adds the specified exception attribute.\n\t * Can be overridden in subclasses.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @return the ModelAndView instance\n\t * @see #setExceptionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView getModelAndView(String viewName, Exception ex)",
    "source_code": "\tprotected ModelAndView getModelAndView(String viewName, Exception ex) {\n\t\tModelAndView mv = new ModelAndView(viewName);\n\t\tif (this.exceptionAttribute != null) {\n\t\t\tmv.addObject(this.exceptionAttribute, ex);\n\t\t}\n\t\treturn mv;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getModelAndView(viewName,ex,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView for the given request, view name and exception.\n\t * <p>The default implementation delegates to {@link #getModelAndView(String, Exception)}.\n\t * @param viewName the name of the error view\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @return the ModelAndView instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView getModelAndView(String viewName, Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected ModelAndView getModelAndView(String viewName, Exception ex, HttpServletRequest request) {\n\t\treturn getModelAndView(viewName, ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleNotAuthorized(request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a request that is not authorized according to this interceptor.\n\t * Default implementation sends HTTP status code 403 (\"forbidden\").\n\t * <p>This method can be overridden to write a custom message, forward or\n\t * redirect to some error page or login page, or throw a ServletException.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler chosen handler to execute, for type and/or instance evaluation\n\t * @throws jakarta.servlet.ServletException if there is an internal error\n\t * @throws java.io.IOException in case of an I/O error when writing the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "protected void handleNotAuthorized(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tprotected void handleNotAuthorized(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException, IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initPatterns(patterns,parser)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "PatternAdapter[]",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#logException(ex,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Log the given exception at warn level, provided that warn logging has been\n\t * activated through the {@link #setWarnLogCategory \"warnLogCategory\"} property.\n\t * <p>Calls {@link #buildLogMessage} in order to determine the concrete message to log.\n\t * @param ex the exception that got thrown during handler execution\n\t * @param request current HTTP request (useful for obtaining metadata)\n\t * @see #setWarnLogCategory\n\t * @see #buildLogMessage\n\t * @see org.apache.commons.logging.Log#warn(Object, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(buildLogMessage(ex, request));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#matches(lookupPath,pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if there is a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lookupPath",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "boolean",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#prepareResponse(ex,response)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the response for the exceptional case.\n\t * <p>The default implementation prevents the response from being cached,\n\t * if the {@link #setPreventResponseCaching \"preventResponseCaching\"} property\n\t * has been set to \"true\".\n\t * @param ex the exception that got thrown during handler execution\n\t * @param response current HTTP response\n\t * @see #preventCaching\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "protected void prepareResponse(Exception ex, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(Exception ex, HttpServletResponse response) {\n\t\tif (this.preventResponseCaching) {\n\t\t\tpreventCaching(response);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#resolveException(request,response,handler,ex)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether this resolver is supposed to apply (i.e. if the supplied handler\n\t * matches any of the configured {@linkplain #setMappedHandlers handlers} or\n\t * {@linkplain #setMappedHandlerClasses handler classes}), and then delegate\n\t * to the {@link #doResolveException} template method.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tpublic @Nullable ModelAndView resolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tif (shouldApplyTo(request, handler)) {\n\t\t\tprepareResponse(ex, response);\n\t\t\tModelAndView result = doResolveException(request, response, handler, ex);\n\t\t\tif (result != null && !disconnectedClientHelper.checkAndLogClientDisconnectedException(ex)) {\n\t\t\t\t// Print debug message when warn logger is not enabled.\n\t\t\t\tif (logger.isDebugEnabled() && (this.warnLogger == null || !this.warnLogger.isWarnEnabled())) {\n\t\t\t\t\tlogger.debug(buildLogMessage(ex, request) + (result.isEmpty() ? \"\" : \" to \" + result));\n\t\t\t\t}\n\t\t\t\t// Explicitly configured warn logger in logException method.\n\t\t\t\tlogException(ex, request);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#preHandle(request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tString newLocale = request.getParameter(getParamName());\n\t\tif (newLocale != null) {\n\t\t\tif (checkHttpMethod(request.getMethod())) {\n\t\t\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);\n\t\t\t\tif (localeResolver == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"No LocaleResolver found: not in a DispatcherServlet request?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tlocaleResolver.setLocale(request, response, parseLocaleValue(newLocale));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (isIgnoreInvalidLocale()) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Ignoring invalid locale value [\" + newLocale + \"]: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Proceed in any case.\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#handle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn ((Controller) handler).handleRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.condition.<unknown>#compareTo(other,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares this and another \"produces\" condition as follows:\n\t * <ol>\n\t * <li>Sort 'Accept' header media types by quality value via\n\t * {@link org.springframework.util.MimeTypeUtils#sortBySpecificity(List)}\n\t * and iterate the list.\n\t * <li>Get the first index of matching media types in each \"produces\"\n\t * condition first matching with {@link MediaType#equals(Object)} and\n\t * then with {@link MediaType#includes(MediaType)}.\n\t * <li>If a lower index is found, the condition at that index wins.\n\t * <li>If both indexes are equal, the media types at the index are\n\t * compared further with {@link MediaType#isMoreSpecific(MimeType)}.\n\t * </ol>\n\t * <p>It is assumed that both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} and each instance\n\t * contains the matching producible media type expression only or\n\t * is otherwise empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "int",
    "signature": "public int compareTo(ProducesRequestCondition other, HttpServletRequest request)",
    "source_code": "\tpublic int compareTo(ProducesRequestCondition other, HttpServletRequest request) {\n\t\tif (this.expressions.isEmpty() && other.expressions.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\t\ttry {\n\t\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(request);\n\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\tint thisIndex = this.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint otherIndex = other.indexOfEqualMediaType(acceptedMediaType);\n\t\t\t\tint result = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tthisIndex = this.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\totherIndex = other.indexOfIncludedMediaType(acceptedMediaType);\n\t\t\t\tresult = compareMatchingMediaTypes(this, thisIndex, other, otherIndex);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tcatch (HttpMediaTypeNotAcceptableException ex) {\n\t\t\t// should never happen\n\t\t\tthrow new IllegalStateException(\"Cannot compare without having any requested media types\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@link jakarta.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t * @deprecated as of 5.3.9 along with\n\t * {@link org.springframework.web.servlet.mvc.LastModified}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 913
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#checkResource(resource,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (ResourceHandlerUtils.isResourceUnderLocation(location, resource)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (ResourceHandlerUtils.isResourceUnderLocation(current, resource)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getResource(resourcePath,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected @Nullable Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourcePath,locations,chain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected @Nullable String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\treturn (StringUtils.hasText(resourcePath) &&\n\t\t\t\tgetResource(resourcePath, null, locations) != null ? resourcePath : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setLocationCharsets(Map<Resource,locationCharsets)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#applyCacheControl(response,cacheControl)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the HTTP Cache-Control header according to the given settings.\n\t * @param response current HTTP response\n\t * @param cacheControl the pre-configured cache control settings\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "cacheControl"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "protected void applyCacheControl(HttpServletResponse response, CacheControl cacheControl)",
    "source_code": "\tprotected final void applyCacheControl(HttpServletResponse response, CacheControl cacheControl) {\n\t\tString ccValue = cacheControl.getHeaderValue();\n\t\tif (ccValue != null) {\n\t\t\t// Set computed HTTP 1.1 Cache-Control header\n\t\t\tresponse.setHeader(HEADER_CACHE_CONTROL, ccValue);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#applyCacheSeconds(response,cacheSeconds)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given cache seconds and generate corresponding HTTP headers,\n\t * i.e. allow caching for the given number of seconds in case of a positive\n\t * value, prevent caching if given a 0 value, do nothing else.\n\t * Does not tell the browser to revalidate the resource.\n\t * @param response current HTTP response\n\t * @param cacheSeconds positive number of seconds into the future that the\n\t * response should be cacheable for, 0 to prevent caching\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "cacheSeconds"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void applyCacheSeconds(HttpServletResponse response, int cacheSeconds)",
    "source_code": "\tprotected final void applyCacheSeconds(HttpServletResponse response, int cacheSeconds) {\n\t\tCacheControl cControl;\n\t\tif (cacheSeconds > 0) {\n\t\t\tcControl = CacheControl.maxAge(cacheSeconds, TimeUnit.SECONDS);\n\t\t}\n\t\telse if (cacheSeconds == 0) {\n\t\t\tcControl = CacheControl.noStore();\n\t\t}\n\t\telse {\n\t\t\tcControl = CacheControl.empty();\n\t\t}\n\t\tapplyCacheControl(response, cControl);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 782
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null),\n\t\t\t\tdefaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 750
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#canRead(context,target,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\treturn (target == null &&\n\t\t\t\t\t(resolveImplicitVariable(name) != null || this.pageContext.findAttribute(name) != null));\n\t\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#canWrite(context,target,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#read(context,target,name)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tObject implicitVar = resolveImplicitVariable(name);\n\t\t\tif (implicitVar != null) {\n\t\t\t\treturn new TypedValue(implicitVar);\n\t\t\t}\n\t\t\treturn new TypedValue(this.pageContext.findAttribute(name));\n\t\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#write(context,target,name,newValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.socket.<unknown>#putIfAbsent(headerName,headerValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String headerName, List<String> headerValues)",
    "source_code": "\tpublic @Nullable List<String> putIfAbsent(String headerName, List<String> headerValues) {\n\t\treturn this.headers.putIfAbsent(headerName, headerValues);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.web.socket.server.standard.<unknown>#handleSuccess(request,response,upgradeInfo,upgradeResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "upgradeInfo",
      "upgradeResponse"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "protected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse)",
    "source_code": "\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse) throws IOException, ServletException {\n\n\t\tresponse.setStatus(upgradeResponse.getStatus());\n\t\tupgradeResponse.getHeaders().forEach((key, value) -> response.addHeader(key, Utils.getHeaderFromList(value)));\n\n\t\tAsyncContext asyncContext = request.startAsync();\n\t\tasyncContext.setTimeout(-1L);\n\n\t\tObject nativeRequest = getNativeRequest(request);\n\t\tBeanWrapper beanWrapper = new BeanWrapperImpl(nativeRequest);\n\t\tObject httpSocket = beanWrapper.getPropertyValue(\"connection.connectionHandler.rawConnection\");\n\t\tObject webSocket = webSocketHelper.newInstance(request, httpSocket);\n\t\twebSocketHelper.upgrade(webSocket, httpSocket, request.getServletContext());\n\n\t\tresponse.flushBuffer();\n\n\t\tboolean isProtected = request.getUserPrincipal() != null;\n\t\tWriter servletWriter = servletWriterHelper.newInstance(webSocket, isProtected);\n\t\tConnection connection = upgradeInfo.createConnection(servletWriter, noOpCloseListener);\n\t\tnew BeanWrapperImpl(webSocket).setPropertyValue(\"connection\", connection);\n\t\tnew BeanWrapperImpl(servletWriter).setPropertyValue(\"connection\", connection);\n\t\twebSocketHelper.registerForReadEvent(webSocket);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequestInternal(request,response,wsHandler,sockJsSession)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, AbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tprotected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, AbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = readMessages(request);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tlogger.error(\"Failed to read message\", ex);\n\t\t\tif (ex.getClass().getName().contains(\"Mapping\")) {\n\t\t\t\t// for example, Jackson's JsonMappingException, indicating an incomplete payload\n\t\t\t\thandleReadError(response, \"Payload expected.\", sockJsSession.getId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\thandleReadError(response, \"Broken JSON encoding.\", sockJsSession.getId());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Failed to read message\", ex);\n\t\t\thandleReadError(response, \"Failed to read message(s)\", sockJsSession.getId());\n\t\t\treturn;\n\t\t}\n\t\tif (messages == null) {\n\t\t\thandleReadError(response, \"Payload expected.\", sockJsSession.getId());\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Received message(s): \" + Arrays.toString(messages));\n\t\t}\n\t\tresponse.setStatusCode(getResponseStatus());\n\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\n\t\tsockJsSession.delegateMessages(messages);\n\t}"
  },
  "org.springframework.web.util.<unknown>#build(Map<String,uriVars)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVars)",
    "source_code": "\t\tpublic URI build(Map<String, ?> uriVars) {\n\t\t\tif (!CollectionUtils.isEmpty(defaultUriVariables)) {\n\t\t\t\tMap<String, Object> map = new HashMap<>(defaultUriVariables.size() + uriVars.size());\n\t\t\t\tmap.putAll(defaultUriVariables);\n\t\t\t\tmap.putAll(uriVars);\n\t\t\t\turiVars = map;\n\t\t\t}\n\t\t\tif (encodingMode.equals(EncodingMode.VALUES_ONLY)) {\n\t\t\t\turiVars = UriUtils.encodeUriVariables(uriVars);\n\t\t\t}\n\t\t\tUriComponents uric = this.uriComponentsBuilder.build().expand(uriVars);\n\t\t\treturn createUri(uric);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#decode(source,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component.\n\t * <p>See {@link StringUtils#uriDecode(String, Charset)} for the decoding rules.\n\t * @param source the encoded String\n\t * @param charset the character encoding to use\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "String",
    "signature": "public String decode(String source, Charset charset)",
    "source_code": "\tpublic static String decode(String source, Charset charset) {\n\t\treturn StringUtils.uriDecode(source, charset);\n\t}"
  },
  "org.springframework.web.util.<unknown>#decode(source,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component.\n\t * <p>See {@link StringUtils#uriDecode(String, Charset)} for the decoding rules.\n\t * @param source the encoded String\n\t * @param encoding the character encoding to use\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @see StringUtils#uriDecode(String, Charset)\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "String",
    "signature": "public String decode(String source, String encoding)",
    "source_code": "\tpublic static String decode(String source, String encoding) {\n\t\treturn StringUtils.uriDecode(source, Charset.forName(encoding));\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(source,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode all characters that are either illegal, or have any reserved\n\t * meaning, anywhere within a URI, as defined in\n\t * <a href=\"https://tools.ietf.org/html/rfc3986\">RFC 3986</a>.\n\t * This is useful to ensure that the given String will be preserved as-is\n\t * and will not have any impact on the structure or meaning of the URI.\n\t * @param source the String to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "String",
    "signature": "public String encode(String source, Charset charset)",
    "source_code": "\tpublic static String encode(String source, Charset charset) {\n\t\treturn encode(source, charset, HierarchicalUriComponents.Type.URI);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(source,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #encode(String, Charset)} with a String charset.\n\t * @param source the String to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded String\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "public String encode(String source, String encoding)",
    "source_code": "\tpublic static String encode(String source, String encoding) {\n\t\treturn encode(source, encoding, HierarchicalUriComponents.Type.URI);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeAuthority(authority,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded authority\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "authority",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "String",
    "signature": "public String encodeAuthority(String authority, Charset charset)",
    "source_code": "\tpublic static String encodeAuthority(String authority, Charset charset) {\n\t\treturn encode(authority, charset, HierarchicalUriComponents.Type.AUTHORITY);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeAuthority(authority,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI authority with the given encoding.\n\t * @param authority the authority to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded authority\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "authority",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "String",
    "signature": "public String encodeAuthority(String authority, String encoding)",
    "source_code": "\tpublic static String encodeAuthority(String authority, String encoding) {\n\t\treturn encode(authority, encoding, HierarchicalUriComponents.Type.AUTHORITY);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeFragment(fragment,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI fragment with the given encoding.\n\t * @param fragment the fragment to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded fragment\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragment",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "String",
    "signature": "public String encodeFragment(String fragment, Charset charset)",
    "source_code": "\tpublic static String encodeFragment(String fragment, Charset charset) {\n\t\treturn encode(fragment, charset, HierarchicalUriComponents.Type.FRAGMENT);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeFragment(fragment,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI fragment with the given encoding.\n\t * @param fragment the fragment to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded fragment\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragment",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "String",
    "signature": "public String encodeFragment(String fragment, String encoding)",
    "source_code": "\tpublic static String encodeFragment(String fragment, String encoding) {\n\t\treturn encode(fragment, encoding, HierarchicalUriComponents.Type.FRAGMENT);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeHost(host,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded host\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "String",
    "signature": "public String encodeHost(String host, Charset charset)",
    "source_code": "\tpublic static String encodeHost(String host, Charset charset) {\n\t\treturn encode(host, charset, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeHost(host,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI host with the given encoding.\n\t * @param host the host to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded host\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "host",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "String",
    "signature": "public String encodeHost(String host, String encoding)",
    "source_code": "\tpublic static String encodeHost(String host, String encoding) {\n\t\treturn encode(host, encoding, HierarchicalUriComponents.Type.HOST_IPV4);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePath(path,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded path\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "String",
    "signature": "public String encodePath(String path, Charset charset)",
    "source_code": "\tpublic static String encodePath(String path, Charset charset) {\n\t\treturn encode(path, charset, HierarchicalUriComponents.Type.PATH);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePath(path,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path with the given encoding.\n\t * @param path the path to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String encodePath(String path, String encoding)",
    "source_code": "\tpublic static String encodePath(String path, String encoding) {\n\t\treturn encode(path, encoding, HierarchicalUriComponents.Type.PATH);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePathSegment(segment,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path segment with the given encoding.\n\t * @param segment the segment to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded segment\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "segment",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "String",
    "signature": "public String encodePathSegment(String segment, Charset charset)",
    "source_code": "\tpublic static String encodePathSegment(String segment, Charset charset) {\n\t\treturn encode(segment, charset, HierarchicalUriComponents.Type.PATH_SEGMENT);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePathSegment(segment,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI path segment with the given encoding.\n\t * @param segment the segment to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded segment\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "segment",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "String",
    "signature": "public String encodePathSegment(String segment, String encoding)",
    "source_code": "\tpublic static String encodePathSegment(String segment, String encoding) {\n\t\treturn encode(segment, encoding, HierarchicalUriComponents.Type.PATH_SEGMENT);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePort(port,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI port with the given encoding.\n\t * @param port the port to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded port\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "String",
    "signature": "public String encodePort(String port, Charset charset)",
    "source_code": "\tpublic static String encodePort(String port, Charset charset) {\n\t\treturn encode(port, charset, HierarchicalUriComponents.Type.PORT);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodePort(port,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI port with the given encoding.\n\t * @param port the port to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded port\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "port",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "String",
    "signature": "public String encodePort(String port, String encoding)",
    "source_code": "\tpublic static String encodePort(String port, String encoding) {\n\t\treturn encode(port, encoding, HierarchicalUriComponents.Type.PORT);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeQuery(query,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query with the given encoding.\n\t * @param query the query to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded query\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "String",
    "signature": "public String encodeQuery(String query, Charset charset)",
    "source_code": "\tpublic static String encodeQuery(String query, Charset charset) {\n\t\treturn encode(query, charset, HierarchicalUriComponents.Type.QUERY);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeQuery(query,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query with the given encoding.\n\t * @param query the query to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded query\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "public String encodeQuery(String query, String encoding)",
    "source_code": "\tpublic static String encodeQuery(String query, String encoding) {\n\t\treturn encode(query, encoding, HierarchicalUriComponents.Type.QUERY);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeQueryParam(queryParam,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query parameter with the given encoding.\n\t * @param queryParam the query parameter to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded query parameter\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryParam",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "String",
    "signature": "public String encodeQueryParam(String queryParam, Charset charset)",
    "source_code": "\tpublic static String encodeQueryParam(String queryParam, Charset charset) {\n\t\treturn encode(queryParam, charset, HierarchicalUriComponents.Type.QUERY_PARAM);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeQueryParam(queryParam,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI query parameter with the given encoding.\n\t * @param queryParam the query parameter to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded query parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryParam",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "String",
    "signature": "public String encodeQueryParam(String queryParam, String encoding)",
    "source_code": "\tpublic static String encodeQueryParam(String queryParam, String encoding) {\n\t\treturn encode(queryParam, encoding, HierarchicalUriComponents.Type.QUERY_PARAM);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeQueryParams(MultiValueMap<String,params)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the query parameters from the given {@code MultiValueMap} with UTF-8.\n\t * <p>This can be used with {@link UriComponentsBuilder#queryParams(MultiValueMap)}\n\t * when building a URI from an already encoded template.\n\t * <pre class=\"code\">{@code\n\t * MultiValueMap<String, String> params = new LinkedMultiValueMap<>(2);\n\t * // add to params...\n\t *\n\t * ServletUriComponentsBuilder.fromCurrentRequest()\n\t *         .queryParams(UriUtils.encodeQueryParams(params))\n\t *         .build(true)\n\t *         .toUriString();\n\t * }</pre>\n\t * @param params the parameters to encode\n\t * @return a new {@code MultiValueMap} with the encoded names and values\n\t * @since 5.2.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "String>",
    "signature": "public String> encodeQueryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic static MultiValueMap<String, String> encodeQueryParams(MultiValueMap<String, String> params) {\n\t\tCharset charset = StandardCharsets.UTF_8;\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(params.size());\n\t\tfor (Map.Entry<String, List<String>> entry : params.entrySet()) {\n\t\t\tfor (String value : entry.getValue()) {\n\t\t\t\tresult.add(encodeQueryParam(entry.getKey(), charset), encodeQueryParam(value, charset));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeScheme(scheme,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI scheme with the given encoding.\n\t * @param scheme the scheme to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded scheme\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "String",
    "signature": "public String encodeScheme(String scheme, Charset charset)",
    "source_code": "\tpublic static String encodeScheme(String scheme, Charset charset) {\n\t\treturn encode(scheme, charset, HierarchicalUriComponents.Type.SCHEME);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeScheme(scheme,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI scheme with the given encoding.\n\t * @param scheme the scheme to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded scheme\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scheme",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "String",
    "signature": "public String encodeScheme(String scheme, String encoding)",
    "source_code": "\tpublic static String encodeScheme(String scheme, String encoding) {\n\t\treturn encode(scheme, encoding, HierarchicalUriComponents.Type.SCHEME);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeUriVariables(Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to apply {@link #encode(String, Charset)} to all\n\t * given URI variable values.\n\t * @param uriVariables the URI variable values to be encoded\n\t * @return the encoded String\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "String>",
    "signature": "public String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\tpublic static Map<String, String> encodeUriVariables(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tMap<String, String> result = CollectionUtils.newLinkedHashMap(uriVariables.size());\n\t\turiVariables.forEach((key, value) -> {\n\t\t\tString stringValue = (value != null ? value.toString() : \"\");\n\t\t\tresult.put(key, encode(stringValue, StandardCharsets.UTF_8));\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeUserInfo(userInfo,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param charset the character encoding to encode to\n\t * @return the encoded user info\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String encodeUserInfo(String userInfo, Charset charset)",
    "source_code": "\tpublic static String encodeUserInfo(String userInfo, Charset charset) {\n\t\treturn encode(userInfo, charset, HierarchicalUriComponents.Type.USER_INFO);\n\t}"
  },
  "org.springframework.web.util.<unknown>#encodeUserInfo(userInfo,encoding)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given URI user info with the given encoding.\n\t * @param userInfo the user info to be encoded\n\t * @param encoding the character encoding to encode to\n\t * @return the encoded user info\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userInfo",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "String",
    "signature": "public String encodeUserInfo(String userInfo, String encoding)",
    "source_code": "\tpublic static String encodeUserInfo(String userInfo, String encoding) {\n\t\treturn encode(userInfo, encoding, HierarchicalUriComponents.Type.USER_INFO);\n\t}"
  },
  "org.springframework.web.util.<unknown>#expand(Map<String,uriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all URI template variables with the values from a given map.\n\t * <p>The given map keys represent variable names; the corresponding values\n\t * represent variable values. The order of variables is not significant.\n\t * @param uriVariables the map of URI variables\n\t * @return the expanded URI components\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "UriComponents",
    "signature": "public UriComponents expand(Map<String, ? extends @Nullable Object> uriVariables)",
    "source_code": "\tpublic final UriComponents expand(Map<String, ? extends @Nullable Object> uriVariables) {\n\t\tAssert.notNull(uriVariables, \"'uriVariables' must not be null\");\n\t\treturn expandInternal(new MapTemplateVariables(uriVariables));\n\t}"
  },
  "org.springframework.web.util.<unknown>#expand(uriTemplate,Map<String,uriVars)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "URI",
    "signature": "public URI expand(String uriTemplate, Map<String, ? extends @Nullable Object> uriVars)",
    "source_code": "\tpublic URI expand(String uriTemplate, Map<String, ? extends @Nullable Object> uriVars) {\n\t\treturn uriString(uriTemplate).build(uriVars);\n\t}"
  },
  "org.springframework.web.util.<unknown>#expand(uriTemplate,uriVars)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "URI",
    "signature": "public URI expand(String uriTemplate, @Nullable Object... uriVars)",
    "source_code": "\tpublic URI expand(String uriTemplate, @Nullable Object... uriVars) {\n\t\treturn uriString(uriTemplate).build(uriVars);\n\t}"
  },
  "org.springframework.web.util.<unknown>#setDefaultUriVariables(Map<String,defaultUriVariables)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide default URI variable values to use when expanding URI templates\n\t * with a Map of variables.\n\t * @param defaultUriVariables default URI variable values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "defaultUriVariables"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables)",
    "source_code": "\tpublic void setDefaultUriVariables(@Nullable Map<String, ? extends @Nullable Object> defaultUriVariables) {\n\t\tif (defaultUriVariables != null) {\n\t\t\tif (this.defaultUriVariables == null) {\n\t\t\t\tthis.defaultUriVariables = new HashMap<>(defaultUriVariables);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.defaultUriVariables.putAll(defaultUriVariables);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.defaultUriVariables != null) {\n\t\t\t\tthis.defaultUriVariables.clear();\n\t\t\t}\n\t\t}\n\t}"
  }
}