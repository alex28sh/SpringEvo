{
  "org.springframework.core.codec.<unknown>#decode(dataBuffer,elementType,mimeType,Map<String,hints)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Buffer",
    "signature": "public Buffer decode(DataBuffer dataBuffer, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Buffer decode(DataBuffer dataBuffer, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Read \" + dataBuffer.readableByteCount() + \" bytes\");\n\t\t}\n\t\tif (dataBuffer instanceof Netty5DataBuffer netty5DataBuffer) {\n\t\t\treturn netty5DataBuffer.getNativeBuffer();\n\t\t}\n\t\tbyte[] bytes = new byte[dataBuffer.readableByteCount()];\n\t\tdataBuffer.read(bytes);\n\t\tBuffer buffer = DefaultBufferAllocators.preferredAllocator().copyOf(bytes);\n\t\tDataBufferUtils.release(dataBuffer);\n\t\treturn buffer;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "Netty5DataBuffer",
    "signature": "public Netty5DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic Netty5DataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.buffer.readBytes(destination, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p><strong>Note</strong> that due to the lack of a {@code slice} method\n\t * in Netty 5's {@link Buffer}, this implementation returns a copy that\n\t * does <strong>not</strong> share its contents with this buffer.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\tpublic DataBuffer slice(int index, int length) {\n\t\tBuffer copy = this.buffer.copy(index, length);\n\t\treturn new Netty5DataBuffer(copy, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Netty5DataBuffer",
    "signature": "public Netty5DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic Netty5DataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.buffer.writeBytes(source, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.style.<unknown>#styleMap(Map<K,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map}.\n\t * @return a styled version of the supplied map\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "protected String styleMap(Map<K, V> map)",
    "source_code": "\tprotected <K, V> String styleMap(Map<K, V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn EMPTY_MAP;\n\t\t}\n\n\t\tStringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Map.Entry<K, V> entry : map.entrySet()) {\n\t\t\tresult.add(styleMapEntry(entry));\n\t\t}\n\t\treturn MAP + result;\n\t}"
  },
  "org.springframework.core.style.<unknown>#styleMapEntry(Map.Entry<?,entry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map.Entry}.\n\t * @return a styled version of the supplied map entry\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<?",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "protected String styleMapEntry(Map.Entry<?, ?> entry)",
    "source_code": "\tprotected String styleMapEntry(Map.Entry<?, ?> entry) {\n\t\treturn style(entry.getKey()) + \" -> \" + style(entry.getValue());\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation simple delegates to {@link #readInternal(Class, HttpInputMessage)}.\n\t * Future implementations might add some default behavior, however.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "T",
    "signature": "public T read(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic final T read(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn readInternal(clazz, inputMessage);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#beforeOrAfterTestClass(testContext,requiredClassMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestClass} and {@link #afterTestClass}\n\t * by dirtying the context if appropriate (i.e., according to the required mode).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode) throws Exception {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean classAnnotated = (dirtiesContext != null);\n\t\tClassMode classMode = (classAnnotated ? dirtiesContext.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s test class: context %s, class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testContext, classAnnotated, classMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"%s test class: class [%s], class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testClass.getSimpleName(), classAnnotated, classMode));\n\t\t}\n\n\t\tif (classMode == requiredClassMode) {\n\t\t\tdirtyContext(testContext, dirtiesContext.hierarchyMode());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#beforeOrAfterTestMethod(testContext,requiredMethodMode,requiredClassMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestMethod} and {@link #afterTestMethod}\n\t * by dirtying the context if appropriate (i.e., according to the required modes).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredMethodMode the method mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredMethodMode",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode) throws Exception {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredMethodMode, \"requiredMethodMode must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext methodAnn = AnnotatedElementUtils.findMergedAnnotation(testMethod, DirtiesContext.class);\n\t\tDirtiesContext classAnn = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean methodAnnotated = (methodAnn != null);\n\t\tboolean classAnnotated = (classAnn != null);\n\t\tMethodMode methodMode = (methodAnnotated ? methodAnn.methodMode() : null);\n\t\tClassMode classMode = (classAnnotated ? classAnn.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"\"\"\n\t\t\t\t\t%s test method: context %s, class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testContext, classAnnotated, classMode,\n\t\t\t\t\t\t\tmethodAnnotated, methodMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t%s test method: class [%s], method [%s], class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testClass.getSimpleName(),\n\t\t\t\t\t\t\ttestMethod.getName(), classAnnotated, classMode, methodAnnotated, methodMode));\n\t\t}\n\n\t\tif ((methodMode == requiredMethodMode) || (classMode == requiredClassMode)) {\n\t\t\tHierarchyMode hierarchyMode = (methodAnnotated ? methodAnn.hierarchyMode() : classAnn.hierarchyMode());\n\t\t\tdirtyContext(testContext, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#dirtyContext(testContext,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Mark the {@linkplain ApplicationContext application context} of the supplied\n\t * {@linkplain TestContext test context} as\n\t * {@linkplain TestContext#markApplicationContextDirty(DirtiesContext.HierarchyMode) dirty}\n\t * and set {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE\n\t * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.\n\t * @param testContext the test context whose application context should\n\t * be marked as dirty\n\t * @param hierarchyMode the context cache clearing mode to be applied if the\n\t * context is part of a hierarchy; may be {@code null}\n\t * @since 3.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tprotected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode) {\n\t\ttestContext.markApplicationContextDirty(hierarchyMode);\n\t\ttestContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#handleFailure(factoryType,factoryImplementationName,failure)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementationName",
      "failure"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure)",
    "source_code": "\tpublic void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure) {\n\t\tThrowable ex = (failure instanceof InvocationTargetException ite ? ite.getTargetException() : failure);\n\t\tif (ex instanceof ClassNotFoundException || ex instanceof NoClassDefFoundError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tSkipping candidate %1$s [%2$s] due to a missing dependency. \\\n\t\t\t\t\t\tSpecify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tand their required dependencies available. Offending class: [%3$s]\"\"\"\n\t\t\t\t\t\t\t.formatted(factoryType.getSimpleName(), factoryImplementationName, ex.getMessage()));\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof LinkageError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tCould not load %1$s [%2$s]. Specify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tavailable.\"\"\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\tif (ex instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Failed to load %s [%s]\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @return the created {@code ProblemDetail} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange) {\n\n\t\tErrorResponse response = ErrorResponse.createFor(\n\t\t\t\tex, status, null, defaultDetail, detailMessageCode, detailMessageArguments);\n\n\t\treturn response.updateAndGetBody(this.messageSource, getLocale(exchange));\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerMethodHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerParameterTypeHints(hints,methodParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter)",
    "source_code": "\tprotected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter) {\n\t\tif (methodParameter.hasParameterAnnotation(RequestBody.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#addRequestValue(name,value,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * <p>If the resolver was created with a {@link ConversionService}, the value\n\t * will have been converted to a String and may be cast down.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param parameter the method parameter type, nested if Map, List/array, or Optional\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues);\n\n\n\t/**\n\t * Info about a request value, typically extracted from a method parameter annotation.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprivate final String label;\n\n\t\tprivate final boolean multiValued;\n\n\t\t/**\n\t\t * Create an instance.\n\t\t * @param name the name to use, possibly empty if not specified\n\t\t * @param required whether it is marked as required\n\t\t * @param defaultValue fallback value, possibly {@link ValueConstants#DEFAULT_NONE}\n\t\t * @param label how it should appear in error messages, e.g. \"path variable\", \"request header\"\n\t\t */\n\t\tpublic NamedValueInfo(\n\t\t\t\tString name, boolean required, @Nullable String defaultValue, String label, boolean multiValued) {\n\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t\tthis.label = label;\n\t\t\tthis.multiValued = multiValued;\n\t\t}\n\n\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}\n\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#addRequestValue(name,value,requestValues)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * <p>If the resolver was created with a {@link ConversionService}, the value\n\t * will have been converted to a String and may be cast down.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue(String name, Object value, HttpRequestValues.Builder requestValues);"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}, falling back on\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)}\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @param request the current request\n\t * @return the created {@code ProblemDetail} instance\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request) {\n\n\t\tErrorResponse errorResponse = ErrorResponse.createFor(\n\t\t\t\tex, status, null, defaultDetail, detailMessageCode, detailMessageArguments);\n\n\t\treturn errorResponse.updateAndGetBody(this.messageSource, LocaleContextHolder.getLocale());\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#checkOrigin(request,response,httpMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "boolean",
    "signature": "protected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)\n\t\t\tthrows IOException {\n\n\t\tif (WebUtils.isSameOrigin(request)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.corsConfiguration.checkOrigin(request.getHeaders().getOrigin()) == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Origin header value '\" + request.getHeaders().getOrigin() + \"' not allowed.\");\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handle(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "void",
    "signature": "public void handle(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() != HttpMethod.GET) {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());\n\t\t\tbyte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\t\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\t\tDigestUtils.appendMd5DigestAsHex(contentBytes, builder);\n\t\t\tbuilder.append('\"');\n\t\t\tString etagValue = builder.toString();\n\n\t\t\tList<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();\n\t\t\tif (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_MODIFIED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"html\", StandardCharsets.UTF_8));\n\t\t\tresponse.getHeaders().setContentLength(contentBytes.length);\n\n\t\t\t// No cache in order to check every time if IFrame are authorized\n\t\t\taddNoCacheHeaders(response);\n\t\t\tresponse.getHeaders().setETag(etagValue);\n\t\t\tresponse.getBody().write(contentBytes);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRawWebSocketRequest(request,response,webSocketHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected abstract void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler) throws IOException;\n\n\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */\n\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRequest(request,response,sockJsPath,wsHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method determines the SockJS path and handles SockJS static URLs.\n\t * Session URLs and raw WebSocket requests are delegated to abstract methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsPath",
      "wsHandler"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler)",
    "source_code": "\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler) throws SockJsException {\n\n\t\tif (sockJsPath == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Expected SockJS path. Failing request: \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trequest.getHeaders();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// As per SockJS protocol content-type can be ignored (it's always json)\n\t\t}\n\n\t\tString requestInfo = (logger.isDebugEnabled() ? request.getMethod() + \" \" + request.getURI() : null);\n\n\t\ttry {\n\t\t\tif (sockJsPath.isEmpty() || sockJsPath.equals(\"/\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tif (\"websocket\".equalsIgnoreCase(request.getHeaders().getUpgrade())) {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\t\t\t\tresponse.getBody().write(\"Welcome to SockJS!\\n\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/info\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.infoHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.matches(\"/iframe[0-9-.a-z_]*.html\")) {\n\t\t\t\tif (!getAllowedOrigins().isEmpty() && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t\t\t!getAllowedOriginPatterns().isEmpty()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Iframe support is disabled when an origin check is required. \" +\n\t\t\t\t\t\t\t\t\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (getAllowedOrigins().isEmpty()) {\n\t\t\t\t\tresponse.getHeaders().add(XFRAME_OPTIONS_HEADER, \"SAMEORIGIN\");\n\t\t\t\t}\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.iframeHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/websocket\")) {\n\t\t\t\tif (isWebSocketEnabled()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\thandleRawWebSocketRequest(request, response, wsHandler);\n\t\t\t\t}\n\t\t\t\telse if (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tString[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");\n\t\t\t\tif (pathSegments.length != 3) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Invalid SockJS path '\" + sockJsPath + \"' - \" +\n\t\t\t\t\t\t\t\t\"required to have 3 path segments\", -1, true));\n\t\t\t\t\t}\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tString serverId = pathSegments[0];\n\t\t\t\tString sessionId = pathSegments[1];\n\t\t\t\tString transport = pathSegments[2];\n\n\t\t\t\tif (!isWebSocketEnabled() && transport.equals(\"websocket\")) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if (!validateRequest(serverId, sessionId, transport) || !validatePath(request)) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\thandleTransportRequest(request, response, wsHandler, sessionId, transport);\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to write to the response\", null, ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleTransportRequest(request,response,webSocketHandler,sessionId,transport)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport)",
    "source_code": "\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#sendMethodNotAllowed(response,httpMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "void",
    "signature": "protected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods) {\n\t\tlogger.warn(\"Sending Method Not Allowed (405)\");\n\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\tresponse.getHeaders().setAllow(new LinkedHashSet<>(Arrays.asList(httpMethods)));\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#validateRequest(serverId,sessionId,transport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!StringUtils.hasText(serverId) || !StringUtils.hasText(sessionId) || !StringUtils.hasText(transport)) {\n\t\t\tlogger.warn(\"No server, session, or transport path segment in SockJS request.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Server and session id's must not contain \".\"\n\t\tif (serverId.contains(\".\") || sessionId.contains(\".\")) {\n\t\t\tlogger.warn(\"Either server or session contains a \\\".\\\" which is not allowed by SockJS protocol.\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#createSession(sessionId,handler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "StreamingSockJsSession",
    "signature": "public StreamingSockJsSession createSession(String sessionId, WebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic StreamingSockJsSession createSession(\n\t\t\tString sessionId, WebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\treturn new HtmlFileStreamingSockJsSession(sessionId, getServiceConfig(), handler, attributes);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequestInternal(request,response,sockJsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString callback = getCallbackParam(request);\n\t\tif (!StringUtils.hasText(callback)) {\n\t\t\tresponse.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(\"\\\"callback\\\" parameter required\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to write to response\", sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.handleRequestInternal(request, response, sockJsSession);\n\t}"
  }
}