{
  "org.springframework.aot.generate.<unknown>#addFile(kind,path,content)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void addFile(Kind kind, String path, InputStreamSource content)",
    "source_code": "\tpublic void addFile(Kind kind, String path, InputStreamSource content) {\n\t\tAssert.notNull(kind, \"'kind' must not be null\");\n\t\tAssert.hasLength(path, \"'path' must not be empty\");\n\t\tAssert.notNull(content, \"'content' must not be null\");\n\t\tPath root = this.roots.apply(kind).toAbsolutePath().normalize();\n\t\tPath relativePath = root.resolve(path).toAbsolutePath().normalize();\n\t\tAssert.isTrue(relativePath.startsWith(root), \"'path' must be relative\");\n\t\ttry {\n\t\t\ttry (InputStream inputStream = content.getInputStream()) {\n\t\t\t\tFiles.createDirectories(relativePath.getParent());\n\t\t\t\tFiles.copy(inputStream, relativePath);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#copy(content,override)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "content",
      "override"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void copy(InputStreamSource content, boolean override)",
    "source_code": "\t\tprotected void copy(InputStreamSource content, boolean override) {\n\t\t\tif (override) {\n\t\t\t\tcopy(content, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopy(content);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#handleFile(kind,path,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler)",
    "source_code": "\tpublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\n\t\tFileSystemFileHandler fileHandler = new FileSystemFileHandler(toPath(kind, path));\n\t\thandler.accept(fileHandler);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#ReflectionRegistration(classes,memberCategories)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classes",
      "memberCategories"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "record",
    "signature": "protected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories)",
    "source_code": "\tprotected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories) {\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#parse(element,annotation)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "ReflectionRegistration",
    "signature": "protected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation)",
    "source_code": "\tprotected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\n\t\tList<Class<?>> allClassNames = new ArrayList<>();\n\t\tallClassNames.addAll(Arrays.asList(annotation.classes()));\n\t\tallClassNames.addAll(Arrays.stream(annotation.classNames())\n\t\t\t\t.map(this::loadClass).filter(Objects::nonNull).toList());\n\t\tif (allClassNames.isEmpty()) {\n\t\t\tif (element instanceof Class<?> clazz) {\n\t\t\t\tallClassNames.add(clazz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"At least one class must be specified: \" + element);\n\t\t\t}\n\t\t}\n\t\treturn new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]), annotation.memberCategories());\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerReflectionHints(hints,registration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "registration"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration)",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\n\t\tfor (Class<?> target : registration.classes) {\n\t\t\tregisterReflectionHints(hints, target, registration.memberCategories);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerReflectionHints(hints,target,memberCategories)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "target",
      "memberCategories"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories)",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\n\t\thints.registerType(target, type -> type.withMembers(memberCategories));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifiers(bdHolder,annotationsToSearch)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t * @return {@code false} if a qualifier has been found but not matched,\n\t * {@code true} if a qualifier has been found and matched,\n\t * {@code null} if no qualifier has been found at all\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Boolean",
    "signature": "protected Boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected Boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tboolean qualifierFound = false;\n\t\tif (!ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\t\tif (isPlainJavaAnnotation(type)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean checkMeta = true;\n\t\t\t\tboolean fallbackToMeta = false;\n\t\t\t\tif (isQualifier(type)) {\n\t\t\t\t\tqualifierFound = true;\n\t\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcheckMeta = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (checkMeta) {\n\t\t\t\t\tboolean foundMeta = false;\n\t\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\t\tif (isPlainJavaAnnotation(metaType)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\t\tqualifierFound = true;\n\t\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (qualifierFound ? true : null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\tpublic void applyTo(GenerationContext generationContext,\n\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode) {\n\n\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t.addForFeature(\"BeanFactoryRegistrations\", type -> {\n\t\t\t\t\ttype.addJavadoc(\"Register bean definitions for the bean factory.\");\n\t\t\t\t\ttype.addModifiers(Modifier.PUBLIC);\n\t\t\t\t});\n\t\tBeanRegistrationsCodeGenerator codeGenerator = new BeanRegistrationsCodeGenerator(generatedClass);\n\t\tGeneratedMethod generatedBeanDefinitionsMethod = new BeanDefinitionsRegistrationGenerator(\n\t\t\t\tgenerationContext, codeGenerator, this.registrations).generateRegisterBeanDefinitionsMethod();\n\t\tbeanFactoryInitializationCode.addInitializer(generatedBeanDefinitionsMethod.toMethodReference());\n\t\tGeneratedMethod generatedAliasesMethod = codeGenerator.getMethods().add(\"registerAliases\",\n\t\t\t\tthis::generateRegisterAliasesMethod);\n\t\tbeanFactoryInitializationCode.addInitializer(generatedAliasesMethod.toMethodReference());\n\t\tgenerateRegisterHints(generationContext.getRuntimeHints(), this.registrations);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,constructor)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Constructor<?> constructor) {\n\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(constructor, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(\n\t\t\t\t\t\tmethodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,executable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "executable"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Executable executable)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Executable executable) {\n\t\t\tClass<?>[] parameterTypes = executable.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Method method)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Method method) {\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#resolveCandidate(beanName,requiredType,beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\treturn beanFactory.getBean(beanName);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#resolveNotUnique(type,Map<String,matchingBeans)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#cacheMergedBeanDefinition(mbd,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1037
    },
    "return": "void",
    "signature": "protected void cacheMergedBeanDefinition(RootBeanDefinition mbd, String beanName)",
    "source_code": "\tprotected void cacheMergedBeanDefinition(RootBeanDefinition mbd, String beanName) {\n\t\tsuper.cacheMergedBeanDefinition(mbd, beanName);\n\t\tif (mbd.isPrimary()) {\n\t\t\tthis.primaryBeanNames.add(beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithFactoryMethod(method,instanceSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@code instanceSupplier} with the factory method exposed\n\t * as being invoked.\n\t * @param method the factory method to expose\n\t * @param instanceSupplier the instance supplier\n\t * @param <T> the type of the instance\n\t * @return the result of the instance supplier\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "instanceSupplier"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "T",
    "signature": "public T instantiateWithFactoryMethod(Method method, Supplier<T> instanceSupplier)",
    "source_code": "\tpublic static <T> T instantiateWithFactoryMethod(Method method, Supplier<T> instanceSupplier) {\n\t\tMethod priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n\t\ttry {\n\t\t\tcurrentlyInvokedFactoryMethod.set(method);\n\t\t\treturn instanceSupplier.get();\n\t\t}\n\t\tfinally {\n\t\t\tif (priorInvokedFactoryMethod != null) {\n\t\t\t\tcurrentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrentlyInvokedFactoryMethod.remove();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanFactory,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the autowire-candidate status for the specified bean.\n\t * @param beanFactory the bean factory\n\t * @param beanName the name of the bean to check\n\t * @return whether the specified bean qualifies as an autowire candidate\n\t * @since 6.2.3\n\t * @see org.springframework.beans.factory.config.BeanDefinition#isAutowireCandidate()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(ConfigurableBeanFactory beanFactory, String beanName)",
    "source_code": "\tpublic static boolean isAutowireCandidate(ConfigurableBeanFactory beanFactory, String beanName) {\n\t\ttry {\n\t\t\treturn beanFactory.getMergedBeanDefinition(beanName).isAutowireCandidate();\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// A manually registered singleton instance not backed by a BeanDefinition.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isDefaultCandidate(beanFactory,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the default-candidate status for the specified bean.\n\t * @param beanFactory the bean factory\n\t * @param beanName the name of the bean to check\n\t * @return whether the specified bean qualifies as a default candidate\n\t * @since 6.2.4\n\t * @see AbstractBeanDefinition#isDefaultCandidate()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "boolean",
    "signature": "public boolean isDefaultCandidate(ConfigurableBeanFactory beanFactory, String beanName)",
    "source_code": "\tpublic static boolean isDefaultCandidate(ConfigurableBeanFactory beanFactory, String beanName) {\n\t\ttry {\n\t\t\tBeanDefinition mbd = beanFactory.getMergedBeanDefinition(beanName);\n\t\t\treturn (!(mbd instanceof AbstractBeanDefinition abd) || abd.isDefaultCandidate());\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// A manually registered singleton instance not backed by a BeanDefinition.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#orderedStream(customFilter,includeNonSingletons)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customFilter",
      "includeNonSingletons"
    ],
    "position": {
      "column": 1,
      "line": 2628
    },
    "return": "Stream<Object>",
    "signature": "public Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons)",
    "source_code": "\t\tpublic Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {\n\t\t\tString[] beanNames = beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true);\n\t\t\tif (beanNames.length == 0) {\n\t\t\t\treturn Stream.empty();\n\t\t\t}\n\t\t\tMap<String, Object> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tif (AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, beanName) &&\n\t\t\t\t\t\tcustomFilter.test(getType(beanName))) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#stream(customFilter,includeNonSingletons)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "customFilter",
      "includeNonSingletons"
    ],
    "position": {
      "column": 1,
      "line": 2619
    },
    "return": "Stream<Object>",
    "signature": "public Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons)",
    "source_code": "\t\tpublic Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {\n\t\t\treturn Arrays.stream(beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true))\n\t\t\t\t\t.filter(name -> AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, name))\n\t\t\t\t\t.filter(name -> customFilter.test(getType(name)))\n\t\t\t\t\t.map(name -> getBean(name))\n\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildLazyResolutionProxy(descriptor,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Object",
    "signature": "protected Object buildLazyResolutionProxy(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\tprotected Object buildLazyResolutionProxy(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn buildLazyResolutionProxy(descriptor, beanName, false);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getLazyResolutionProxyIfNecessary(descriptor,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\tpublic Object getLazyResolutionProxyIfNecessary(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\treturn (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : null);\n\t}"
  },
  "org.springframework.context.aot.<unknown>#scan(classLoader,packageNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Scan the given {@code packageNames} and their sub-packages for classes\n\t * that uses {@link Reflective}.\n\t * <p>This performs a \"deep scan\" by loading every class in the specified\n\t * packages and search for {@link Reflective} on types, constructors, methods,\n\t * and fields. Enclosed classes are candidates as well. Classes that fail to\n\t * load are ignored.\n\t * @param classLoader the classloader to use\n\t * @param packageNames the package names to scan\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "packageNames"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ReflectiveProcessorAotContributionBuilder",
    "signature": "public ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames)",
    "source_code": "\tpublic ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames) {\n\t\tReflectiveClassPathScanner scanner = new ReflectiveClassPathScanner(classLoader);\n\t\treturn withClasses(scanner.scan(packageNames));\n\t}"
  },
  "org.springframework.context.support.<unknown>#setConcurrentStartupForPhase(phase,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Switch to concurrent startup for a specific phase (group of {@link SmartLifecycle}\n\t * beans with the same 'phase' value) with a corresponding timeout.\n\t * <p><b>Note: By default, the startup for every phase will be sequential without\n\t * a timeout. Calling this setter with a timeout for the given phase switches to a\n\t * mode where the beans in this phase will be started concurrently, cancelling\n\t * the startup if the corresponding timeout is not met for this phase.</b>\n\t * <p>For an actual concurrent startup, a bootstrap {@code Executor} needs to be\n\t * set for the application context, typically through a \"bootstrapExecutor\" bean.\n\t * @param phase the phase value (matching {@link SmartLifecycle#getPhase()})\n\t * @param timeout the corresponding timeout value (in milliseconds)\n\t * @since 6.2.6\n\t * @see SmartLifecycle#getPhase()\n\t * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#getBootstrapExecutor()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setConcurrentStartupForPhase(int phase, long timeout)",
    "source_code": "\tpublic void setConcurrentStartupForPhase(int phase, long timeout) {\n\t\tthis.concurrentStartupForPhases.put(phase, timeout);\n\t}"
  },
  "org.springframework.context.support.<unknown>#setConcurrentStartupForPhases(Map<Integer,phasesWithTimeouts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Switch to concurrent startup for each given phase (group of {@link SmartLifecycle}\n\t * beans with the same 'phase' value) with corresponding timeouts.\n\t * <p><b>Note: By default, the startup for every phase will be sequential without\n\t * a timeout. Calling this setter with timeouts for the given phases switches to a\n\t * mode where the beans in these phases will be started concurrently, cancelling\n\t * the startup if the corresponding timeout is not met for any of these phases.</b>\n\t * <p>For an actual concurrent startup, a bootstrap {@code Executor} needs to be\n\t * set for the application context, typically through a \"bootstrapExecutor\" bean.\n\t * @param phasesWithTimeouts a map of phase values (matching\n\t * {@link SmartLifecycle#getPhase()}) and corresponding timeout values\n\t * (in milliseconds)\n\t * @since 6.2.6\n\t * @see SmartLifecycle#getPhase()\n\t * @see org.springframework.beans.factory.config.ConfigurableBeanFactory#getBootstrapExecutor()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Integer",
      "phasesWithTimeouts"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setConcurrentStartupForPhases(Map<Integer, Long> phasesWithTimeouts)",
    "source_code": "\tpublic void setConcurrentStartupForPhases(Map<Integer, Long> phasesWithTimeouts) {\n\t\tthis.concurrentStartupForPhases.putAll(phasesWithTimeouts);\n\t}"
  },
  "org.springframework.context.support.<unknown>#setTimeoutForShutdownPhase(phase,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of a specific phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param phase the phase value (matching {@link SmartLifecycle#getPhase()})\n\t * @param timeout the corresponding timeout value (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "void",
    "signature": "public void setTimeoutForShutdownPhase(int phase, long timeout)",
    "source_code": "\tpublic void setTimeoutForShutdownPhase(int phase, long timeout) {\n\t\tthis.timeoutsForShutdownPhases.put(phase, timeout);\n\t}"
  },
  "org.springframework.context.support.<unknown>#setTimeoutsForShutdownPhases(Map<Integer,phasesWithTimeouts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of each given phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param phasesWithTimeouts a map of phase values (matching\n\t * {@link SmartLifecycle#getPhase()}) and corresponding timeout values\n\t * (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Integer",
      "phasesWithTimeouts"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void setTimeoutsForShutdownPhases(Map<Integer, Long> phasesWithTimeouts)",
    "source_code": "\tpublic void setTimeoutsForShutdownPhases(Map<Integer, Long> phasesWithTimeouts) {\n\t\tthis.timeoutsForShutdownPhases.putAll(phasesWithTimeouts);\n\t}"
  },
  "org.springframework.core.<unknown>#equalsType(type,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are equal to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are equal to the type\n\t\t * @since 6.2.4\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1799
    },
    "return": "boolean",
    "signature": "public boolean equalsType(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean equalsType(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER && bound.hasUnresolvableGenerics() ?\n\t\t\t\t\t\t!type.isAssignableFrom(bound, true, matchedBefore, false) :\n\t\t\t\t\t\t!type.equalsType(bound)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.<unknown>#isAssignableFrom(type,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1763
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.<unknown>#isAssignableFrom(types,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1740
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tboolean matched = false;\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (this.kind == Kind.UPPER ? bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t\ttype.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!matched) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.<unknown>#isAssignableTo(type,Map<Type,matchedBefore)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1779
    },
    "return": "boolean",
    "signature": "public boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tif (this.kind == Kind.UPPER) {\n\t\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\t\tif (type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (type.resolve() == Object.class);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.annotation.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#formatArgumentError(param,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#matchesFallback(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "boolean",
    "signature": "public boolean matchesFallback(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matchesFallback(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn (this.typeInfo.getTargetType() == targetType.getObjectType() &&\n\t\t\t\t\tthis.targetType.hasUnresolvableGenerics() &&\n\t\t\t\t\t(!(this.converter instanceof ConditionalConverter conditionalConverter) ||\n\t\t\t\t\t\t\tconditionalConverter.matches(sourceType, targetType)));\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#map(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 1303
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic DataBuffer map(byte[] b, int off, int len) {\n\t\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(len);\n\t\t\tbuffer.write(b, off, len);\n\t\t\treturn buffer;\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#outputStreamPublisher(consumer,bufferFactory,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param consumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(\n\t\t\tConsumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor) {\n\n\t\treturn new OutputStreamPublisher<>(\n\t\t\t\tconsumer::accept, new DataBufferMapper(bufferFactory), executor, null);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#outputStreamPublisher(consumer,bufferFactory,executor,chunkSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #outputStreamPublisher(Consumer, DataBufferFactory, Executor)}\n\t * providing control over the chunk sizes to be produced by the publisher.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(\n\t\t\tConsumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor, int chunkSize) {\n\n\t\treturn new OutputStreamPublisher<>(\n\t\t\t\tconsumer::accept, new DataBufferMapper(bufferFactory), executor, chunkSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor) {\n\n\t\treturn outputStreamPublisher(outputStreamConsumer, bufferFactory, executor, DEFAULT_CHUNK_SIZE);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#outputStreamPublisher(outputStreamConsumer,bufferFactory,executor,chunkSize)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamHandler} are buffered until they\n\t * reach or exceed {@code chunkSize}, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param outputStreamConsumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> outputStreamConsumer,\n\t\t\tDataBufferFactory bufferFactory, Executor executor, int chunkSize) {\n\n\t\tAssert.notNull(outputStreamConsumer, \"OutputStreamConsumer must not be null\");\n\t\tAssert.notNull(bufferFactory, \"BufferFactory must not be null\");\n\t\tAssert.notNull(executor, \"Executor must not be null\");\n\t\tAssert.isTrue(chunkSize > 0, \"Chunk size must be > 0\");\n\n\t\treturn new OutputStreamPublisher(outputStreamConsumer, bufferFactory, executor, chunkSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer read(byte[] destination, int offset, int length) {\n\t\tAssert.notNull(destination, \"Byte array must not be null\");\n\t\tassertIndex(this.readPosition <= this.writePosition - length,\n\t\t\t\t\"readPosition %d and length %d should be smaller than writePosition %d\",\n\t\t\t\tthis.readPosition, length, this.writePosition);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.readPosition + length;\n\t\ttmp.clear().position(this.readPosition).limit(limit);\n\t\ttmp.get(destination, offset, length);\n\n\t\tthis.readPosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer slice(int index, int length)",
    "source_code": "\tpublic DefaultDataBuffer slice(int index, int length) {\n\t\tcheckIndex(index, length);\n\t\tint oldPosition = this.byteBuffer.position();\n\t\ttry {\n\t\t\tthis.byteBuffer.position(index);\n\t\t\tByteBuffer slice = this.byteBuffer.slice();\n\t\t\tslice.limit(length);\n\t\t\treturn new SlicedDefaultDataBuffer(slice, this.dataBufferFactory, length);\n\t\t}\n\t\tfinally {\n\t\t\tthis.byteBuffer.position(oldPosition);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#subscriberInputStream(publisher,demand)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subscribe to given {@link Publisher} of {@code DataBuffer}s, and return an\n\t * {@link InputStream} to consume the byte content with.\n\t * <p>Byte buffers are stored in a queue. The {@code demand} constructor value\n\t * determines the number of buffers requested initially. When storage falls\n\t * below a {@code (demand - (demand >> 2))} limit, a request is made to refill\n\t * the queue.\n\t * <p>The {@code InputStream} terminates after an onError or onComplete signal,\n\t * and stored buffers are read. If the {@code InputStream} is closed,\n\t * the {@link Flow.Subscription} is cancelled, and stored buffers released.\n\t * @param publisher the source of {@code DataBuffer}s\n\t * @param demand the number of buffers to request initially, and buffer\n\t * internally on an ongoing basis.\n\t * @return an {@link InputStream} backed by the {@link Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "demand"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "InputStream",
    "signature": "public InputStream subscriberInputStream(Publisher<T> publisher, int demand)",
    "source_code": "\tpublic static <T extends DataBuffer> InputStream subscriberInputStream(Publisher<T> publisher, int demand) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(demand > 0, \"maxBufferCount must be > 0\");\n\n\t\tSubscriberInputStream subscriber = new SubscriberInputStream(demand);\n\t\tpublisher.subscribe(subscriber);\n\t\treturn subscriber;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer write(byte[] source, int offset, int length) {\n\t\tAssert.notNull(source, \"Byte array must not be null\");\n\t\tensureWritable(length);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.writePosition + length;\n\t\ttmp.clear().position(this.writePosition).limit(limit);\n\t\ttmp.put(source, offset, length);\n\n\t\tthis.writePosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.docs.integration.resthttpinterface.customresolver.<unknown>#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "boolean",
    "signature": "public boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\t\tpublic boolean resolve(Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\t\t\tif (parameter.getParameterType().equals(Search.class)) {\n\t\t\t\tSearch search = (Search) argument;\n\t\t\t\trequestValues.addRequestParameter(\"owner\", search.owner());\n\t\t\t\trequestValues.addRequestParameter(\"language\", search.language());\n\t\t\t\trequestValues.addRequestParameter(\"query\", search.query());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.expression.spel.<unknown>#generateCodeForArgument(methodVisitor,argument,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>Delegates to {@link #generateCodeForArgument(MethodVisitor, SpelNode, String)}\n\t * with the {@linkplain #toDescriptor(Class) descriptor} for\n\t * the supplied {@code requiredType}.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredType}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, int.class)}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredType the required type for the argument when invoking the\n\t * corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType) {\n\t\tgenerateCodeForArgument(methodVisitor, argument, toDescriptor(requiredType));\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#generateCodeForArgument(methodVisitor,argument,requiredTypeDesc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredTypeDesc}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, \"I\")}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredTypeDesc a descriptor for the required type for the argument\n\t * when invoking the corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, Class)\n\t * @see #toDescriptor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredTypeDesc"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc) {\n\t\tenterCompilationScope();\n\t\targument.generateCode(methodVisitor, this);\n\t\tString lastDesc = lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = isPrimitive(lastDesc);\n\t\t// Check if we need to box it.\n\t\tif (primitiveOnStack && requiredTypeDesc.charAt(0) == 'L') {\n\t\t\tinsertBoxIfNecessary(methodVisitor, lastDesc.charAt(0));\n\t\t}\n\t\t// Check if we need to unbox it.\n\t\telse if (requiredTypeDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tinsertUnboxInsns(methodVisitor, requiredTypeDesc.charAt(0), lastDesc);\n\t\t}\n\t\t// Check if we need to check-cast\n\t\telse if (!requiredTypeDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (for example, method takes Number but Integer passed in)\n\t\t\tinsertCheckCast(methodVisitor, requiredTypeDesc);\n\t\t}\n\t\texitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertArrayStore(mv,arrayComponentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array.\n\t * <p>The instruction to use varies depending on whether the type is a\n\t * primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayComponentType the component type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayComponentType"
    ],
    "position": {
      "column": 1,
      "line": 908
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayComponentType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayComponentType) {\n\t\tif (arrayComponentType.length() == 1) {\n\t\t\tchar componentType = arrayComponentType.charAt(0);\n\t\t\tswitch (componentType) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array component type \" + componentType);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertArrayStore(mv,arrayElementType)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArguments(mv,cf,executable,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified\n\t * {@link Executable} (method or constructor).\n\t * <p>This method takes into account whether the method or constructor was\n\t * declared to accept varargs, and if it was then the argument values will be\n\t * appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current {@link CodeFlow}\n\t * @param executable the {@link Executable} (method or constructor) for which\n\t * arguments are being set up\n\t * @param arguments the expression nodes for the expression supplied argument\n\t * values\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "executable",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments(\n\t\t\tMethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments) {\n\n\t\tClass<?>[] parameterTypes = executable.getParameterTypes();\n\t\tString[] parameterDescriptors = CodeFlow.toDescriptors(parameterTypes);\n\t\tint parameterCount = parameterTypes.length;\n\n\t\tif (executable.isVarArgs()) {\n\t\t\t// The final parameter may or may not need packaging into an array, or nothing may\n\t\t\t// have been passed to satisfy the varargs which means something needs to be built.\n\n\t\t\tint varargsIndex = parameterCount - 1;\n\t\t\tint argumentCount = arguments.length;\n\t\t\tint p = 0;  // Current supplied argument being processed\n\n\t\t\t// Fulfill all the parameter requirements except the last one (the varargs array).\n\t\t\tfor (p = 0; p < varargsIndex; p++) {\n\t\t\t\tcf.generateCodeForArgument(mv, arguments[p], parameterDescriptors[p]);\n\t\t\t}\n\n\t\t\tSpelNodeImpl lastArgument = (argumentCount != 0 ? arguments[argumentCount - 1] : null);\n\t\t\tClassLoader classLoader = executable.getDeclaringClass().getClassLoader();\n\t\t\tClass<?> lastArgumentType = (lastArgument != null ?\n\t\t\t\t\tloadClassForExitDescriptor(lastArgument.getExitDescriptor(), classLoader) : null);\n\t\t\tClass<?> lastParameterType = parameterTypes[varargsIndex];\n\n\t\t\t// Determine if the final passed argument is already suitably packaged in array\n\t\t\t// form to be passed to the method.\n\t\t\tif (lastArgument != null && lastArgumentType != null && lastParameterType.isAssignableFrom(lastArgumentType)) {\n\t\t\t\tcf.generateCodeForArgument(mv, lastArgument, parameterDescriptors[p]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString arrayComponentType = parameterDescriptors[varargsIndex];\n\t\t\t\t// Trim the leading '[', potentially leaving other '[' characters.\n\t\t\t\tarrayComponentType = arrayComponentType.substring(1);\n\t\t\t\t// Build array big enough to hold remaining arguments.\n\t\t\t\tCodeFlow.insertNewArrayCode(mv, argumentCount - p, arrayComponentType);\n\t\t\t\t// Package up the remaining arguments into the array.\n\t\t\t\tint arrayIndex = 0;\n\t\t\t\twhile (p < argumentCount) {\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tCodeFlow.insertOptimalLoad(mv, arrayIndex++);\n\t\t\t\t\tcf.generateCodeForArgument(mv, arguments[p++], arrayComponentType);\n\t\t\t\t\tCodeFlow.insertArrayStore(mv, arrayComponentType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < parameterCount; i++) {\n\t\t\t\tcf.generateCodeForArgument(mv, arguments[i], parameterDescriptors[i]);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#convertAllArguments(converter,arguments,method)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link Method}.\n\t * <p>If the supplied method is a varargs method, the final parameter type must be an\n\t * array whose component type should be used as the conversion target for extraneous\n\t * arguments. For example, if the parameter types are <code>{Integer, String[]}</code>\n\t * and the input arguments are <code>{Integer, boolean, float}</code>, then both the\n\t * {@code boolean} and the {@code float} must be converted to strings.\n\t * <p>This method does <strong>not</strong> repackage the arguments into a form suitable\n\t * for the varargs invocation: a subsequent call to\n\t * {@link #setupArgumentsForVarargsInvocation(Class[], Object...)} is required for that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param method the target {@code Method}\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws SpelEvaluationException if a problem occurs during conversion\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter",
      "arguments",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "boolean",
    "signature": "public boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)",
    "source_code": "\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n\t\t\tthrows SpelEvaluationException {\n\n\t\tInteger varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null);\n\t\treturn convertArguments(converter, arguments, method, varargsPosition);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#convertAllMethodHandleArguments(converter,arguments,methodHandle,varargsPosition)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied set of arguments into the parameter types of the supplied\n\t * {@link MethodHandle}, taking the varargs position into account.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the required parameter types\n\t * @param methodHandle the target {@code MethodHandle}\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converter",
      "arguments",
      "methodHandle",
      "varargsPosition"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "boolean",
    "signature": "public boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition)",
    "source_code": "\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tMethodType methodHandleType = methodHandle.type();\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleType.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleType.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tClass<?> varargsArrayClass = methodHandleType.lastParameterType();\n\t\t\t// We use the wrapper type for a primitive varargs array, since we eventually\n\t\t\t// need an Object array in order to invoke the MethodHandle in\n\t\t\t// FunctionReference#executeFunctionViaMethodHandle().\n\t\t\tClass<?> varargsComponentClass = ClassUtils.resolvePrimitiveIfNecessary(varargsArrayClass.componentType());\n\t\t\tTypeDescriptor varargsArrayType = TypeDescriptor.array(TypeDescriptor.valueOf(varargsComponentClass));\n\t\t\tAssert.state(varargsArrayType != null, \"Array type must not be null for a varargs array\");\n\t\t\tTypeDescriptor varargsComponentType = varargsArrayType.getElementTypeDescriptor();\n\t\t\tAssert.state(varargsComponentType != null, \"Component type must not be null for a varargs array\");\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (varargsComponentType.getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is assignable to the varargs component type, there is no need to\n\t\t\t\t// convert it. For example, using StringToArrayConverter to convert a String containing a\n\t\t\t\t// comma would result in the String being split and repackaged in an array when it should\n\t\t\t\t// be used as-is. Similarly, if the argument is an array that is assignable to the varargs\n\t\t\t\t// array type, there is no need to convert it. However, if the argument is a java.util.List,\n\t\t\t\t// we let the TypeConverter convert the list to an array.\n\t\t\t\telse if (!sourceType.isAssignableTo(varargsComponentType) ||\n\t\t\t\t\t\t(sourceType.isArray() && !sourceType.isAssignableTo(varargsArrayType)) ||\n\t\t\t\t\t\t(argument instanceof List)) {\n\n\t\t\t\t\tTypeDescriptor targetTypeToUse =\n\t\t\t\t\t\t\t(sourceType.isArray() || argument instanceof List ? varargsArrayType : varargsComponentType);\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetTypeToUse);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs component type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was the correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., an Object array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted as explained in the comments above.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs component type.\n\t\t\telse {\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\t\targuments[i] = converter.convertValue(argument, sourceType, varargsComponentType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#getTypeDifferenceWeight(paramTypes,argTypes)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramTypes",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
    "source_code": "\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#setupArgumentsForVarargsInvocation(requiredParameterTypes,args)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Package up the supplied {@code args} so that they correctly match what is\n\t * expected in {@code requiredParameterTypes}.\n\t * <p>For example, if {@code requiredParameterTypes} is {@code (int, String[])}\n\t * because the second parameter was declared as {@code String...}, then if\n\t * {@code args} is {@code [1, \"a\", \"b\"]} it must be repackaged as\n\t * {@code [1, new String[] {\"a\", \"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be set up for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been performed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredParameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "Object[]",
    "signature": "public Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args)",
    "source_code": "\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\tAssert.notEmpty(requiredParameterTypes, \"Required parameter types array must not be empty\");\n\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tClass<?> lastRequiredParameterType = requiredParameterTypes[parameterCount - 1];\n\t\tAssert.isTrue(lastRequiredParameterType.isArray(),\n\t\t\t\t\"The last required parameter type must be an array to support varargs invocation\");\n\n\t\tint argumentCount = args.length;\n\t\tObject lastArgument = (argumentCount > 0 ? args[argumentCount - 1] : null);\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != argumentCount || !lastRequiredParameterType.isInstance(lastArgument)) {\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = lastRequiredParameterType.componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\n\t\treturn args;\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#detectAndParse(value,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Detect the style then parse the value to return a duration.\n\t * @param value the value to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return the parsed duration\n\t * @throws IllegalArgumentException if the value is not a known style or cannot be\n\t * parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Duration",
    "signature": "public Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit) {\n\t\treturn parse(value, detect(value), unit);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#parse(value,style)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @return a duration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Duration",
    "signature": "public Duration parse(String value, DurationFormat.Style style)",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style) {\n\t\treturn parse(value, style, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#parse(value,style,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return a duration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Duration",
    "signature": "public Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\tAssert.hasText(value, () -> \"Value must not be empty\");\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> parseIso8601(value);\n\t\t\tcase SIMPLE -> parseSimple(value, unit);\n\t\t\tcase COMPOSITE -> parseComposite(value);\n\t\t};\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#print(value,style)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style) {\n\t\treturn print(value, style, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#print(value,style,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style using the given unit.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @param unit the unit to use for printing, if relevant ({@code null} will default\n\t * to ms)\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> value.toString();\n\t\t\tcase SIMPLE -> printSimple(value, unit);\n\t\t\tcase COMPOSITE -> printComposite(value);\n\t\t};\n\t}"
  },
  "org.springframework.http.<unknown>#body(body,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body, Type type)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}"
  },
  "org.springframework.http.<unknown>#compare(other,strong)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a strong or weak comparison to another {@link ETag}.\n\t * @param other the ETag to compare to\n\t * @param strong whether to perform strong or weak comparison\n\t * @return whether there is a match or not\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3.2\">RFC 9110, Section 8.8.3.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "strong"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "boolean",
    "signature": "public boolean compare(ETag other, boolean strong)",
    "source_code": "\tpublic boolean compare(ETag other, boolean strong) {\n\t\tif (!StringUtils.hasLength(tag()) || !StringUtils.hasLength(other.tag())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strong && (weak() || other.weak())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tag().equals(other.tag());\n\t}"
  },
  "org.springframework.http.<unknown>#method(method,uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#method(method,uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#method(method,url)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, URI url)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}"
  },
  "org.springframework.http.<unknown>#patch(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#post(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#put(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuf map(byte[] b, int off, int len) {\n\t\t\tByteBuf buf = this.allocator.buffer(len);\n\t\t\tbuf.writeBytes(b, off, len);\n\t\t\treturn buf;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#asByteBuffer(index,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tif (!uri.isAbsolute()) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n\t\t}\n\n\t\tif (!this.httpClient.isStarted()) {\n\t\t\ttry {\n\t\t\t\tthis.httpClient.start();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tRequest jettyRequest = this.httpClient.newRequest(uri).method(method.toString());\n\t\tJettyClientHttpRequest request = new JettyClientHttpRequest(jettyRequest, this.bufferFactory);\n\n\t\treturn requestCallback.apply(request).then(execute(request));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#indexOf(predicate,fromIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#lastIndexOf(predicate,fromIndex)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#read(destination,offset,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#slice(index,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toByteBuffer(index,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toString(index,length,charset)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#write(source,offset,length)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.<unknown>#addHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.0\n\t * @deprecated since 6.1, in favor of {@link #addDefaultHeaders(ReactiveHttpOutputMessage, Resource, MediaType, Map)},\n\t * for removal = 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic void addHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\taddDefaultHeaders(message, resource, contentType, hints).block();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\treturn canSerialize(elementType, mimeType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canSerialize(type,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether the given type can be serialized using Kotlin\n\t * serialization.\n\t * @param type the type to be serialized\n\t * @param mimeType the mimetype to use (can be {@code null})\n\t * @return {@code true} if {@code type} can be serialized; false otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "protected boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType)",
    "source_code": "\tprotected final boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn (supports(mimeType) && !String.class.isAssignableFrom(type.toClass()) &&\n\t\t\t\t\t!ServerSentEvent.class.isAssignableFrom(type.toClass()));\n\t\t}\n\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (inputStream instanceof Mono<?> mono) {\n\t\t\treturn mono\n\t\t\t\t\t.map(value -> encodeValue(value, bufferFactory, elementType, mimeType, hints))\n\t\t\t\t\t.flux();\n\t\t}\n\t\tif (mimeType != null && this.streamingMediaTypes.contains(mimeType)) {\n\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t.map(value -> encodeStreamingValue(value, bufferFactory, elementType, mimeType, hints, EMPTY_BYTES,\n\t\t\t\t\t\t\tNEWLINE_SEPARATOR));\n\t\t}\n\t\treturn encodeNonStream(inputStream, bufferFactory, elementType, mimeType, hints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encodeNonStream(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encodeNonStream(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encodeNonStream(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\n\t\treturn Flux.from(inputStream)\n\t\t\t\t.collectList()\n\t\t\t\t.map(list -> encodeValue(list, bufferFactory, listType, mimeType, hints))\n\t\t\t\t.flux();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encodeStreamingValue(value,bufferFactory,valueType,mimeType,Map<String,hints,prefix,suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints",
      "prefix",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "DataBuffer",
    "signature": "protected DataBuffer encodeStreamingValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints, byte[] prefix, byte[] suffix)",
    "source_code": "\tprotected DataBuffer encodeStreamingValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints, byte[] prefix, byte[] suffix) {\n\n\t\tList<DataBuffer> buffers = new ArrayList<>(3);\n\t\tif (prefix.length > 0) {\n\t\t\tbuffers.add(bufferFactory.allocateBuffer(prefix.length).write(prefix));\n\t\t}\n\t\tbuffers.add(encodeValue(value, bufferFactory, valueType, mimeType, hints));\n\t\tif (suffix.length > 0) {\n\t\t\tbuffers.add(bufferFactory.allocateBuffer(suffix.length).write(suffix));\n\t\t}\n\t\treturn bufferFactory.join(buffers);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\tKSerializer<Object> serializer = serializer(valueType);\n\t\tif (serializer == null) {\n\t\t\tthrow new EncodingException(\"Could not find KSerializer for \" + valueType);\n\t\t}\n\t\tString string = format().encodeToString(serializer, value);\n\t\treturn this.charSequenceEncoder.encodeValue(string, bufferFactory, valueType, mimeType, null);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(type,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType type, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType type, @Nullable MediaType mediaType) {\n\t\tif (!ResolvableType.NONE.equals(type) && serializer(type) != null) {\n\t\t\treturn canRead(mediaType);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(type,inputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Object",
    "signature": "public Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic final Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Could not find KSerializer for \" + type, inputMessage);\n\t\t}\n\t\treturn readInternal(serializer, this.format, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(serializer,format,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Reads the given input message with the given serializer and format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serializer",
      "format",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Object",
    "signature": "protected Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)",
    "source_code": "\tprotected abstract Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t@Override\n\tprotected final void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException {\n\n\t\tResolvableType resolvableType = (ResolvableType.NONE.equals(type) ? ResolvableType.forInstance(object) : type);\n\t\tKSerializer<Object> serializer = serializer(resolvableType);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not find KSerializer for \" + resolvableType);\n\t\t}\n\t\twriteInternal(object, serializer, this.format, outputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,type,contentType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void write(T t, ResolvableType type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic final void write(T t, ResolvableType type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tHttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, hints);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, type, outputMessage, hints);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,serializer,format,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given object to the output message with the given serializer and format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "serializer",
      "format",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, KSerializer<Object> serializer, T format,\n\t\t\tHttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(Object object, KSerializer<Object> serializer, T format,\n\t\t\tHttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;\n\n\t/**\n\t * Tries to find a serializer that can marshall or unmarshall instances of the given type\n\t * using kotlinx.serialization. If no serializer can be found, {@code null} is returned."
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,type,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tprotected final void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException {\n\n\t\tResolvableType resolvableType = (ResolvableType.NONE.equals(type) ? ResolvableType.forInstance(object) : type);\n\t\tKSerializer<Object> serializer = serializer(resolvableType);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not find KSerializer for \" + resolvableType);\n\t\t}\n\t\twriteInternal(object, serializer, this.format, outputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,type,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from\n\t * {@link #write(Object, ResolvableType, MediaType, HttpOutputMessage, Map)}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write\n\t * @param outputMessage the HTTP output message to write to\n\t * @param hints additional information about how to encode\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "type",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tprotected abstract void writeInternal(T t, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException;\n\n\t@Override\n\tprotected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn read(ResolvableType.forClass(clazz), inputMessage, null);\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(value,headers,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void writeToResult(Object value, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object value, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(value, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.server.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject old = get(key);\n\t\t\tservletRequest.setAttribute(key, value);\n\t\t\treturn old;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#customizeConfigurer(type,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer customizeConfigurer(EmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer(\n\t\t\tEmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer) {\n\n\t\tEmbeddedDatabaseConfigurer defaultConfigurer = getConfigurer(type);\n\t\treturn customizer.apply(defaultConfigurer);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerEndpoint(endpoint,factory)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateContext(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "JMSContext",
    "signature": "protected JMSContext doCreateContext(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected JMSContext doCreateContext(@Nullable String username, @Nullable String password) {\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn obtainTargetConnectionFactory().createContext(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createContext();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateContext(username,password,sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "JMSContext",
    "signature": "protected JMSContext doCreateContext(@Nullable String username, @Nullable String password, int sessionMode)",
    "source_code": "\tprotected JMSContext doCreateContext(@Nullable String username, @Nullable String password, int sessionMode) {\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn obtainTargetConnectionFactory().createContext(username, password, sessionMode);\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createContext(sessionMode);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource} and assigning the provided\n\t * {@code inlineFileName} to the element.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 932
    },
    "return": "void",
    "signature": "public void addInline(String contentId, @Nullable String inlineFilename, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, @Nullable String inlineFilename, DataSource dataSource)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(contentId, \"Content ID must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\tmimeBodyPart.setDisposition(Part.INLINE);\n\t\tmimeBodyPart.setContentID(\"<\" + contentId + \">\");\n\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\tif (inlineFilename != null) {\n\t\t\ttry {\n\t\t\tmimeBodyPart.setFileName(isEncodeFilenames() ?\n\t\t\t\t\tMimeUtility.encodeText(inlineFilename) : inlineFilename);\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\tthrow new MessagingException(\"Failed to encode inline filename\", ex);\n\t\t\t}\n\t\t}\n\t\tgetMimeMultipart().addBodyPart(mimeBodyPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,inputStreamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName explicitly.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the file name to use for the inline element\n\t * @param inputStreamSource the resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText(String)\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1056
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource)\n\t\t\tthrows MessagingException {\n\n\t\tString contentType = getFileTypeMap().getContentType(inlineFilename);\n\t\taddInline(contentId, inlineFilename, inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,inputStreamSource,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName and content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1087
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, inlineFilename);\n\t\taddInline(contentId, inlineFilename, dataSource);\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Executor",
    "signature": "public Executor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic Executor brokerChannelExecutor(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tChannelRegistration registration = registry.getBrokerChannelRegistration();\n\t\tExecutor executor = getExecutor(registration, \"brokerChannel-\", () -> {\n\t\t\t// Should never be used\n\t\t\tThreadPoolTaskExecutor fallbackExecutor = new ThreadPoolTaskExecutor();\n\t\t\tfallbackExecutor.setCorePoolSize(0);\n\t\t\tfallbackExecutor.setMaxPoolSize(1);\n\t\t\tfallbackExecutor.setQueueCapacity(0);\n\t\t\treturn fallbackExecutor;\n\t\t});\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#fromMap(Map<String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance from a plain {@link Map}.\n\t * @param map the raw headers\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "MessageHeaderAccessor",
    "signature": "public MessageHeaderAccessor fromMap(@Nullable Map<String, Object> map)",
    "source_code": "\tpublic static MessageHeaderAccessor fromMap(@Nullable Map<String, Object> map) {\n\t\treturn fromMessageHeaders(new MessageHeaders(map));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendRedirect(url,sc,clearBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void sendRedirect(String url, int sc, boolean clearBuffer)",
    "source_code": "\tpublic void sendRedirect(String url, int sc, boolean clearBuffer) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot send redirect - response is already committed\");\n\t\tAssert.notNull(url, \"Redirect URL must not be null\");\n\t\tsetHeader(HttpHeaders.LOCATION, url);\n\t\tsetStatus(sc);\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCommit(TransactionSynchronizationManager,status)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Committing R2DBC transaction on Connection [\" +\n\t\t\t\t\ttxObject.getConnectionHolder().getConnection() + \"]\");\n\t\t}\n\t\treturn txObject.commit().onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC commit\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCommit(synchronizationManager,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCommit(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doCommit(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Committing R2DBC transaction on Connection [\" +\n\t\t\t\t\ttxObject.getConnectionHolder().getConnection() + \"]\");\n\t\t}\n\t\treturn txObject.commit().onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC commit\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doRollback(TransactionSynchronizationManager,status)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Rolling back R2DBC transaction on Connection [\" +\n\t\t\t\t\ttxObject.getConnectionHolder().getConnection() + \"]\");\n\t\t}\n\t\treturn txObject.rollback().onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC rollback\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doRollback(synchronizationManager,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doRollback(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doRollback(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Rolling back R2DBC transaction on Connection [\" +\n\t\t\t\t\ttxObject.getConnectionHolder().getConnection() + \"]\");\n\t\t}\n\t\treturn txObject.rollback().onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC rollback\", ex));\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#decorateTask(callable,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "callable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#decorateTask(runnable,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "runnable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}"
  },
  "org.springframework.scheduling.config.<unknown>#TaskExecutionOutcome(executionTime,status,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n *\n * @author Brian Clozel\n * @since 6.2\n * @param executionTime the instant when the task execution started, or\n * {@code null} if the task has not started\n * @param status the {@link Status} of the execution outcome\n * @param throwable the exception thrown from the task execution, if any\n */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executionTime",
      "status",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "return": "record",
    "signature": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable)",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\n\t}\n\n}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "TestBeanOverrideHandler",
    "signature": "public TestBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic TestBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (!(overrideAnnotation instanceof TestBean testBean)) {\n\t\t\tthrow new IllegalStateException(\"Invalid annotation passed to %s: expected @TestBean on field %s.%s\"\n\t\t\t\t\t.formatted(getClass().getSimpleName(), field.getDeclaringClass().getName(), field.getName()));\n\t\t}\n\n\t\tString beanName = (!testBean.name().isBlank() ? testBean.name() : null);\n\t\tString methodName = testBean.methodName();\n\t\tBeanOverrideStrategy strategy = (testBean.enforceOverride() ? REPLACE : REPLACE_OR_CREATE);\n\n\t\tMethod factoryMethod;\n\t\tif (!methodName.isBlank()) {\n\t\t\t// If the user specified an explicit method name, search for that.\n\t\t\tfactoryMethod = findTestBeanFactoryMethod(field.getDeclaringClass(), field.getType(), methodName);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise, search for candidate factory methods whose names match either\n\t\t\t// the field name or the explicit bean name (if any).\n\t\t\tList<String> candidateMethodNames = new ArrayList<>();\n\t\t\tcandidateMethodNames.add(field.getName());\n\n\t\t\tif (beanName != null) {\n\t\t\t\tcandidateMethodNames.add(beanName);\n\t\t\t}\n\t\t\tfactoryMethod = findTestBeanFactoryMethod(field.getDeclaringClass(), field.getType(), candidateMethodNames);\n\t\t}\n\n\t\treturn new TestBeanOverrideHandler(\n\t\t\t\tfield, ResolvableType.forField(field, testClass), beanName, testBean.contextName(), strategy, factoryMethod);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#apply(reset,settings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset",
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "MockSettings",
    "signature": "public MockSettings apply(MockReset reset, MockSettings settings)",
    "source_code": "\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "AbstractMockitoBeanOverrideHandler",
    "signature": "public AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockitoBean) {\n\t\t\tAssert.state(mockitoBean.types().length == 0,\n\t\t\t\t\t\"The @MockitoBean 'types' attribute must be omitted when declared on a field\");\n\t\t\treturn new MockitoBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockitoBean);\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean mockitoSpyBean) {\n\t\t\tAssert.state(mockitoSpyBean.types().length == 0,\n\t\t\t\t\t\"The @MockitoSpyBean 'types' attribute must be omitted when declared on a field\");\n\t\t\treturn new MockitoSpyBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockitoSpyBean);\n\t\t}\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\texpected either @MockitoBean or @MockitoSpyBean on field %s.%s\"\"\"\n\t\t\t\t\t.formatted(field.getDeclaringClass().getName(), field.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createHandlers(overrideAnnotation,testClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "List<BeanOverrideHandler>",
    "signature": "public List<BeanOverrideHandler> createHandlers(Annotation overrideAnnotation, Class<?> testClass)",
    "source_code": "\tpublic List<BeanOverrideHandler> createHandlers(Annotation overrideAnnotation, Class<?> testClass) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockitoBean) {\n\t\t\tClass<?>[] types = mockitoBean.types();\n\t\t\tAssert.state(types.length > 0,\n\t\t\t\t\t\"The @MockitoBean 'types' attribute must not be empty when declared on a class\");\n\t\t\tAssert.state(mockitoBean.name().isEmpty() || types.length == 1,\n\t\t\t\t\t\"The @MockitoBean 'name' attribute cannot be used when mocking multiple types\");\n\t\t\tList<BeanOverrideHandler> handlers = new ArrayList<>();\n\t\t\tfor (Class<?> type : types) {\n\t\t\t\thandlers.add(new MockitoBeanOverrideHandler(ResolvableType.forClass(type), mockitoBean));\n\t\t\t}\n\t\t\treturn handlers;\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean mockitoSpyBean) {\n\t\t\tClass<?>[] types = mockitoSpyBean.types();\n\t\t\tAssert.state(types.length > 0,\n\t\t\t\t\t\"The @MockitoSpyBean 'types' attribute must not be empty when declared on a class\");\n\t\t\tAssert.state(mockitoSpyBean.name().isEmpty() || types.length == 1,\n\t\t\t\t\t\"The @MockitoSpyBean 'name' attribute cannot be used when mocking multiple types\");\n\t\t\tList<BeanOverrideHandler> handlers = new ArrayList<>();\n\t\t\tfor (Class<?> type : types) {\n\t\t\t\thandlers.add(new MockitoSpyBeanOverrideHandler(ResolvableType.forClass(type), mockitoSpyBean));\n\t\t\t}\n\t\t\treturn handlers;\n\t\t}\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\texpected either @MockitoBean or @MockitoSpyBean on test class %s\"\"\"\n\t\t\t\t\t.formatted(testClass.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createOverrideInstance(beanName,existingBeanDefinition,existingBeanInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "existingBeanDefinition",
      "existingBeanInstance"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Object",
    "signature": "protected Object createOverrideInstance(String beanName,\n\t\t\t@Nullable BeanDefinition existingBeanDefinition, @Nullable Object existingBeanInstance)",
    "source_code": "\tprotected Object createOverrideInstance(String beanName,\n\t\t\t@Nullable BeanDefinition existingBeanDefinition, @Nullable Object existingBeanInstance) {\n\n\t\treturn createMock(beanName);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#trackOverrideInstance(mock,trackingBeanRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mock",
      "trackingBeanRegistry"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry)",
    "source_code": "\tprotected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry) {\n\t\tgetMockBeans(trackingBeanRegistry).add(mock);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#loadContextForAotProcessing(mergedConfig,runtimeHints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to an appropriate candidate {@code SmartContextLoader} to load\n\t * an {@link ApplicationContext} for AOT processing.\n\t * <p>Delegation is based on explicit knowledge of the implementations of the\n\t * default loaders. See {@link #loadContext(MergedContextConfiguration)} for\n\t * details.\n\t * @param mergedConfig the merged context configuration to use to load the application context\n\t * @param runtimeHints the runtime hints\n\t * @return a new application context\n\t * @throws IllegalArgumentException if the supplied merged configuration is {@code null}\n\t * @throws IllegalStateException if neither candidate loader is capable of loading an\n\t * {@code ApplicationContext} from the supplied merged context configuration\n\t * @since 6.2.4\n\t * @see AotContextLoader#loadContextForAotProcessing(MergedContextConfiguration, RuntimeHints)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,\n\t\t\tRuntimeHints runtimeHints)",
    "source_code": "\tpublic final ApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,\n\t\t\tRuntimeHints runtimeHints) throws Exception {\n\n\t\tAotContextLoader loader = getAotContextLoader(mergedConfig);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Delegating to %s to load context for AOT processing for %s\"\n\t\t\t\t\t.formatted(name(loader), mergedConfig));\n\t\t}\n\t\treturn loader.loadContextForAotProcessing(mergedConfig, runtimeHints);\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToResourceList(resourceLoader,environment,paths)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to a list of {@link Resource} handles using the given\n\t * {@link ResourceLoader} and {@link Environment}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param environment the {@code Environment} to use to resolve property placeholders\n\t * in the paths\n\t * @param paths the paths to be converted\n\t * @return a new, mutable list of resources\n\t * @since 6.2\n\t * @see #convertToResources(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t * @see Environment#resolveRequiredPlaceholders(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "environment",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "List<Resource>",
    "signature": "public List<Resource> convertToResourceList(ResourceLoader resourceLoader, Environment environment, String... paths)",
    "source_code": "\tpublic static List<Resource> convertToResourceList(\n\t\t\tResourceLoader resourceLoader, Environment environment, String... paths) {\n\n\t\treturn Arrays.stream(paths)\n\t\t\t\t.map(environment::resolveRequiredPlaceholders)\n\t\t\t\t.map(resourceLoader::getResource)\n\t\t\t\t.collect(Collectors.toCollection(ArrayList::new));\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#loadContextForAotProcessing(mergedConfig,runtimeHints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load a {@link GenericWebApplicationContext} for AOT build-time processing based\n\t * on the supplied {@link MergedContextConfiguration}.\n\t * <p>In contrast to {@link #loadContext(MergedContextConfiguration)}, this\n\t * method does not\n\t * {@linkplain org.springframework.context.ConfigurableApplicationContext#refresh()\n\t * refresh} the {@code ApplicationContext} or\n\t * {@linkplain org.springframework.context.ConfigurableApplicationContext#registerShutdownHook()\n\t * register a JVM shutdown hook} for it. Otherwise, this method implements\n\t * behavior identical to {@link #loadContext(MergedContextConfiguration)}.\n\t * @param mergedConfig the merged context configuration to use to load the\n\t * application context\n\t * @param runtimeHints the runtime hints\n\t * @return a new web application context\n\t * @throws Exception if context loading failed\n\t * @since 6.2.4\n\t * @see AotContextLoader#loadContextForAotProcessing(MergedContextConfiguration, RuntimeHints)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "runtimeHints"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "GenericWebApplicationContext",
    "signature": "public GenericWebApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,\n\t\t\tRuntimeHints runtimeHints)",
    "source_code": "\tpublic final GenericWebApplicationContext loadContextForAotProcessing(MergedContextConfiguration mergedConfig,\n\t\t\tRuntimeHints runtimeHints) throws Exception {\n\n\t\treturn loadContext(mergedConfig, true);\n\t}"
  },
  "org.springframework.test.http.<unknown>#convert(message,mediaType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given {@link HttpInputMessage} whose content must match the\n\t * given {@link MediaType} to the requested {@code targetType}.\n\t * @param message an input message\n\t * @param mediaType the media type of the input\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "mediaType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "T",
    "signature": "public T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)",
    "source_code": "\tpublic <T> T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\t\tClass<?> contextClass = targetType.getRawClass();\n\t\tSingletonSupplier<Type> javaType = SingletonSupplier.of(targetType::getType);\n\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\tif (messageConverter instanceof GenericHttpMessageConverter<?> genericMessageConverter) {\n\t\t\t\tType type = javaType.obtain();\n\t\t\t\tif (genericMessageConverter.canRead(type, contextClass, mediaType)) {\n\t\t\t\t\treturn (T) genericMessageConverter.read(type, contextClass, message);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (messageConverter instanceof SmartHttpMessageConverter<?> smartMessageConverter) {\n\t\t\t\tif (smartMessageConverter.canRead(targetType, mediaType)) {\n\t\t\t\t\treturn (T) smartMessageConverter.read(targetType, message, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> targetClass = (contextClass != null ? contextClass : Object.class);\n\t\t\t\tif (messageConverter.canRead(targetClass, mediaType)) {\n\t\t\t\t\tHttpMessageConverter<T> simpleMessageConverter = (HttpMessageConverter<T>) messageConverter;\n\t\t\t\t\tClass<? extends T> clazz = (Class<? extends T>) targetClass;\n\t\t\t\t\treturn simpleMessageConverter.read(clazz, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"No converter found to read [%s] to [%s]\".formatted(mediaType, targetType));\n\t}"
  },
  "org.springframework.test.http.<unknown>#convertViaJson(value,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given raw value to the given {@code targetType} by writing\n\t * it first to JSON and reading it back.\n\t * @param value the value to convert\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "T",
    "signature": "public T convertViaJson(Object value, ResolvableType targetType)",
    "source_code": "\tpublic <T> T convertViaJson(Object value, ResolvableType targetType) throws IOException {\n\t\tMockHttpOutputMessage outputMessage = convertToJson(value, ResolvableType.forInstance(value));\n\t\treturn convert(fromHttpOutputMessage(outputMessage), JSON, targetType);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateJsonPath(content,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type that has\n\t * generics.\n\t * <p>This must be used with a {@link Configuration} that defines a more\n\t * elaborate {@link MappingProvider} as the default one cannot handle\n\t * generic types.\n\t * @param content the content to evaluate against\n\t * @param targetType the requested target type\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "T",
    "signature": "public T evaluateJsonPath(String content, ParameterizedTypeReference<T> targetType)",
    "source_code": "\tpublic <T> T evaluateJsonPath(String content, ParameterizedTypeReference<T> targetType) {\n\t\treturn evaluateExpression(content, context ->\n\t\t\t\tcontext.read(this.expression, new TypeRefAdapter<>(targetType)));\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,comparator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@link JsonComparator}. If the comparison failed, throws an\n\t * {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use this matcher if you require a custom JSONAssert configuration or\n\t * if you desire to use another assertion library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param comparator the comparator to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonComparator comparator)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonComparator comparator) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tcomparator.assertIsMatch(expectedJsonContent, mockRequest.getBodyAsString());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,compareMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@linkplain JsonCompareMode mode}. If the comparison failed,\n\t * throws an {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param compareMode the compare mode\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode) {\n\t\treturn json(expectedJsonContent, JsonAssert.comparator(compareMode));\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartData(MultiValueMap<String,expectedMap,defaultCharset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} with a defaultCharset.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap",
      "defaultCharset"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset) {\n\t\treturn multipartData(expectedMap, defaultCharset, true);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#from(applicationContext,Function<DefaultMockMvcBuilder,customizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext",
      "Function<DefaultMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations) {\n\n\t\tDefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(applicationContext);\n\t\tMockMvc mockMvc = customizations.apply(builder);\n\t\treturn create(mockMvc);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#isInvokedOn(controllerType,Function<T,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "Function<T",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#of(controllers,Function<StandaloneMockMvcBuilder,customizations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by registering one or more {@code @Controller} instances\n\t * and configuring Spring MVC infrastructure programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers",
      "Function<StandaloneMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations) {\n\n\t\tStandaloneMockMvcBuilder builder = MockMvcBuilders.standaloneSetup(controllers.toArray());\n\t\treturn create(customizations.apply(builder));\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#file(name,content)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new {@link MockMultipartFile} with the given content.\n\t * @param name the name of the file\n\t * @param content the content of the file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "B",
    "signature": "public B file(String name, byte[] content)",
    "source_code": "\tpublic B file(String name, byte[] content) {\n\t\tthis.files.add(new MockMultipartFile(name, content));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttr(name,value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "B",
    "signature": "public B flashAttr(String name, Object value)",
    "source_code": "\tpublic B flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttrs(Map<String,flashAttributes)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "B",
    "signature": "public B flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic B flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#formField(name,values)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "B",
    "signature": "public B formField(String name, String... values)",
    "source_code": "\tpublic B formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#formFields(MultiValueMap<String,formFields)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formField(String, String...)} with a {@link MultiValueMap}.\n\t * @param formFields the form fields to add\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formFields"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "B",
    "signature": "public B formFields(MultiValueMap<String, String> formFields)",
    "source_code": "\tpublic B formFields(MultiValueMap<String, String> formFields) {\n\t\tparams(formFields);\n\t\tthis.formFields.addAll(formFields);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#header(name,values)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "B",
    "signature": "public B header(String name, Object... values)",
    "source_code": "\tpublic B header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#param(name,values)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "B",
    "signature": "public B param(String name, String... values)",
    "source_code": "\tpublic B param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#params(MultiValueMap<String,params)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "B",
    "signature": "public B params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParam(name,values)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "B",
    "signature": "public B queryParam(String name, String... values)",
    "source_code": "\tpublic B queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParams(MultiValueMap<String,params)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "B",
    "signature": "public B queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#requestAttr(name,value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "B",
    "signature": "public B requestAttr(String name, Object value)",
    "source_code": "\tpublic B requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttr(name,value)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "B",
    "signature": "public B sessionAttr(String name, Object value)",
    "source_code": "\tpublic B sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttrs(Map<String,sessionAttributes)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "B",
    "signature": "public B sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic B sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI for the request using a URI template and URI variables.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "B",
    "signature": "public B uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic B uri(String uriTemplate, Object... uriVariables) {\n\t\treturn updateUri(initUri(uriTemplate, uriVariables), uriTemplate);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addMappedInterceptors(pathPatterns,interceptors)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors) {\n\n\t\tfor (HandlerInterceptor interceptor : interceptors) {\n\t\t\tthis.mappedInterceptors.add(new MappedInterceptor(pathPatterns, null, interceptor));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#doFilter(request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tString requestPath = UrlPathHelper.defaultInstance.getPathWithinApplication(httpRequest);\n\n\t\tif (matchDispatcherType(httpRequest.getDispatcherType()) && matchRequestPath(requestPath)) {\n\t\t\tthis.delegate.doFilter(request, response, filterChain);\n\t\t}\n\t\telse {\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getHandlerMapping(mvcConversionService,mvcResourceUrlProvider)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mvcConversionService",
      "mvcResourceUrlProvider"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "RouterFunctionMapping",
    "signature": "public RouterFunctionMapping getHandlerMapping(FormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider)",
    "source_code": "\t\tpublic RouterFunctionMapping getHandlerMapping(\n\t\t\t\tFormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider) {\n\n\t\t\tRouterFunctionMapping handlerMapping = handlerMappingFactory.get();\n\t\t\thandlerMapping.setOrder(0);\n\t\t\thandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\t\t\thandlerMapping.setMessageConverters(getMessageConverters());\n\t\t\tif (patternParser != null) {\n\t\t\t\thandlerMapping.setPatternParser(patternParser);\n\t\t\t}\n\t\t\treturn handlerMapping;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveViewName(viewName,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 613
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) {\n\t\t\treturn this.view;\n\t\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#determineTransactionManager(txAttr,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t * @param txAttr the current transaction attribute\n\t * @param targetClass the target class that the attribute has been declared on\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txAttr",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionManager determineTransactionManager(\n\t\t\t@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass) {\n\n\t\tTransactionManager tm = determineTransactionManager(txAttr);\n\t\tif (tm != null) {\n\t\t\treturn tm;\n\t\t}\n\n\t\t// Do not attempt to lookup tx manager if no tx attributes are set\n\t\tif (txAttr == null || this.beanFactory == null) {\n\t\t\treturn getTransactionManager();\n\t\t}\n\n\t\tString qualifier = txAttr.getQualifier();\n\t\tif (StringUtils.hasText(qualifier)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, qualifier);\n\t\t}\n\t\telse if (targetClass != null) {\n\t\t\t// Consider type-level qualifier annotations for transaction manager selection\n\t\t\tString typeQualifier = BeanFactoryAnnotationUtils.getQualifierValue(targetClass);\n\t\t\tif (StringUtils.hasText(typeQualifier)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, typeQualifier);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t// Consider type qualifier as optional, proceed with regular resolution below.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StringUtils.hasText(this.transactionManagerBeanName)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);\n\t\t}\n\t\telse {\n\t\t\tTransactionManager defaultTransactionManager = getTransactionManager();\n\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\tdefaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);\n\t\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\t\tdefaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);\n\t\t\t\t\tthis.transactionManagerCache.putIfAbsent(\n\t\t\t\t\t\t\tDEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn defaultTransactionManager;\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#hasTransactionAttribute(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (getTransactionAttribute(method, targetClass, false) != null);\n\t}"
  },
  "org.springframework.util.<unknown>#compositeMap(Map<K,first,Map<K,second)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second) {\n\t\treturn new CompositeMap<>(first, second);\n\t}"
  },
  "org.springframework.util.<unknown>#compositeMap(Map<K,first,Map<K,second,BiFunction<K,V,putFunction,Consumer<Map<K,putAllFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second",
      "BiFunction<K",
      "V",
      "putFunction",
      "Consumer<Map<K",
      "putAllFunction"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction) {\n\n\t\treturn new CompositeMap<>(first, second, putFunction, putAllFunction);\n\t}"
  },
  "org.springframework.util.<unknown>#handleUnresolvablePlaceholder(key,text)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "text"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "String",
    "signature": "public String handleUnresolvablePlaceholder(String key, String text)",
    "source_code": "\t\tpublic String handleUnresolvablePlaceholder(String key, String text) {\n\t\t\tif (this.ignoreUnresolvablePlaceholders) {\n\t\t\t\treturn toPlaceholderText(key);\n\t\t\t}\n\t\t\tString originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\n\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#put(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "List<V>",
    "signature": "public List<V> put(K key, List<V> values)",
    "source_code": "\tpublic List<V> put(K key, List<V> values) {\n\t\tif (values.isEmpty()) {\n\t\t\tV result = this.targetMap.put(key, null);\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse if (values.size() == 1) {\n\t\t\tV result = this.targetMap.put(key, values.get(0));\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse {\n\t\t\tthrow new UnsupportedOperationException(\"Duplicate key: \" + key);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends V> map)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends V> map) {\n\t\tfor (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#replacePlaceholders(value,placeholderResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "placeholderResolver"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver)",
    "source_code": "\tpublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\tParsedValue parsedValue = parse(value);\n\t\tPartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver,\n\t\t\t\tthis.prefix, this.suffix, this.ignoreUnresolvablePlaceholders,\n\t\t\t\tcandidate -> parse(candidate, false));\n\t\treturn parsedValue.resolve(resolutionContext);\n\t}"
  },
  "org.springframework.util.<unknown>#resolveRecursively(resolutionContext,key)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Resolve the placeholder with the given {@code key}. If the result of such\n\t\t * resolution return other placeholders, those are resolved as well until the\n\t\t * resolution no longer contains any placeholders.\n\t\t * @param resolutionContext the resolution context to use\n\t\t * @param key the initial placeholder\n\t\t * @return the full resolution of the given {@code key} or {@code null} if\n\t\t * the placeholder has no value to begin with\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolutionContext",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "String",
    "signature": "protected String resolveRecursively(PartResolutionContext resolutionContext, String key)",
    "source_code": "\t\tprotected String resolveRecursively(PartResolutionContext resolutionContext, String key) {\n\t\t\tString resolvedValue = resolutionContext.resolvePlaceholder(key);\n\t\t\tif (resolvedValue != null) {\n\t\t\t\tresolutionContext.flagPlaceholderAsVisited(key);\n\t\t\t\t// Let's check if we need to recursively resolve that value\n\t\t\t\tList<Part> nestedParts = resolutionContext.parse(resolvedValue);\n\t\t\t\tString value = toText(nestedParts);\n\t\t\t\tif (!isTextOnly(nestedParts)) {\n\t\t\t\t\tvalue = new ParsedValue(resolvedValue, nestedParts).resolve(resolutionContext);\n\t\t\t\t}\n\t\t\t\tresolutionContext.removePlaceholder(key);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t// Not found\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.validation.method.<unknown>#unwrap(error,sourceType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error",
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "T",
    "signature": "public T unwrap(MessageSourceResolvable error, Class<T> sourceType)",
    "source_code": "\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tgetAttributes().put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(getAttributes());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#cookie(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#exchangeForRequiredValue(exchangeFunction,close)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction",
      "close"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "T",
    "signature": "public T exchangeForRequiredValue(RequiredValueExchangeFunction<T> exchangeFunction, boolean close)",
    "source_code": "\t\tpublic <T> T exchangeForRequiredValue(RequiredValueExchangeFunction<T> exchangeFunction, boolean close) {\n\t\t\tT value = exchangeInternal(exchangeFunction, close);\n\t\t\tAssert.state(value != null, \"The exchanged value must not be null\");\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#handleError(response,statusCode,url,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the error based on the resolved status code.\n\t * <p>The default implementation delegates to\n\t * {@link HttpClientErrorException#create} for errors in the 4xx range, to\n\t * {@link HttpServerErrorException#create} for errors in the 5xx range,\n\t * or otherwise raises {@link UnknownHttpStatusCodeException}.\n\t * @since 6.2\n\t * @see HttpClientErrorException#create\n\t * @see HttpServerErrorException#create\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "statusCode",
      "url",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "protected void handleError(ClientHttpResponse response, HttpStatusCode statusCode,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method)",
    "source_code": "\tprotected void handleError(\n\t\t\tClientHttpResponse response, HttpStatusCode statusCode,\n\t\t\t@Nullable URI url, @Nullable HttpMethod method) throws IOException {\n\n\t\tString statusText = response.getStatusText();\n\t\tHttpHeaders headers = response.getHeaders();\n\t\tbyte[] body = getResponseBody(response);\n\t\tCharset charset = getCharset(response);\n\t\tString message = getErrorMessage(statusCode.value(), statusText, body, charset, url, method);\n\n\t\tRestClientResponseException ex;\n\t\tif (statusCode.is4xxClientError()) {\n\t\t\tex = HttpClientErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse if (statusCode.is5xxServerError()) {\n\t\t\tex = HttpServerErrorException.create(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\tex = new UnknownHttpStatusCodeException(message, statusCode.value(), statusText, headers, body, charset);\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.messageConverters)) {\n\t\t\tex.setBodyConvertFunction(initBodyConvertFunction(response, body));\n\t\t}\n\n\t\tthrow ex;\n\t}"
  },
  "org.springframework.web.client.<unknown>#handleError(url,method,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the error in the given response with the given resolved status code\n\t * and extra information providing access to the request URL and HTTP method.\n\t * <p>The default implementation throws:\n\t * <ul>\n\t * <li>{@link HttpClientErrorException} if the status code is in the 4xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpClientErrorException.BadRequest} and others.\n\t * <li>{@link HttpServerErrorException} if the status code is in the 5xx\n\t * series, or one of its sub-classes such as\n\t * {@link HttpServerErrorException.InternalServerError} and others.\n\t * <li>{@link UnknownHttpStatusCodeException} for error status codes not in the\n\t * {@link HttpStatus} enum range.\n\t * </ul>\n\t * @throws UnknownHttpStatusCodeException in case of an unresolvable status code\n\t * @since 6.2\n\t * @see #handleError(ClientHttpResponse, HttpStatusCode, URI, HttpMethod)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void handleError(URI url, HttpMethod method, ClientHttpResponse response)",
    "source_code": "\tpublic void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\n\t\t// For backwards compatibility try handle(response) first\n\t\tHandleErrorResponseDecorator decorator = new HandleErrorResponseDecorator(response);\n\t\thandleError(decorator);\n\t\tif (decorator.isHandled()) {\n\t\t\treturn;\n\t\t}\n\n\t\thandleError(response, response.getStatusCode(), url, method);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#compare(o1,o2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "int",
    "signature": "public int compare(ExceptionMapping o1, ExceptionMapping o2)",
    "source_code": "\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#getDetailMessageArguments(messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] { BindErrorUtils.resolveAndJoin(getAllErrors(), messageSource, locale) };\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveExceptionMapping(exception,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveExceptionMappingByExceptionType(exceptionType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (for example, for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#createBinderInstance(target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param name the binding target object name\n\t * @return the created {@link WebExchangeDataBinder} instance\n\t * @since 6.2.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder createBinderInstance(@Nullable Object target, String name)",
    "source_code": "\tprotected WebExchangeDataBinder createBinderInstance(@Nullable Object target, String name) {\n\t\treturn new WebExchangeDataBinder(target, name);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromValue(body,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object, ParameterizedTypeReference)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param bodyType the type of the body, used to capture the generic type\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, ParameterizedTypeReference)} or\n\t * {@link #fromProducer(Object, ParameterizedTypeReference)} should be used.\n\t * @since 6.2\n\t * @see #fromPublisher(Publisher, ParameterizedTypeReference)\n\t * @see #fromProducer(Object, ParameterizedTypeReference)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.notNull(bodyType, \"'bodyType' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forType(bodyType), null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#context(Function<Context,contextModifier)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Context",
      "contextModifier"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec context(Function<Context, Context> contextModifier)",
    "source_code": "\t\tpublic RequestBodySpec context(Function<Context, Context> contextModifier) {\n\t\t\tthis.contextModifier = (this.contextModifier != null ?\n\t\t\t\t\tthis.contextModifier.andThen(contextModifier) : contextModifier);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookie(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToFlux(Function<ClientResponse,responseHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "Flux<V>",
    "signature": "public Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler) {\n\t\t\treturn exchange().flatMapMany(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.concatWith(Flux.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#exchangeToMono(Function<ClientResponse,responseHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ClientResponse",
      "responseHandler"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Mono<V>",
    "signature": "public Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler)",
    "source_code": "\t\tpublic <V> Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler) {\n\t\t\treturn exchange().flatMap(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.flatMap(value -> releaseIfNotConsumed(response).thenReturn(value))\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#filter(request,next)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "Mono<ClientResponse>",
    "signature": "public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next)",
    "source_code": "\t\tpublic Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {\n\t\t\tMono<ClientResponse> exchange = next.exchange(request);\n\t\t\tif (this.observationContext instanceof ClientRequestObservationContext clientContext) {\n\t\t\t\texchange = exchange.doOnNext(clientContext::setResponse);\n\t\t\t}\n\t\t\treturn exchange;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onRawStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onRawStatus(IntPredicate statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onRawStatus(IntPredicate statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\treturn onStatus(toStatusCodePredicate(statusCodePredicate), exceptionFunction);\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#onStatus(statusCodePredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCodePredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\tAssert.notNull(statusCodePredicate, \"StatusCodePredicate must not be null\");\n\t\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\t\t\tint index = this.statusHandlers.size() - this.defaultStatusHandlerCount;  // Default handlers always last\n\t\t\tthis.statusHandlers.add(index, new StatusHandler(statusCodePredicate, exceptionFunction));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#toEntityFlux(BodyExtractor<Flux<T>,bodyExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<Flux<T>",
      "bodyExtractor"
    ],
    "position": {
      "column": 1,
      "line": 648
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor)",
    "source_code": "\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.body(bodyExtractor)));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriFunction.apply(uriBuilder));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bodyValue(body,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\treturn initBuilder(body, BodyInserters.fromValue(body, bodyType));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#checkResource(resource,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#createRelativeResource(location,resourcePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a resource relative to the given {@link Resource}, also decoding\n\t * the resource path for a {@link UrlResource}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resourcePath"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Resource",
    "signature": "public Resource createRelativeResource(Resource location, String resourcePath)",
    "source_code": "\tpublic static Resource createRelativeResource(Resource location, String resourcePath) throws IOException {\n\t\tif (!(location instanceof UrlResource)) {\n\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t}\n\t\treturn location.createRelative(resourcePath);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getResource(resourcePath,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tif (!(location instanceof UrlResource)) {\n\t\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\tResource resource = location.createRelative(resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#isResourceUnderLocation(location,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the resource is under the given location.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "boolean",
    "signature": "public boolean isResourceUnderLocation(Resource location, Resource resource)",
    "source_code": "\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(path,locations,chain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#format(fragmentFlux,fragment,hints,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragmentFlux",
      "fragment",
      "hints",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 570
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> format(Flux<DataBuffer> fragmentFlux, Fragment fragment, @Nullable Object hints,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic Flux<DataBuffer> format(\n\t\t\t\tFlux<DataBuffer> fragmentFlux, Fragment fragment, @Nullable Object hints,\n\t\t\t\tServerWebExchange exchange) {\n\n\t\t\tMediaType mediaType = exchange.getResponse().getHeaders().getContentType();\n\t\t\tCharset charset = (mediaType != null && mediaType.getCharset() != null ?\n\t\t\t\t\tmediaType.getCharset() : StandardCharsets.UTF_8);\n\t\t\tAssert.state(hints == null || hints instanceof ServerSentEvent, \"Expected ServerSentEvent\");\n\n\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\n\t\t\tServerSentEvent<?> sse = (ServerSentEvent<?>) hints;\n\t\t\tCharSequence eventText = (sse != null ? sse.format() :\n\t\t\t\t\t(fragment.viewName() != null ? \"event:\" + fragment.viewName() + \"\\n\" : \"\") + \"data:\");\n\n\t\t\tDataBuffer prefix = encodeText(eventText.toString(), charset, bufferFactory);\n\t\t\tDataBuffer suffix = encodeText(\"\\n\\n\", charset, bufferFactory);\n\n\t\t\tMono<DataBuffer> content = DataBufferUtils.join(fragmentFlux)\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tString text;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttext = buffer.toString(charset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext = text.replace(\"\\n\", \"\\ndata:\");\n\t\t\t\t\t\treturn bufferFactory.wrap(text.getBytes(charset));\n\t\t\t\t\t});\n\n\t\t\treturn Flux.concat(Flux.just(prefix), content, Flux.just(suffix));\n\t\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#addUrlTransformer(Function<String,transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "public void addUrlTransformer(Function<String, String> transformer)",
    "source_code": "\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#checkNotModified(eTag,lastModified)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eTag",
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String eTag, Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#httpHandlerDecorator(Function<HttpHandler,handlerDecorator)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a {@link Function} to decorate the {@link HttpHandler} returned\n\t * by this builder which effectively wraps the entire\n\t * {@link WebExceptionHandler} - {@link WebFilter} - {@link WebHandler}\n\t * processing chain. This provides access to the request and response before\n\t * the entire chain and likewise the ability to observe the result of\n\t * the entire chain.\n\t * @param handlerDecorator the decorator to apply\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpHandler",
      "handlerDecorator"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "WebHttpHandlerBuilder",
    "signature": "public WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator)",
    "source_code": "\tpublic WebHttpHandlerBuilder httpHandlerDecorator(Function<HttpHandler, HttpHandler> handlerDecorator) {\n\t\tthis.httpHandlerDecorator = (this.httpHandlerDecorator != null ?\n\t\t\t\thandlerDecorator.andThen(this.httpHandlerDecorator) : handlerDecorator);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#createNamedValueInfo(parameter,metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #createNamedValueInfo(MethodParameter)} that also provides\n\t * access to the static values set from {@code @HttpExchange} attributes.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter, HttpRequestValues.Metadata metadata)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(\n\t\t\tMethodParameter parameter, HttpRequestValues.Metadata metadata) {\n\n\t\treturn createNamedValueInfo(parameter);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "AsyncServerResponse",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendRedirect(location,sc,clearBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void sendRedirect(String location, int sc, boolean clearBuffer)",
    "source_code": "\t\tpublic void sendRedirect(String location, int sc, boolean clearBuffer) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#write(object,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "StreamBuilder",
    "signature": "public StreamBuilder write(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic StreamBuilder write(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\t\tAssert.notNull(object, \"data must not be null\");\n\t\t\ttry {\n\t\t\t\tif (object instanceof byte[] bytes) {\n\t\t\t\t\tthis.outputMessage.getBody().write(bytes);\n\t\t\t\t}\n\t\t\t\telse if (object instanceof String str) {\n\t\t\t\t\tthis.outputMessage.getBody().write(str.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteObject(object, mediaType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.sendFailed = true;\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeTo(request,response,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tpublic ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)\n\t\t\tthrows ServletException, IOException {\n\n\t\twriteAsync(request, response, createDeferredResult(request));\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handlePreFlight(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "void",
    "signature": "public void handlePreFlight(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handlePreFlight(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tinvokeCorsProcessor(request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#invokeCorsProcessor(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "boolean",
    "signature": "protected boolean invokeCorsProcessor(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tprotected boolean invokeCorsProcessor(\n\t\t\t\tHttpServletRequest request, HttpServletResponse response) throws IOException {\n\n\t\t\treturn corsProcessor.processRequest(this.config, request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPath,handler)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void registerHandler(String urlPath, Object handler)",
    "source_code": "\tpublic void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\t\tif (applicationContext.isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = applicationContext.getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\tif (mappedHandler != null) {\n\t\t\tif (mappedHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to URL path [\" + urlPath +\n\t\t\t\t\t\t\t\t\"]: There is already \" + getHandlerDescription(mappedHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (urlPath.equals(\"/\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Root mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetRootHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Default mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetDefaultHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handlerMap.put(urlPath, resolvedHandler);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tpublic void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#addBindValues(mpvs,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge URI variables into the property values to use for data binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "protected void addBindValues(MutablePropertyValues mpvs, ServletRequest request)",
    "source_code": "\tprotected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n\t\tMap<String, String> uriVars = getUriVars(request);\n\t\tif (uriVars != null) {\n\t\t\turiVars.forEach((name, value) -> addValueIfNotPresent(mpvs, \"URI variable\", name, value));\n\t\t}\n\t\tif (request instanceof HttpServletRequest httpRequest) {\n\t\t\tEnumeration<String> names = httpRequest.getHeaderNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tObject value = getHeaderValue(httpRequest, name);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tname = normalizeHeaderName(name);\n\t\t\t\t\taddValueIfNotPresent(mpvs, \"Header\", name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod(\n\t\t\t@Nullable HandlerMethod handlerMethod, Exception exception) {\n\n\t\tClass<?> handlerType = null;\n\n\t\tif (handlerMethod != null) {\n\t\t\t// Local exception handler methods on the controller class itself.\n\t\t\t// To be invoked through the proxy, even in case of an interface-based proxy.\n\t\t\thandlerType = handlerMethod.getBeanType();\n\t\t\tExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.computeIfAbsent(\n\t\t\t\t\thandlerType, ExceptionHandlerMethodResolver::new);\n\t\t\tMethod method = resolver.resolveMethod(exception);\n\t\t\tif (method != null) {\n\t\t\t\treturn new ServletInvocableHandlerMethod(handlerMethod.getBean(), method, this.applicationContext);\n\t\t\t}\n\t\t\t// For advice applicability check below (involving base packages, assignable types\n\t\t\t// and annotation presence), use target class instead of interface-based proxy.\n\t\t\tif (Proxy.isProxyClass(handlerType)) {\n\t\t\t\thandlerType = AopUtils.getTargetClass(handlerMethod.getBean());\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tControllerAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(handlerType)) {\n\t\t\t\tExceptionHandlerMethodResolver resolver = entry.getValue();\n\t\t\t\tMethod method = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new ServletInvocableHandlerMethod(advice.resolveBean(), method, this.applicationContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @param webRequest the original web request that resulted in a handler error\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception, ServletWebRequest webRequest)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod(\n\t\t\t@Nullable HandlerMethod handlerMethod, Exception exception, ServletWebRequest webRequest) {\n\n\t\tList<MediaType> acceptedMediaTypes = List.of(MediaType.ALL);\n\t\ttry {\n\t\t\tacceptedMediaTypes = this.contentNegotiationManager.resolveMediaTypes(webRequest);\n\t\t}\n\t\tcatch (HttpMediaTypeNotAcceptableException mediaTypeExc) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not resolve accepted media types for @ExceptionHandler [\" + webRequest.getHeader(HttpHeaders.ACCEPT) + \"]\", mediaTypeExc);\n\t\t\t}\n\t\t}\n\n\t\tClass<?> handlerType = null;\n\n\t\tif (handlerMethod != null) {\n\t\t\t// Local exception handler methods on the controller class itself.\n\t\t\t// To be invoked through the proxy, even in case of an interface-based proxy.\n\t\t\thandlerType = handlerMethod.getBeanType();\n\t\t\tExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.computeIfAbsent(\n\t\t\t\t\thandlerType, ExceptionHandlerMethodResolver::new);\n\n\t\t\tfor (MediaType mediaType : acceptedMediaTypes) {\n\t\t\t\tExceptionHandlerMappingInfo mappingInfo = resolver.resolveExceptionMapping(exception, mediaType);\n\t\t\t\tif (mappingInfo != null) {\n\t\t\t\t\tif (!mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\t\twebRequest.setAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mappingInfo.getProducibleTypes(), RequestAttributes.SCOPE_REQUEST);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ServletInvocableHandlerMethod(handlerMethod.getBean(), mappingInfo.getHandlerMethod(), this.applicationContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// For advice applicability check below (involving base packages, assignable types\n\t\t\t// and annotation presence), use target class instead of interface-based proxy.\n\t\t\tif (Proxy.isProxyClass(handlerType)) {\n\t\t\t\thandlerType = AopUtils.getTargetClass(handlerMethod.getBean());\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tControllerAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(handlerType)) {\n\t\t\t\tExceptionHandlerMethodResolver resolver = entry.getValue();\n\t\t\t\tfor (MediaType mediaType : acceptedMediaTypes) {\n\t\t\t\t\tExceptionHandlerMappingInfo mappingInfo = resolver.resolveExceptionMapping(exception, mediaType);\n\t\t\t\t\tif (mappingInfo != null) {\n\t\t\t\t\t\tif (!mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\t\t\twebRequest.setAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mappingInfo.getProducibleTypes(), RequestAttributes.SCOPE_REQUEST);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new ServletInvocableHandlerMethod(advice.resolveBean(), mappingInfo.getHandlerMethod(), this.applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getRequestParameter(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Object",
    "signature": "protected Object getRequestParameter(String name, Class<?> type)",
    "source_code": "\t\tprotected Object getRequestParameter(String name, Class<?> type) {\n\t\t\tObject value = super.getRequestParameter(name, type);\n\t\t\tif (value == null) {\n\t\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\t\tif (uriVars != null) {\n\t\t\t\t\tvalue = uriVars.get(name);\n\t\t\t\t}\n\t\t\t\tif (value == null && getRequest() instanceof HttpServletRequest httpServletRequest) {\n\t\t\t\t\tvalue = getHeaderValue(httpServletRequest, name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleAsyncRequestNotUsableException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link AsyncRequestNotUsableException}.\n\t * <p>By default, return {@code null} since the response is not usable.\n\t * @param ex the exception to handle\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleAsyncRequestNotUsableException(AsyncRequestNotUsableException ex, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleAsyncRequestNotUsableException(\n\t\t\tAsyncRequestNotUsableException ex, WebRequest request) {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleBindException(ex,headers,status,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link BindException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and then delegates to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleBindException(BindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleBindException(\n\t\t\tBindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tProblemDetail body = ProblemDetail.forStatusAndDetail(status, \"Failed to bind request\");\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeErrorResponseInterceptors(detail,errorResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the configured {@link ErrorResponse.Interceptor}'s.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "detail",
      "errorResponse"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "protected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse)",
    "source_code": "\tprotected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse) {\n\t\ttry {\n\t\t\tfor (ErrorResponse.Interceptor handler : this.errorResponseInterceptors) {\n\t\t\t\thandler.handleError(detail, errorResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveViewName(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) throws Exception {\n\t\t\tfor (ViewResolver resolver : this.viewResolvers) {\n\t\t\t\tView view = resolver.resolveViewName(viewName, locale);\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn view;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#write(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int len)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int len) {\n\t\t\tthis.outputStream.write(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleBindException(ex,request,response,handler)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleDisconnectedClientException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle an Exception that indicates the client has gone away. This is\n\t * typically an {@link IOException} of a specific subtype or with a message\n\t * specific to the underlying Servlet container. Those are detected through\n\t * {@link DisconnectedClientHelper#isClientDisconnectedException(Throwable)}\n\t * <p>By default, do nothing since the response is not usable.\n\t * @param ex the {@code Exception} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty ModelAndView indicating the exception was handled\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleDisconnectedClientException(Exception ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleDisconnectedClientException(\n\t\t\tException ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) {\n\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#checkResource(resource,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resource exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@linkplain #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getResource(resourcePath,location)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#isResourceUnderLocation(location,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the resource is under the given location.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "boolean",
    "signature": "public boolean isResourceUnderLocation(Resource location, Resource resource)",
    "source_code": "\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse if (resource instanceof ServletContextResource servletContextResource) {\n\t\t\tresourcePath = servletContextResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ServletContextResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourcePath,locations,chain)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\treturn (StringUtils.hasText(resourcePath) &&\n\t\t\t\tgetResource(resourcePath, null, locations) != null ? resourcePath : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setLocationCharsets(Map<Resource,locationCharsets)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.view.freemarker.<unknown>#loadView(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@code super.loadView(viewName, locale)} for standard behavior\n\t * and then to {@link #postProcessView(FreeMarkerView)} for customization.\n\t * @since 6.2\n\t * @see org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(String, Locale)\n\t * @see #postProcessView(FreeMarkerView)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "View",
    "signature": "protected View loadView(String viewName, Locale locale)",
    "source_code": "\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tView view = super.loadView(viewName, locale);\n\t\tif (view instanceof FreeMarkerView freeMarkerView) {\n\t\t\tpostProcessView(freeMarkerView);\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.util.<unknown>#fromUriString(uri,parserType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder that is initialized by parsing the given URI string.\n\t * <p><strong>Note:</strong> The presence of reserved characters can prevent\n\t * correct parsing of the URI string. For example if a query parameter\n\t * contains {@code '='} or {@code '&'} characters, the query string cannot\n\t * be parsed unambiguously. Such values should be substituted for URI\n\t * variables to enable correct parsing:\n\t * <pre class=\"code\">\n\t * String uriString = &quot;/hotels/42?filter={value}&quot;;\n\t * UriComponentsBuilder.fromUriString(uriString).buildAndExpand(&quot;hot&amp;cold&quot;);\n\t * </pre>\n\t * @param uri the URI string to initialize with\n\t * @param parserType the parsing algorithm to use\n\t * @return the new {@code UriComponentsBuilder}\n\t * @throws InvalidUrlException if {@code uri} cannot be parsed\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "parserType"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromUriString(String uri, ParserType parserType)",
    "source_code": "\tpublic static UriComponentsBuilder fromUriString(String uri, ParserType parserType) throws InvalidUrlException {\n\t\tAssert.notNull(uri, \"URI must not be null\");\n\t\tif (uri.isEmpty()) {\n\t\t\treturn new UriComponentsBuilder();\n\t\t}\n\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\treturn switch (parserType) {\n\t\t\tcase RFC -> {\n\t\t\t\tRfcUriParser.UriRecord record = RfcUriParser.parse(uri);\n\t\t\t\tyield builder.rfcUriRecord(record);\n\t\t\t}\n\t\t\tcase WHAT_WG -> {\n\t\t\t\tWhatWgUrlParser.UrlRecord record =\n\t\t\t\t\t\tWhatWgUrlParser.parse(uri, WhatWgUrlParser.EMPTY_RECORD, null, null);\n\t\t\t\tyield builder.whatWgUrlRecord(record);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.web.util.<unknown>#handle(c,url,p)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "c",
      "url",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 1712
    },
    "return": "void",
    "signature": "public void handle(int c, UrlRecord url, WhatWgUrlParser p)",
    "source_code": "\t\tpublic abstract void handle(int c, UrlRecord url, WhatWgUrlParser p);"
  },
  "org.springframework.web.util.<unknown>#parse(input,base,encoding,validationErrorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given input into a URL record.\n\t * @param input the scalar value string\n\t * @param base the optional base URL to resolve relative URLs against. If\n\t * {@code null}, relative URLs cannot be parsed.\n\t * @param encoding the optional encoding to use. If {@code null}, no\n\t * encoding is performed.\n\t * @param validationErrorHandler optional consumer for non-fatal URL\n\t * validation messages\n\t * @return a URL record, as defined in the\n\t * <a href=\"https://url.spec.whatwg.org/#concept-url\">living URL\n\t * specification</a>\n\t * @throws InvalidUrlException if the {@code input} does not contain a\n\t * parsable URL\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "base",
      "encoding",
      "validationErrorHandler"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "UrlRecord",
    "signature": "public UrlRecord parse(String input, @Nullable UrlRecord base,\n\t\t\t@Nullable Charset encoding, @Nullable Consumer<String> validationErrorHandler)",
    "source_code": "\tpublic static UrlRecord parse(String input, @Nullable UrlRecord base,\n\t\t\t@Nullable Charset encoding, @Nullable Consumer<String> validationErrorHandler)\n\t\t\tthrows InvalidUrlException {\n\n\t\tAssert.notNull(input, \"Input must not be null\");\n\n\t\tWhatWgUrlParser parser = new WhatWgUrlParser(input, base, encoding, validationErrorHandler);\n\t\treturn parser.basicUrlParser(null, null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input,p)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 2380
    },
    "return": "Ipv4Address",
    "signature": "public Ipv4Address parse(String input, WhatWgUrlParser p)",
    "source_code": "\t\tpublic static Ipv4Address parse(String input, WhatWgUrlParser p) {\n\t\t\t// Let parts be the result of strictly splitting input on U+002E (.).\n\t\t\tList<String> parts = strictSplit(input, '.');\n\t\t\tint partsSize = parts.size();\n\t\t\t// If the last item in parts is the empty string, then:\n\t\t\tif (parts.get(partsSize - 1).isEmpty()) {\n\t\t\t\t// IPv4-empty-part validation error.\n\t\t\t\tp.validationError(\"IPv4 address ends with \\\".\\\"\");\n\t\t\t\t// If parts\u2019s size is greater than 1, then remove the last item from parts.\n\t\t\t\tif (partsSize > 1) {\n\t\t\t\t\tparts.remove(partsSize - 1);\n\t\t\t\t\tpartsSize--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If parts\u2019s size is greater than 4, IPv4-too-many-parts validation error, return failure.\n\t\t\tif (partsSize > 4) {\n\t\t\t\tthrow new InvalidUrlException(\"IPv4 address does not consist of exactly 4 parts.\");\n\t\t\t}\n\t\t\t// Let numbers be an empty list.\n\t\t\tList<Integer> numbers = new ArrayList<>(partsSize);\n\t\t\t// For each part of parts:\n\t\t\tfor (int i = 0; i < partsSize; i++) {\n\t\t\t\tString part = parts.get(i);\n\t\t\t\t// Let result be the result of parsing part.\n\t\t\t\tParseIpv4NumberResult result = parseIpv4Number(part);\n\t\t\t\t// If result is failure, IPv4-non-numeric-part validation error, return failure.\n\t\t\t\tif (result == ParseIpv4NumberFailure.INSTANCE) {\n\t\t\t\t\tp.failure(\"An IPv4 address part is not numeric.\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParseIpv4NumberSuccess success = (ParseIpv4NumberSuccess) result;\n\t\t\t\t\tif (p.validate() && success.validationError()) {\n\t\t\t\t\t\tp.validationError(\n\t\t\t\t\t\t\t\t\"The IPv4 address contains numbers expressed using hexadecimal or octal digits.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Append result to numbers.\n\t\t\t\t\tnumbers.add(success.number());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext(); ) {\n\t\t\t\tInteger number = iterator.next();\n\t\t\t\t// If any item in numbers is greater than 255, IPv4-out-of-range-part validation error.\n\t\t\t\tif (p.validate() && number > 255) {\n\t\t\t\t\tp.validationError(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\t// If any but the last item in numbers is greater than 255, then return failure.\n\t\t\t\t\tif (number > 255) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If the last item in numbers is greater than or equal to 256^(5 \u2212 numbers\u2019s size),\n\t\t\t\t\t// then return failure.\n\t\t\t\t\tdouble limit = Math.pow(256, (5 - numbers.size()));\n\t\t\t\t\tif (number >= limit) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\"IPv4 address part \" + number + \" exceeds \" + limit + \".'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Let ipv4 be the last item in numbers.\n\t\t\tint ipv4 = numbers.get(numbers.size() - 1);\n\t\t\t// Remove the last item from numbers.\n\t\t\tnumbers.remove(numbers.size() - 1);\n\t\t\t// Let counter be 0.\n\t\t\tint counter = 0;\n\t\t\t// For each n of numbers:\n\t\t\tfor (Integer n : numbers) {\n\t\t\t\t// Increment ipv4 by n \u00d7 256^(3 \u2212 counter).\n\t\t\t\tint increment = n * (int) Math.pow(256, 3 - counter);\n\t\t\t\tipv4 += increment;\n\t\t\t\t// Increment counter by 1.\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\t// Return ipv4.\n\t\t\treturn new Ipv4Address(ipv4);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#parseForwardedFor(request,remoteAddress)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the first \"Forwarded: for=...\" or \"X-Forwarded-For\" header value to\n\t * an {@code InetSocketAddress} representing the address of the client.\n\t * @param request a request with headers that may contain forwarded headers\n\t * @param remoteAddress the current remoteAddress\n\t * @return an {@code InetSocketAddress} with the extracted host and port, or\n\t * {@code null} if the headers are not present.\n\t * @since 5.3\n\t * @deprecated in favor of {@link ForwardedHeaderUtils#parseForwardedFor};\n\t * to be removed in 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "remoteAddress"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "InetSocketAddress",
    "signature": "public InetSocketAddress parseForwardedFor(HttpRequest request, @Nullable InetSocketAddress remoteAddress)",
    "source_code": "\tpublic static InetSocketAddress parseForwardedFor(\n\t\t\tHttpRequest request, @Nullable InetSocketAddress remoteAddress) {\n\n\t\treturn ForwardedHeaderUtils.parseForwardedFor(\n\t\t\t\trequest.getURI(), request.getHeaders(), remoteAddress);\n\t}"
  }
}