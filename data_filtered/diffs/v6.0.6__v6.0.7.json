{
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 579
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 539
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#addProperty(propertyName,propertyValue)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "GroovyBeanDefinitionWrapper",
    "signature": "public GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue)",
    "source_code": "\tpublic GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue) {\n\t\tif (propertyValue instanceof GroovyBeanDefinitionWrapper wrapper) {\n\t\t\tpropertyValue = wrapper.getBeanDefinition();\n\t\t}\n\t\tgetBeanDefinition().getPropertyValues().add(propertyName, propertyValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(bd,beanName,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\t// Don't override the class with CGLIB if no overrides.\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\tConstructor<?> constructorToUse;\n\t\t\tsynchronized (bd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse == null) {\n\t\t\t\t\tfinal Class<?> clazz = bd.getBeanClass();\n\t\t\t\t\tif (clazz.isInterface()) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"Specified class is an interface\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconstructorToUse = clazz.getDeclaredConstructor();\n\t\t\t\t\t\tbd.resolvedConstructorOrFactoryMethod = constructorToUse;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(constructorToUse);\n\t\t}\n\t\telse {\n\t\t\t// Must generate CGLIB subclass.\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(bd,beanName,owner,ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\tfinal Constructor<?> ctor, Object... args)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\tfinal Constructor<?> ctor, Object... args) {\n\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner, ctor, args);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(bd,beanName,owner,factoryBean,factoryMethod,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "factoryBean",
      "factoryMethod",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Object factoryBean, final Method factoryMethod, Object... args)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Object factoryBean, final Method factoryMethod, Object... args) {\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(factoryMethod);\n\n\t\t\tMethod priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n\t\t\ttry {\n\t\t\t\tcurrentlyInvokedFactoryMethod.set(factoryMethod);\n\t\t\t\tObject result = factoryMethod.invoke(factoryBean, args);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = new NullBean();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (priorInvokedFactoryMethod != null) {\n\t\t\t\t\tcurrentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcurrentlyInvokedFactoryMethod.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\"Illegal arguments to factory method '\" + factoryMethod.getName() + \"'; \" +\n\t\t\t\t\t\"args: \" + StringUtils.arrayToCommaDelimitedString(args), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\"Cannot access factory method '\" + factoryMethod.getName() + \"'; is it public?\", ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tString msg = \"Factory method '\" + factoryMethod.getName() + \"' threw exception with message: \" +\n\t\t\t\t\tex.getTargetException().getMessage();\n\t\t\tif (bd.getFactoryBeanName() != null && owner instanceof ConfigurableBeanFactory cbf &&\n\t\t\t\t\tcbf.isCurrentlyInCreation(bd.getFactoryBeanName())) {\n\t\t\t\tmsg = \"Circular reference involving containing bean '\" + bd.getFactoryBeanName() + \"' - consider \" +\n\t\t\t\t\t\t\"declaring the factory method as static for independence from its containing instance. \" + msg;\n\t\t\t}\n\t\t\tthrow new BeanInstantiationException(factoryMethod, msg, ex.getTargetException());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#obtainFromSupplier(supplier,beanName)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @return a BeanWrapper for the new instance\n\t * @since 5.0\n\t * @see #getObjectForBeanInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName)",
    "source_code": "\tprotected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName) {\n\t\tObject instance = obtainInstanceFromSupplier(supplier, beanName);\n\t\tif (instance == null) {\n\t\t\tinstance = new NullBean();\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(instance);\n\t\tinitBeanWrapper(bw);\n\t\treturn bw;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#obtainInstanceFromSupplier(supplier,beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @param mbd the bean definition for the bean\n\t * @return the bean instance (possibly {@code null})\n\t * @since 6.0.7\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1248
    },
    "return": "Object",
    "signature": "protected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)\n\t\t\tthrows Exception {\n\n\t\tif (supplier instanceof ThrowingSupplier<?> throwingSupplier) {\n\t\t\treturn throwingSupplier.getWithException();\n\t\t}\n\t\treturn supplier.get();\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#get(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "T",
    "signature": "public T get(Object key, final Callable<T> valueLoader)",
    "source_code": "\tpublic <T> T get(Object key, final Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.cache.get(key, new LoadFunction(valueLoader)));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable final Object value)",
    "source_code": "\tpublic ValueWrapper putIfAbsent(Object key, @Nullable final Object value) {\n\t\tPutIfAbsentFunction callable = new PutIfAbsentFunction(value);\n\t\tObject result = this.cache.get(key, callable);\n\t\treturn (callable.called ? null : toValueWrapper(result));\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors)",
    "source_code": "    public static void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors) {\n        for (PropertyDescriptor descriptor : descriptors) {\n            gen.addProperty(descriptor.getName(), descriptor.getPropertyType());\n        }\n    }"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,props)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Map props)",
    "source_code": "    public static void addProperties(BeanGenerator gen, Map props) {\n        for (Iterator it = props.keySet().iterator(); it.hasNext();) {\n            String name = (String)it.next();\n            gen.addProperty(name, (Class)props.get(name));\n        }\n    }"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Class type)",
    "source_code": "    public static void addProperties(BeanGenerator gen, Class type) {\n        addProperties(gen, ReflectUtils.getBeanProperties(type));\n    }"
  },
  "org.springframework.cglib.beans.<unknown>#addProperty(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void addProperty(String name, Class type)",
    "source_code": "    public void addProperty(String name, Class type) {\n        if (props.containsKey(name)) {\n            throw new IllegalArgumentException(\"Duplicate property name \\\"\" + name + \"\\\"\");\n        }\n        props.put(name, Type.getType(type));\n    }"
  },
  "org.springframework.cglib.beans.<unknown>#newInstance(superclass,props)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superclass",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "Object",
    "signature": "public Object newInstance(String superclass, Map props)",
    "source_code": "        public Object newInstance(String superclass, Map props);"
  },
  "org.springframework.cglib.core.<unknown>#add_properties(ce,names,types)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "names",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 867
    },
    "return": "void",
    "signature": "public void add_properties(ClassEmitter ce, String[] names, Type[] types)",
    "source_code": "    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#add_property(ce,name,type,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "name",
      "type",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "void",
    "signature": "public void add_property(ClassEmitter ce, String name, Type type, String fieldName)",
    "source_code": "    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#append_string(e,type,delims,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "void",
    "signature": "public void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer)",
    "source_code": "    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#append_string(e,type,delims,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "void",
    "signature": "public void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry)",
    "source_code": "    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 944
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\n        return begin_method(e, method, method.getModifiers());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method,access)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n        return e.begin_method(access,\n                              method.getSignature(),\n                              method.getExceptionTypes());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#constructor_switch(e,constructors,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "constructors",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "public void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback)",
    "source_code": "    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#factory_method(ce,sig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "sig"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void factory_method(ClassEmitter ce, Signature sig)",
    "source_code": "    public static void factory_method(ClassEmitter ce, Signature sig) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        e.new_instance_this();\n        e.dup();\n        e.load_args();\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#hash_code(e,type,multiplier,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#hash_code(e,type,multiplier,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\n        if (TypeUtils.isArray(type)) {\n            hash_array(e, type, multiplier, registry);\n        } else {\n            e.swap(Type.INT_TYPE, type);\n            e.push(multiplier);\n            e.math(CodeEmitter.MUL, Type.INT_TYPE);\n            e.swap(type, Type.INT_TYPE);\n            if (TypeUtils.isPrimitive(type)) {\n                hash_primitive(e, type);\n            } else {\n                hash_object(e, type, registry);\n            }\n            e.math(CodeEmitter.ADD, Type.INT_TYPE);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#load_class(e,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void load_class(CodeEmitter e, Type type)",
    "source_code": "    public static void load_class(CodeEmitter e, Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                throw new IllegalArgumentException(\"cannot load void type\");\n            }\n            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n        } else {\n            load_class_helper(e, type);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#load_method(e,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 705
    },
    "return": "void",
    "signature": "public void load_method(CodeEmitter e, MethodInfo method)",
    "source_code": "    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#method_switch(e,methods,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "methods",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 716
    },
    "return": "void",
    "signature": "public void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback)",
    "source_code": "    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#not_equals(e,type,notEquals,customizer)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "notEquals",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer)",
    "source_code": "    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#not_equals(e,type,notEquals,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "notEquals",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "public void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry)",
    "source_code": "    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\n        (new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                not_equals_helper(e, type, notEquals, registry, this);\n            }\n        }).processElement(type);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#processCase(key,dontUseEnd)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "dontUseEnd"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "void",
    "signature": "public void processCase(Object key, Label dontUseEnd)",
    "source_code": "                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }"
  },
  "org.springframework.cglib.core.<unknown>#processCase(key,ignore_end)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "ignore_end"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void processCase(int key, Label ignore_end)",
    "source_code": "            public void processCase(int key, Label ignore_end) throws Exception {\n                List bucket = (List)buckets.get(key);\n                Label next = null;\n                if (skipEquals && bucket.size() == 1) {\n                    if (skipEquals) {\n\t\t\t\t\t\te.pop();\n\t\t\t\t\t}\n                    callback.processCase(bucket.get(0), end);\n                } else {\n                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n                        String string = (String)it.next();\n                        if (next != null) {\n                            e.mark(next);\n                        }\n                        if (it.hasNext()) {\n                            e.dup();\n                        }\n                        e.push(string);\n                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                        if (it.hasNext()) {\n                            e.if_jump(CodeEmitter.EQ, next = e.make_label());\n                            e.pop();\n                        } else {\n                            e.if_jump(CodeEmitter.EQ, def);\n                        }\n                        callback.processCase(string, end);\n                    }\n                }\n            }"
  },
  "org.springframework.cglib.core.<unknown>#process_array(e,type,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback)",
    "source_code": "    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#process_arrays(e,type,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback)",
    "source_code": "    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array1 = e.make_local();\n        Local array2 = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array1);\n        e.store_local(array2);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array1);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        e.load_local(array2);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array1);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#push_array(e,array)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void push_array(CodeEmitter e, Object[] array)",
    "source_code": "    public static void push_array(CodeEmitter e, Object[] array) {\n        e.push(array.length);\n        e.newarray(Type.getType(remapComponentType(array.getClass().getComponentType())));\n        for (int i = 0; i < array.length; i++) {\n            e.dup();\n            e.push(i);\n            push_object(e, array[i]);\n            e.aastore();\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#push_object(e,obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void push_object(CodeEmitter e, Object obj)",
    "source_code": "    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#string_switch(e,strings,switchStyle,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "strings",
      "switchStyle",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback)",
    "source_code": "    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n        try {\n            switch (switchStyle) {\n            case Constants.SWITCH_STYLE_TRIE:\n                string_switch_trie(e, strings, callback);\n                break;\n            case Constants.SWITCH_STYLE_HASH:\n                string_switch_hash(e, strings, callback, false);\n                break;\n            case Constants.SWITCH_STYLE_HASHONLY:\n                string_switch_hash(e, strings, callback, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n            }\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#to_string(e,type,delims,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "void",
    "signature": "public void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry)",
    "source_code": "    public static void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry) {\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\n        e.dup();\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n        e.swap();\n        append_string(e, type, delims, registry);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#wrap_throwable(block,wrapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "block",
      "wrapper"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "void",
    "signature": "public void wrap_throwable(Block block, Type wrapper)",
    "source_code": "    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#wrap_undeclared_throwable(e,handler,exceptions,wrapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */\n    @Deprecated\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }\n\n    private static void append_string_helper(CodeEmitter e,\n                                             Type type,\n                                             ArrayDelimiters delims,\n                                             CustomizerRegistry registry,\n                                             ProcessArrayCallback callback) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n                break;\n            case Type.DOUBLE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n                break;\n            case Type.FLOAT:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n                break;\n            case Type.LONG:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n                break;\n            case Type.BOOLEAN:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n                break;\n            case Type.CHAR:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n                break;\n            }\n        } else if (TypeUtils.isArray(type)) {\n            e.dup();\n            e.ifnull(skip);\n            e.swap();\n            if (delims != null && delims.before != null && !\"\".equals(delims.before)) {\n                e.push(delims.before);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                e.swap();\n            }\n            EmitUtils.process_array(e, type, callback);\n            shrinkStringBuffer(e, 2);\n            if (delims != null && delims.after != null && !\"\".equals(delims.after)) {\n                e.push(delims.after);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        } else {\n            e.dup();\n            e.ifnull(skip);\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(\"null\");\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        e.mark(end);\n    }\n\n    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n        e.dup();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n        e.push(amt);\n        e.math(CodeEmitter.SUB, Type.INT_TYPE);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n    }\n\n    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }\n\n    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }\n\n    private interface ParameterTyper {\n        Type[] getParameterTypes(MethodInfo member);\n    }\n\n    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }\n\n    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }\n\n    private static void member_switch_helper(final CodeEmitter e,\n                                             List members,\n                                             final ObjectSwitchCallback callback,\n                                             boolean useName) {\n        try {\n            final Map cache = new HashMap();\n            final ParameterTyper cached = member -> {\n                Type[] types = (Type[]) cache.get(member);\n                if (types == null) {\n                    cache.put(member, types = member.getSignature().getArgumentTypes());\n                }\n                return types;\n            };\n            final Label def = e.make_label();\n            final Label end = e.make_label();\n            if (useName) {\n                e.swap();\n                final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo)value).getSignature().getName());\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                        @Override\n                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n                        }\n                        @Override\n                        public void processDefault() throws Exception {\n                            e.goTo(def);\n                        }\n                    });\n            } else {\n                member_helper_size(e, members, callback, cached, def, end);\n            }\n            e.mark(def);\n            e.pop();\n            callback.processDefault();\n            e.mark(end);\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void member_helper_size(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end) throws Exception {\n        final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo)value).length);\n        e.dup();\n        e.arraylength();\n        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label dontUseEnd) throws Exception {\n                List bucket = (List)buckets.get(key);\n                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n            }\n            @Override\n            public void processDefault() throws Exception {\n                e.goTo(def);\n            }\n        });\n    }\n\n    private static void member_helper_type(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end,\n                                           final BitSet checked) throws Exception {\n        if (members.size() == 1) {\n            MethodInfo member = (MethodInfo)members.get(0);\n            Type[] types = typer.getParameterTypes(member);\n            // need to check classes that have not already been checked via switches\n            for (int i = 0; i < types.length; i++) {\n                if (checked == null || !checked.get(i)) {\n                    e.dup();\n                    e.aaload(i);\n                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n                    e.push(TypeUtils.emulateClassGetName(types[i]));\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                    e.if_jump(CodeEmitter.EQ, def);\n                }\n            }\n            e.pop();\n            callback.processCase(member, end);\n        } else {\n            // choose the index that has the best chance of uniquely identifying member\n            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n            Map buckets = null;\n            int index = -1;\n            for (int i = 0; i < example.length; i++) {\n                final int j = i;\n                Map test = CollectionUtils.bucket(members,\n                        value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]));\n                if (buckets == null || test.size() > buckets.size()) {\n                    buckets = test;\n                    index = i;\n                }\n            }\n            if (buckets == null || buckets.size() == 1) {\n                // TODO: switch by returnType\n                // must have two methods with same name, types, and different return types\n                e.goTo(def);\n            } else {\n                checked.set(index);\n\n                e.dup();\n                e.aaload(index);\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n\n                final Map fbuckets = buckets;\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                    @Override\n                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }\n                    @Override\n                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }\n                });\n            }\n        }\n    }\n\n    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }\n\n    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }\n\n    /* generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }\n    */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "handler",
      "exceptions",
      "wrapper"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "public void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper)",
    "source_code": "    public static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\n        Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\n\n        if (set.contains(Constants.TYPE_THROWABLE)) {\n\t\t\treturn;\n\t\t}\n\n        boolean needThrow = exceptions != null;\n        if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\n            e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\n            needThrow = true;\n        }\n        if (!set.contains(Constants.TYPE_ERROR)) {\n            e.catch_exception(handler, Constants.TYPE_ERROR);\n            needThrow = true;\n        }\n        if (exceptions != null) {\n            for (Type exception : exceptions) {\n                e.catch_exception(handler, exception);\n            }\n        }\n        if (needThrow) {\n            e.athrow();\n        }\n        // e -> eo -> oeo -> ooe -> o\n        e.catch_exception(handler, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }"
  },
  "org.springframework.cglib.core.internal.<unknown>#createEntry(key,cacheKey,v)": {
    "change": "added",
    "deprecated": false,
    "doc": "    /**\n     * Loads entry to the cache.\n     * If entry is missing, put {@link FutureTask} first so other competing thread might wait for the result.\n     * @param key original key that would be used to load the instance\n     * @param cacheKey key that would be used to store the entry in internal map\n     * @param v null or {@link FutureTask<V>}\n     * @return newly created instance\n     */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "cacheKey",
      "v"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "V",
    "signature": "protected V createEntry(final K key, KK cacheKey, Object v)",
    "source_code": "    protected V createEntry(final K key, KK cacheKey, Object v) {\n        FutureTask<V> task;\n        boolean creator = false;\n        if (v != null) {\n            // Another thread is already loading an instance\n            task = (FutureTask<V>) v;\n        } else {\n            task = new FutureTask<>(() -> loader.apply(key));\n            Object prevTask = map.putIfAbsent(cacheKey, task);\n            if (prevTask == null) {\n                // creator does the load\n                creator = true;\n                task.run();\n            } else if (prevTask instanceof FutureTask) {\n                task = (FutureTask<V>) prevTask;\n            } else {\n                return (V) prevTask;\n            }\n        }\n\n        V result;\n        try {\n            result = task.get();\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(\"Interrupted while loading cache item\", e);\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException runtimeException) {\n                throw runtimeException;\n            }\n            throw new IllegalStateException(\"Unable to load cache item\", cause);\n        }\n        if (creator) {\n            map.put(cacheKey, result);\n        }\n        return result;\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#create(loader,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loader",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "FastClass",
    "signature": "public FastClass create(ClassLoader loader, Class type)",
    "source_code": "    public static FastClass create(ClassLoader loader, Class type) {\n        Generator gen = new Generator();\n        gen.setType(type);\n        gen.setClassLoader(loader);\n        return gen.create();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getMethod(name,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "FastMethod",
    "signature": "public FastMethod getMethod(String name, Class[] parameterTypes)",
    "source_code": "    public FastMethod getMethod(String name, Class[] parameterTypes) {\n        try {\n            return getMethod(type.getMethod(name, parameterTypes));\n        } catch (NoSuchMethodException e) {\n            throw new NoSuchMethodError(e.getMessage());\n        }\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getSignatureWithoutReturnType(name,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "protected String getSignatureWithoutReturnType(String name, Class[] parameterTypes)",
    "source_code": "    protected static String getSignatureWithoutReturnType(String name, Class[] parameterTypes) {\n\t\tStringBuilder sb = new StringBuilder();\n        sb.append(name);\n        sb.append('(');\n        for (Class parameterType : parameterTypes) {\n            sb.append(Type.getDescriptor(parameterType));\n        }\n        sb.append(')');\n        return sb.toString();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#invoke(name,parameterTypes,obj,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes",
      "obj",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Object",
    "signature": "public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args)",
    "source_code": "    public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) throws InvocationTargetException {\n        return invoke(getIndex(name, parameterTypes), obj, args);\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#newInstance(parameterTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object newInstance(Class[] parameterTypes, Object[] args)",
    "source_code": "    public Object newInstance(Class[] parameterTypes, Object[] args) throws InvocationTargetException {\n        return newInstance(getIndex(parameterTypes), args);\n    }"
  },
  "org.springframework.context.annotation.<unknown>#registerAnnotationConfigProcessors(registry,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Set<BeanDefinitionHolder>",
    "signature": "public Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)",
    "source_code": "\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n\t\tif (beanFactory != null) {\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\tbeanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);\n\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif (jakartaAnnotationsPresent && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JSR-250 support, and if present add an InitDestroyAnnotationBeanPostProcessor\n\t\t// for the javax variant of PostConstruct/PreDestroy.\n\t\tif (jsr250Present && !registry.containsBeanDefinition(JSR250_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition def = new RootBeanDefinition(InitDestroyAnnotationBeanPostProcessor.class);\n\t\t\t\tdef.getPropertyValues().add(\"initAnnotationType\", classLoader.loadClass(\"javax.annotation.PostConstruct\"));\n\t\t\t\tdef.getPropertyValues().add(\"destroyAnnotationType\", classLoader.loadClass(\"javax.annotation.PreDestroy\"));\n\t\t\t\tdef.setSource(source);\n\t\t\t\tbeanDefs.add(registerPostProcessor(registry, def, JSR250_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t// Failed to load javax variants of the annotation types -> ignore.\n\t\t\t}\n\t\t}\n\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n\t}"
  },
  "org.springframework.context.event.<unknown>#invokeListener(listener,event)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given listener with the given event.\n\t * @param listener the ApplicationListener to invoke\n\t * @param event the current event to propagate\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "event"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event)",
    "source_code": "\tprotected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {\n\t\tErrorHandler errorHandler = getErrorHandler();\n\t\tif (errorHandler != null) {\n\t\t\ttry {\n\t\t\t\tdoInvokeListener(listener, event);\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\terrorHandler.handleError(err);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoInvokeListener(listener, event);\n\t\t}\n\t}"
  },
  "org.springframework.context.event.<unknown>#multicastEvent(event,eventType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType)",
    "source_code": "\tpublic void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) {\n\t\tResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n\t\tExecutor executor = getTaskExecutor();\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.execute(() -> invokeListener(listener, event));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinvokeListener(listener, event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.i18n.<unknown>#setLocale(locale,inheritable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given Locale with the current thread,\n\t * preserving any TimeZone that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param locale the current Locale, or {@code null} to reset\n\t * the locale part of thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setTimeZone(TimeZone, boolean)\n\t * @see SimpleLocaleContext#SimpleLocaleContext(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setLocale(@Nullable Locale locale, boolean inheritable)",
    "source_code": "\tpublic static void setLocale(@Nullable Locale locale, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tTimeZone timeZone = (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware ?\n\t\t\t\ttimeZoneAware.getTimeZone() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}"
  },
  "org.springframework.context.i18n.<unknown>#setLocaleContext(localeContext,inheritable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given LocaleContext with the current thread.\n\t * <p>The given LocaleContext may be a {@link TimeZoneAwareLocaleContext},\n\t * containing a locale with associated time zone information.\n\t * @param localeContext the current LocaleContext,\n\t * or {@code null} to reset the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see SimpleLocaleContext\n\t * @see SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContext",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable)",
    "source_code": "\tpublic static void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable) {\n\t\tif (localeContext == null) {\n\t\t\tresetLocaleContext();\n\t\t}\n\t\telse {\n\t\t\tif (inheritable) {\n\t\t\t\tinheritableLocaleContextHolder.set(localeContext);\n\t\t\t\tlocaleContextHolder.remove();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlocaleContextHolder.set(localeContext);\n\t\t\t\tinheritableLocaleContextHolder.remove();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.i18n.<unknown>#setTimeZone(timeZone,inheritable)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given TimeZone with the current thread,\n\t * preserving any Locale that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param timeZone the current TimeZone, or {@code null} to reset\n\t * the time zone part of the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setLocale(Locale, boolean)\n\t * @see SimpleTimeZoneAwareLocaleContext#SimpleTimeZoneAwareLocaleContext(Locale, TimeZone)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable)",
    "source_code": "\tpublic static void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tLocale locale = (localeContext != null ? localeContext.getLocale() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}"
  },
  "org.springframework.context.index.processor.<unknown>#process(annotations,roundEnv)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotations",
      "roundEnv"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "boolean",
    "signature": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)",
    "source_code": "\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\tthis.metadataCollector.processing(roundEnv);\n\t\troundEnv.getRootElements().forEach(this::processElement);\n\t\tif (roundEnv.processingOver()) {\n\t\t\twriteMetaData();\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.weaving.<unknown>#postProcessAfterInitialization(bean,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String name)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String name) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.context.weaving.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof LoadTimeWeaverAware loadTimeWeaverAware) {\n\t\t\tLoadTimeWeaver ltw = this.loadTimeWeaver;\n\t\t\tif (ltw == null) {\n\t\t\t\tAssert.state(this.beanFactory != null,\n\t\t\t\t\t\t\"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n\t\t\t\tltw = this.beanFactory.getBean(\n\t\t\t\t\t\tConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n\t\t\t}\n\t\t\tloadTimeWeaverAware.setLoadTimeWeaver(ltw);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.core.<unknown>#computeAttribute(name,Function<String,computeFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.core.<unknown>#getAdapter(reactiveType,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the adapter for the given reactive type. Or if a \"source\" object is\n\t * provided, its actual type is used instead.\n\t * @param reactiveType the reactive type\n\t * (may be {@code null} if a concrete source object is given)\n\t * @param source an instance of the reactive type\n\t * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reactiveType",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "ReactiveAdapter",
    "signature": "public ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source)",
    "source_code": "\tpublic ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\n\t\tif (this.adapters.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\n\t\tClass<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType() == clazz) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType().isAssignableFrom(clazz)) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.<unknown>#registerReactiveType(descriptor,Function<Object,toAdapter,Function<Publisher<?>,fromAdapter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "Function<Object",
      "toAdapter",
      "Function<Publisher<?>",
      "fromAdapter"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter)",
    "source_code": "\tpublic void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\tif (reactorPresent) {\n\t\t\tthis.adapters.add(new ReactorAdapter(descriptor, toAdapter, fromAdapter));\n\t\t}\n\t\telse {\n\t\t\tthis.adapters.add(new ReactiveAdapter(descriptor, toAdapter, fromAdapter));\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tif (value != null) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#toCode(value,namePrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "namePrefix"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "String",
    "signature": "public String toCode(Object value, @Nullable String namePrefix)",
    "source_code": "\tpublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, prefixToUse, value);\n\t}"
  },
  "org.springframework.core.<unknown>#toCodeForProperty(value,propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the group of constants for\n\t * the given bean property name. Will return the first match.\n\t * @param value constant value to look up\n\t * @param propertyName the name of the bean property\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t * @see #propertyToConstantNamePrefix\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "public String toCodeForProperty(Object value, String propertyName)",
    "source_code": "\tpublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\n\t\treturn toCode(value, propertyToConstantNamePrefix(propertyName));\n\t}"
  },
  "org.springframework.core.<unknown>#toCodeForSuffix(value,nameSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "nameSuffix"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "String",
    "signature": "public String toCodeForSuffix(Object value, @Nullable String nameSuffix)",
    "source_code": "\tpublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, suffixToUse, value);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic NettyDataBuffer read(byte[] destination, int offset, int length) {\n\t\tthis.byteBuf.readBytes(destination, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#retainedSlice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer retainedSlice(int index, int length)",
    "source_code": "\tpublic NettyDataBuffer retainedSlice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.retainedSlice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer slice(int index, int length)",
    "source_code": "\tpublic NettyDataBuffer slice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.slice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic NettyDataBuffer write(byte[] source, int offset, int length) {\n\t\tthis.byteBuf.writeBytes(source, offset, length);\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.type.<unknown>#getAllAnnotationAttributes(annotationName,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.<unknown>#getAnnotationAttributes(annotationName,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.http.client.<unknown>#openConnection(url,proxy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Opens and returns a connection to the given URL.\n\t * <p>The default implementation uses the given {@linkplain #setProxy(java.net.Proxy) proxy} -\n\t * if any - to open a connection.\n\t * @param url the URL to open a connection to\n\t * @param proxy the proxy to use, may be {@code null}\n\t * @return the opened connection\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "HttpURLConnection",
    "signature": "protected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy)",
    "source_code": "\tprotected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy) throws IOException {\n\t\tURLConnection urlConnection = (proxy != null ? url.openConnection(proxy) : url.openConnection());\n\t\tif (!(urlConnection instanceof HttpURLConnection httpUrlConnection)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"HttpURLConnection required for [\" + url + \"] but got: \" + urlConnection);\n\t\t}\n\t\treturn httpUrlConnection;\n\t}"
  },
  "org.springframework.http.client.<unknown>#prepareConnection(connection,httpMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for preparing the given {@link HttpURLConnection}.\n\t * <p>The default implementation prepares the connection for input and output, and sets the HTTP method.\n\t * @param connection the connection to prepare\n\t * @param httpMethod the HTTP request method ({@code GET}, {@code POST}, etc.)\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connection",
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "protected void prepareConnection(HttpURLConnection connection, String httpMethod)",
    "source_code": "\tprotected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\t\tif (this.connectTimeout >= 0) {\n\t\t\tconnection.setConnectTimeout(this.connectTimeout);\n\t\t}\n\t\tif (this.readTimeout >= 0) {\n\t\t\tconnection.setReadTimeout(this.readTimeout);\n\t\t}\n\n\t\tboolean mayWrite =\n\t\t\t\t(\"POST\".equals(httpMethod) || \"PUT\".equals(httpMethod) ||\n\t\t\t\t\t\t\"PATCH\".equals(httpMethod) || \"DELETE\".equals(httpMethod));\n\n\t\tconnection.setDoInput(true);\n\t\tconnection.setInstanceFollowRedirects(\"GET\".equals(httpMethod));\n\t\tconnection.setDoOutput(mayWrite);\n\t\tconnection.setRequestMethod(httpMethod);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#write(MultiValueMap<String,inputStream,elementType,mediaType,outputMessage,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "inputStream",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\treturn Mono.from(inputStream)\n\t\t\t\t.flatMap(map -> {\n\t\t\t\t\tif (this.formWriter == null || isMultipart(map, mediaType)) {\n\t\t\t\t\t\treturn writeMultipart(map, outputMessage, mediaType, hints);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tMono<MultiValueMap<String, String>> input = Mono.just((MultiValueMap<String, String>) map);\n\t\t\t\t\t\treturn this.formWriter.write(input, elementType, mediaType, outputMessage, hints);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that reads the actual object. Invoked from {@link #read}.\n\t * @param clazz the type of object to return\n\t * @param inputMessage the HTTP input message to read from\n\t * @return the converted object\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotReadableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "T",
    "signature": "protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected abstract T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}."
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\tregisterSqlType(paramName, sqlParameterValue.getSqlType());\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\tregisterTypeName(paramName, typeName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValues(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Map of parameters to this parameter source.\n\t * @param values a Map holding existing parameter values (can be {@code null})\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValues(@Nullable Map<String, ?> values)",
    "source_code": "\tpublic MapSqlParameterSource addValues(@Nullable Map<String, ?> values) {\n\t\tif (values != null) {\n\t\t\tvalues.forEach((key, value) -> {\n\t\t\t\tthis.values.put(key, value);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tregisterSqlType(key, sqlParameterValue.getSqlType());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#createBatch(Map<String,valueMaps)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of {@link MapSqlParameterSource} objects populated with data from\n\t * the values passed in. This will define what is included in a batch operation.\n\t * @param valueMaps array of {@link Map} instances containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @see MapSqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, Map[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "valueMaps"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "SqlParameterSource[]",
    "signature": "public SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps)",
    "source_code": "\tpublic static SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps) {\n\t\tSqlParameterSource[] batch = new SqlParameterSource[valueMaps.length];\n\t\tfor (int i = 0; i < valueMaps.length; i++) {\n\t\t\tbatch[i] = new MapSqlParameterSource(valueMaps[i]);\n\t\t}\n\t\treturn batch;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getTypedValue(source,parameterName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a wrapped value if parameter has type information, plain object if not.\n\t * @param source the source of parameter values and type information\n\t * @param parameterName the name of the parameter\n\t * @return the value object\n\t * @see SqlParameterValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Object",
    "signature": "public Object getTypedValue(SqlParameterSource source, String parameterName)",
    "source_code": "\tpublic static Object getTypedValue(SqlParameterSource source, String parameterName) {\n\t\tint sqlType = source.getSqlType(parameterName);\n\t\tif (sqlType != SqlParameterSource.TYPE_UNKNOWN) {\n\t\t\treturn new SqlParameterValue(sqlType, source.getTypeName(parameterName), source.getValue(parameterName));\n\t\t}\n\t\telse {\n\t\t\treturn source.getValue(parameterName);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#getInstance(domainName,Hashtable<String,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an {@code ObjectName} instance with the specified domain name\n\t * and the supplied key/name properties.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param properties the properties for the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, java.util.Hashtable)\n\t * @see ObjectName#getInstance(String, java.util.Hashtable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "domainName",
      "Hashtable<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String domainName, Hashtable<String, String> properties)",
    "source_code": "\tpublic static ObjectName getInstance(String domainName, Hashtable<String, String> properties)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\treturn ObjectName.getInstance(domainName, properties);\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#getInstance(domainName,key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an {@code ObjectName} instance for the specified domain and a\n\t * single property with the supplied key and value.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param key the key for the single property in the {@code ObjectName}\n\t * @param value the value for the single property in the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, String, String)\n\t * @see ObjectName#getInstance(String, String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "domainName",
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String domainName, String key, String value)",
    "source_code": "\tpublic static ObjectName getInstance(String domainName, String key, String value)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\treturn ObjectName.getInstance(domainName, key, value);\n\t}"
  },
  "org.springframework.messaging.<unknown>#get(key,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "T",
    "signature": "public T get(Object key, Class<T> type)",
    "source_code": "\tpublic <T> T get(Object key, Class<T> type) {\n\t\tObject value = this.headers.get(key);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Incorrect type specified for header '\" +\n\t\t\t\t\tkey + \"'. Expected [\" + type + \"] but actual type is [\" + value.getClass() + \"]\");\n\t\t}\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.messaging.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\tpublic Object put(String key, Object value) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends Object> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends Object> map) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromJson(payload,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "protected Object fromJson(String payload, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(String payload, Type resolvedType);"
  },
  "org.springframework.messaging.converter.<unknown>#fromJson(reader,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "protected Object fromJson(Reader reader, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(Reader reader, Type resolvedType);"
  },
  "org.springframework.messaging.converter.<unknown>#toJson(payload,resolvedType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "String",
    "signature": "protected String toJson(Object payload, Type resolvedType)",
    "source_code": "\tprotected abstract String toJson(Object payload, Type resolvedType);"
  },
  "org.springframework.messaging.converter.<unknown>#toJson(payload,resolvedType,writer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "protected void toJson(Object payload, Type resolvedType, Writer writer)",
    "source_code": "\tprotected abstract void toJson(Object payload, Type resolvedType, Writer writer);"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload) throws MessagingException {\n\t\tconvertAndSend(destination, payload, (Map<String, Object>) null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tMessage<?> message = doConvert(payload, headers, postProcessor);\n\t\tsend(destination, message);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(getRequiredDefaultDestination(), payload, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doSend(channel,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "channel",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message)",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message) {\n\t\tdoSend(channel, message, sendTimeout(message));\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doSend(channel,message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "channel",
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message, long timeout)",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message, long timeout) {\n\t\tAssert.notNull(channel, \"MessageChannel is required\");\n\n\t\tMessage<?> messageToSend = message;\n\t\tMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\tif (accessor != null && accessor.isMutable()) {\n\t\t\taccessor.removeHeader(this.sendTimeoutHeader);\n\t\t\taccessor.removeHeader(this.receiveTimeoutHeader);\n\t\t\taccessor.setImmutable();\n\t\t}\n\t\telse if (message.getHeaders().containsKey(this.sendTimeoutHeader)\n\t\t\t\t|| message.getHeaders().containsKey(this.receiveTimeoutHeader)) {\n\t\t\tmessageToSend = MessageBuilder.fromMessage(message)\n\t\t\t\t\t.setHeader(this.sendTimeoutHeader, null)\n\t\t\t\t\t.setHeader(this.receiveTimeoutHeader, null)\n\t\t\t\t\t.build();\n\t\t}\n\n\t\tboolean sent = (timeout >= 0 ? channel.send(messageToSend, timeout) : channel.send(messageToSend));\n\n\t\tif (!sent) {\n\t\t\tthrow new MessageDeliveryException(message,\n\t\t\t\t\t\"Failed to send message to channel '\" + channel + \"' within timeout: \" + timeout);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void doSend(D destination, Message<?> message)",
    "source_code": "\tprotected abstract void doSend(D destination, Message<?> message);"
  },
  "org.springframework.messaging.core.<unknown>#processHeadersToSend(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provides access to the map of input headers before a send operation.\n\t * Subclasses can modify the headers and then return the same or a different map.\n\t * <p>This default implementation in this class returns the input map.\n\t * @param headers the headers to send (or {@code null} if none)\n\t * @return the actual headers to send (or {@code null} if none)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\treturn headers;\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#send(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void send(D destination, Message<?> message)",
    "source_code": "\tpublic void send(D destination, Message<?> message) {\n\t\tdoSend(destination, message);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#send(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\t\tpublic boolean send(Message<?> message, long timeout) {\n\t\t\tthis.replyMessage = message;\n\t\t\tboolean alreadyReceivedReply = this.hasReceived;\n\t\t\tthis.replyLatch.countDown();\n\n\t\t\tString errorDescription = null;\n\t\t\tif (this.hasTimedOut) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has exited due to a timeout\";\n\t\t\t}\n\t\t\telse if (alreadyReceivedReply) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has already received a reply\";\n\t\t\t}\n\t\t\telse if (this.hasSendFailed) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has exited due to \" +\n\t\t\t\t\t\t\"an exception while sending the request message\";\n\t\t\t}\n\n\t\t\tif (errorDescription != null) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(errorDescription + \": \" + message);\n\t\t\t\t}\n\t\t\t\tif (this.throwExceptionOnLateReply) {\n\t\t\t\t\tthrow new MessageDeliveryException(message, errorDescription);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#createInvocableHandlerMethod(bean,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\tInvocableHandlerMethod handlerMethod = new InvocableHandlerMethod(bean, method);\n\t\thandlerMethod.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMethodArgumentValues(message,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current message, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(Message<?> message, Object... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(Message<?> message, Object... providedArgs) throws Exception {\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new MethodArgumentResolutionException(\n\t\t\t\t\t\tmessage, parameter, formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, message);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#invoke(message,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given message.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param message the current message being processed\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Object",
    "signature": "public Object invoke(Message<?> message, Object... providedArgs)",
    "source_code": "\tpublic Object invoke(Message<?> message, Object... providedArgs) throws Exception {\n\t\tObject[] args = getMethodArgumentValues(message, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "int",
    "signature": "public int compare(Match<T> match1, Match<T> match2)",
    "source_code": "\t\tpublic int compare(Match<T> match1, Match<T> match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#extendMapping(mapping,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method is invoked just before mappings are added. It allows\n\t * subclasses to update the mapping with the {@link HandlerMethod} in mind.\n\t * This can be useful when the method signature is used to refine the\n\t * mapping, e.g. based on the cardinality of input and output.\n\t * <p>By default this method returns the mapping that is passed in.\n\t * @param mapping the mapping to be added\n\t * @param handlerMethod the target handler for the mapping\n\t * @return a new mapping or the same\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "T",
    "signature": "protected T extendMapping(T mapping, HandlerMethod handlerMethod)",
    "source_code": "\tprotected T extendMapping(T mapping, HandlerMethod handlerMethod) {\n\t\treturn mapping;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the mapping for the given method, if any.\n\t * @param method the method to check\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#getMatchingMapping(mapping,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleMatch(mapping,handlerMethod,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleMatch(T mapping, HandlerMethod handlerMethod, Message<?> message)",
    "source_code": "\tprotected Mono<Void> handleMatch(T mapping, HandlerMethod handlerMethod, Message<?> message) {\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\treturn this.invocableHelper.handleMessage(handlerMethod, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleNoMatch(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching handler is found.\n\t * @param destination the destination\n\t * @param message the message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "void",
    "signature": "protected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tlogger.debug(\"No handlers for destination '\" +\n\t\t\t\t(destination != null ? destination.value() : \"\") + \"'\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#registerExceptionHandlerAdvice(bean,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (e.g. to support \"global\" {@code @MessageExceptionHandler}).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.invocableHelper.registerExceptionHandlerAdvice(bean, resolver);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * <p><strong>Note:</strong> As of 5.3 this method is public (rather than\n\t * protected) and can be used both at startup and at runtime.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tpublic final void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tmapping = extendMapping(mapping, newHandlerMethod);\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupMappings(mapping)) {\n\t\t\tList<T> values = this.destinationLookup.computeIfAbsent(pattern, p -> new CopyOnWriteArrayList<>());\n\t\t\tvalues.add(mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, Class<?> elementClass)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, Class<?> elementClass) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forClass(elementClass));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forType(elementTypeRef));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadata(metadata,mimeType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec metadata(Object metadata, MimeType mimeType)",
    "source_code": "\t\tpublic RequestSpec metadata(Object metadata, MimeType mimeType) {\n\t\t\tthis.metadataEncoder.metadata(metadata, mimeType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,vars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "vars"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec route(String route, Object... vars)",
    "source_code": "\tpublic RequestSpec route(String route, Object... vars) {\n\t\treturn new DefaultRequestSpec(route, vars);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#extendMapping(composite,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "composite",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler)",
    "source_code": "\tprotected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler) {\n\n\t\tList<MessageCondition<?>> conditions = composite.getMessageConditions();\n\t\tAssert.isTrue(conditions.size() == 2 &&\n\t\t\t\t\t\tconditions.get(0) instanceof RSocketFrameTypeMessageCondition &&\n\t\t\t\t\t\tconditions.get(1) instanceof DestinationPatternsMessageCondition,\n\t\t\t\t\"Unexpected message condition types\");\n\n\t\tif (conditions.get(0) != RSocketFrameTypeMessageCondition.EMPTY_CONDITION) {\n\t\t\treturn composite;\n\t\t}\n\n\t\tint responseCardinality = getCardinality(handler.getReturnType());\n\t\tint requestCardinality = 0;\n\t\tfor (MethodParameter parameter : handler.getMethodParameters()) {\n\t\t\tif (getArgumentResolvers().getArgumentResolver(parameter) instanceof PayloadMethodArgumentResolver) {\n\t\t\t\trequestCardinality = getCardinality(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn new CompositeMessageCondition(\n\t\t\t\tRSocketFrameTypeMessageCondition.getCondition(requestCardinality, responseCardinality),\n\t\t\t\tconditions.get(1));\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#handleNoMatch(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "protected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tFrameType frameType = RSocketFrameTypeMessageCondition.getFrameType(message);\n\t\tif (frameType == FrameType.SETUP || frameType == FrameType.METADATA_PUSH) {\n\t\t\treturn;  // optional handling\n\t\t}\n\t\tif (frameType == FrameType.REQUEST_FNF) {\n\t\t\t// Can't propagate error to client, so just log\n\t\t\tlogger.warn(\"No handler for fireAndForget to '\" + destination + \"'\");\n\t\t\treturn;\n\t\t}\n\n\t\tSet<FrameType> frameTypes = getHandlerMethods().keySet().stream()\n\t\t\t\t.map(CompositeMessageCondition::getMessageConditions)\n\t\t\t\t.filter(conditions -> conditions.get(1).getMatchingCondition(message) != null)\n\t\t\t\t.map(conditions -> (RSocketFrameTypeMessageCondition) conditions.get(0))\n\t\t\t\t.flatMap(condition -> condition.getFrameTypes().stream())\n\t\t\t\t.collect(Collectors.toSet());\n\n\t\tthrow new MessageDeliveryException(frameTypes.isEmpty() ?\n\t\t\t\t\"No handler for destination '\" + destination + \"'\" :\n\t\t\t\t\"Destination '\" + destination + \"' does not support \" + frameType + \". \" +\n\t\t\t\t\t\t\"Supported interaction(s): \" + frameTypes);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#responder(strategies,candidateHandlers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create an RSocket {@link SocketAcceptor}\n\t * backed by handlers with annotated methods. Effectively a shortcut for:\n\t * <pre class=\"code\">\n\t * RSocketMessageHandler handler = new RSocketMessageHandler();\n\t * handler.setHandlers(handlers);\n\t * handler.setRSocketStrategies(strategies);\n\t * handler.afterPropertiesSet();\n\t *\n\t * SocketAcceptor acceptor = handler.responder();\n\t * </pre>\n\t * <p>This is intended for programmatic creation and registration of a\n\t * client-side responder. For example:\n\t * <pre class=\"code\">\n\t * SocketAcceptor responder =\n\t *         RSocketMessageHandler.responder(strategies, new ClientHandler());\n\t *\n\t * RSocketRequester.builder()\n\t *         .rsocketConnector(connector -&gt; connector.acceptor(responder))\n\t *         .connectTcp(\"localhost\", server.address().getPort());\n\t * </pre>\n\t *\n\t * <p>Note that the given handlers do not need to have any stereotype\n\t * annotations such as {@code @Controller} which helps to avoid overlap with\n\t * server side handlers that may be used in the same application. However,\n\t * for more advanced scenarios, e.g. discovering handlers through a custom\n\t * stereotype annotation, consider declaring {@code RSocketMessageHandler}\n\t * as a bean, and then obtain the responder from it.\n\t * @param strategies the strategies to set on the created\n\t * {@code RSocketMessageHandler}\n\t * @param candidateHandlers a list of Objects and/or Classes with annotated\n\t * handler methods; used to call {@link #setHandlers(List)} with\n\t * on the created {@code RSocketMessageHandler}\n\t * @return a configurer that may be passed into\n\t * {@link org.springframework.messaging.rsocket.RSocketRequester.Builder#rsocketConnector}\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategies",
      "candidateHandlers"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "SocketAcceptor",
    "signature": "public SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers)",
    "source_code": "\tpublic static SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers) {\n\t\tAssert.notEmpty(candidateHandlers, \"No handlers\");\n\t\tList<Object> handlers = new ArrayList<>(candidateHandlers.length);\n\t\tfor (Object obj : candidateHandlers) {\n\t\t\thandlers.add(obj instanceof Class<?> clazz ? BeanUtils.instantiateClass(clazz) : obj);\n\t\t}\n\t\tRSocketMessageHandler handler = new RSocketMessageHandler();\n\t\thandler.setHandlers(handlers);\n\t\thandler.setRSocketStrategies(strategies);\n\t\thandler.afterPropertiesSet();\n\t\treturn handler.responder();\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, RSocketRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, RSocketRequestValues.Builder requestValues) {\n\n\t\tDestinationVariable annot = parameter.getParameterAnnotation(DestinationVariable.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument != null) {\n\t\t\tif (argument instanceof Collection<?> collection) {\n\t\t\t\tcollection.forEach(requestValues::addRouteVariable);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (argument.getClass().isArray()) {\n\t\t\t\tfor (Object variable : (Object[]) argument) {\n\t\t\t\t\trequestValues.addRouteVariable(variable);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequestValues.addRouteVariable(argument);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#compareTo(other,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "int",
    "signature": "public int compareTo(SimpMessageMappingInfo other, Message<?> message)",
    "source_code": "\tpublic int compareTo(SimpMessageMappingInfo other, Message<?> message) {\n\t\treturn this.delegate.compareTo(other.delegate, message);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload) throws MessagingException {\n\t\tconvertAndSendToUser(user, destination, payload, (MessagePostProcessor) null);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers) throws MessagingException {\n\n\t\tconvertAndSendToUser(user, destination, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,Map<String,headers,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(user, \"User must not be null\");\n\t\tString username = user;\n\t\tAssert.isTrue(!user.contains(\"%2F\"), () -> \"Invalid sequence \\\"%2F\\\" in user name: \" + username);\n\t\tuser = StringUtils.replace(user, \"/\", \"%2F\");\n\t\tdestination = destination.startsWith(\"/\") ? destination : \"/\" + destination;\n\t\tsuper.convertAndSend(this.destinationPrefix + user + destination, payload, headers, postProcessor);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tconvertAndSendToUser(user, destination, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#doSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "protected void doSend(String destination, Message<?> message)",
    "source_code": "\tprotected void doSend(String destination, Message<?> message) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSimpMessageHeaderAccessor simpAccessor =\n\t\t\t\tMessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class);\n\n\t\tif (simpAccessor != null) {\n\t\t\tif (simpAccessor.isMutable()) {\n\t\t\t\tsimpAccessor.setDestination(destination);\n\t\t\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\t\t\tsimpAccessor.setImmutable();\n\t\t\t\tsendInternal(message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try and keep the original accessor type\n\t\t\t\tsimpAccessor = (SimpMessageHeaderAccessor) MessageHeaderAccessor.getMutableAccessor(message);\n\t\t\t\tinitHeaders(simpAccessor);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsimpAccessor = SimpMessageHeaderAccessor.wrap(message);\n\t\t\tinitHeaders(simpAccessor);\n\t\t}\n\n\t\tsimpAccessor.setDestination(destination);\n\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), simpAccessor.getMessageHeaders());\n\t\tsendInternal(message);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#processHeadersToSend(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new map and puts the given headers under the key\n\t * {@link NativeMessageHeaderAccessor#NATIVE_HEADERS NATIVE_HEADERS NATIVE_HEADERS NATIVE_HEADERS}.\n\t * effectively treats the input header map as headers to be sent out to the\n\t * destination.\n\t * <p>However if the given headers already contain the key\n\t * {@code NATIVE_HEADERS NATIVE_HEADERS} then the same headers instance is\n\t * returned without changes.\n\t * <p>Also if the given headers were prepared and obtained with\n\t * {@link SimpMessageHeaderAccessor#getMessageHeaders()} then the same headers\n\t * instance is also returned without changes.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\tif (headers == null) {\n\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\tinitHeaders(headerAccessor);\n\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\treturn headerAccessor.getMessageHeaders();\n\t\t}\n\t\tif (headers.containsKey(NativeMessageHeaderAccessor.NATIVE_HEADERS)) {\n\t\t\treturn headers;\n\t\t}\n\t\tif (headers instanceof MessageHeaders messageHeaders) {\n\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(messageHeaders, SimpMessageHeaderAccessor.class);\n\t\t\tif (accessor != null) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t}\n\n\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\tinitHeaders(headerAccessor);\n\t\theaders.forEach((key, value) -> headerAccessor.setNativeHeader(key, (value != null ? value.toString() : null)));\n\t\treturn headerAccessor.getMessageHeaders();\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "SimpMessageMappingInfo",
    "signature": "protected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tMessageMapping messageAnn = AnnotatedElementUtils.findMergedAnnotation(method, MessageMapping.class);\n\t\tif (messageAnn != null) {\n\t\t\tMessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class);\n\t\t\t// Only actually register it if there are destinations specified;\n\t\t\t// otherwise @MessageMapping is just being used as a (meta-annotation) marker.\n\t\t\tif (messageAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {\n\t\t\t\tSimpMessageMappingInfo result = createMessageMappingCondition(messageAnn.value());\n\t\t\t\tif (typeAnn != null) {\n\t\t\t\t\tresult = createMessageMappingCondition(typeAnn.value()).combine(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tSubscribeMapping subscribeAnn = AnnotatedElementUtils.findMergedAnnotation(method, SubscribeMapping.class);\n\t\tif (subscribeAnn != null) {\n\t\t\tMessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class);\n\t\t\t// Only actually register it if there are destinations specified;\n\t\t\t// otherwise @SubscribeMapping is just being used as a (meta-annotation) marker.\n\t\t\tif (subscribeAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {\n\t\t\t\tSimpMessageMappingInfo result = createSubscribeMappingCondition(subscribeAnn.value());\n\t\t\t\tif (typeAnn != null) {\n\t\t\t\t\tresult = createMessageMappingCondition(typeAnn.value()).combine(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getMatchingMapping(mapping,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "SimpMessageMappingInfo",
    "signature": "protected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message)",
    "source_code": "\tprotected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message) {\n\t\treturn mapping.getMatchingCondition(message);\n\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getTargetDestinations(annotation,message,defaultPrefix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotation",
      "message",
      "defaultPrefix"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "String[]",
    "signature": "protected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix)",
    "source_code": "\tprotected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix) {\n\t\tif (annotation != null) {\n\t\t\tString[] value = (String[]) AnnotationUtils.getValue(annotation);\n\t\t\tif (!ObjectUtils.isEmpty(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tString name = DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER;\n\t\tString destination = (String) message.getHeaders().get(name);\n\t\tif (!StringUtils.hasText(destination)) {\n\t\t\tthrow new IllegalStateException(\"No lookup destination header in \" + message);\n\t\t}\n\n\t\treturn (destination.startsWith(\"/\") ?\n\t\t\t\tnew String[] {defaultPrefix + destination} : new String[] {defaultPrefix + '/' + destination});\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getUserName(message,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "String",
    "signature": "protected String getUserName(Message<?> message, MessageHeaders headers)",
    "source_code": "\tprotected String getUserName(Message<?> message, MessageHeaders headers) {\n\t\tPrincipal principal = SimpMessageHeaderAccessor.getUser(headers);\n\t\tif (principal != null) {\n\t\t\treturn (principal instanceof DestinationUserNameProvider provider ?\n\t\t\t\t\tprovider.getDestinationUserName() : principal.getName());\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "protected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod,\n\t\t\tString lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod,\n\t\t\tString lookupDestination, Message<?> message) {\n\n\t\tSet<String> patterns = mapping.getDestinationConditions().getPatterns();\n\t\tif (!CollectionUtils.isEmpty(patterns)) {\n\t\t\tString pattern = patterns.iterator().next();\n\t\t\tMap<String, String> vars = getPathMatcher().extractUriTemplateVariables(pattern, lookupDestination);\n\t\t\tif (!CollectionUtils.isEmpty(vars)) {\n\t\t\t\tMessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\t\t\tAssert.state(mha != null && mha.isMutable(), \"Mutable MessageHeaderAccessor required\");\n\t\t\t\tmha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\tsuper.handleMatch(mapping, handlerMethod, lookupDestination, message);\n\t\t}\n\t\tfinally {\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\t\tDestinationHelper destinationHelper = getDestinationHelper(headers, returnType);\n\n\t\tSendToUser sendToUser = destinationHelper.getSendToUser();\n\t\tif (sendToUser != null) {\n\t\t\tboolean broadcast = sendToUser.broadcast();\n\t\t\tString user = getUserName(message, headers);\n\t\t\tif (user == null) {\n\t\t\t\tif (sessionId == null) {\n\t\t\t\t\tthrow new MissingSessionUserException(message);\n\t\t\t\t}\n\t\t\t\tuser = sessionId;\n\t\t\t\tbroadcast = false;\n\t\t\t}\n\t\t\tString[] destinations = getTargetDestinations(sendToUser, message, this.defaultUserDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tif (broadcast) {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(null, returnType));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSendTo sendTo = destinationHelper.getSendTo();\n\t\tif (sendTo != null || sendToUser == null) {\n\t\t\tString[] destinations = getTargetDestinations(sendTo, message, this.defaultDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tthis.messagingTemplate.convertAndSend(destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#afterSendCompletion(message,channel,sent,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "public void afterSendCompletion(Message<?> message, MessageChannel channel, boolean sent, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterSendCompletion(\n\t\t\t\tMessage<?> message, MessageChannel channel, boolean sent, @Nullable Exception ex) {\n\n\t\t\tif (!sent) {\n\t\t\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());\n\t\t\t\tif (SimpMessageType.DISCONNECT.equals(messageType)) {\n\t\t\t\t\tlogger.debug(\"Detected unsent DISCONNECT message. Processing anyway.\");\n\t\t\t\t\thandleMessage(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#sendMessageToSubscribers(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "void",
    "signature": "protected void sendMessageToSubscribers(@Nullable String destination, Message<?> message)",
    "source_code": "\tprotected void sendMessageToSubscribers(@Nullable String destination, Message<?> message) {\n\t\tMultiValueMap<String,String> subscriptions = this.subscriptionRegistry.findSubscriptions(message);\n\t\tif (!subscriptions.isEmpty() && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Broadcasting to \" + subscriptions.size() + \" sessions.\");\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tsubscriptions.forEach((sessionId, subscriptionIds) -> {\n\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\t\tinitHeaders(headerAccessor);\n\t\t\t\theaderAccessor.setSessionId(sessionId);\n\t\t\t\theaderAccessor.setSubscriptionId(subscriptionId);\n\t\t\t\theaderAccessor.copyHeadersIfAbsent(message.getHeaders());\n\t\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\t\tObject payload = message.getPayload();\n\t\t\t\tMessage<?> reply = MessageBuilder.createMessage(payload, headerAccessor.getMessageHeaders());\n\t\t\t\tSessionInfo info = this.sessions.get(sessionId);\n\t\t\t\tif (info != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinfo.getClientOutboundChannel().send(reply);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\t\tlogger.error(\"Failed to send \" + message, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tinfo.setLastWriteTime(now);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#add(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\theaderValues.add(headerValue);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#addAll(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "void",
    "signature": "public void addAll(String headerName, List<? extends String> headerValues)",
    "source_code": "\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tList<String> currentValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\tcurrentValues.addAll(headerValues);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#forward(message,accessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "accessor"
    ],
    "position": {
      "column": 1,
      "line": 1101
    },
    "return": "CompletableFuture<Void>",
    "signature": "public CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor)",
    "source_code": "\t\tpublic CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor) {\n\t\t\ttry {\n\t\t\t\tCompletableFuture<Void> future = super.forward(message, accessor);\n\t\t\t\tif (message.getHeaders().get(SimpMessageHeaderAccessor.IGNORE_ERROR) == null) {\n\t\t\t\t\tfuture.get();\n\t\t\t\t}\n\t\t\t\treturn future;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new MessageDeliveryException(message, ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#handleTcpConnectionFailure(error,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked when any TCP connectivity issue is detected, i.e. failure to establish\n\t\t * the TCP connection, failure to send a message, missed heartbeat, etc.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "error",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String error, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String error, @Nullable Throwable ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"TCP connection failure in session \" + this.sessionId + \": \" + error, ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsendStompErrorFrameToClient(error);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failure while clearing TCP connection state in session \" + this.sessionId, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#handleTcpConnectionFailure(errorMessage,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "errorMessage",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1089
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex) {\n\t\t\tsuper.handleTcpConnectionFailure(errorMessage, ex);\n\t\t\tpublishBrokerUnavailableEvent();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#readOnlyStompHeaders(Map<String,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code StompHeaders} object that can only be read, not written to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "StompHeaders",
    "signature": "public StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers)",
    "source_code": "\tpublic static StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers) {\n\t\treturn new StompHeaders((headers != null ? headers : Collections.emptyMap()), true);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#set(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = new ArrayList<>(1);\n\t\theaderValues.add(headerValue);\n\t\tthis.headers.put(headerName, headerValues);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setSystemSubscriptions(Map<String,subscriptions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more destinations to subscribe to on the shared \"system\"\n\t * connection along with MessageHandler's to handle received messages.\n\t * <p>This is for internal use in a multi-application server scenario where\n\t * servers forward messages to each other (e.g. unresolved user destinations).\n\t * @param subscriptions the destinations to subscribe to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "subscriptions"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "public void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions)",
    "source_code": "\tpublic void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {\n\t\tthis.systemSubscriptions.clear();\n\t\tif (subscriptions != null) {\n\t\t\tthis.systemSubscriptions.putAll(subscriptions);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#addInterceptor(index,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, ChannelInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, ChannelInterceptor interceptor) {\n\t\tsuper.addInterceptor(index, interceptor);\n\t\tupdateExecutorInterceptorsFor(interceptor);\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#applyPostSend(message,channel,sent)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void applyPostSend(Message<?> message, MessageChannel channel, boolean sent)",
    "source_code": "\t\tpublic void applyPostSend(Message<?> message, MessageChannel channel, boolean sent) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tinterceptor.postSend(message, channel, sent);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#send(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic final boolean send(Message<?> message, long timeout) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tMessage<?> messageToUse = message;\n\t\tChannelInterceptorChain chain = new ChannelInterceptorChain();\n\t\tboolean sent = false;\n\t\ttry {\n\t\t\tmessageToUse = chain.applyPreSend(messageToUse, this);\n\t\t\tif (messageToUse == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsent = sendInternal(messageToUse, timeout);\n\t\t\tchain.applyPostSend(messageToUse, this, sent);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, null);\n\t\t\treturn sent;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex);\n\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\tthrow messagingException;\n\t\t\t}\n\t\t\tthrow new MessageDeliveryException(messageToUse,\"Failed to send message to \" + this, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\tMessageDeliveryException ex2 =\n\t\t\t\t\tnew MessageDeliveryException(messageToUse, \"Failed to send message to \" + this, err);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex2);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#sendInternal(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor == null) {\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#triggerAfterReceiveCompletion(message,channel,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void triggerAfterReceiveCompletion(@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex)",
    "source_code": "\t\tpublic void triggerAfterReceiveCompletion(\n\t\t\t\t@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.receiveInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterReceiveCompletion(message, channel, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Exception from afterReceiveCompletion in \" + interceptor, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#triggerAfterSendCompletion(message,channel,sent,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex)",
    "source_code": "\t\tpublic void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.sendInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterSendCompletion(message, channel, sent, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.error(\"Exception from afterSendCompletion in \" + interceptor, ex2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#applyNamedParameterToQuery(queryObject,paramName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject",
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1115
    },
    "return": "void",
    "signature": "protected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)",
    "source_code": "\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)\n\t\t\tthrows HibernateException {\n\n\t\tif (value instanceof Collection<?> collection) {\n\t\t\tqueryObject.setParameterList(paramName, collection);\n\t\t}\n\t\telse if (value instanceof Object[] array) {\n\t\t\tqueryObject.setParameterList(paramName, array);\n\t\t}\n\t\telse {\n\t\t\tqueryObject.setParameter(paramName, value);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#bulkUpdate(queryString,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryString",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1014
    },
    "return": "int",
    "signature": "public int bulkUpdate(String queryString, @Nullable Object... values)",
    "source_code": "\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void delete(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\tsession.delete(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doExecute(action,enforceNativeSession)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "action",
      "enforceNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "T",
    "signature": "protected T doExecute(HibernateCallback<T> action, boolean enforceNativeSession)",
    "source_code": "\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(String entityName, T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(exampleEntity, \"Example entity must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria executableCriteria = (entityName != null ?\n\t\t\t\t\tsession.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass()));\n\t\t\texecutableCriteria.add(Example.create(exampleEntity));\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(exampleEntity,firstResult,maxResults)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id)",
    "source_code": "\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1150
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Session interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Invoke method on target Session.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t// If return value is a Query or Criteria, apply transaction timeout.\n\t\t\t\t// Applies to createQuery, getNamedQuery, createCriteria.\n\t\t\t\tif (retVal instanceof Criteria criteria) {\n\t\t\t\t\tprepareCriteria(criteria);\n\t\t\t\t}\n\t\t\t\telse if (retVal instanceof Query<?> query) {\n\t\t\t\t\tprepareQuery(query);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entity,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void load(Object entity, Serializable id)",
    "source_code": "\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityClass, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id)",
    "source_code": "\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void lock(Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void lock(String entityName, Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(String entityName, Object entity, LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#merge(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#persist(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "public void persist(String entityName, Object entity)",
    "source_code": "\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#refresh(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void refresh(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entity,replicationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void replicate(Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entityName,entity,replicationMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void replicate(String entityName, Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entityName, entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#save(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "Serializable",
    "signature": "public Serializable save(String entityName, Object entity)",
    "source_code": "\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#saveOrUpdate(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void saveOrUpdate(String entityName, Object entity)",
    "source_code": "\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void update(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity,lockMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entityName, entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#postProcessEntityManagerFactory(emf,pui)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook method allowing subclasses to customize the EntityManagerFactory\n\t * after its creation via the PersistenceProvider.\n\t * <p>The default implementation is empty.\n\t * @param emf the newly created EntityManagerFactory we are working with\n\t * @param pui the PersistenceUnitInfo used to configure the EntityManagerFactory\n\t * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "emf",
      "pui"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "void",
    "signature": "protected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui)",
    "source_code": "\tprotected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui) {\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#createContainerEntityManagerFactory(info,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "info",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties)",
    "source_code": "\tpublic EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties) {\n\t\tfinal List<String> mergedClassesAndPackages = new ArrayList<>(info.getManagedClassNames());\n\t\tif (info instanceof SmartPersistenceUnitInfo smartInfo) {\n\t\t\tmergedClassesAndPackages.addAll(smartInfo.getManagedPackages());\n\t\t}\n\t\treturn new EntityManagerFactoryBuilderImpl(\n\t\t\t\tnew PersistenceUnitInfoDescriptor(info) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic List<String> getManagedClassNames() {\n\t\t\t\t\t\treturn mergedClassesAndPackages;\n\t\t\t\t\t}\n\t\t\t\t}, properties).build();\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshal(graph,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshals the object graph with the given root into the provided {@code javax.xml.transform.Result}.\n\t * <p>This implementation inspects the given result, and calls {@code marshalDomResult},\n\t * {@code marshalSaxResult}, or {@code marshalStreamResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param result the result to marshal to\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code result} if neither a {@code DOMResult},\n\t * a {@code SAXResult}, nor a {@code StreamResult}\n\t * @see #marshalDomResult(Object, javax.xml.transform.dom.DOMResult)\n\t * @see #marshalSaxResult(Object, javax.xml.transform.sax.SAXResult)\n\t * @see #marshalStreamResult(Object, javax.xml.transform.stream.StreamResult)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic final void marshal(Object graph, Result result) throws IOException, XmlMappingException {\n\t\tif (result instanceof DOMResult domResult) {\n\t\t\tmarshalDomResult(graph, domResult);\n\t\t}\n\t\telse if (StaxUtils.isStaxResult(result)) {\n\t\t\tmarshalStaxResult(graph, result);\n\t\t}\n\t\telse if (result instanceof SAXResult saxResult) {\n\t\t\tmarshalSaxResult(graph, saxResult);\n\t\t}\n\t\telse if (result instanceof StreamResult streamResult) {\n\t\t\tmarshalStreamResult(graph, streamResult);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Result type: \" + result.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalDomNode(graph,node)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a DOM {@code Node}.\n\t * <p>In practice, {@code node} is a {@code Document} node, a {@code DocumentFragment} node,\n\t * or a {@code Element} node. In other words, a node that accepts children.\n\t * @param graph the root of the object graph to marshal\n\t * @param node the DOM node that will contain the result tree\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t * @see org.w3c.dom.Document\n\t * @see org.w3c.dom.DocumentFragment\n\t * @see org.w3c.dom.Element\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "node"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "protected void marshalDomNode(Object graph, Node node)",
    "source_code": "\tprotected abstract void marshalDomNode(Object graph, Node node)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}."
  },
  "org.springframework.oxm.support.<unknown>#marshalDomResult(graph,domResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code DOMResult}s.\n\t * <p>This implementation delegates to {@code marshalDomNode}.\n\t * @param graph the root of the object graph to marshal\n\t * @param domResult the {@code DOMResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "domResult"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "protected void marshalDomResult(Object graph, DOMResult domResult)",
    "source_code": "\tprotected void marshalDomResult(Object graph, DOMResult domResult) throws XmlMappingException {\n\t\tif (domResult.getNode() == null) {\n\t\t\tdomResult.setNode(buildDocument());\n\t\t}\n\t\tmarshalDomNode(graph, domResult.getNode());\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalOutputStream(graph,outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}.\n\t * @param graph the root of the object graph to marshal\n\t * @param outputStream the {@code OutputStream} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "protected void marshalOutputStream(Object graph, OutputStream outputStream)",
    "source_code": "\tprotected abstract void marshalOutputStream(Object graph, OutputStream outputStream)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code Writer}."
  },
  "org.springframework.oxm.support.<unknown>#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}.\n\t * @param graph the root of the object graph to marshal\n\t * @param contentHandler the SAX {@code ContentHandler}\n\t * @param lexicalHandler the SAX2 {@code LexicalHandler}. Can be {@code null}.\n\t * @throws XmlMappingException if the given object cannot be marshalled to the handlers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected abstract void marshalSaxHandlers(\n\t\t\tObject graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}."
  },
  "org.springframework.oxm.support.<unknown>#marshalSaxResult(graph,saxResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code SAXResult}s.\n\t * <p>This implementation delegates to {@code marshalSaxHandlers}.\n\t * @param graph the root of the object graph to marshal\n\t * @param saxResult the {@code SAXResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @see #marshalSaxHandlers(Object, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "saxResult"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void marshalSaxResult(Object graph, SAXResult saxResult)",
    "source_code": "\tprotected void marshalSaxResult(Object graph, SAXResult saxResult) throws XmlMappingException {\n\t\tContentHandler contentHandler = saxResult.getHandler();\n\t\tAssert.notNull(contentHandler, \"ContentHandler not set on SAXResult\");\n\t\tLexicalHandler lexicalHandler = saxResult.getLexicalHandler();\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalStaxResult(graph,staxResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StaxResult}s.\n\t * <p>This implementation delegates to {@code marshalXMLSteamWriter} or\n\t * {@code marshalXMLEventConsumer}, depending on what is contained in the\n\t * {@code StaxResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param staxResult a JAXP 1.4 {@link StAXSource}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "staxResult"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "protected void marshalStaxResult(Object graph, Result staxResult)",
    "source_code": "\tprotected void marshalStaxResult(Object graph, Result staxResult) throws XmlMappingException {\n\t\tXMLStreamWriter streamWriter = StaxUtils.getXMLStreamWriter(staxResult);\n\t\tif (streamWriter != null) {\n\t\t\tmarshalXmlStreamWriter(graph, streamWriter);\n\t\t}\n\t\telse {\n\t\t\tXMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);\n\t\t\tif (eventWriter != null) {\n\t\t\t\tmarshalXmlEventWriter(graph, eventWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxResult contains neither XMLStreamWriter nor XMLEventConsumer\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalStreamResult(graph,streamResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StreamResult}s.\n\t * <p>This implementation delegates to {@code marshalOutputStream} or {@code marshalWriter},\n\t * depending on what is contained in the {@code StreamResult}\n\t * @param graph the root of the object graph to marshal\n\t * @param streamResult the {@code StreamResult}\n\t * @throws IOException if an I/O Exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code streamResult} does neither\n\t * contain an {@code OutputStream} nor a {@code Writer}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamResult"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "protected void marshalStreamResult(Object graph, StreamResult streamResult)",
    "source_code": "\tprotected void marshalStreamResult(Object graph, StreamResult streamResult)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (streamResult.getOutputStream() != null) {\n\t\t\tmarshalOutputStream(graph, streamResult.getOutputStream());\n\t\t}\n\t\telse if (streamResult.getWriter() != null) {\n\t\t\tmarshalWriter(graph, streamResult.getWriter());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"StreamResult contains neither OutputStream nor Writer\");\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalWriter(graph,writer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code Writer}.\n\t * @param graph the root of the object graph to marshal\n\t * @param writer the {@code Writer} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "void",
    "signature": "protected void marshalWriter(Object graph, Writer writer)",
    "source_code": "\tprotected abstract void marshalWriter(Object graph, Writer writer)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given DOM {@code Node}."
  },
  "org.springframework.oxm.support.<unknown>#marshalXmlEventWriter(graph,eventWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param eventWriter the {@code XMLEventWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected abstract void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}."
  },
  "org.springframework.oxm.support.<unknown>#marshalXmlStreamWriter(graph,streamWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param streamWriter the {@code XMLStreamWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamWriter"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)",
    "source_code": "\tprotected abstract void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}."
  },
  "org.springframework.oxm.support.<unknown>#unmarshalSaxReader(xmlReader,inputSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling using a given SAX {@code XMLReader}\n\t * and {@code InputSource}.\n\t * @param xmlReader the SAX {@code XMLReader} to parse with\n\t * @param inputSource the input source to parse from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given reader and input source cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xmlReader",
      "inputSource"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)",
    "source_code": "\tprotected abstract Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given {@code InputStream}."
  },
  "org.springframework.r2dbc.connection.<unknown>#convertR2dbcException(task,sql,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given {@link R2dbcException} into a generic {@link DataAccessException}.\n\t * <p>The returned DataAccessException is supposed to contain the original\n\t * {@link R2dbcException} as root cause. However, client code may not generally\n\t * rely on this due to DataAccessExceptions possibly being caused by other resource\n\t * APIs as well. That said, a {@code getRootCause() instanceof R2dbcException}\n\t * check (and subsequent cast) is considered reliable when expecting R2DBC-based\n\t * access to have happened.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (if known)\n\t * @param ex the offending {@link R2dbcException}\n\t * @return the corresponding DataAccessException instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "DataAccessException",
    "signature": "public DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex)",
    "source_code": "\tpublic static DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex) {\n\t\tif (ex instanceof R2dbcTransientException) {\n\t\t\tif (ex instanceof R2dbcTransientResourceException) {\n\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcRollbackException) {\n\t\t\t\tif (\"40001\".equals(ex.getSqlState())) {\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new PessimisticLockingFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcTimeoutException) {\n\t\t\t\treturn new QueryTimeoutException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof R2dbcNonTransientException) {\n\t\t\tif (ex instanceof R2dbcNonTransientResourceException) {\n\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcDataIntegrityViolationException) {\n\t\t\t\tif (indicatesDuplicateKey(ex.getSqlState(), ex.getErrorCode())) {\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcPermissionDeniedException) {\n\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcBadGrammarException) {\n\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), ex);\n\t\t\t}\n\t\t}\n\t\treturn new UncategorizedR2dbcException(buildMessage(task, sql, ex), sql, ex);\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doReleaseConnection(connection,connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually close the given {@link Connection}, obtained from the given\n\t * {@link ConnectionFactory}. Same as {@link #releaseConnection},\n\t * but preserving the original exception.\n\t * @param connection the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #doGetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory) {\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction()\n\t\t\t\t.flatMap(synchronizationManager -> {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, connection)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t}\n\t\t\treturn Mono.from(connection.close());\n\t\t}).onErrorResume(NoTransactionException.class, e -> Mono.from(connection.close()));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#releaseConnection(con,connectionFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given {@link Connection}, obtained from the given {@link ConnectionFactory}, if\n\t * it is not managed externally (that is, not bound to the subscription).\n\t * @param con the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #getConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory) {\n\t\treturn doReleaseConnection(con, connectionFactory)\n\t\t\t\t.onErrorMap(e -> new DataAccessResourceFailureException(\"Failed to close R2DBC Connection\", e));\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.<unknown>#setTargetConnectionFactories(Map<?,targetConnectionFactories)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target {@link ConnectionFactory ConnectionFactories},\n\t * with the lookup key as key. The mapped value can either be a corresponding\n\t * {@link ConnectionFactory} instance or a connection factory name String (to be\n\t * resolved via a {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the generic lookup\n\t * process only. The concrete key representation will be handled by\n\t * {@link #resolveSpecifiedLookupKey(Object)} and {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "targetConnectionFactories"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories)",
    "source_code": "\tpublic void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories) {\n\t\tthis.targetConnectionFactories = targetConnectionFactories;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#addCallback(successCallback,failureCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "successCallback",
      "failureCallback"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback)",
    "source_code": "\tpublic void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback) {\n\t\ttry {\n\t\t\tif (this.executionException != null) {\n\t\t\t\tfailureCallback.onFailure(exposedException(this.executionException));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccessCallback.onSuccess(this.value);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#buildAdvice(executor,exceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "executor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Advice",
    "signature": "protected Advice buildAdvice(@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tprotected Advice buildAdvice(\n\t\t\t@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tAnnotationAsyncExecutionInterceptor interceptor = new AnnotationAsyncExecutionInterceptor(null);\n\t\tinterceptor.configure(executor, exceptionHandler);\n\t\treturn interceptor;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createRunnable(target,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 5.1\n\t * @see ScheduledMethodRunnable#ScheduledMethodRunnable(Object, Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method) {\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic V get(long timeout, TimeUnit unit) throws ExecutionException {\n\t\treturn get();\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler ||\n\t\t\t\tbean instanceof ScheduledExecutorService) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, List.of(Scheduled.class, Schedules.class))) {\n\t\t\tMap<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {\n\t\t\t\t\t\tSet<Scheduled> scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, Scheduled.class, Schedules.class);\n\t\t\t\t\t\treturn (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @Scheduled annotations found on bean class: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, scheduledAnnotations) ->\n\t\t\t\t\t\tscheduledAnnotations.forEach(scheduled -> processScheduled(scheduled, method, bean)));\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(annotatedMethods.size() + \" @Scheduled methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tSet<ScheduledTask> tasks;\n\t\tsynchronized (this.scheduledTasks) {\n\t\t\ttasks = this.scheduledTasks.remove(bean);\n\t\t}\n\t\tif (tasks != null) {\n\t\t\tfor (ScheduledTask task : tasks) {\n\t\t\t\ttask.cancel();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#processScheduled(scheduled,method,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@code @Scheduled} method declaration on the given bean.\n\t * @param scheduled the {@code @Scheduled} annotation\n\t * @param method the method that the annotation has been declared on\n\t * @param bean the target bean instance\n\t * @see #createRunnable(Object, Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduled",
      "method",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "void",
    "signature": "protected void processScheduled(Scheduled scheduled, Method method, Object bean)",
    "source_code": "\tprotected void processScheduled(Scheduled scheduled, Method method, Object bean) {\n\t\ttry {\n\t\t\tRunnable runnable = createRunnable(bean, method);\n\t\t\tboolean processedSchedule = false;\n\t\t\tString errorMessage =\n\t\t\t\t\t\"Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required\";\n\n\t\t\tSet<ScheduledTask> tasks = new LinkedHashSet<>(4);\n\n\t\t\t// Determine initial delay\n\t\t\tDuration initialDelay = toDuration(scheduled.initialDelay(), scheduled.timeUnit());\n\t\t\tString initialDelayString = scheduled.initialDelayString();\n\t\t\tif (StringUtils.hasText(initialDelayString)) {\n\t\t\t\tAssert.isTrue(initialDelay.isNegative(), \"Specify 'initialDelay' or 'initialDelayString', not both\");\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tinitialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(initialDelayString)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinitialDelay = toDuration(initialDelayString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid initialDelayString value \\\"\" + initialDelayString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check cron expression\n\t\t\tString cron = scheduled.cron();\n\t\t\tif (StringUtils.hasText(cron)) {\n\t\t\t\tString zone = scheduled.zone();\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tcron = this.embeddedValueResolver.resolveStringValue(cron);\n\t\t\t\t\tzone = this.embeddedValueResolver.resolveStringValue(zone);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(cron)) {\n\t\t\t\t\tAssert.isTrue(initialDelay.isNegative(), \"'initialDelay' not supported for cron triggers\");\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\tif (!Scheduled.CRON_DISABLED.equals(cron)) {\n\t\t\t\t\t\tTimeZone timeZone;\n\t\t\t\t\t\tif (StringUtils.hasText(zone)) {\n\t\t\t\t\t\t\ttimeZone = StringUtils.parseTimeZoneString(zone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttimeZone = TimeZone.getDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// At this point we don't need to differentiate between initial delay set or not anymore\n\t\t\tif (initialDelay.isNegative()) {\n\t\t\t\tinitialDelay = Duration.ZERO;\n\t\t\t}\n\n\t\t\t// Check fixed delay\n\t\t\tDuration fixedDelay = toDuration(scheduled.fixedDelay(), scheduled.timeUnit());\n\t\t\tif (!fixedDelay.isNegative()) {\n\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\tprocessedSchedule = true;\n\t\t\t\ttasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));\n\t\t\t}\n\n\t\t\tString fixedDelayString = scheduled.fixedDelayString();\n\t\t\tif (StringUtils.hasText(fixedDelayString)) {\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tfixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(fixedDelayString)) {\n\t\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfixedDelay = toDuration(fixedDelayString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid fixedDelayString value \\\"\" + fixedDelayString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t\ttasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check fixed rate\n\t\t\tDuration fixedRate = toDuration(scheduled.fixedRate(), scheduled.timeUnit());\n\t\t\tif (!fixedRate.isNegative()) {\n\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\tprocessedSchedule = true;\n\t\t\t\ttasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));\n\t\t\t}\n\t\t\tString fixedRateString = scheduled.fixedRateString();\n\t\t\tif (StringUtils.hasText(fixedRateString)) {\n\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\tfixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(fixedRateString)) {\n\t\t\t\t\tAssert.isTrue(!processedSchedule, errorMessage);\n\t\t\t\t\tprocessedSchedule = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfixedRate = toDuration(fixedRateString, scheduled.timeUnit());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Invalid fixedRateString value \\\"\" + fixedRateString + \"\\\" - cannot parse into long\");\n\t\t\t\t\t}\n\t\t\t\t\ttasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check whether we had any attribute set\n\t\t\tAssert.isTrue(processedSchedule, errorMessage);\n\n\t\t\t// Finally register the scheduled tasks\n\t\t\tsynchronized (this.scheduledTasks) {\n\t\t\t\tSet<ScheduledTask> regTasks = this.scheduledTasks.computeIfAbsent(bean, key -> new LinkedHashSet<>(4));\n\t\t\t\tregTasks.addAll(tasks);\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Encountered invalid @Scheduled method '\" + method.getName() + \"': \" + ex.getMessage());\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#buildManagedTask(task,identityName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "identityName"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Callable<T>",
    "signature": "public Callable<T> buildManagedTask(Callable<T> task, String identityName)",
    "source_code": "\t\tpublic static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {\n\t\t\tMap<String, String> properties = new HashMap<>(2);\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#registerTasks(tasks,executor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks}\n\t * on the given {@link ScheduledExecutorService}.\n\t * @param tasks the specified ScheduledExecutorTasks (never empty)\n\t * @param executor the ScheduledExecutorService to register the tasks on.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tasks",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor)",
    "source_code": "\tprotected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor) {\n\t\tfor (ScheduledExecutorTask task : tasks) {\n\t\t\tRunnable runnable = getRunnableToSchedule(task);\n\t\t\tif (task.isOneTimeTask()) {\n\t\t\t\texecutor.schedule(runnable, task.getDelay(), task.getTimeUnit());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (task.isFixedRate()) {\n\t\t\t\t\texecutor.scheduleAtFixedRate(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texecutor.scheduleWithFixedDelay(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#newJob(bundle,scheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bundle",
      "scheduler"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "Job",
    "signature": "public Job newJob(TriggerFiredBundle bundle, Scheduler scheduler)",
    "source_code": "\tpublic Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException {\n\t\ttry {\n\t\t\tObject jobObject = createJobInstance(bundle);\n\t\t\treturn adaptJob(jobObject);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SchedulerException(\"Job instantiation failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#setCalendars(Map<String,calendars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of Quartz Calendar objects with the Scheduler\n\t * that this FactoryBean creates, to be referenced by Triggers.\n\t * @param calendars a Map with calendar names as keys as Calendar\n\t * objects as values\n\t * @see org.quartz.Calendar\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "calendars"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setCalendars(Map<String, Calendar> calendars)",
    "source_code": "\tpublic void setCalendars(Map<String, Calendar> calendars) {\n\t\tthis.calendars = calendars;\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#decorateTaskWithErrorHandler(task,errorHandler,isRepeatingTask)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the task for error handling. If the provided {@link ErrorHandler}\n\t * is not {@code null}, it will be used. Otherwise, repeating tasks will have\n\t * errors suppressed by default whereas one-shot tasks will have errors\n\t * propagated by default since those errors may be expected through the\n\t * returned {@link Future}. In both cases, the errors will be logged.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "errorHandler",
      "isRepeatingTask"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "DelegatingErrorHandlingRunnable",
    "signature": "public DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(Runnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask)",
    "source_code": "\tpublic static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(\n\t\t\tRunnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask) {\n\n\t\tif (task instanceof DelegatingErrorHandlingRunnable dehRunnable) {\n\t\t\treturn dehRunnable;\n\t\t}\n\t\tErrorHandler eh = (errorHandler != null ? errorHandler : getDefaultErrorHandler(isRepeatingTask));\n\t\treturn new DelegatingErrorHandlingRunnable(task, eh);\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and parse the BeanShell script via {@link BshScriptUtils}.\n\t * @see BshScriptUtils#createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tClass<?> clazz;\n\n\t\ttry {\n\t\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\t\tboolean requiresScriptEvaluation = (this.wasModifiedForTypeCheck && this.scriptClass == null);\n\t\t\t\tthis.wasModifiedForTypeCheck = false;\n\n\t\t\t\tif (scriptSource.isModified() || requiresScriptEvaluation) {\n\t\t\t\t\t// New script content: Let's check whether it evaluates to a Class.\n\t\t\t\t\tObject result = BshScriptUtils.evaluateBshScript(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader);\n\t\t\t\t\tif (result instanceof Class<?> type) {\n\t\t\t\t\t\t// A Class: We'll cache the Class here and create an instance\n\t\t\t\t\t\t// outside the synchronized block.\n\t\t\t\t\t\tthis.scriptClass = type;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Not a Class: OK, we'll simply create BeanShell objects\n\t\t\t\t\t\t// through evaluating the script for every call later on.\n\t\t\t\t\t\t// For this first-time check, let's simply return the\n\t\t\t\t\t\t// already evaluated object.\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclazz = this.scriptClass;\n\t\t\t}\n\t\t}\n\t\tcatch (EvalError ex) {\n\t\t\tthis.scriptClass = null;\n\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t}\n\n\t\tif (clazz != null) {\n\t\t\t// A Class: We need to create an instance for every call.\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Not a Class: We need to evaluate the script for every call.\n\t\t\ttry {\n\t\t\t\treturn BshScriptUtils.createBshObject(\n\t\t\t\t\t\tscriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader);\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#evaluate(script,Map<String,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments) {\n\t\tGroovyShell groovyShell = new GroovyShell(\n\t\t\t\tthis.classLoader, new Binding(arguments), this.compilerConfiguration);\n\t\ttry {\n\t\t\tString filename = (script instanceof ResourceScriptSource resourceScriptSource ?\n\t\t\t\t\tresourceScriptSource.getResource().getFilename() : null);\n\t\t\tif (filename != null) {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString(), filename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access Groovy script\", ex);\n\t\t}\n\t\tcatch (GroovyRuntimeException ex) {\n\t\t\tthrow new ScriptCompilationException(script, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#executeScript(scriptSource,scriptClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the given Groovy script class and run it if necessary.\n\t * @param scriptSource the source for the underlying script\n\t * @param scriptClass the Groovy script class\n\t * @return the result object (either an instance of the script class\n\t * or the result of running the script instance)\n\t * @throws ScriptCompilationException in case of instantiation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scriptSource",
      "scriptClass"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "Object",
    "signature": "protected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass)",
    "source_code": "\tprotected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass) throws ScriptCompilationException {\n\t\ttry {\n\t\t\tGroovyObject groovyObj = (GroovyObject) ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\n\t\t\tif (this.groovyObjectCustomizer != null) {\n\t\t\t\t// Allow metaclass and other customization.\n\t\t\t\tthis.groovyObjectCustomizer.customize(groovyObj);\n\t\t\t}\n\n\t\t\tif (groovyObj instanceof Script script) {\n\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\treturn script.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// An instance of the scripted class: let's return it as-is.\n\t\t\t\treturn groovyObj;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"No default constructor on Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InstantiationException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Unable to instantiate Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Could not access Groovy script constructor: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"Failed to invoke Groovy script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Loads and parses the Groovy script via the GroovyClassLoader.\n\t * @see groovy.lang.GroovyClassLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\ttry {\n\t\t\t\tClass<?> scriptClassToExecute;\n\t\t\t\tthis.wasModifiedForTypeCheck = false;\n\n\t\t\t\tif (this.cachedResult != null) {\n\t\t\t\t\tObject result = this.cachedResult.object;\n\t\t\t\t\tthis.cachedResult = null;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (this.scriptClass == null || scriptSource.isModified()) {\n\t\t\t\t\t// New script content...\n\t\t\t\t\tthis.scriptClass = getGroovyClassLoader().parseClass(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), scriptSource.suggestedClassName());\n\n\t\t\t\t\tif (Script.class.isAssignableFrom(this.scriptClass)) {\n\t\t\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\t\t\tObject result = executeScript(scriptSource, this.scriptClass);\n\t\t\t\t\t\tthis.scriptResultClass = (result != null ? result.getClass() : null);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.scriptResultClass = this.scriptClass;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscriptClassToExecute = this.scriptClass;\n\n\t\t\t\t// Process re-execution outside the synchronized block.\n\t\t\t\treturn executeScript(scriptSource, scriptClassToExecute);\n\t\t\t}\n\t\t\tcatch (CompilationFailedException ex) {\n\t\t\t\tthis.scriptClass = null;\n\t\t\t\tthis.scriptResultClass = null;\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#convertToScriptSource(beanName,scriptSourceLocator,resourceLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given script source locator to a ScriptSource instance.\n\t * <p>By default, supported locators are Spring resource locations\n\t * (such as \"file:C:/myScript.bsh\" or \"classpath:myPackage/myScript.bsh\")\n\t * and inline scripts (\"inline:myScriptText...\").\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator\n\t * @param resourceLoader the ResourceLoader to use (if necessary)\n\t * @return the ScriptSource instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator",
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,\n\t\t\tResourceLoader resourceLoader)",
    "source_code": "\tprotected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,\n\t\t\tResourceLoader resourceLoader) {\n\n\t\tif (scriptSourceLocator.startsWith(INLINE_SCRIPT_PREFIX)) {\n\t\t\treturn new StaticScriptSource(scriptSourceLocator.substring(INLINE_SCRIPT_PREFIX.length()), beanName);\n\t\t}\n\t\telse {\n\t\t\treturn new ResourceScriptSource(resourceLoader.getResource(scriptSourceLocator));\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#createRefreshableProxy(ts,interfaces,proxyTargetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a refreshable proxy for the given AOP TargetSource.\n\t * @param ts the refreshable TargetSource\n\t * @param interfaces the proxy interfaces (may be {@code null} to\n\t * indicate proxying of all interfaces implemented by the target class)\n\t * @return the generated proxy\n\t * @see RefreshableScriptTargetSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "interfaces",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Object",
    "signature": "protected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass)",
    "source_code": "\tprotected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.setTargetSource(ts);\n\t\tClassLoader classLoader = this.beanClassLoader;\n\n\t\tif (interfaces != null) {\n\t\t\tproxyFactory.setInterfaces(interfaces);\n\t\t}\n\t\telse {\n\t\t\tClass<?> targetClass = ts.getTargetClass();\n\t\t\tif (targetClass != null) {\n\t\t\t\tproxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.beanClassLoader));\n\t\t\t}\n\t\t}\n\n\t\tif (proxyTargetClass) {\n\t\t\tclassLoader = null;  // force use of Class.getClassLoader()\n\t\t\tproxyFactory.setProxyTargetClass(true);\n\t\t}\n\n\t\tDelegatingIntroductionInterceptor introduction = new DelegatingIntroductionInterceptor(ts);\n\t\tintroduction.suppressInterface(TargetSource.class);\n\t\tproxyFactory.addAdvice(introduction);\n\n\t\treturn proxyFactory.getProxy(classLoader);\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#createScriptedObjectBeanDefinition(bd,scriptFactoryBeanName,scriptSource,interfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean definition for the scripted object, based on the given script\n\t * definition, extracting the definition data that is relevant for the scripted\n\t * object (that is, everything but bean class and constructor arguments).\n\t * @param bd the full script bean definition\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptSource the ScriptSource for the scripted bean\n\t * @param interfaces the interfaces that the scripted bean is supposed to implement\n\t * @return the extracted ScriptFactory bean definition\n\t * @see org.springframework.scripting.ScriptFactory#getScriptedObject\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptSource",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "BeanDefinition",
    "signature": "protected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,\n\t\t\tScriptSource scriptSource, @Nullable Class<?>[] interfaces)",
    "source_code": "\tprotected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,\n\t\t\tScriptSource scriptSource, @Nullable Class<?>[] interfaces) {\n\n\t\tGenericBeanDefinition objectBd = new GenericBeanDefinition(bd);\n\t\tobjectBd.setFactoryBeanName(scriptFactoryBeanName);\n\t\tobjectBd.setFactoryMethodName(\"getScriptedObject\");\n\t\tobjectBd.getConstructorArgumentValues().clear();\n\t\tobjectBd.getConstructorArgumentValues().addIndexedArgumentValue(0, scriptSource);\n\t\tobjectBd.getConstructorArgumentValues().addIndexedArgumentValue(1, interfaces);\n\t\treturn objectBd;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#evaluate(script,Map<String,argumentBindings)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "argumentBindings"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings) {\n\t\tScriptEngine engine = getScriptEngine(script);\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(argumentBindings)) {\n\t\t\t\treturn engine.eval(script.getScriptAsString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBindings bindings = StandardScriptUtils.getBindings(argumentBindings);\n\t\t\t\treturn engine.eval(script.getScriptAsString(), bindings);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access script for ScriptEngine\", ex);\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ScriptCompilationException(script, new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#getScriptSource(beanName,scriptSourceLocator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a ScriptSource for the given bean, lazily creating it\n\t * if not cached already.\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator associated with the bean\n\t * @return the corresponding ScriptSource instance\n\t * @see #convertToScriptSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource getScriptSource(String beanName, String scriptSourceLocator)",
    "source_code": "\tprotected ScriptSource getScriptSource(String beanName, String scriptSourceLocator) {\n\t\treturn this.scriptSourceCache.computeIfAbsent(beanName, key ->\n\t\t\t\tconvertToScriptSource(beanName, scriptSourceLocator, this.resourceLoader));\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\t// We only apply special treatment to ScriptFactory implementations here.\n\t\tif (!ScriptFactory.class.isAssignableFrom(beanClass)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAssert.state(this.beanFactory != null, \"No BeanFactory set\");\n\t\tBeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);\n\t\tString scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName;\n\t\tString scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName;\n\t\tprepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName);\n\n\t\tScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\tScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\tboolean isFactoryBean = false;\n\t\ttry {\n\t\t\tClass<?> scriptedObjectType = scriptFactory.getScriptedObjectType(scriptSource);\n\t\t\t// Returned type may be null if the factory is unable to determine the type.\n\t\t\tif (scriptedObjectType != null) {\n\t\t\t\tisFactoryBean = FactoryBean.class.isAssignableFrom(scriptedObjectType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\"Could not determine scripted object type for \" + scriptFactory, ex);\n\t\t}\n\n\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\tif (refreshCheckDelay >= 0) {\n\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\t\t\tRefreshableScriptTargetSource ts = new RefreshableScriptTargetSource(this.scriptBeanFactory,\n\t\t\t\t\tscriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean);\n\t\t\tboolean proxyTargetClass = resolveProxyTargetClass(bd);\n\t\t\tString language = (String) bd.getAttribute(LANGUAGE_ATTRIBUTE);\n\t\t\tif (proxyTargetClass && (language == null || !language.equals(\"groovy\"))) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\n\t\t\t\t\t\t\"Cannot use proxyTargetClass=true with script beans where language is not 'groovy': '\" +\n\t\t\t\t\t\tlanguage + \"'\");\n\t\t\t}\n\t\t\tts.setRefreshCheckDelay(refreshCheckDelay);\n\t\t\treturn createRefreshableProxy(ts, interfaces, proxyTargetClass);\n\t\t}\n\n\t\tif (isFactoryBean) {\n\t\t\tscriptedObjectBeanName = BeanFactory.FACTORY_BEAN_PREFIX + scriptedObjectBeanName;\n\t\t}\n\t\treturn this.scriptBeanFactory.getBean(scriptedObjectBeanName);\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#prepareScriptBeans(bd,scriptFactoryBeanName,scriptedObjectBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the script beans in the internal BeanFactory that this\n\t * post-processor uses. Each original bean definition will be split\n\t * into a ScriptFactory definition and a scripted object definition.\n\t * @param bd the original bean definition in the main BeanFactory\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptedObjectBeanName the name of the internal scripted object bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptedObjectBeanName"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "protected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName)",
    "source_code": "\tprotected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {\n\t\t// Avoid recreation of the script bean definition in case of a prototype.\n\t\tsynchronized (this.scriptBeanFactory) {\n\t\t\tif (!this.scriptBeanFactory.containsBeanDefinition(scriptedObjectBeanName)) {\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(\n\t\t\t\t\t\tscriptFactoryBeanName, createScriptFactoryBeanDefinition(bd));\n\t\t\t\tScriptFactory scriptFactory =\n\t\t\t\t\t\tthis.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\t\t\tScriptSource scriptSource =\n\t\t\t\t\t\tgetScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\n\t\t\t\tClass<?>[] scriptedInterfaces = interfaces;\n\t\t\t\tif (scriptFactory.requiresConfigInterface() && !bd.getPropertyValues().isEmpty()) {\n\t\t\t\t\tClass<?> configInterface = createConfigInterface(bd, interfaces);\n\t\t\t\t\tscriptedInterfaces = ObjectUtils.addObjectToArray(interfaces, configInterface);\n\t\t\t\t}\n\n\t\t\t\tBeanDefinition objectBd = createScriptedObjectBeanDefinition(\n\t\t\t\t\t\tbd, scriptFactoryBeanName, scriptSource, scriptedInterfaces);\n\t\t\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\t\t\tif (refreshCheckDelay >= 0) {\n\t\t\t\t\tobjectBd.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(scriptedObjectBeanName, objectBd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#retrieveEngineByName(scriptEngineManager,engineName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a {@link ScriptEngine} from the given {@link ScriptEngineManager}\n\t * by name, delegating to {@link ScriptEngineManager#getEngineByName} but\n\t * throwing a descriptive exception if not found or if initialization failed.\n\t * @param scriptEngineManager the ScriptEngineManager to use\n\t * @param engineName the name of the engine\n\t * @return a corresponding ScriptEngine (never {@code null})\n\t * @throws IllegalArgumentException if no matching engine has been found\n\t * @throws IllegalStateException if the desired engine failed to initialize\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptEngineManager",
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "ScriptEngine",
    "signature": "public ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName)",
    "source_code": "\tpublic static ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName) {\n\t\tScriptEngine engine = scriptEngineManager.getEngineByName(engineName);\n\t\tif (engine == null) {\n\t\t\tSet<String> engineNames = new LinkedHashSet<>();\n\t\t\tfor (ScriptEngineFactory engineFactory : scriptEngineManager.getEngineFactories()) {\n\t\t\t\tList<String> factoryNames = engineFactory.getNames();\n\t\t\t\tif (factoryNames.contains(engineName)) {\n\t\t\t\t\t// Special case: getEngineByName returned null but engine is present...\n\t\t\t\t\t// Let's assume it failed to initialize (which ScriptEngineManager silently swallows).\n\t\t\t\t\t// If it happens to initialize fine now, alright, but we really expect an exception.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tengine = engineFactory.getScriptEngine();\n\t\t\t\t\t\tengine.setBindings(scriptEngineManager.getBindings(), ScriptContext.GLOBAL_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\t\t\t\"' failed to initialize\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tengineNames.addAll(factoryNames);\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\"' not found; registered engine names: \" + engineNames);\n\t\t}\n\t\treturn engine;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#setGlobalBindings(Map<String,globalBindings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the globally scoped bindings on the underlying script engine manager,\n\t * shared by all scripts, as an alternative to script argument bindings.\n\t * @since 4.2.2\n\t * @see #evaluate(ScriptSource, Map)\n\t * @see javax.script.ScriptEngineManager#setBindings(Bindings)\n\t * @see javax.script.SimpleBindings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "globalBindings"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setGlobalBindings(Map<String, Object> globalBindings)",
    "source_code": "\tpublic void setGlobalBindings(Map<String, Object> globalBindings) {\n\t\tBindings bindings = StandardScriptUtils.getBindings(globalBindings);\n\t\tthis.globalBindings = bindings;\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager != null) {\n\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.jdbc.<unknown>#processAheadOfTime(runtimeHints,testClass,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the supplied test class and its methods and register run-time\n\t * hints for any SQL scripts configured or detected as classpath resources\n\t * via {@link Sql @Sql}.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "testClass",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader)",
    "source_code": "\tpublic void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader) {\n\t\tgetSqlAnnotationsFor(testClass).forEach(sql ->\n\t\t\tregisterClasspathResources(getScripts(sql, testClass, null, true), runtimeHints, classLoader));\n\t\tgetSqlMethods(testClass).forEach(testMethod ->\n\t\t\tgetSqlAnnotationsFor(testMethod).forEach(sql ->\n\t\t\t\tregisterClasspathResources(getScripts(sql, testClass, testMethod, false), runtimeHints, classLoader)));\n\t}"
  },
  "org.springframework.ui.<unknown>#addAllAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#addAttribute(attributeName,attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (ignored if {@code null},\n\t * just removing an existing entry if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#mergeAttributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Object",
    "signature": "public Object put(String key, @Nullable Object value)",
    "source_code": "\tpublic Object put(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\treturn super.put(key, value);\n\t\t}\n\t\telse {\n\t\t\treturn remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.ui.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ?> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tfor (Map.Entry<? extends String, ?> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#addStringToArray(array,str)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given {@code String} to the given {@code String} array,\n\t * returning a new array consisting of the input array contents plus\n\t * the given {@code String}.\n\t * @param array the array to append to (can be {@code null})\n\t * @param str the {@code String} to append\n\t * @return the new array (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 961
    },
    "return": "String[]",
    "signature": "public String[] addStringToArray(@Nullable String[] array, String str)",
    "source_code": "\tpublic static String[] addStringToArray(@Nullable String[] array, String str) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tString[] newArr = new String[array.length + 1];\n\t\tSystem.arraycopy(array, 0, newArr, 0, array.length);\n\t\tnewArr[array.length] = str;\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#applyRelativePath(path,relativePath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given relative path to the given Java resource path,\n\t * assuming standard Java folder separation (i.e. \"/\" separators).\n\t * @param path the path to start from (usually a full file path)\n\t * @param relativePath the relative path to apply\n\t * (relative to the full file path above)\n\t * @return the full file path that results from applying the relative path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "String",
    "signature": "public String applyRelativePath(String path, String relativePath)",
    "source_code": "\tpublic static String applyRelativePath(String path, String relativePath) {\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (separatorIndex != -1) {\n\t\t\tString newPath = path.substring(0, separatorIndex);\n\t\t\tif (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n\t\t\t\tnewPath += FOLDER_SEPARATOR_CHAR;\n\t\t\t}\n\t\t\treturn newPath + relativePath;\n\t\t}\n\t\telse {\n\t\t\treturn relativePath;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#arrayToDelimitedString(arr,delim)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code String} array into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param arr the array to display (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arr",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1324
    },
    "return": "String",
    "signature": "public String arrayToDelimitedString(@Nullable Object[] arr, String delim)",
    "source_code": "\tpublic static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {\n\t\tif (ObjectUtils.isEmpty(arr)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (arr.length == 1) {\n\t\t\treturn ObjectUtils.nullSafeToString(arr[0]);\n\t\t}\n\n\t\tStringJoiner sj = new StringJoiner(delim);\n\t\tfor (Object elem : arr) {\n\t\t\tsj.add(String.valueOf(elem));\n\t\t}\n\t\treturn sj.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#collectionToDelimitedString(coll,delim)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1303
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim)",
    "source_code": "\tpublic static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {\n\t\treturn collectionToDelimitedString(coll, delim, \"\", \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#collectionToDelimitedString(coll,delim,prefix,suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @param prefix the {@code String} to start each element with\n\t * @param suffix the {@code String} to end each element with\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim",
      "prefix",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 1273
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim, String prefix, String suffix)",
    "source_code": "\tpublic static String collectionToDelimitedString(\n\t\t\t@Nullable Collection<?> coll, String delim, String prefix, String suffix) {\n\n\t\tif (CollectionUtils.isEmpty(coll)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tint totalLength = coll.size() * (prefix.length() + suffix.length()) + (coll.size() - 1) * delim.length();\n\t\tfor (Object element : coll) {\n\t\t\ttotalLength += String.valueOf(element).length();\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder(totalLength);\n\t\tIterator<?> it = coll.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tsb.append(prefix).append(it.next()).append(suffix);\n\t\t\tif (it.hasNext()) {\n\t\t\t\tsb.append(delim);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#concatenateStringArrays(array1,array2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array1",
      "array2"
    ],
    "position": {
      "column": 1,
      "line": 981
    },
    "return": "String[]",
    "signature": "public String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2)",
    "source_code": "\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#contains(enumeration,element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Enumeration<?> enumeration, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tObject candidate = enumeration.nextElement();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#contains(iterator,element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Iterator contains the given element.\n\t * @param iterator the Iterator to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "iterator",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Iterator<?> iterator, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\n\t\tif (iterator != null) {\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject candidate = iterator.next();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#containsAny(source,candidates)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if any element in '{@code candidates}' is\n\t * contained in '{@code source}'; otherwise returns {@code false}.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return whether any of the candidates has been found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "boolean",
    "signature": "public boolean containsAny(Collection<?> source, Collection<?> candidates)",
    "source_code": "\tpublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\n\t\treturn findFirstMatch(source, candidates) != null;\n\t}"
  },
  "org.springframework.util.<unknown>#containsInstance(collection,element)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Collection contains the given element instance.\n\t * <p>Enforces the given instance to be present, rather than returning\n\t * {@code true} for an equal element as well.\n\t * @param collection the Collection to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "public boolean containsInstance(@Nullable Collection<?> collection, Object element)",
    "source_code": "\tpublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\n\t\tif (collection != null) {\n\t\t\tfor (Object candidate : collection) {\n\t\t\t\tif (candidate == element) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#countOccurrencesOf(str,sub)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Count the occurrences of the substring {@code sub} in string {@code str}.\n\t * @param str string to search in\n\t * @param sub string to search for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "sub"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "int",
    "signature": "public int countOccurrencesOf(String str, String sub)",
    "source_code": "\tpublic static int countOccurrencesOf(String str, String sub) {\n\t\tif (!hasLength(str) || !hasLength(sub)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint count = 0;\n\t\tint pos = 0;\n\t\tint idx;\n\t\twhile ((idx = str.indexOf(sub, pos)) != -1) {\n\t\t\t++count;\n\t\t\tpos = idx + sub.length();\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.<unknown>#delete(inString,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delete all occurrences of the given substring.\n\t * @param inString the original {@code String}\n\t * @param pattern the pattern to delete all occurrences of\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "String",
    "signature": "public String delete(String inString, String pattern)",
    "source_code": "\tpublic static String delete(String inString, String pattern) {\n\t\treturn replace(inString, pattern, \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#deleteAny(inString,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delete any character in a given {@code String}.\n\t * @param inString the original {@code String}\n\t * @param charsToDelete a set of characters to delete.\n\t * E.g. \"az\\n\" will delete 'a's, 'z's and new lines.\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "String",
    "signature": "public String deleteAny(String inString, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String deleteAny(String inString, @Nullable String charsToDelete) {\n\t\tif (!hasLength(inString) || !hasLength(charsToDelete)) {\n\t\t\treturn inString;\n\t\t}\n\n\t\tint lastCharIndex = 0;\n\t\tchar[] result = new char[inString.length()];\n\t\tfor (int i = 0; i < inString.length(); i++) {\n\t\t\tchar c = inString.charAt(i);\n\t\t\tif (charsToDelete.indexOf(c) == -1) {\n\t\t\t\tresult[lastCharIndex++] = c;\n\t\t\t}\n\t\t}\n\t\tif (lastCharIndex == inString.length()) {\n\t\t\treturn inString;\n\t\t}\n\t\treturn new String(result, 0, lastCharIndex);\n\t}"
  },
  "org.springframework.util.<unknown>#delimitedListToStringArray(str,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into a\n\t * {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1191
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {\n\t\treturn delimitedListToStringArray(str, delimiter, null);\n\t}"
  },
  "org.springframework.util.<unknown>#delimitedListToStringArray(str,delimiter,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into\n\t * a {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @param charsToDelete a set of characters to delete; useful for deleting unwanted\n\t * line breaks: e.g. \"\\r\\n\\f\" will delete all new lines and line feeds in a {@code String}\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1210
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(\n\t\t\t@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\t\tif (delimiter == null) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tList<String> result = new ArrayList<>();\n\t\tif (delimiter.isEmpty()) {\n\t\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\t\tresult.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint pos = 0;\n\t\t\tint delPos;\n\t\t\twhile ((delPos = str.indexOf(delimiter, pos)) != -1) {\n\t\t\t\tresult.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n\t\t\t\tpos = delPos + delimiter.length();\n\t\t\t}\n\t\t\tif (str.length() > 0 && pos <= str.length()) {\n\t\t\t\t// Add rest of String, but not in case of empty input.\n\t\t\t\tresult.add(deleteAny(str.substring(pos), charsToDelete));\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(result);\n\t}"
  },
  "org.springframework.util.<unknown>#endsWithIgnoreCase(str,suffix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} ends with the specified suffix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param suffix the suffix to look for\n\t * @see java.lang.String#endsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "boolean",
    "signature": "public boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix)",
    "source_code": "\tpublic static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {\n\t\treturn (str != null && suffix != null && str.length() >= suffix.length() &&\n\t\t\t\tstr.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()));\n\t}"
  },
  "org.springframework.util.<unknown>#findFirstMatch(source,candidates)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "E",
    "signature": "public E findFirstMatch(Collection<?> source, Collection<E> candidates)",
    "source_code": "\tpublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\n\t\tif (isEmpty(source) || isEmpty(candidates)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (E candidate : candidates) {\n\t\t\tif (source.contains(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#findValueOfType(collection,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "T",
    "signature": "public T findValueOfType(Collection<?> collection, @Nullable Class<T> type)",
    "source_code": "\tpublic static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.util.<unknown>#findValueOfType(collection,types)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of one of the given types in the given Collection:\n\t * searching the Collection for a value of the first type, then\n\t * searching for a value of the second type, etc.\n\t * @param collection the collection to search\n\t * @param types the types to look for, in prioritized order\n\t * @return a value of one of the given types found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "Object",
    "signature": "public Object findValueOfType(Collection<?> collection, Class<?>[] types)",
    "source_code": "\tpublic static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n\t\tif (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Class<?> type : types) {\n\t\t\tObject value = findValueOfType(collection, type);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#isEmpty(Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean isEmpty(@Nullable Map<?, ?> map)",
    "source_code": "\tpublic static boolean isEmpty(@Nullable Map<?, ?> map) {\n\t\treturn (map == null || map.isEmpty());\n\t}"
  },
  "org.springframework.util.<unknown>#matchesCharacter(str,singleCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} matches the given single character.\n\t * @param str the {@code String} to check\n\t * @param singleCharacter the character to compare to\n\t * @since 5.2.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "singleCharacter"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "boolean",
    "signature": "public boolean matchesCharacter(@Nullable String str, char singleCharacter)",
    "source_code": "\tpublic static boolean matchesCharacter(@Nullable String str, char singleCharacter) {\n\t\treturn (str != null && str.length() == 1 && str.charAt(0) == singleCharacter);\n\t}"
  },
  "org.springframework.util.<unknown>#mergeArrayIntoCollection(array,collection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given array into the given Collection.\n\t * @param array the array to merge (may be {@code null})\n\t * @param collection the target Collection to merge the array into\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection)",
    "source_code": "\tpublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\n\t\tObject[] arr = ObjectUtils.toObjectArray(array);\n\t\tCollections.addAll(collection, (E[])arr);\n\t}"
  },
  "org.springframework.util.<unknown>#mergePropertiesIntoMap(props,Map<K,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given Properties instance into the given Map,\n\t * copying all properties (key-value pairs) over.\n\t * <p>Uses {@code Properties.propertyNames()} to even catch\n\t * default properties linked into the original Properties instance.\n\t * @param props the Properties instance to merge (may be {@code null})\n\t * @param map the target Map to merge the properties into\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "props",
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map)",
    "source_code": "\tpublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\n\t\tif (props != null) {\n\t\t\tfor (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {\n\t\t\t\tString key = (String) en.nextElement();\n\t\t\t\tObject value = props.get(key);\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// Allow for defaults fallback or potentially overridden accessor...\n\t\t\t\t\tvalue = props.getProperty(key);\n\t\t\t\t}\n\t\t\t\tmap.put((K) key, (V) value);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#pathEquals(path1,path2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compare two paths after normalization of them.\n\t * @param path1 first path for comparison\n\t * @param path2 second path for comparison\n\t * @return whether the two paths are equivalent after normalization\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path1",
      "path2"
    ],
    "position": {
      "column": 1,
      "line": 774
    },
    "return": "boolean",
    "signature": "public boolean pathEquals(String path1, String path2)",
    "source_code": "\tpublic static boolean pathEquals(String path1, String path2) {\n\t\treturn cleanPath(path1).equals(cleanPath(path2));\n\t}"
  },
  "org.springframework.util.<unknown>#replace(inString,oldPattern,newPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all occurrences of a substring within a string with another string.\n\t * @param inString {@code String} to examine\n\t * @param oldPattern {@code String} to replace\n\t * @param newPattern {@code String} to insert\n\t * @return a {@code String} with the replacements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "oldPattern",
      "newPattern"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "String",
    "signature": "public String replace(String inString, String oldPattern, @Nullable String newPattern)",
    "source_code": "\tpublic static String replace(String inString, String oldPattern, @Nullable String newPattern) {\n\t\tif (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n\t\t\treturn inString;\n\t\t}\n\t\tint index = inString.indexOf(oldPattern);\n\t\tif (index == -1) {\n\t\t\t// no occurrence -> can return input as-is\n\t\t\treturn inString;\n\t\t}\n\n\t\tint capacity = inString.length();\n\t\tif (newPattern.length() > oldPattern.length()) {\n\t\t\tcapacity += 16;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(capacity);\n\n\t\tint pos = 0;  // our position in the old string\n\t\tint patLen = oldPattern.length();\n\t\twhile (index >= 0) {\n\t\t\tsb.append(inString, pos, index);\n\t\t\tsb.append(newPattern);\n\t\t\tpos = index + patLen;\n\t\t\tindex = inString.indexOf(oldPattern, pos);\n\t\t}\n\n\t\t// append any characters to the right of a match\n\t\tsb.append(inString, pos, inString.length());\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#split(toSplit,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1053
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.util.<unknown>#splitArrayElementsIntoProperties(array,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the delimiter\n\t * providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the {@code Properties}.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1078
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n\t\treturn splitArrayElementsIntoProperties(array, delimiter, null);\n\t}"
  },
  "org.springframework.util.<unknown>#splitArrayElementsIntoProperties(array,delimiter,charsToDelete)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the\n\t * delimiter providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the\n\t * {@code Properties} instance.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @param charsToDelete one or more characters to remove from each element\n\t * prior to attempting the split operation (typically the quotation mark\n\t * symbol), or {@code null} if no removal should occur\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(\n\t\t\tString[] array, String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tProperties result = new Properties();\n\t\tfor (String element : array) {\n\t\t\tif (charsToDelete != null) {\n\t\t\t\telement = deleteAny(element, charsToDelete);\n\t\t\t}\n\t\t\tString[] splittedElement = split(element, delimiter);\n\t\t\tif (splittedElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.<unknown>#startsWithIgnoreCase(str,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} starts with the specified prefix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param prefix the prefix to look for\n\t * @see java.lang.String#startsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "boolean",
    "signature": "public boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix)",
    "source_code": "\tpublic static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {\n\t\treturn (str != null && prefix != null && str.length() >= prefix.length() &&\n\t\t\t\tstr.regionMatches(true, 0, prefix, 0, prefix.length()));\n\t}"
  },
  "org.springframework.util.<unknown>#substringMatch(str,index,substring)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Test whether the given string matches the given substring\n\t * at the given index.\n\t * @param str the original string (or StringBuilder)\n\t * @param index the index in the original string to start matching against\n\t * @param substring the substring to match at the given index\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "index",
      "substring"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "boolean",
    "signature": "public boolean substringMatch(CharSequence str, int index, CharSequence substring)",
    "source_code": "\tpublic static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n\t\tif (index + substring.length() > str.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < substring.length(); i++) {\n\t\t\tif (str.charAt(index + i) != substring.charAt(i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.util.<unknown>#toArray(enumeration,array)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "A[]",
    "signature": "public A[] toArray(Enumeration<E> enumeration, A[] array)",
    "source_code": "\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}"
  },
  "org.springframework.util.<unknown>#toMultiValueMap(Map<K,targetMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\n\t * @param targetMap the original map\n\t * @return the adapted multi-value map (wrapping the original map)\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "V>",
    "signature": "public V> toMultiValueMap(Map<K, List<V>> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\n\t\treturn new MultiValueMapAdapter<>(targetMap);\n\t}"
  },
  "org.springframework.util.<unknown>#tokenizeToStringArray(str,delimiters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>Trims tokens and omits empty tokens.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters"
    ],
    "position": {
      "column": 1,
      "line": 1134
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters)",
    "source_code": "\tpublic static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {\n\t\treturn tokenizeToStringArray(str, delimiters, true, true);\n\t}"
  },
  "org.springframework.util.<unknown>#tokenizeToStringArray(str,delimiters,trimTokens,ignoreEmptyTokens)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @param trimTokens trim the tokens via {@link String#trim()}\n\t * @param ignoreEmptyTokens omit empty tokens from the result array\n\t * (only applies to tokens that are empty after trimming; StringTokenizer\n\t * will not consider subsequent delimiters as token in the first place).\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters",
      "trimTokens",
      "ignoreEmptyTokens"
    ],
    "position": {
      "column": 1,
      "line": 1157
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)",
    "source_code": "\tpublic static String[] tokenizeToStringArray(\n\t\t\t@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\tStringTokenizer st = new StringTokenizer(str, delimiters);\n\t\tList<String> tokens = new ArrayList<>();\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tString token = st.nextToken();\n\t\t\tif (trimTokens) {\n\t\t\t\ttoken = token.trim();\n\t\t\t}\n\t\t\tif (!ignoreEmptyTokens || token.length() > 0) {\n\t\t\t\ttokens.add(token);\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(tokens);\n\t}"
  },
  "org.springframework.util.<unknown>#trimLeadingCharacter(str,leadingCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim all occurrences of the supplied leading character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param leadingCharacter the leading character to be trimmed\n\t * @return the trimmed {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "leadingCharacter"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "String",
    "signature": "public String trimLeadingCharacter(String str, char leadingCharacter)",
    "source_code": "\tpublic static String trimLeadingCharacter(String str, char leadingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint beginIdx = 0;\n\t\twhile (beginIdx < str.length() && leadingCharacter == str.charAt(beginIdx)) {\n\t\t\tbeginIdx++;\n\t\t}\n\t\treturn str.substring(beginIdx);\n\t}"
  },
  "org.springframework.util.<unknown>#trimTrailingCharacter(str,trailingCharacter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Trim all occurrences of the supplied trailing character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param trailingCharacter the trailing character to be trimmed\n\t * @return the trimmed {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "trailingCharacter"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "String",
    "signature": "public String trimTrailingCharacter(String str, char trailingCharacter)",
    "source_code": "\tpublic static String trimTrailingCharacter(String str, char trailingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint endIdx = str.length() - 1;\n\t\twhile (endIdx >= 0 && trailingCharacter == str.charAt(endIdx)) {\n\t\t\tendIdx--;\n\t\t}\n\t\treturn str.substring(0, endIdx + 1);\n\t}"
  },
  "org.springframework.util.<unknown>#unmodifiableMultiValueMap(K,targetMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "V>",
    "signature": "public V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(\n\t\t\tMultiValueMap<? extends K, ? extends V> targetMap) {\n\n\t\tAssert.notNull(targetMap, \"'targetMap' must not be null\");\n\t\tif (targetMap instanceof UnmodifiableMultiValueMap) {\n\t\t\treturn (MultiValueMap<K, V>) targetMap;\n\t\t}\n\t\treturn new UnmodifiableMultiValueMap<>(targetMap);\n\t}"
  },
  "org.springframework.util.<unknown>#unqualify(qualifiedName,separator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unqualify a string qualified by a separator character. For example,\n\t * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n\t * @param qualifiedName the qualified name\n\t * @param separator the separator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifiedName",
      "separator"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "String",
    "signature": "public String unqualify(String qualifiedName, char separator)",
    "source_code": "\tpublic static String unqualify(String qualifiedName, char separator) {\n\t\treturn qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n\t}"
  },
  "org.springframework.util.<unknown>#uriDecode(source,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component value. Based on the following rules:\n\t * <ul>\n\t * <li>Alphanumeric characters {@code \"a\"} through {@code \"z\"}, {@code \"A\"} through {@code \"Z\"},\n\t * and {@code \"0\"} through {@code \"9\"} stay the same.</li>\n\t * <li>Special characters {@code \"-\"}, {@code \"_\"}, {@code \".\"}, and {@code \"*\"} stay the same.</li>\n\t * <li>A sequence \"{@code %<i>xy</i>}\" is interpreted as a hexadecimal representation of the character.</li>\n\t * </ul>\n\t * @param source the encoded String\n\t * @param charset the character set\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "String",
    "signature": "public String uriDecode(String source, Charset charset)",
    "source_code": "\tpublic static String uriDecode(String source, Charset charset) {\n\t\tint length = source.length();\n\t\tif (length == 0) {\n\t\t\treturn source;\n\t\t}\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n\t\tboolean changed = false;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tint ch = source.charAt(i);\n\t\t\tif (ch == '%') {\n\t\t\t\tif (i + 2 < length) {\n\t\t\t\t\tchar hex1 = source.charAt(i + 1);\n\t\t\t\t\tchar hex2 = source.charAt(i + 2);\n\t\t\t\t\tint u = Character.digit(hex1, 16);\n\t\t\t\t\tint l = Character.digit(hex2, 16);\n\t\t\t\t\tif (u == -1 || l == -1) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tbaos.write((char) ((u << 4) + l));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbaos.write(ch);\n\t\t\t}\n\t\t}\n\t\treturn (changed ? StreamUtils.copyToString(baos, charset) : source);\n\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(v1,v2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v1",
      "v2"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "public int compare(Boolean v1, Boolean v2)",
    "source_code": "\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#createAsyncWebRequest(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an AsyncWebRequest instance. By default, an instance of\n\t * {@link StandardServletAsyncWebRequest} gets created.\n\t * @param request the current request\n\t * @param response the current response\n\t * @return an AsyncWebRequest instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "AsyncWebRequest",
    "signature": "public AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic static AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) {\n\t\treturn new StandardServletAsyncWebRequest(request, response);\n\t}"
  },
  "org.springframework.web.multipart.support.<unknown>#doFilterInternal(request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a multipart request via this filter's MultipartResolver,\n\t * and wrap the original request with a MultipartHttpServletRequest if appropriate.\n\t * <p>All later elements in the filter chain, most importantly servlets, benefit\n\t * from proper parameter extraction in the multipart case, and are able to cast to\n\t * MultipartHttpServletRequest if they need to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tMultipartResolver multipartResolver = lookupMultipartResolver(request);\n\n\t\tHttpServletRequest processedRequest = request;\n\t\tif (multipartResolver.isMultipart(processedRequest)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolving multipart request\");\n\t\t\t}\n\t\t\tprocessedRequest = multipartResolver.resolveMultipart(processedRequest);\n\t\t}\n\t\telse {\n\t\t\t// A regular request...\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not a multipart request\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfilterChain.doFilter(processedRequest, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (processedRequest instanceof MultipartHttpServletRequest multipartRequest) {\n\t\t\t\tmultipartResolver.cleanupMultipart(multipartRequest);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addAllObjects(Map<String,modelMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all attributes contained in the provided Map to the model.\n\t * @param modelMap a Map of attributeName &rarr; attributeValue pairs\n\t * @see ModelMap#addAllAttributes(Map)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "modelMap"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap)",
    "source_code": "\tpublic ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap) {\n\t\tgetModelMap().addAllAttributes(modelMap);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addObject(attributeName,attributeValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute to the model.\n\t * @param attributeName name of the object to add to the model (never {@code null})\n\t * @param attributeValue object to add to the model (can be {@code null})\n\t * @see ModelMap#addAttribute(String, Object)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addObject(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ModelAndView addObject(String attributeName, @Nullable Object attributeValue) {\n\t\tgetModelMap().addAttribute(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#createDefaultStrategy(context,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default strategy.\n\t * <p>The default implementation uses\n\t * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean}.\n\t * @param context the current WebApplicationContext\n\t * @param clazz the strategy implementation class to instantiate\n\t * @return the fully configured strategy instance\n\t * @see org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "Object",
    "signature": "protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz)",
    "source_code": "\tprotected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {\n\t\treturn context.getAutowireCapableBeanFactory().createBean(clazz);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doDispatch(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the actual dispatching to the handler.\n\t * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.\n\t * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters\n\t * to find the first that supports the handler class.\n\t * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers\n\t * themselves to decide which methods are acceptable.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1041
    },
    "return": "void",
    "signature": "protected void doDispatch(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n\t\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new ServletException(\"Handler dispatch failed: \" + err, err);\n\t\t\t}\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew ServletException(\"Handler processing failed: \" + err, err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#getDefaultStrategies(context,strategyInterface)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a List of default strategy objects for the given strategy interface.\n\t * <p>The default implementation uses the \"DispatcherServlet.properties\" file (in the same\n\t * package as the DispatcherServlet class) to determine the class names. It instantiates\n\t * the strategy objects through the context's BeanFactory.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the List of corresponding strategy objects\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "strategyInterface"
    ],
    "position": {
      "column": 1,
      "line": 872
    },
    "return": "List<T>",
    "signature": "protected List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface)",
    "source_code": "\tprotected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {\n\t\tif (defaultStrategies == null) {\n\t\t\ttry {\n\t\t\t\t// Load default strategy implementations from properties file.\n\t\t\t\t// This is currently strictly internal and not meant to be customized\n\t\t\t\t// by application developers.\n\t\t\t\tClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n\t\t\t\tdefaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tString key = strategyInterface.getName();\n\t\tString value = defaultStrategies.getProperty(key);\n\t\tif (value != null) {\n\t\t\tString[] classNames = StringUtils.commaDelimitedListToStringArray(value);\n\t\t\tList<T> strategies = new ArrayList<>(classNames.length);\n\t\t\tfor (String className : classNames) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());\n\t\t\t\t\tObject strategy = createDefaultStrategy(context, clazz);\n\t\t\t\t\tstrategies.add((T) strategy);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Could not find DispatcherServlet's default strategy class [\" + className +\n\t\t\t\t\t\t\t\"] for interface [\" + key + \"]\", ex);\n\t\t\t\t}\n\t\t\t\tcatch (LinkageError err) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Unresolvable class definition for DispatcherServlet's default strategy class [\" +\n\t\t\t\t\t\t\tclassName + \"] for interface [\" + key + \"]\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn strategies;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#getDefaultStrategy(context,strategyInterface)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default strategy object for the given strategy interface.\n\t * <p>The default implementation delegates to {@link #getDefaultStrategies},\n\t * expecting a single object in the list.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the corresponding strategy object\n\t * @see #getDefaultStrategies\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "strategyInterface"
    ],
    "position": {
      "column": 1,
      "line": 853
    },
    "return": "T",
    "signature": "protected T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface)",
    "source_code": "\tprotected <T> T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface) {\n\t\tList<T> strategies = getDefaultStrategies(context, strategyInterface);\n\t\tif (strategies.size() != 1) {\n\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\"DispatcherServlet needs exactly 1 strategy for interface [\" + strategyInterface.getName() + \"]\");\n\t\t}\n\t\treturn strategies.get(0);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#noHandlerFound(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * No handler found &rarr; set appropriate HTTP response status.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception if preparing the response failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1290
    },
    "return": "void",
    "signature": "protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tif (pageNotFoundLogger.isWarnEnabled()) {\n\t\t\tpageNotFoundLogger.warn(\"No mapping for \" + request.getMethod() + \" \" + getRequestUri(request));\n\t\t}\n\t\tif (this.throwExceptionIfNoHandlerFound) {\n\t\t\tthrow new NoHandlerFoundException(request.getMethod(), getRequestUri(request),\n\t\t\t\t\tnew ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\telse {\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine an error ModelAndView via the registered HandlerExceptionResolvers.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time of the exception\n\t * (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to\n\t * @throws Exception if no error ModelAndView found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1331
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\t// Success and error responses may use different content types\n\t\trequest.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\n\t\t// Check registered HandlerExceptionResolvers...\n\t\tModelAndView exMv = null;\n\t\tif (this.handlerExceptionResolvers != null) {\n\t\t\tfor (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {\n\t\t\t\texMv = resolver.resolveException(request, response, handler, ex);\n\t\t\t\tif (exMv != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exMv != null) {\n\t\t\tif (exMv.isEmpty()) {\n\t\t\t\trequest.setAttribute(EXCEPTION_ATTRIBUTE, ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// We might still need view name translation for a plain error model...\n\t\t\tif (!exMv.hasView()) {\n\t\t\t\tString defaultViewName = getDefaultViewName(request);\n\t\t\t\tif (defaultViewName != null) {\n\t\t\t\t\texMv.setViewName(defaultViewName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Using resolved error view: \" + exMv, ex);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using resolved error view: \" + exMv);\n\t\t\t}\n\t\t\tWebUtils.exposeErrorRequestAttributes(request, ex, getServletName());\n\t\t\treturn exMv;\n\t\t}\n\n\t\tthrow ex;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#render(mv,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Render the given ModelAndView.\n\t * <p>This is the last stage in handling a request. It may involve resolving the view by name.\n\t * @param mv the ModelAndView to render\n\t * @param request current HTTP servlet request\n\t * @param response current HTTP servlet response\n\t * @throws ServletException if view is missing or cannot be resolved\n\t * @throws Exception if there's a problem rendering the view\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1381
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\t// Determine locale for request and apply it to the response.\n\t\tLocale locale =\n\t\t\t\t(this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t// We need to resolve the view name.\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No need to lookup: the ModelAndView object contains the actual View object.\n\t\t\tview = mv.getView();\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" +\n\t\t\t\t\t\t\"View object in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t// Delegate to the View object for rendering.\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view [\" + view + \"] \");\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, mv.getStatus());\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#resolveViewName(viewName,Map<String,model,locale,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given view name into a View object (to be rendered).\n\t * <p>The default implementations asks all ViewResolvers of this dispatcher.\n\t * Can be overridden for custom resolution strategies, potentially based on\n\t * specific model attributes or request parameters.\n\t * @param viewName the name of the view to resolve\n\t * @param model the model to be passed to the view\n\t * @param locale the current locale\n\t * @param request current HTTP servlet request\n\t * @return the View object, or {@code null} if none found\n\t * @throws Exception if the view cannot be resolved\n\t * (typically in case of problems creating an actual View object)\n\t * @see ViewResolver#resolveViewName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "Map<String",
      "model",
      "locale",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1451
    },
    "return": "View",
    "signature": "protected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\t\tLocale locale, HttpServletRequest request)",
    "source_code": "\tprotected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\t\tLocale locale, HttpServletRequest request) throws Exception {\n\n\t\tif (this.viewResolvers != null) {\n\t\t\tfor (ViewResolver viewResolver : this.viewResolvers) {\n\t\t\t\tView view = viewResolver.resolveViewName(viewName, locale);\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn view;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerCorsConfigurations(Map<String,corsConfigurations,context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Registers a {@code Map<String, CorsConfiguration>} (mapped {@code CorsConfiguration}s)\n\t * under a well-known name unless already registered. The bean definition may be updated\n\t * if a non-null CORS configuration is provided.\n\t * @return a RuntimeBeanReference to this {@code Map<String, CorsConfiguration>} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerCorsConfigurations(@Nullable Map<String, CorsConfiguration> corsConfigurations,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerCorsConfigurations(\n\t\t\t@Nullable Map<String, CorsConfiguration> corsConfigurations,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (!context.getRegistry().containsBeanDefinition(CORS_CONFIGURATION_BEAN_NAME)) {\n\t\t\tRootBeanDefinition corsDef = new RootBeanDefinition(LinkedHashMap.class);\n\t\t\tcorsDef.setSource(source);\n\t\t\tcorsDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tif (corsConfigurations != null) {\n\t\t\t\tcorsDef.getConstructorArgumentValues().addIndexedArgumentValue(0, corsConfigurations);\n\t\t\t}\n\t\t\tcontext.getReaderContext().getRegistry().registerBeanDefinition(CORS_CONFIGURATION_BEAN_NAME, corsDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(corsDef, CORS_CONFIGURATION_BEAN_NAME));\n\t\t}\n\t\telse if (corsConfigurations != null) {\n\t\t\tBeanDefinition corsDef = context.getRegistry().getBeanDefinition(CORS_CONFIGURATION_BEAN_NAME);\n\t\t\tcorsDef.getConstructorArgumentValues().addIndexedArgumentValue(0, corsConfigurations);\n\t\t}\n\t\treturn new RuntimeBeanReference(CORS_CONFIGURATION_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerDefaultComponents(context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void registerDefaultComponents(ParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static void registerDefaultComponents(ParserContext context, @Nullable Object source) {\n\t\tregisterBeanNameUrlHandlerMapping(context, source);\n\t\tregisterHttpRequestHandlerAdapter(context, source);\n\t\tregisterSimpleControllerHandlerAdapter(context, source);\n\t\tregisterHandlerMappingIntrospector(context, source);\n\t\tregisterLocaleResolver(context, source);\n\t\tregisterThemeResolver(context, source);\n\t\tregisterViewNameTranslator(context, source);\n\t\tregisterFlashMapManager(context, source);\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerPathMatcher(pathMatcherRef,context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link PathMatcher}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link PathMatcher} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcherRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (pathMatcherRef != null) {\n\t\t\tif (context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(PATH_MATCHER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(pathMatcherRef.getBeanName(), PATH_MATCHER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition pathMatcherDef = new RootBeanDefinition(AntPathMatcher.class);\n\t\t\tpathMatcherDef.setSource(source);\n\t\t\tpathMatcherDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(PATH_MATCHER_BEAN_NAME, pathMatcherDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(pathMatcherDef, PATH_MATCHER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(PATH_MATCHER_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerUrlPathHelper(urlPathHelperRef,context,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link UrlPathHelper}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link UrlPathHelper} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelperRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerUrlPathHelper(@Nullable RuntimeBeanReference urlPathHelperRef, ParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerUrlPathHelper(\n\t\t\t@Nullable RuntimeBeanReference urlPathHelperRef, ParserContext context, @Nullable Object source) {\n\n\t\tif (urlPathHelperRef != null) {\n\t\t\tif (context.getRegistry().isAlias(URL_PATH_HELPER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(URL_PATH_HELPER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(urlPathHelperRef.getBeanName(), URL_PATH_HELPER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(URL_PATH_HELPER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(URL_PATH_HELPER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition urlPathHelperDef = new RootBeanDefinition(UrlPathHelper.class);\n\t\t\turlPathHelperDef.setSource(source);\n\t\t\turlPathHelperDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(URL_PATH_HELPER_BEAN_NAME, urlPathHelperDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(urlPathHelperDef, URL_PATH_HELPER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(URL_PATH_HELPER_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addErrorHandler(predicate,BiFunction<Throwable,ServerRequest,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "predicate",
      "BiFunction<Throwable",
      "ServerRequest",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "protected void addErrorHandler(Predicate<Throwable> predicate,\n\t\t\tBiFunction<Throwable, ServerRequest, T> errorHandler)",
    "source_code": "\tprotected final <T extends ServerResponse> void addErrorHandler(Predicate<Throwable> predicate,\n\t\t\tBiFunction<Throwable, ServerRequest, T> errorHandler) {\n\n\t\tAssert.notNull(predicate, \"Predicate must not be null\");\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\t\tthis.errorHandlers.add(new ErrorHandler<>(predicate, errorHandler));\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(obj,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "AsyncServerResponse",
    "signature": "public AsyncServerResponse create(Object obj, @Nullable Duration timeout)",
    "source_code": "\tpublic static AsyncServerResponse create(Object obj, @Nullable Duration timeout) {\n\t\tAssert.notNull(obj, \"Argument to async must not be null\");\n\n\t\tif (obj instanceof CompletableFuture futureResponse) {\n\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t}\n\t\telse if (reactiveStreamsPresent) {\n\t\t\tReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\t\t\tReactiveAdapter publisherAdapter = registry.getAdapter(obj.getClass());\n\t\t\tif (publisherAdapter != null) {\n\t\t\t\tPublisher<ServerResponse> publisher = publisherAdapter.toPublisher(obj);\n\t\t\t\tReactiveAdapter futureAdapter = registry.getAdapter(CompletableFuture.class);\n\t\t\t\tif (futureAdapter != null) {\n\t\t\t\t\tCompletableFuture<ServerResponse> futureResponse =\n\t\t\t\t\t\t\t(CompletableFuture<ServerResponse>) futureAdapter.fromPublisher(publisher);\n\t\t\t\t\treturn new DefaultAsyncServerResponse(futureResponse, timeout);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Asynchronous type not supported: \" + obj.getClass());\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(sseConsumer,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sseConsumer",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse create(Consumer<SseBuilder> sseConsumer, @Nullable Duration timeout)",
    "source_code": "\tpublic static ServerResponse create(Consumer<SseBuilder> sseConsumer, @Nullable Duration timeout) {\n\t\tAssert.notNull(sseConsumer, \"SseConsumer must not be null\");\n\n\t\treturn new SseServerResponse(sseConsumer, timeout);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#errorResponse(t,servletRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "servletRequest"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "ServerResponse",
    "signature": "protected ServerResponse errorResponse(Throwable t, HttpServletRequest servletRequest)",
    "source_code": "\tprotected final ServerResponse errorResponse(Throwable t, HttpServletRequest servletRequest) {\n\t\tfor (ErrorHandler<?> errorHandler : this.errorHandlers) {\n\t\t\tif (errorHandler.test(t)) {\n\t\t\t\tServerRequest serverRequest = (ServerRequest)\n\t\t\t\t\t\tservletRequest.getAttribute(RouterFunctions.REQUEST_ATTRIBUTE);\n\t\t\t\treturn errorHandler.handle(t, serverRequest);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handle(t,serverRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "serverRequest"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T handle(Throwable t, ServerRequest serverRequest)",
    "source_code": "\t\tpublic T handle(Throwable t, ServerRequest serverRequest) {\n\t\t\treturn this.responseProvider.apply(t, serverRequest);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handleError(t,servletRequest,servletResponse,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "servletRequest",
      "servletResponse",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleError(Throwable t, HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse, Context context)",
    "source_code": "\tprotected final ModelAndView handleError(Throwable t, HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse, Context context) throws ServletException, IOException {\n\n\t\tServerResponse serverResponse = errorResponse(t, servletRequest);\n\t\tif (serverResponse != null) {\n\t\t\treturn serverResponse.writeTo(servletRequest, servletResponse, context);\n\t\t}\n\t\telse if (t instanceof ServletException servletException) {\n\t\t\tthrow servletException;\n\t\t}\n\t\telse if (t instanceof IOException ioException ) {\n\t\t\tthrow ioException;\n\t\t}\n\t\telse {\n\t\t\tthrow new ServletException(t);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#read(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\t\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\t\treturn this.delegate.read(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeTo(request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tpublic ModelAndView writeTo(HttpServletRequest request, HttpServletResponse response, Context context)\n\t\t\tthrows ServletException, IOException {\n\n\t\twriteAsync(request, response, createDeferredResult(request));\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.support.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.function.support.<unknown>#handle(servletRequest,servletResponse,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse,\n\t\t\tObject handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse,\n\t\t\tObject handler) throws Exception {\n\n\t\tWebAsyncManager asyncManager = getWebAsyncManager(servletRequest, servletResponse);\n\n\t\tServerRequest serverRequest = getServerRequest(servletRequest);\n\t\tServerResponse serverResponse;\n\n\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\tserverResponse = handleAsync(asyncManager);\n\t\t}\n\t\telse {\n\t\t\tHandlerFunction<?> handlerFunction = (HandlerFunction<?>) handler;\n\t\t\tserverResponse = handlerFunction.handle(serverRequest);\n\t\t}\n\n\t\tif (serverResponse != null) {\n\t\t\treturn serverResponse.writeTo(servletRequest, servletResponse, new ServerRequestContext(serverRequest));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tServletConfig config = this.servletConfig;\n\t\t\tif (config == null || !this.useSharedServletConfig) {\n\t\t\t\tconfig = new DelegatingServletConfig(beanName, this.servletContext);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tservlet.init(config);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Servlet.init threw exception\", ex);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tservlet.destroy();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandlers(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\turlMap.forEach((url, handler) -> {\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t});\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setUrlMap(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#handle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn ((Controller) handler).handleRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#applyStatusAndReason(statusCode,reason,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the resolved status code and reason to the response.\n\t * <p>The default implementation sends a response error using\n\t * {@link HttpServletResponse#sendError(int)} or\n\t * {@link HttpServletResponse#sendError(int, String)} if there is a reason\n\t * and then returns an empty ModelAndView.\n\t * @param statusCode the HTTP status code\n\t * @param reason the associated reason (may be {@code null} or empty)\n\t * @param response current HTTP response\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "statusCode",
      "reason",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)",
    "source_code": "\tprotected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\tif (!StringUtils.hasLength(reason)) {\n\t\t\tresponse.sendError(statusCode);\n\t\t}\n\t\telse {\n\t\t\tString resolvedReason = (this.messageSource != null ?\n\t\t\t\t\tthis.messageSource.getMessage(reason, null, reason, LocaleContextHolder.getLocale()) :\n\t\t\t\t\treason);\n\t\t\tresponse.sendError(statusCode, resolvedReason);\n\t\t}\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\tif (ex instanceof ResponseStatusException rse) {\n\t\t\t\treturn resolveResponseStatusException(rse, request, response, handler);\n\t\t\t}\n\n\t\t\tResponseStatus status = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);\n\t\t\tif (status != null) {\n\t\t\t\treturn resolveResponseStatus(status, request, response, handler, ex);\n\t\t\t}\n\n\t\t\tif (ex.getCause() instanceof Exception cause) {\n\t\t\t\treturn doResolveException(request, response, handler, cause);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception resolveEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", resolveEx);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#resolveResponseStatus(responseStatus,request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that handles the {@link ResponseStatus @ResponseStatus} annotation.\n\t * <p>The default implementation delegates to {@link #applyStatusAndReason}\n\t * with the status code and reason from the annotation.\n\t * @param responseStatus the {@code @ResponseStatus} annotation\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, e.g. if multipart resolution failed\n\t * @param ex the exception\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "responseStatus",
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {\n\n\t\tint statusCode = responseStatus.code().value();\n\t\tString reason = responseStatus.reason();\n\t\treturn applyStatusAndReason(statusCode, reason, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#resolveResponseStatusException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that handles an {@link ResponseStatusException}.\n\t * <p>The default implementation applies the headers from\n\t * {@link ResponseStatusException#getHeaders()} and delegates to\n\t * {@link #applyStatusAndReason} with the status code and reason from the\n\t * exception.\n\t * @param ex the exception\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, e.g. if multipart resolution failed\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView resolveResponseStatusException(ResponseStatusException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView resolveResponseStatusException(ResponseStatusException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws Exception {\n\n\t\tex.getHeaders().forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));\n\t\treturn applyStatusAndReason(ex.getStatusCode().value(), ex.getReason(), response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModified(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@link jakarta.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t * @deprecated as of 5.3.9 along with\n\t * {@link org.springframework.web.servlet.mvc.LastModified}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getMatchingMapping(info,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given RequestMappingInfo matches the current request and\n\t * return a (potentially new) instance with conditions that match the\n\t * current request -- for example with a subset of URL patterns.\n\t * @return an info in case of a match; or {@code null} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request)",
    "source_code": "\tprotected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {\n\t\treturn info.getMatchingCondition(request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn handleInternal(request, response, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleInternal(request,response,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use the given handler method to handle the request.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod handler method to use. This object must have previously been passed to the\n\t * {@link #supportsInternal(HandlerMethod)} this interface, which must have returned {@code true}.\n\t * @return a ModelAndView object with the name of the view and the required model data,\n\t * or {@code null} if the request has been handled directly\n\t * @throws Exception in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception;\n\n\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}."
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleMatch(info,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose URI template variables, matrix variables, and producible media types in the request.\n\t * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {\n\t\tsuper.handleMatch(info, lookupPath, request);\n\n\t\tRequestCondition<?> condition = info.getActivePatternsCondition();\n\t\tif (condition instanceof PathPatternsRequestCondition pprc) {\n\t\t\textractMatchDetails(pprc, lookupPath, request);\n\t\t}\n\t\telse {\n\t\t\textractMatchDetails((PatternsRequestCondition) condition, lookupPath, request);\n\t\t}\n\n\t\tProducesRequestCondition producesCondition = info.getProducesCondition();\n\t\tif (!producesCondition.isEmpty()) {\n\t\t\tSet<MediaType> mediaTypes = producesCondition.getProducibleMediaTypes();\n\t\t\tif (!mediaTypes.isEmpty()) {\n\t\t\t\trequest.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleNoMatch(infos,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate all RequestMappingInfo's once again, look if any match by URL at\n\t * least and raise exceptions according to what doesn't match.\n\t * @throws HttpRequestMethodNotSupportedException if there are matches by URL\n\t * but not by HTTP method\n\t * @throws HttpMediaTypeNotAcceptableException if there are matches by URL\n\t * but not by consumable/producible media types\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infos",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(\n\t\t\tSet<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request) throws ServletException {\n\n\t\tif (CollectionUtils.isEmpty(infos)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPartialMatchHelper helper = new PartialMatchHelper(infos, request);\n\t\tif (helper.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (helper.hasMethodsMismatch()) {\n\t\t\tSet<String> methods = helper.getAllowedMethods();\n\t\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\t\tSet<MediaType> mediaTypes = helper.getConsumablePatchMediaTypes();\n\t\t\t\tHttpOptionsHandler handler = new HttpOptionsHandler(methods, mediaTypes);\n\t\t\t\treturn new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD);\n\t\t\t}\n\t\t\tthrow new HttpRequestMethodNotSupportedException(request.getMethod(), methods);\n\t\t}\n\n\t\tif (helper.hasConsumesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getConsumableMediaTypes();\n\t\t\tMediaType contentType = null;\n\t\t\tif (StringUtils.hasLength(request.getContentType())) {\n\t\t\t\ttry {\n\t\t\t\t\tcontentType = MediaType.parseMediaType(request.getContentType());\n\t\t\t\t}\n\t\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage(), new ArrayList<>(mediaTypes));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tcontentType, new ArrayList<>(mediaTypes), HttpMethod.valueOf(request.getMethod()));\n\t\t}\n\n\t\tif (helper.hasProducesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getProducibleMediaTypes();\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(new ArrayList<>(mediaTypes));\n\t\t}\n\n\t\tif (helper.hasParamsMismatch()) {\n\t\t\tList<String[]> conditions = helper.getParamConditions();\n\t\t\tthrow new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap());\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#adaptArgumentIfNecessary(arg,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given argument against the method parameter, if necessary.\n\t * @param arg the resolved argument\n\t * @param parameter the method parameter descriptor\n\t * @return the adapted argument, or the original resolved argument as-is\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Object",
    "signature": "protected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter)",
    "source_code": "\tprotected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter) {\n\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\tif (arg == null || (arg instanceof Collection<?> collection && collection.isEmpty()) ||\n\t\t\t\t\t(arg instanceof Object[] array && array.length == 0)) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Optional.of(arg);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyWriteInternal(bodyContainer,contentType,returnType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked only if the converter type is {@code MappingJackson2HttpMessageConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyContainer",
      "contentType",
      "returnType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected abstract void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response);\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tif (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {\n\t\t\treturn;\n\t\t}\n\n\t\tPathVariable ann = parameter.getParameterAnnotation(PathVariable.class);\n\t\tString name = (ann != null && StringUtils.hasLength(ann.value()) ? ann.value() : parameter.getParameterName());\n\t\tString formatted = formatUriValue(conversionService, new TypeDescriptor(parameter.nestedIfOptional()), value);\n\t\turiVariables.put(name, formatted);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#doResolveHandlerMethodException(request,response,handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method and invoke it to handle the raised exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) {\n\n\t\tServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (exceptionHandlerMethod == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.argumentResolvers != null) {\n\t\t\texceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t}\n\t\tif (this.returnValueHandlers != null) {\n\t\t\texceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t}\n\n\t\tServletWebRequest webRequest = new ServletWebRequest(request, response);\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\n\t\tArrayList<Throwable> exceptions = new ArrayList<>();\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using @ExceptionHandler \" + exceptionHandlerMethod);\n\t\t\t}\n\t\t\t// Expose causes as provided arguments as well\n\t\t\tThrowable exToExpose = exception;\n\t\t\twhile (exToExpose != null) {\n\t\t\t\texceptions.add(exToExpose);\n\t\t\t\tThrowable cause = exToExpose.getCause();\n\t\t\t\texToExpose = (cause != exToExpose ? cause : null);\n\t\t\t}\n\t\t\tObject[] arguments = new Object[exceptions.size() + 1];\n\t\t\texceptions.toArray(arguments);  // efficient arraycopy call in ArrayList\n\t\t\targuments[arguments.length - 1] = handlerMethod;\n\t\t\texceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, arguments);\n\t\t}\n\t\tcatch (Throwable invocationEx) {\n\t\t\t// Any other than the original exception (or a cause) is unintended here,\n\t\t\t// probably an accident (e.g. failed assertion or the like).\n\t\t\tif (!exceptions.contains(invocationEx) && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure in @ExceptionHandler \" + exceptionHandlerMethod, invocationEx);\n\t\t\t}\n\t\t\t// Continue with default processing of the original exception...\n\t\t\treturn null;\n\t\t}\n\n\t\tif (mavContainer.isRequestHandled()) {\n\t\t\treturn new ModelAndView();\n\t\t}\n\t\telse {\n\t\t\tModelMap model = mavContainer.getModel();\n\t\t\tHttpStatusCode status = mavContainer.getStatus();\n\t\t\tModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);\n\t\t\tmav.setViewName(mavContainer.getViewName());\n\t\t\tif (!mavContainer.isViewReference()) {\n\t\t\t\tmav.setView((View) mavContainer.getView());\n\t\t\t}\n\t\t\tif (model instanceof RedirectAttributes redirectAttributes) {\n\t\t\t\tMap<String, ?> flashAttributes = redirectAttributes.getFlashAttributes();\n\t\t\t\tRequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);\n\t\t\t}\n\t\t\treturn mav;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#formatUriValue(cs,sourceType,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, Object value)",
    "source_code": "\tprotected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, Object value) {\n\t\tif (value instanceof String string) {\n\t\t\treturn string;\n\t\t}\n\t\telse if (cs != null) {\n\t\t\treturn (String) cs.convert(value, sourceType, STRING_TYPE_DESCRIPTOR);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod(\n\t\t\t@Nullable HandlerMethod handlerMethod, Exception exception) {\n\n\t\tClass<?> handlerType = null;\n\n\t\tif (handlerMethod != null) {\n\t\t\t// Local exception handler methods on the controller class itself.\n\t\t\t// To be invoked through the proxy, even in case of an interface-based proxy.\n\t\t\thandlerType = handlerMethod.getBeanType();\n\t\t\tExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.computeIfAbsent(\n\t\t\t\t\thandlerType, ExceptionHandlerMethodResolver::new);\n\t\t\tMethod method = resolver.resolveMethod(exception);\n\t\t\tif (method != null) {\n\t\t\t\treturn new ServletInvocableHandlerMethod(handlerMethod.getBean(), method, this.applicationContext);\n\t\t\t}\n\t\t\t// For advice applicability check below (involving base packages, assignable types\n\t\t\t// and annotation presence), use target class instead of interface-based proxy.\n\t\t\tif (Proxy.isProxyClass(handlerType)) {\n\t\t\t\thandlerType = AopUtils.getTargetClass(handlerMethod.getBean());\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tControllerAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(handlerType)) {\n\t\t\t\tExceptionHandlerMethodResolver resolver = entry.getValue();\n\t\t\t\tMethod method = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new ServletInvocableHandlerMethod(advice.resolveBean(), method, this.applicationContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getProducibleMediaTypes(request,valueClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types that can be produced.\n\t * @see #getProducibleMediaTypes(HttpServletRequest, Class, Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "valueClass"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass)",
    "source_code": "\tprotected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass) {\n\t\treturn getProducibleMediaTypes(request, valueClass, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getProducibleMediaTypes(request,valueClass,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types that can be produced. The resulting media types are:\n\t * <ul>\n\t * <li>The producible media types specified in the request mappings, or\n\t * <li>Media types of configured converters that can write the specific return value, or\n\t * <li>{@link MediaType#ALL}\n\t * </ul>\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "valueClass",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass, @Nullable Type targetType)",
    "source_code": "\tprotected List<MediaType> getProducibleMediaTypes(\n\t\t\tHttpServletRequest request, Class<?> valueClass, @Nullable Type targetType) {\n\n\t\tSet<MediaType> mediaTypes =\n\t\t\t\t(Set<MediaType>) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\t\tif (!CollectionUtils.isEmpty(mediaTypes)) {\n\t\t\treturn new ArrayList<>(mediaTypes);\n\t\t}\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\tif (converter instanceof GenericHttpMessageConverter<?> ghmc && targetType != null) {\n\t\t\t\tif (ghmc.canWrite(targetType, valueClass, null)) {\n\t\t\t\t\tresult.addAll(converter.getSupportedMediaTypes(valueClass));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (converter.canWrite(valueClass, null)) {\n\t\t\t\tresult.addAll(converter.getSupportedMediaTypes(valueClass));\n\t\t\t}\n\t\t}\n\t\treturn (result.isEmpty() ? Collections.singletonList(MediaType.ALL) : new ArrayList<>(result));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingValue(name,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) throws ServletRequestBindingException {\n\t\tthrow new MissingPathVariableException(name, parameter);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingValueAfterConversion(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\n\t\tthrow new MissingPathVariableException(name, parameter, true);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleResolvedValue(arg,name,parameter,mavContainer,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "mavContainer",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest request)",
    "source_code": "\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest request) {\n\n\t\tString key = View.PATH_VARIABLES;\n\t\tint scope = RequestAttributes.SCOPE_REQUEST;\n\t\tMap<String, Object> pathVars = (Map<String, Object>) request.getAttribute(key, scope);\n\t\tif (pathVars == null) {\n\t\t\tpathVars = new HashMap<>();\n\t\t\trequest.setAttribute(key, pathVars, scope);\n\t\t}\n\t\tpathVars.put(name, arg);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeAndHandle(webRequest,mavContainer,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\t\tsetResponseStatus(webRequest);\n\n\t\tif (returnValue == null) {\n\t\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\t\tdisableContentCachingIfNecessary(webRequest);\n\t\t\t\tmavContainer.setRequestHandled(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tmavContainer.setRequestHandled(false);\n\t\tAssert.state(this.returnValueHandlers != null, \"No return value handlers\");\n\t\ttry {\n\t\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter descriptor\n\t * @return {@code true} if the next method argument is not of type {@link Errors}\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#isResourceType(value,returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned value or the declared return type extends {@link Resource}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "boolean",
    "signature": "protected boolean isResourceType(@Nullable Object value, MethodParameter returnType)",
    "source_code": "\tprotected boolean isResourceType(@Nullable Object value, MethodParameter returnType) {\n\t\tClass<?> clazz = getReturnValueType(value, returnType);\n\t\treturn clazz != InputStreamResource.class && Resource.class.isAssignableFrom(clazz);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#readWithMessageConverters(inputMessage,parameter,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param parameter the method parameter descriptor\n\t * @param targetType the target type, not necessarily the same as the method\n\t * parameter type, e.g. for {@code HttpEntity<String>}.\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputMessage",
      "parameter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType)",
    "source_code": "\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tClass<?> contextClass = parameter.getContainingClass();\n\t\tClass<T> targetClass = (targetType instanceof Class clazz ? clazz : null);\n\t\tif (targetClass == null) {\n\t\t\tResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);\n\t\t\ttargetClass = (Class<T>) resolvableType.resolve();\n\t\t}\n\n\t\tMediaType contentType;\n\t\tboolean noContentType = false;\n\t\ttry {\n\t\t\tcontentType = inputMessage.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tex.getMessage(), getSupportedMediaTypes(targetClass != null ? targetClass : Object.class));\n\t\t}\n\t\tif (contentType == null) {\n\t\t\tnoContentType = true;\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tHttpMethod httpMethod = (inputMessage instanceof HttpRequest httpRequest ? httpRequest.getMethod() : null);\n\t\tObject body = NO_VALUE;\n\n\t\tEmptyBodyCheckingHttpInputMessage message = null;\n\t\ttry {\n\t\t\tmessage = new EmptyBodyCheckingHttpInputMessage(inputMessage);\n\n\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\t\tClass<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();\n\t\t\t\tGenericHttpMessageConverter<?> genericConverter =\n\t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ghmc ? ghmc : null);\n\t\t\t\tif (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :\n\t\t\t\t\t\t(targetClass != null && converter.canRead(targetClass, contentType))) {\n\t\t\t\t\tif (message.hasBody()) {\n\t\t\t\t\t\tHttpInputMessage msgToUse =\n\t\t\t\t\t\t\t\tgetAdvice().beforeBodyRead(message, parameter, targetType, converterType);\n\t\t\t\t\t\tbody = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :\n\t\t\t\t\t\t\t\t((HttpMessageConverter<T>) converter).read(targetClass, msgToUse));\n\t\t\t\t\t\tbody = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbody = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\"I/O error while reading input message\", ex, inputMessage);\n\t\t}\n\t\tfinally {\n\t\t\tif (message != null && message.hasBody()) {\n\t\t\t\tcloseStreamIfNecessary(message.getBody());\n\t\t\t}\n\t\t}\n\n\t\tif (body == NO_VALUE) {\n\t\t\tif (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) ||\n\t\t\t\t\t(noContentType && !message.hasBody())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(contentType,\n\t\t\t\t\tgetSupportedMediaTypes(targetClass != null ? targetClass : Object.class), httpMethod);\n\t\t}\n\n\t\tMediaType selectedContentType = contentType;\n\t\tObject theBody = body;\n\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\tString formatted = LogFormatUtils.formatValue(theBody, !traceOn);\n\t\t\treturn \"Read \\\"\" + selectedContentType + \"\\\" to [\" + formatted + \"]\";\n\t\t});\n\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveName(name,parameter,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tMap<String, String> uriTemplateVars = (Map<String, String>) request.getAttribute(\n\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);\n\t\treturn (uriTemplateVars != null ? uriTemplateVars.get(name) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#validateIfApplicable(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the binding target if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter descriptor\n\t * @since 4.1.5\n\t * @see #isBindExceptionRequired\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tAnnotation[] annotations = parameter.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#writeWithMessageConverters(value,returnType,inputMessage,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return type to the given output message.\n\t * @param value the value to write to the output message\n\t * @param returnType the type of the value\n\t * @param inputMessage the input messages. Used to inspect the {@code Accept} header.\n\t * @param outputMessage the output message to write to\n\t * @throws IOException thrown in case of I/O errors\n\t * @throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\n\t * by the {@code Accept} header on the request cannot be met by the message converters\n\t * @throws HttpMessageNotWritableException thrown if a given message cannot\n\t * be written by a converter, or if the content-type chosen by the server\n\t * has no compatible converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "inputMessage",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tObject body;\n\t\tClass<?> valueType;\n\t\tType targetType;\n\n\t\tif (value instanceof CharSequence) {\n\t\t\tbody = value.toString();\n\t\t\tvalueType = String.class;\n\t\t\ttargetType = String.class;\n\t\t}\n\t\telse {\n\t\t\tbody = value;\n\t\t\tvalueType = getReturnValueType(body, returnType);\n\t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n\t\t}\n\n\t\tif (isResourceType(value, returnType)) {\n\t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &&\n\t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) {\n\t\t\t\tResource resource = (Resource) value;\n\t\t\t\ttry {\n\t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n\t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n\t\t\t\t\tvalueType = body.getClass();\n\t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMediaType selectedMediaType = null;\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tboolean isContentTypePreset = contentType != null && contentType.isConcrete();\n\t\tif (isContentTypePreset) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n\t\t\t}\n\t\t\tselectedMediaType = contentType;\n\t\t}\n\t\telse {\n\t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n\t\t\tList<MediaType> acceptableTypes;\n\t\t\ttry {\n\t\t\t\tacceptableTypes = getAcceptableMediaTypes(request);\n\t\t\t}\n\t\t\tcatch (HttpMediaTypeNotAcceptableException ex) {\n\t\t\t\tint series = outputMessage.getServletResponse().getStatus() / 100;\n\t\t\t\tif (body == null || series == 4 || series == 5) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring error response content (if any). \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n\t\t\tif (body != null && producibleTypes.isEmpty()) {\n\t\t\t\tthrow new HttpMessageNotWritableException(\n\t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n\t\t\t}\n\n\t\t\tList<MediaType> compatibleMediaTypes = new ArrayList<>();\n\t\t\tdetermineCompatibleMediaTypes(acceptableTypes, producibleTypes, compatibleMediaTypes);\n\n\t\t\t// For ProblemDetail, fall back on RFC 7807 format\n\t\t\tif (compatibleMediaTypes.isEmpty() && ProblemDetail.class.isAssignableFrom(valueType)) {\n\t\t\t\tdetermineCompatibleMediaTypes(this.problemMediaTypes, producibleTypes, compatibleMediaTypes);\n\t\t\t}\n\n\t\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n\t\t\t\t}\n\t\t\t\tif (body != null) {\n\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMimeTypeUtils.sortBySpecificity(compatibleMediaTypes);\n\n\t\t\tfor (MediaType mediaType : compatibleMediaTypes) {\n\t\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\t\tselectedMediaType = mediaType;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {\n\t\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"', given \" +\n\t\t\t\t\t\tacceptableTypes + \" and supported \" + producibleTypes);\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType != null) {\n\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\t\tGenericHttpMessageConverter genericConverter =\n\t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ghmc ? ghmc : null);\n\t\t\t\tif (genericConverter != null ?\n\t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n\t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n\t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n\t\t\t\t\t\t\tinputMessage, outputMessage);\n\t\t\t\t\tif (body != null) {\n\t\t\t\t\t\tObject theBody = body;\n\t\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn ->\n\t\t\t\t\t\t\t\t\"Writing [\" + LogFormatUtils.formatValue(theBody, !traceOn) + \"]\");\n\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n\t\t\t\t\t\tif (genericConverter != null) {\n\t\t\t\t\t\t\tgenericConverter.write(body, targetType, selectedMediaType, outputMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (body != null) {\n\t\t\tSet<MediaType> producibleMediaTypes =\n\t\t\t\t\t(Set<MediaType>) inputMessage.getServletRequest()\n\t\t\t\t\t\t\t.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\n\t\t\tif (isContentTypePreset || !CollectionUtils.isEmpty(producibleMediaTypes)) {\n\t\t\t\tthrow new HttpMessageNotWritableException(\n\t\t\t\t\t\t\"No converter for [\" + valueType + \"] with preset Content-Type '\" + contentType + \"'\");\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(getSupportedMediaTypes(body.getClass()));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#writeWithMessageConverters(value,returnType,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return value to the given web request. Delegates to\n\t * {@link #writeWithMessageConverters(Object, MethodParameter, ServletServerHttpRequest, ServletServerHttpResponse)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\t\twriteWithMessageConverters(value, returnType, inputMessage, outputMessage);\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\t// ErrorResponse exceptions that expose HTTP response details\n\t\t\tif (ex instanceof ErrorResponse errorResponse) {\n\t\t\t\tModelAndView mav = null;\n\t\t\t\tif (ex instanceof HttpRequestMethodNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpRequestMethodNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotAcceptable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingPathVariableException theEx) {\n\t\t\t\t\tmav = handleMissingPathVariable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestParameterException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestParameter(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestPartException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestPartException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof ServletRequestBindingException theEx) {\n\t\t\t\t\tmav = handleServletRequestBindingException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MethodArgumentNotValidException theEx) {\n\t\t\t\t\tmav = handleMethodArgumentNotValidException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof NoHandlerFoundException theEx) {\n\t\t\t\t\tmav = handleNoHandlerFoundException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof AsyncRequestTimeoutException theEx) {\n\t\t\t\t\tmav = handleAsyncRequestTimeoutException(theEx, request, response, handler);\n\t\t\t\t}\n\n\t\t\t\treturn (mav != null ? mav :\n\t\t\t\t\t\thandleErrorResponse(errorResponse, request, response, handler));\n\t\t\t}\n\n\t\t\t// Other, lower level exceptions\n\n\t\t\tif (ex instanceof ConversionNotSupportedException theEx) {\n\t\t\t\treturn handleConversionNotSupported(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof TypeMismatchException theEx) {\n\t\t\t\treturn handleTypeMismatch(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotReadableException theEx) {\n\t\t\t\treturn handleHttpMessageNotReadable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotWritableException theEx) {\n\t\t\t\treturn handleHttpMessageNotWritable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof BindException theEx) {\n\t\t\t\treturn handleBindException(theEx, request, response, handler);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception handlerEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", handlerEx);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleAsyncRequestTimeoutException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an async request timed out.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link AsyncRequestTimeoutException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleBindException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain ModelAttribute @ModelAttribute} method\n\t * argument has binding or validation errors and is not followed by another\n\t * method argument of type {@link BindingResult}.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @deprecated as of 6.0 since {@link org.springframework.web.method.annotation.ModelAttributeMethodProcessor}\n\t * now raises the {@link MethodArgumentNotValidException} subclass instead.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleBindException(BindException ex, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleConversionNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion cannot occur.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the ConversionNotSupportedException could be\n\t * rethrown as-is.\n\t * @param ex the ConversionNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleErrorResponse(errorResponse,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle an {@link ErrorResponse} exception.\n\t * <p>The default implementation sets status and the headers of the response\n\t * to those obtained from the {@code ErrorResponse}. If available, the\n\t * {@link ProblemDetail#getDetail()}  is used as the message for\n\t * {@link HttpServletResponse#sendError(int, String)}.\n\t * @param errorResponse the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "errorResponse",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleErrorResponse(ErrorResponse errorResponse,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleErrorResponse(ErrorResponse errorResponse,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tif (!response.isCommitted()) {\n\t\t\tHttpHeaders headers = errorResponse.getHeaders();\n\t\t\theaders.forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));\n\n\t\t\tint status = errorResponse.getStatusCode().value();\n\t\t\tString message = errorResponse.getBody().getDetail();\n\t\t\tif (message != null) {\n\t\t\t\tresponse.sendError(status, message);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.sendError(status);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Ignoring exception, response committed. : \" + errorResponse);\n\t\t}\n\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMediaTypeNotAcceptable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found that were acceptable for the client (expressed via the {@code Accept} header).\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotAcceptableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMediaTypeNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found for PUT or POSTed content.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMessageNotReadable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where a {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot read from an HTTP request.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotReadableException could be\n\t * rethrown as-is.\n\t * @param ex the HttpMessageNotReadableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMessageNotWritable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where a\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot write to an HTTP request.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the HttpMessageNotWritableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpRequestMethodNotSupported(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no handler was found for the HTTP method.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpRequestMethodNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMethodArgumentNotValidException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an argument annotated with {@code @Valid} such as\n\t * an {@link RequestBody} or {@link RequestPart} argument fails validation.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMissingPathVariable(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a declared path variable does not match any extracted URI variable.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingPathVariableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMissingServletRequestParameter(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a required parameter is missing.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingServletRequestParameterException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMissingServletRequestPartException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain RequestPart @RequestPart}, a {@link MultipartFile},\n\t * or a {@code jakarta.servlet.http.Part} argument is required but is missing.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleNoHandlerFoundException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no handler was found during the dispatch.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the NoHandlerFoundException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleServletRequestBindingException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when an unrecoverable binding exception occurs - e.g.\n\t * required header, required cookie.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleTypeMismatch(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion error occurs.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the TypeMismatchException could be rethrown as-is.\n\t * @param ex the TypeMismatchException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleTypeMismatch(TypeMismatchException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleTypeMismatch(TypeMismatchException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#sendServerError(ex,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked to send a server error. Sets the status to 500 and also sets the\n\t * request attribute \"jakarta.servlet.error.exception\" to the Exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "protected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\trequest.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex);\n\t\tresponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#registerExtension(coding,extension)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setExtensions(Map<String,extensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#changeLocale(locale,timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified locale and time zone context,\n\t * storing the new locale context through the configured {@link LocaleResolver}.\n\t * @param locale the new locale\n\t * @param timeZone the new time zone\n\t * @see LocaleContextResolver#setLocaleContext\n\t * @see org.springframework.context.i18n.SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale, TimeZone timeZone)",
    "source_code": "\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(this.request);\n\t\tif (!(localeResolver instanceof LocaleContextResolver localeContextResolver)) {\n\t\t\tthrow new IllegalStateException(\"Cannot change locale context if no LocaleContextResolver configured\");\n\t\t}\n\t\tlocaleContextResolver.setLocaleContext(this.request, this.response,\n\t\t\t\tnew SimpleTimeZoneAwareLocaleContext(locale, timeZone));\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#exposeLocalizationContext(request,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param request the current HTTP request\n\t * @param messageSource the MessageSource to expose,\n\t * typically the current ApplicationContext (may be {@code null})\n\t * @see #exposeLocalizationContext(RequestContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource)",
    "source_code": "\tpublic static void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource) {\n\t\tLocale jstlLocale = RequestContextUtils.getLocale(request);\n\t\tConfig.set(request, Config.FMT_LOCALE, jstlLocale);\n\t\tTimeZone timeZone = RequestContextUtils.getTimeZone(request);\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(request, Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tif (messageSource != null) {\n\t\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, request);\n\t\t\tConfig.set(request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getBindStatus(path,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders (named keys with braces {@code {}}).\n\t * For example, send in a relative URL {@code foo/{bar}?spam={spam}} and a parameter map\n\t * {@code {bar=baz,spam=nuts}} and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getErrors(name,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 861
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name, boolean htmlEscape)",
    "source_code": "\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tboolean put = false;\n\t\tif (errors == null) {\n\t\t\terrors = (Errors) getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\t// Check old BindException prefix for backwards compatibility.\n\t\t\tif (errors instanceof BindException bindException) {\n\t\t\t\terrors = bindException.getBindingResult();\n\t\t\t}\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tput = true;\n\t\t}\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t\tput = true;\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t\tput = true;\n\t\t}\n\t\tif (put) {\n\t\t\tthis.errorsMap.put(name, errors);\n\t\t}\n\t\treturn errors;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlAwareMessageSource(servletContext,messageSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks JSTL's \"jakarta.servlet.jsp.jstl.fmt.localizationContext\"\n\t * context-param and creates a corresponding child message source,\n\t * with the provided Spring-defined MessageSource as parent.\n\t * @param servletContext the ServletContext we're running in\n\t * (to check JSTL-related context-params in {@code web.xml})\n\t * @param messageSource the MessageSource to expose, typically\n\t * the ApplicationContext of the current DispatcherServlet\n\t * @return the MessageSource to expose to JSTL; first checking the\n\t * JSTL-defined bundle, then the Spring-defined MessageSource\n\t * @see org.springframework.context.ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "MessageSource",
    "signature": "public MessageSource getJstlAwareMessageSource(@Nullable ServletContext servletContext, MessageSource messageSource)",
    "source_code": "\tpublic static MessageSource getJstlAwareMessageSource(\n\t\t\t@Nullable ServletContext servletContext, MessageSource messageSource) {\n\n\t\tif (servletContext != null) {\n\t\t\tString jstlInitParam = servletContext.getInitParameter(Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\tif (jstlInitParam != null) {\n\t\t\t\t// Create a ResourceBundleMessageSource for the specified resource bundle\n\t\t\t\t// basename in the JSTL context-param in web.xml, wiring it with the given\n\t\t\t\t// Spring-defined MessageSource as parent.\n\t\t\t\tResourceBundleMessageSource jstlBundleWrapper = new ResourceBundleMessageSource();\n\t\t\t\tjstlBundleWrapper.setBasename(jstlInitParam);\n\t\t\t\tjstlBundleWrapper.setParentMessageSource(messageSource);\n\t\t\t\treturn jstlBundleWrapper;\n\t\t\t}\n\t\t}\n\t\treturn messageSource;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlLocale(request,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 937
    },
    "return": "Locale",
    "signature": "public Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\t\tpublic static Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject localeObject = Config.get(request, Config.FMT_LOCALE);\n\t\t\tif (localeObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\tlocaleObject = Config.get(session, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t\tif (localeObject == null && servletContext != null) {\n\t\t\t\t\tlocaleObject = Config.get(servletContext, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (localeObject instanceof Locale locale ? locale : null);\n\t\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlTimeZone(request,servletContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 952
    },
    "return": "TimeZone",
    "signature": "public TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\t\tpublic static TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject timeZoneObject = Config.get(request, Config.FMT_TIME_ZONE);\n\t\t\tif (timeZoneObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(session, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t\tif (timeZoneObject == null && servletContext != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(servletContext, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (timeZoneObject instanceof TimeZone timeZone ? timeZone : null);\n\t\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,defaultMessage,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, defaultMessage, getLocale());\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 711
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(code, args, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 629
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(resolvable,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 733
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.webApplicationContext.getMessage(resolvable, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 826
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null),\n\t\t\t\tdefaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 748
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#createQueryString(params,usedParams,includeQueryStringDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build the query string from available parameters that have not already\n\t * been applied as template params.\n\t * <p>The names and values of parameters are URL encoded.\n\t * @param params the parameters to build the query string from\n\t * @param usedParams set of parameter names that have been applied as\n\t * template params\n\t * @param includeQueryStringDelimiter true if the query string should start\n\t * with a '?' instead of '&amp;'\n\t * @return the query string\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "params",
      "usedParams",
      "includeQueryStringDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "String",
    "signature": "protected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)",
    "source_code": "\tprotected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)\n\t\t\tthrows JspException {\n\n\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\tStringBuilder qs = new StringBuilder();\n\t\tfor (Param param : params) {\n\t\t\tif (!usedParams.contains(param.getName()) && StringUtils.hasLength(param.getName())) {\n\t\t\t\tif (includeQueryStringDelimiter && qs.length() == 0) {\n\t\t\t\t\tqs.append('?');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqs.append('&');\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tqs.append(UriUtils.encodeQueryParam(param.getName(), encoding));\n\t\t\t\t\tif (param.getValue() != null) {\n\t\t\t\t\t\tqs.append('=');\n\t\t\t\t\t\tqs.append(UriUtils.encodeQueryParam(param.getValue(), encoding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn qs.toString();\n\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#replaceUriTemplateParams(uri,params,usedParams)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace template markers in the URL matching available parameters. The\n\t * name of matched parameters are added to the used parameters set.\n\t * <p>Parameter values are URL encoded.\n\t * @param uri the URL with template parameters to replace\n\t * @param params parameters used to replace template markers\n\t * @param usedParams set of template parameter names that have been replaced\n\t * @return the URL with template parameters replaced\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "uri",
      "params",
      "usedParams"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "String",
    "signature": "protected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)",
    "source_code": "\tprotected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)\n\t\t\tthrows JspException {\n\n\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\tfor (Param param : params) {\n\t\t\tString template = URL_TEMPLATE_DELIMITER_PREFIX + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\tif (uri.contains(template)) {\n\t\t\t\tusedParams.add(param.getName());\n\t\t\t\tString value = param.getValue();\n\t\t\t\ttry {\n\t\t\t\t\turi = StringUtils.replace(uri, template,\n\t\t\t\t\t\t\t(value != null ? UriUtils.encodePath(value, encoding) : \"\"));\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemplate = URL_TEMPLATE_DELIMITER_PREFIX + '/' + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\t\tif (uri.contains(template)) {\n\t\t\t\t\tusedParams.add(param.getName());\n\t\t\t\t\tString value = param.getValue();\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi = StringUtils.replace(uri, template,\n\t\t\t\t\t\t\t\t(value != null ? UriUtils.encodePathSegment(value, encoding) : \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uri;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#processFieldValue(name,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given form field through a {@link RequestDataValueProcessor}\n\t * instance if one is configured or otherwise returns the same value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "String",
    "signature": "protected String processFieldValue(@Nullable String name, String value, String type)",
    "source_code": "\tprotected final String processFieldValue(@Nullable String name, String value, String type) {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\tvalue = processor.processFormFieldValue(httpServletRequest, name, value, type);\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#applyLifecycleMethods(viewName,view)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @since 5.0\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#canHandle(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link org.springframework.web.servlet.ViewResolver} can\n\t * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will\n\t * return {@code null}. The default implementation checks against the configured\n\t * {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#createView(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to implement check for \"redirect:\" prefix.\n\t * <p>Not possible in {@code loadView}, since overridden\n\t * {@code loadView} versions in subclasses might rely on the\n\t * superclass always creating instances of the required view class.\n\t * @see #loadView\n\t * @see #requiredViewClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "View",
    "signature": "protected View createView(String viewName, Locale locale)",
    "source_code": "\tprotected View createView(String viewName, Locale locale) throws Exception {\n\t\t// If this resolver is not supposed to handle the given view,\n\t\t// return null to pass on to the next resolver in the chain.\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check for special \"redirect:\" prefix.\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\tRedirectView view = new RedirectView(redirectUrl,\n\t\t\t\t\tisRedirectContextRelative(), isRedirectHttp10Compatible());\n\t\t\tString[] hosts = getRedirectHosts();\n\t\t\tif (hosts != null) {\n\t\t\t\tview.setHosts(hosts);\n\t\t\t}\n\t\t\treturn applyLifecycleMethods(REDIRECT_URL_PREFIX, view);\n\t\t}\n\n\t\t// Check for special \"forward:\" prefix.\n\t\tif (viewName.startsWith(FORWARD_URL_PREFIX)) {\n\t\t\tString forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());\n\t\t\tInternalResourceView view = new InternalResourceView(forwardUrl);\n\t\t\treturn applyLifecycleMethods(FORWARD_URL_PREFIX, view);\n\t\t}\n\n\t\t// Else fall back to superclass implementation: calling loadView.\n\t\treturn super.createView(viewName, locale);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#getCacheKey(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns just the view name,\n\t * as this ViewResolver doesn't support localized resolution.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(String viewName, Locale locale)",
    "source_code": "\tprotected Object getCacheKey(String viewName, Locale locale) {\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#loadView(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@code buildView} for creating a new instance of the\n\t * specified view class. Applies the following Spring lifecycle methods\n\t * (as supported by the generic Spring bean factory):\n\t * <ul>\n\t * <li>ApplicationContextAware's {@code setApplicationContext}\n\t * <li>InitializingBean's {@code afterPropertiesSet}\n\t * </ul>\n\t * @param viewName the name of the view to retrieve\n\t * @return the View instance\n\t * @throws Exception if the view couldn't be resolved\n\t * @see #buildView(String)\n\t * @see org.springframework.context.ApplicationContextAware#setApplicationContext\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "View",
    "signature": "protected View loadView(String viewName, Locale locale)",
    "source_code": "\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tAbstractUrlBasedView view = buildView(viewName);\n\t\tView result = applyLifecycleMethods(viewName, view);\n\t\treturn (view.checkResource(locale) ? result : null);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#setAttributesMap(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set static attributes from a Map, for all views returned by this resolver.\n\t * This allows to set any kind of attribute values, for example bean references.\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @param attributes a Map with name Strings as keys and attribute objects as values\n\t * @see AbstractView#setAttributesMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "void",
    "signature": "public void setAttributesMap(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic void setAttributesMap(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tthis.staticAttributes.putAll(attributes);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#isEligibleForMarshalling(modelKey,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given value from the current view's model is eligible\n\t * for marshalling through the configured {@link Marshaller}.\n\t * <p>The default implementation calls {@link Marshaller#supports(Class)},\n\t * unwrapping a given {@link JAXBElement} first if applicable.\n\t * @param modelKey the value's key in the model (never {@code null})\n\t * @param value the value to check (never {@code null})\n\t * @return whether the given value is to be considered as eligible\n\t * @see Marshaller#supports(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "modelKey",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleForMarshalling(String modelKey, Object value)",
    "source_code": "\tprotected boolean isEligibleForMarshalling(String modelKey, Object value) {\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tClass<?> classToCheck = value.getClass();\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\tclassToCheck = jaxbElement.getDeclaredType();\n\t\t}\n\t\treturn this.marshaller.supports(classToCheck);\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#locateToBeMarshalled(Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Locate the object to be marshalled.\n\t * <p>The default implementation first attempts to look under the configured\n\t * {@linkplain #setModelKey(String) model key}, if any, before attempting to\n\t * locate an object of {@linkplain Marshaller#supports(Class) supported type}.\n\t * @param model the model Map\n\t * @return the Object to be marshalled (or {@code null} if none found)\n\t * @throws IllegalStateException if the model object specified by the\n\t * {@linkplain #setModelKey(String) model key} is not supported by the marshaller\n\t * @see #setModelKey(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object",
    "signature": "protected Object locateToBeMarshalled(Map<String, Object> model)",
    "source_code": "\tprotected Object locateToBeMarshalled(Map<String, Object> model) throws IllegalStateException {\n\t\tif (this.modelKey != null) {\n\t\t\tObject value = model.get(this.modelKey);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalStateException(\"Model contains no object with key [\" + this.modelKey + \"]\");\n\t\t\t}\n\t\t\tif (!isEligibleForMarshalling(this.modelKey, value)) {\n\t\t\t\tthrow new IllegalStateException(\"Model object [\" + value + \"] retrieved via key [\" +\n\t\t\t\t\t\tthis.modelKey + \"] is not supported by the Marshaller\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tObject value = entry.getValue();\n\t\t\tif (value != null && (model.size() == 1 || !(value instanceof BindingResult)) &&\n\t\t\t\t\tisEligibleForMarshalling(entry.getKey(), value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\tObject toBeMarshalled = locateToBeMarshalled(model);\n\t\tif (toBeMarshalled == null) {\n\t\t\tthrow new IllegalStateException(\"Unable to locate object to be marshalled in model: \" + model);\n\t\t}\n\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n\t\tthis.marshaller.marshal(toBeMarshalled, new StreamResult(baos));\n\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setContentLength(baos.size());\n\t\tbaos.writeTo(response.getOutputStream());\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#createAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "protected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel,AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate)",
    "source_code": "\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel,AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate) {\n\n\t\treturn new WebSocketAnnotationMethodMessageHandler(\n\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping(\n\t\t\tWebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler) {\n\n\t\tWebSocketHandler handler = decorateWebSocketHandler(subProtocolWebSocketHandler);\n\t\tWebMvcStompEndpointRegistry registry =\n\t\t\t\tnew WebMvcStompEndpointRegistry(handler, getTransportRegistration(), messageBrokerTaskScheduler);\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tif (applicationContext != null) {\n\t\t\tregistry.setApplicationContext(applicationContext);\n\t\t}\n\t\tregisterStompEndpoints(registry);\n\t\treturn registry.getHandlerMapping();\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#subProtocolWebSocketHandler(clientInboundChannel,clientOutboundChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler subProtocolWebSocketHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic WebSocketHandler subProtocolWebSocketHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\treturn new SubProtocolWebSocketHandler(clientInboundChannel, clientOutboundChannel);\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#webSocketMessageBrokerStats(stompBrokerRelayMessageHandler,subProtocolWebSocketHandler,@Qualifier(\"clientInboundChannelExecutor\")": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stompBrokerRelayMessageHandler",
      "subProtocolWebSocketHandler",
      "@Qualifier(\"clientInboundChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "WebSocketMessageBrokerStats",
    "signature": "public WebSocketMessageBrokerStats webSocketMessageBrokerStats(@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\")",
    "source_code": "\tpublic WebSocketMessageBrokerStats webSocketMessageBrokerStats(\n\t\t\t@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\") TaskExecutor inboundExecutor,\n\t\t\t@Qualifier(\"clientOutboundChannelExecutor\") TaskExecutor outboundExecutor,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\") TaskScheduler scheduler) {\n\n\t\tWebSocketMessageBrokerStats stats = new WebSocketMessageBrokerStats();\n\t\tstats.setSubProtocolWebSocketHandler((SubProtocolWebSocketHandler) subProtocolWebSocketHandler);\n\t\tif (stompBrokerRelayMessageHandler instanceof StompBrokerRelayMessageHandler sbrmh) {\n\t\t\tstats.setStompBrokerRelay(sbrmh);\n\t\t}\n\t\tstats.setInboundChannelExecutor(inboundExecutor);\n\t\tstats.setOutboundChannelExecutor(outboundExecutor);\n\t\tstats.setSockJsTaskScheduler(scheduler);\n\t\treturn stats;\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#afterConnectionClosed(session,closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\tthis.delegate.afterConnectionClosed(session, closeStatus);\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#afterConnectionClosed(session,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus status)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleBinaryMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message)",
    "source_code": "\tprotected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> message)",
    "source_code": "\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n\t\tthis.delegate.handleMessage(session, message);\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handlePongMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void handlePongMessage(WebSocketSession session, PongMessage message)",
    "source_code": "\tprotected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleTextMessage(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "protected void handleTextMessage(WebSocketSession session, TextMessage message)",
    "source_code": "\tprotected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleTransportError(session,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n\t\tthis.delegate.handleTransportError(session, exception);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#accept(webSocketSession,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "void",
    "signature": "public void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable)",
    "source_code": "\t\tpublic void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable) {\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.connectionHandler.afterConnectFailure(throwable);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterConnectionClosed(session,closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\t\tcancelInactivityTasks();\n\t\t\tthis.connectionHandler.afterConnectionClosed();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handler,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Connect to the given WebSocket URL and notify the given\n\t * {@link org.springframework.messaging.simp.stomp.StompSessionHandler}\n\t * when connected on the STOMP level after the CONNECTED frame is received.\n\t * @param url the url to connect to\n\t * @param handler the session handler\n\t * @param uriVars the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handler",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars) {\n\t\treturn connectAsync(url, null, handler, uriVars);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,connectHeaders,handler,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also accepts\n\t * {@link WebSocketHttpHeaders} to use for the WebSocket handshake and\n\t * {@link StompHeaders} for the STOMP CONNECT frame.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "connectHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables) {\n\n\t\tAssert.notNull(url, \"'url' must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(url).buildAndExpand(uriVariables).encode().toUri();\n\t\treturn connectAsync(uri, handshakeHeaders, connectHeaders, handler);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,connectHeaders,sessionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, WebSocketHttpHeaders, StompSessionHandler, Object...)}\n\t * that accepts a fully prepared {@link java.net.URI}.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param sessionHandler the STOMP session handler\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "connectHeaders",
      "sessionHandler"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler) {\n\n\t\tAssert.notNull(url, \"'url' must not be null\");\n\t\tConnectionHandlingStompSession session = createSession(connectHeaders, sessionHandler);\n\t\tWebSocketTcpConnectionHandlerAdapter adapter = new WebSocketTcpConnectionHandlerAdapter(session);\n\t\tgetWebSocketClient()\n\t\t\t\t.execute(new LoggingWebSocketHandlerDecorator(adapter), handshakeHeaders, url)\n\t\t\t\t.whenComplete(adapter);\n\t\treturn session.getSession();\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,handler,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn connectAsync(url, handshakeHeaders, null, handler, uriVariables);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessage(session,webSocketMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage)",
    "source_code": "\t\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage) {\n\t\t\tthis.lastReadTime = (this.lastReadTime != -1 ? System.currentTimeMillis() : -1);\n\t\t\tList<Message<byte[]>> messages;\n\t\t\ttry {\n\t\t\t\tmessages = this.codec.decode(webSocketMessage);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.connectionHandler.handleFailure(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (Message<byte[]> message : messages) {\n\t\t\t\tthis.connectionHandler.handleMessage(message);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleTransportError(session,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession session, Throwable ex) throws Exception {\n\t\t\tthis.connectionHandler.handleFailure(ex);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#onReadInactivity(runnable,duration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "void",
    "signature": "public void onReadInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onReadInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastReadTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastReadTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"ReadInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#onWriteInactivity(runnable,duration)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "public void onWriteInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onWriteInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastWriteTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.inactivityTasks.add(getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastWriteTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"WriteInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay));\n\t\t}"
  },
  "org.springframework.web.socket.server.standard.<unknown>#handleSuccess(request,response,upgradeInfo,upgradeResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "upgradeInfo",
      "upgradeResponse"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "protected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse)",
    "source_code": "\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse) throws IOException, ServletException {\n\n\t\tresponse.setStatus(upgradeResponse.getStatus());\n\t\tupgradeResponse.getHeaders().forEach((key, value) -> response.addHeader(key, Utils.getHeaderFromList(value)));\n\n\t\tAsyncContext asyncContext = request.startAsync();\n\t\tasyncContext.setTimeout(-1L);\n\n\t\tObject nativeRequest = getNativeRequest(request);\n\t\tBeanWrapper beanWrapper = new BeanWrapperImpl(nativeRequest);\n\t\tObject httpSocket = beanWrapper.getPropertyValue(\"connection.connectionHandler.rawConnection\");\n\t\tObject webSocket = webSocketHelper.newInstance(request, httpSocket);\n\t\twebSocketHelper.upgrade(webSocket, httpSocket, request.getServletContext());\n\n\t\tresponse.flushBuffer();\n\n\t\tboolean isProtected = request.getUserPrincipal() != null;\n\t\tWriter servletWriter = servletWriterHelper.newInstance(webSocket, isProtected);\n\t\tConnection connection = upgradeInfo.createConnection(servletWriter, noOpCloseListener);\n\t\tnew BeanWrapperImpl(webSocket).setPropertyValue(\"connection\", connection);\n\t\tnew BeanWrapperImpl(servletWriter).setPropertyValue(\"connection\", connection);\n\t\twebSocketHelper.registerForReadEvent(webSocket);\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#determineUser(request,wsHandler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A method that can be used to associate a user with the WebSocket session\n\t * in the process of being established. The default implementation calls\n\t * {@link ServerHttpRequest#getPrincipal()}\n\t * <p>Subclasses can provide custom logic for associating a user with a session,\n\t * for example for assigning a name to anonymous users (i.e. not fully authenticated).\n\t * @param request the handshake request\n\t * @param wsHandler the WebSocket handler that will handle messages\n\t * @param attributes handshake attributes to pass to the WebSocket session\n\t * @return the user for the WebSocket session, or {@code null} if not available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Principal",
    "signature": "protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tprotected Principal determineUser(\n\t\t\tServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\treturn request.getPrincipal();\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#doHandshake(request,response,wsHandler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tpublic final boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws HandshakeFailureException {\n\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHeaders());\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing request \" + request.getURI() + \" with headers=\" + headers);\n\t\t}\n\t\ttry {\n\t\t\tif (HttpMethod.GET != request.getMethod()) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\t\t\tresponse.getHeaders().setAllow(Collections.singleton(HttpMethod.GET));\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Handshake failed due to unexpected HTTP method: \" + request.getMethod());\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\t\thandleInvalidUpgradeHeader(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!headers.getConnection().contains(\"Upgrade\") && !headers.getConnection().contains(\"upgrade\")) {\n\t\t\t\thandleInvalidConnectHeader(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isWebSocketVersionSupported(headers)) {\n\t\t\t\thandleWebSocketVersionNotSupported(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isValidOrigin(request)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tString wsKey = headers.getSecWebSocketKey();\n\t\t\tif (wsKey == null) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t\t\t}\n\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HandshakeFailureException(\n\t\t\t\t\t\"Response update failed during upgrade to WebSocket: \" + request.getURI(), ex);\n\t\t}\n\n\t\tString subProtocol = selectProtocol(headers.getSecWebSocketProtocol(), wsHandler);\n\t\tList<WebSocketExtension> requested = headers.getSecWebSocketExtensions();\n\t\tList<WebSocketExtension> supported = this.requestUpgradeStrategy.getSupportedExtensions(request);\n\t\tList<WebSocketExtension> extensions = filterRequestedExtensions(request, requested, supported);\n\t\tPrincipal user = determineUser(request, wsHandler, attributes);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Upgrading to WebSocket, subProtocol=\" + subProtocol + \", extensions=\" + extensions);\n\t\t}\n\t\tthis.requestUpgradeStrategy.upgrade(request, response, subProtocol, extensions, user, wsHandler, attributes);\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#filterRequestedExtensions(request,requestedExtensions,supportedExtensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Filter the list of requested WebSocket extensions.\n\t * <p>As of 4.1, the default implementation of this method filters the list to\n\t * leave only extensions that are both requested and supported.\n\t * @param request the current request\n\t * @param requestedExtensions the list of extensions requested by the client\n\t * @param supportedExtensions the list of extensions supported by the server\n\t * @return the selected extensions or an empty list\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestedExtensions",
      "supportedExtensions"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "List<WebSocketExtension>",
    "signature": "protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions)",
    "source_code": "\tprotected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {\n\n\t\tList<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size());\n\t\tfor (WebSocketExtension extension : requestedExtensions) {\n\t\t\tif (supportedExtensions.contains(extension)) {\n\t\t\t\tresult.add(extension);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleInvalidConnectHeader(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Connection header\" + request.getHeaders().getConnection(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"\\\"Connection\\\" must be \\\"upgrade\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleInvalidUpgradeHeader(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Upgrade header: \" + request.getHeaders().getUpgrade(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleRequest(servletRequest,servletResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, this.wsHandler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(servletRequest.getMethod() + \" \" + servletRequest.getRequestURI());\n\t\t\t}\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handshakeHandler.doHandshake(request, response, this.wsHandler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\n\t\t\t\t\t\"Uncaught failure for request \" + request.getURI() + \" - \" + ex.getMessage(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tresponse.close();\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleWebSocketVersionNotSupported(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tString version = request.getHeaders().getFirst(\"Sec-WebSocket-Version\");\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to unsupported WebSocket version: \" + version +\n\t\t\t\t\t\t\t\". Supported versions: \" + Arrays.toString(getSupportedVersions()), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.UPGRADE_REQUIRED);\n\t\tresponse.getHeaders().set(WebSocketHttpHeaders.SEC_WEBSOCKET_VERSION,\n\t\t\t\tStringUtils.arrayToCommaDelimitedString(getSupportedVersions()));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#selectProtocol(requestedProtocols,webSocketHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the sub-protocol negotiation based on requested and supported sub-protocols.\n\t * For the list of supported sub-protocols, this method first checks if the target\n\t * WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any\n\t * sub-protocols have been explicitly configured with\n\t * {@link #setSupportedProtocols(String...)}.\n\t * @param requestedProtocols the requested sub-protocols\n\t * @param webSocketHandler the WebSocketHandler that will be used\n\t * @return the selected protocols or {@code null}\n\t * @see #determineHandlerSupportedProtocols(WebSocketHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestedProtocols",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "String",
    "signature": "protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {\n\t\tList<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler);\n\t\tfor (String protocol : requestedProtocols) {\n\t\t\tif (handlerProtocols.contains(protocol.toLowerCase())) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t\tif (this.supportedProtocols.contains(protocol.toLowerCase())) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#afterConnectionClosed(webSocketSession,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status) throws Exception {\n\t\t\tthis.sockJsSession.afterTransportClosed(status);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#connectAsync(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,\n\t\t\tWebSocketHandler handler)",
    "source_code": "\tpublic CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,\n\t\t\tWebSocketHandler handler) {\n\t\tCompletableFuture<WebSocketSession> future = new CompletableFuture<>();\n\t\tWebSocketClientSockJsSession session = new WebSocketClientSockJsSession(request, handler, future);\n\t\thandler = new ClientSockJsWebSocketHandler(session);\n\t\trequest.addTimeoutTask(session.getTimeoutTask());\n\n\t\tURI url = request.getTransportUrl();\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHandshakeHeaders());\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Starting WebSocket session on \" + url);\n\t\t}\n\t\tthis.webSocketClient.execute(handler, headers, url).whenComplete((webSocketSession, throwable) -> {\n\t\t\tif (throwable != null) {\n\t\t\t\tfuture.completeExceptionally(throwable);\n\t\t\t}\n\t\t});\n\t\treturn future;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#connectInternal(transportRequest,handler,receiveUrl,handshakeHeaders,session,connectFuture)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transportRequest",
      "handler",
      "receiveUrl",
      "handshakeHeaders",
      "session",
      "connectFuture"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "protected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,\n\t\t\tfinal URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,\n\t\t\tfinal CompletableFuture<WebSocketSession> connectFuture)",
    "source_code": "\tprotected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,\n\t\t\tfinal URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,\n\t\t\tfinal CompletableFuture<WebSocketSession> connectFuture) {\n\n\t\tgetTaskExecutor().execute(() -> {\n\t\t\tHttpHeaders httpHeaders = transportRequest.getHttpRequestHeaders();\n\t\t\tXhrRequestCallback requestCallback = new XhrRequestCallback(handshakeHeaders);\n\t\t\tXhrRequestCallback requestCallbackAfterHandshake = new XhrRequestCallback(httpHeaders);\n\t\t\tXhrReceiveExtractor responseExtractor = new XhrReceiveExtractor(session);\n\t\t\twhile (true) {\n\t\t\t\tif (session.isDisconnected()) {\n\t\t\t\t\tsession.afterTransportClosed(null);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Starting XHR receive request, url=\" + receiveUrl);\n\t\t\t\t\t}\n\t\t\t\t\tgetRestTemplate().execute(receiveUrl, HttpMethod.POST, requestCallback, responseExtractor);\n\t\t\t\t\trequestCallback = requestCallbackAfterHandshake;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (!connectFuture.isDone()) {\n\t\t\t\t\t\tconnectFuture.completeExceptionally(ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsession.handleTransportError(ex);\n\t\t\t\t\t\tsession.afterTransportClosed(new CloseStatus(1006, ex.getMessage()));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#executeInfoRequestInternal(infoUrl,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infoUrl",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "ResponseEntity<String>",
    "signature": "protected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers)",
    "source_code": "\tprotected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers);\n\t\treturn nonNull(this.restTemplate.execute(infoUrl, HttpMethod.GET, requestCallback, textResponseExtractor));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#executeSendRequestInternal(url,headers,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "headers",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "ResponseEntity<String>",
    "signature": "public ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message)",
    "source_code": "\tpublic ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers, message.getPayload());\n\t\treturn nonNull(this.restTemplate.execute(url, HttpMethod.POST, requestCallback, textResponseExtractor));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTextMessage(webSocketSession,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession webSocketSession, TextMessage message)",
    "source_code": "\t\tpublic void handleTextMessage(WebSocketSession webSocketSession, TextMessage message) throws Exception {\n\t\t\tthis.sockJsSession.handleFrame(message.getPayload());\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTransportError(webSocketSession,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {\n\t\t\tthis.sockJsSession.handleTransportError(ex);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRequest(servletRequest,servletResponse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\ttry {\n\t\t\tthis.sockJsService.handleRequest(request, response, getSockJsPath(servletRequest), this.webSocketHandler);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new SockJsException(\"Uncaught failure in SockJS request, uri=\" + request.getURI(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#afterConnectionClosed(wsSession,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status) throws Exception {\n\t\tthis.sockJsSession.delegateConnectionClosed(status);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#createSession(id,handler,Map<String,attrs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id",
      "handler",
      "Map<String",
      "attrs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "AbstractSockJsSession",
    "signature": "public AbstractSockJsSession createSession(String id, WebSocketHandler handler, Map<String, Object> attrs)",
    "source_code": "\tpublic AbstractSockJsSession createSession(String id, WebSocketHandler handler, Map<String, Object> attrs) {\n\t\treturn new WebSocketServerSockJsSession(id, getServiceConfig(), handler, attrs);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#doHandshake(request,response,handler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "public boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes) throws HandshakeFailureException {\n\n\t\treturn this.handshakeHandler.doHandshake(request, response, handler, attributes);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequest(request,response,wsHandler,wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession)",
    "source_code": "\tpublic void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession) throws SockJsException {\n\n\t\tWebSocketServerSockJsSession sockJsSession = (WebSocketServerSockJsSession) wsSession;\n\t\ttry {\n\t\t\twsHandler = new SockJsWebSocketHandler(getServiceConfig(), wsHandler, sockJsSession);\n\t\t\tthis.handshakeHandler.doHandshake(request, response, wsHandler, sockJsSession.getAttributes());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"WebSocket handshake failure\", wsSession.getId(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleTextMessage(wsSession,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession wsSession, TextMessage message)",
    "source_code": "\tpublic void handleTextMessage(WebSocketSession wsSession, TextMessage message) throws Exception {\n\t\tthis.sockJsSession.handleMessage(message, wsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleTransportError(webSocketSession,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable exception) throws Exception {\n\t\tthis.sockJsSession.delegateError(exception);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleInitialRequest(request,response,frameFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the first request for receiving messages on a SockJS HTTP transport\n\t * based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing the open frame. Streaming-based transports (\"xhr_streaming\",\n\t * \"eventsource\", and \"htmlfile\") leave the response open longer for further\n\t * streaming of message frames but will also close it eventually after some\n\t * amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\ttry {\n\t\t\tthis.localAddress = request.getLocalAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\t\ttry {\n\t\t\tthis.remoteAddress = request.getRemoteAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\t// Let \"our\" handler know before sending the open frame to the remote handler\n\t\t\t\tdelegateConnectionEstablished();\n\t\t\t\thandleRequestInternal(request, response, true);\n\t\t\t\t// Request might have been reset (e.g. polling sessions do after writing)\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to open session\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleMessage(message,wsSession)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void handleMessage(TextMessage message, WebSocketSession wsSession)",
    "source_code": "\tpublic void handleMessage(TextMessage message, WebSocketSession wsSession) throws Exception {\n\t\tString payload = message.getPayload();\n\t\tif (!StringUtils.hasLength(payload)) {\n\t\t\treturn;\n\t\t}\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = getSockJsServiceConfig().getMessageCodec().decode(payload);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Broken data received. Terminating WebSocket connection abruptly\", ex);\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.BAD_DATA);\n\t\t\treturn;\n\t\t}\n\t\tif (messages != null) {\n\t\t\tdelegateMessages(messages);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleRequestInternal(request,response,initialRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a SockJS transport request is received.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param initialRequest whether it is the first request for the session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "initialRequest"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tboolean initialRequest)",
    "source_code": "\tprotected abstract void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tboolean initialRequest) throws IOException;\n\n\t@Override\n\tprotected final void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\tsynchronized (this.responseLock) {\n\t\t\tthis.messageCache.add(message);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush in session \" + getId());\n\t\t\t}\n\t\t\tif (isActive() && this.readyToSend) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is active, ready to flush.\");\n\t\t\t\t}\n\t\t\t\tcancelHeartbeat();\n\t\t\t\tflushCache();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is not active, not ready to flush.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleSuccessiveRequest(request,response,frameFormat)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle all requests, except the first one, to receive messages on a SockJS\n\t * HTTP transport based session.\n\t * <p>Long polling-based transports (e.g. \"xhr\", \"jsonp\") complete the request\n\t * after writing any buffered message frames (or the next one). Streaming-based\n\t * transports (\"xhr_streaming\", \"eventsource\", and \"htmlfile\") leave the\n\t * response open longer for further streaming of message frames but will also\n\t * close it eventually after some amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tif (isClosed()) {\n\t\t\t\t\tString formattedFrame = frameFormat.format(SockJsFrame.closeFrameGoAway());\n\t\t\t\t\tresponse.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\thandleRequestInternal(request, response, false);\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to handle SockJS receive request\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}"
  }
}