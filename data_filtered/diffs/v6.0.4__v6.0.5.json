{
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {\n\n\t\treturn convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type (if necessary from a String),\n\t * for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param typeDescriptor the descriptor for the target property or field\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx = null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n\t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue = newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n\t\t\t\t\tconvertedValue instanceof String text) {\n\t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc != null) {\n\t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray(text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor == null) {\n\t\t\t\teditor = findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion = false;\n\n\t\tif (requiredType != null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue != null) {\n\t\t\t\tif (Object.class == requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String text && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray(text);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection<?> coll) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue = convertToTypedCollection(coll, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map<?, ?> map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue = convertToTypedMap(map, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n\t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String text && !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue = text.trim();\n\t\t\t\t\tif (requiredType.isEnum() && trimmedValue.isEmpty()) {\n\t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number num && Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(num, (Class<Number>) requiredType);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue == null\n\t\t\t\tif (requiredType == Optional.class) {\n\t\t\t\t\tconvertedValue = Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx != null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService != null && typeDescriptor != null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn't produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append('\\'');\n\t\t\t\tif (propertyName != null) {\n\t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append('\\'');\n\t\t\t\t}\n\t\t\t\tif (editor != null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append('\\'');\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx != null) {\n\t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifier(bdHolder,annotation,typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotation against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotation",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifier(BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter)",
    "source_code": "\tprotected boolean checkQualifier(\n\t\t\tBeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter) {\n\n\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\tRootBeanDefinition bd = (RootBeanDefinition) bdHolder.getBeanDefinition();\n\n\t\tAutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());\n\t\tif (qualifier == null) {\n\t\t\tqualifier = bd.getQualifier(ClassUtils.getShortName(type));\n\t\t}\n\t\tif (qualifier == null) {\n\t\t\t// First, check annotation on qualified element, if any\n\t\t\tAnnotation targetAnnotation = getQualifiedElementAnnotation(bd, type);\n\t\t\t// Then, check annotation on factory method, if applicable\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(bd, type);\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);\n\t\t\t\tif (dbd != null) {\n\t\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(dbd, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\t// Look for matching annotation on the target class\n\t\t\t\tif (getBeanFactory() != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());\n\t\t\t\t\t\tif (beanType != null) {\n\t\t\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t// Not the usual case - simply forget about the type check...\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (targetAnnotation == null && bd.hasBeanClass()) {\n\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation != null && targetAnnotation.equals(annotation)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);\n\t\tif (attributes.isEmpty() && qualifier == null) {\n\t\t\t// If no attributes, the qualifier must be present\n\t\t\treturn false;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tObject expectedValue = entry.getValue();\n\t\t\tObject actualValue = null;\n\t\t\t// Check qualifier first\n\t\t\tif (qualifier != null) {\n\t\t\t\tactualValue = qualifier.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null) {\n\t\t\t\t// Fall back on bean definition attribute\n\t\t\t\tactualValue = bd.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null && attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &&\n\t\t\t\t\texpectedValue instanceof String name && bdHolder.matchesName(name)) {\n\t\t\t\t// Fall back on bean name (or alias) match\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (actualValue == null && qualifier != null) {\n\t\t\t\t// Fall back on default, but only if the qualifier is present\n\t\t\t\tactualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);\n\t\t\t}\n\t\t\tif (actualValue != null) {\n\t\t\t\tactualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());\n\t\t\t}\n\t\t\tif (!expectedValue.equals(actualValue)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifiers(bdHolder,annotationsToSearch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tif (ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\treturn true;\n\t\t}\n\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\tboolean checkMeta = true;\n\t\t\tboolean fallbackToMeta = false;\n\t\t\tif (isQualifier(type)) {\n\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheckMeta = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkMeta) {\n\t\t\t\tboolean foundMeta = false;\n\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getFactoryMethodAnnotation(bd,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Annotation",
    "signature": "protected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tMethod resolvedFactoryMethod = bd.getResolvedFactoryMethod();\n\t\treturn (resolvedFactoryMethod != null ? AnnotationUtils.getAnnotation(resolvedFactoryMethod, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getQualifiedElementAnnotation(bd,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "Annotation",
    "signature": "protected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tAnnotatedElement qualifiedElement = bd.getQualifiedElement();\n\t\treturn (qualifiedElement != null ? AnnotationUtils.getAnnotation(qualifiedElement, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the provided bean definition is an autowire candidate.\n\t * <p>To be considered a candidate the bean's <em>autowire-candidate</em>\n\t * attribute must not have been set to 'false'. Also, if an annotation on\n\t * the field or parameter to be autowired is recognized by this bean factory\n\t * as a <em>qualifier</em>, the bean must 'match' against the annotation as\n\t * well as any attributes it may contain. The bean definition must contain\n\t * the same qualifier or match by meta attributes. A \"value\" attribute will\n\t * fall back to match against the bean name or an alias if a qualifier or\n\t * attribute does not match.\n\t * @see Qualifier\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tboolean match = super.isAutowireCandidate(bdHolder, descriptor);\n\t\tif (match) {\n\t\t\tmatch = checkQualifiers(bdHolder, descriptor.getAnnotations());\n\t\t\tif (match) {\n\t\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\t\tif (methodParam != null) {\n\t\t\t\t\tMethod method = methodParam.getMethod();\n\t\t\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\t\t\tmatch = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#createServiceLocatorException(exceptionConstructor,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a service locator exception for the given cause.\n\t * Only called in case of a custom service locator exception.\n\t * <p>The default implementation can handle all variations of\n\t * message and exception arguments.\n\t * @param exceptionConstructor the constructor to use\n\t * @param cause the cause of the service lookup failure\n\t * @return the service locator exception to throw\n\t * @see #setServiceLocatorExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionConstructor",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Exception",
    "signature": "protected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause)",
    "source_code": "\tprotected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause) {\n\t\tClass<?>[] paramTypes = exceptionConstructor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (String.class == paramTypes[i]) {\n\t\t\t\targs[i] = cause.getMessage();\n\t\t\t}\n\t\t\telse if (paramTypes[i].isInstance(cause)) {\n\t\t\t\targs[i] = cause;\n\t\t\t}\n\t\t}\n\t\treturn BeanUtils.instantiateClass(exceptionConstructor, args);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getFlattenedMap(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a flattened version of the given map, recursively following any nested Map\n\t * or Collection values. Entries from the resulting map retain the same order as the\n\t * source. When called with the Map from a {@link MatchCallback} the result will\n\t * contain the same values as the {@link MatchCallback} Properties.\n\t * @param source the source map\n\t * @return a flattened map\n\t * @since 4.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Object>",
    "signature": "protected Object> getFlattenedMap(Map<String, Object> source)",
    "source_code": "\tprotected final Map<String, Object> getFlattenedMap(Map<String, Object> source) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tbuildFlattenedMap(result, source, null);\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getMostSpecific(a,b)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "MatchStatus",
    "signature": "public MatchStatus getMostSpecific(MatchStatus a, MatchStatus b)",
    "source_code": "\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t// Use hashCode of service locator proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"Service locator: \" + serviceLocatorInterface;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn invokeServiceLocatorMethod(method, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addBean(name,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new singleton bean.\n\t * <p>Will overwrite any existing instance for the given name.\n\t * @param name the name of the bean\n\t * @param bean the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beans.put(name, bean);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectFromFactoryBean(factory,beanName,shouldPostProcess)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an object to expose from the given FactoryBean.\n\t * @param factory the FactoryBean instance\n\t * @param beanName the name of the bean\n\t * @param shouldPostProcess whether the bean is subject to post-processing\n\t * @return the object obtained from the FactoryBean\n\t * @throws BeanCreationException if FactoryBean object creation failed\n\t * @see org.springframework.beans.factory.FactoryBean#getObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "beanName",
      "shouldPostProcess"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Object",
    "signature": "protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess)",
    "source_code": "\tprotected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n\t\tif (factory.isSingleton() && containsSingleton(beanName)) {\n\t\t\tsynchronized (getSingletonMutex()) {\n\t\t\t\tObject object = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\tif (object == null) {\n\t\t\t\t\tobject = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\t\t\t// Only post-process and store if not put there already during getObject() call above\n\t\t\t\t\t// (e.g. because of circular reference processing triggered by custom getBean calls)\n\t\t\t\t\tObject alreadyThere = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\t\tif (alreadyThere != null) {\n\t\t\t\t\t\tobject = alreadyThere;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (shouldPostProcess) {\n\t\t\t\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\t\t\t\t// Temporarily return non-post-processed object, not storing it yet..\n\t\t\t\t\t\t\t\treturn object;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\t\"Post-processing of FactoryBean's singleton object failed\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (containsSingleton(beanName)) {\n\t\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tObject object = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\tif (shouldPostProcess) {\n\t\t\t\ttry {\n\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create a new instance of a dynamically generated subclass implementing the\n\t\t * required lookups.\n\t\t * @param ctor constructor to use. If this is {@code null}, use the\n\t\t * no-arg constructor (no parameterization, or Setter Injection)\n\t\t * @param args arguments to use for the constructor.\n\t\t * Ignored if the {@code ctor} parameter is {@code null}.\n\t\t * @return new instance of the dynamically generated subclass\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "public Object instantiate(@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\t\tpublic Object instantiate(@Nullable Constructor<?> ctor, Object... args) {\n\t\t\tClass<?> subclass = createEnhancedSubclass(this.beanDefinition);\n\t\t\tObject instance;\n\t\t\tif (ctor == null) {\n\t\t\t\tinstance = BeanUtils.instantiateClass(subclass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());\n\t\t\t\t\tinstance = enhancedSubclassConstructor.newInstance(args);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new BeanInstantiationException(this.beanDefinition.getBeanClass(),\n\t\t\t\t\t\t\t\"Failed to invoke constructor for CGLIB enhanced subclass [\" + subclass.getName() + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPR-10785: set callbacks directly on the instance instead of in the\n\t\t\t// enhanced class (via the Enhancer) in order to avoid memory leaks.\n\t\t\tFactory factory = (Factory) instance;\n\t\t\tfactory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n\t\t\t\t\tnew LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n\t\t\t\t\tnew ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});\n\t\t\treturn instance;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithMethodInjection(bd,beanName,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\treturn instantiateWithMethodInjection(bd, beanName, owner, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithMethodInjection(bd,beanName,owner,ctor,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args) {\n\n\t\treturn new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#intercept(obj,method,args,mp)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "mp"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\tReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(ro != null, \"ReplaceOverride not found\");\n\t\t\t// TODO could cache if a singleton for minor performance optimization\n\t\t\tMethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);\n\t\t\treturn mr.reimplement(obj, method, args);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(location,actualResources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified resource location.\n\t * <p>The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @param actualResources a Set to be filled with the actual Resource objects\n\t * that have been resolved during the loading process. May be {@code null}\n\t * to indicate that the caller is not interested in those Resource objects.\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "actualResources"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)",
    "source_code": "\tpublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tif (resourceLoader == null) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t\t}\n\n\t\tif (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\t// Resource pattern matching available.\n\t\t\ttry {\n\t\t\t\tResource[] resources = resourcePatternResolver.getResources(location);\n\t\t\t\tint count = loadBeanDefinitions(resources);\n\t\t\t\tif (actualResources != null) {\n\t\t\t\t\tCollections.addAll(actualResources, resources);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Can only load single resources by absolute URL.\n\t\t\tResource resource = resourceLoader.getResource(location);\n\t\t\tint count = loadBeanDefinitions(resource);\n\t\t\tif (actualResources != null) {\n\t\t\t\tactualResources.add(resource);\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.<unknown>#compare(o1,o2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "int",
    "signature": "public int compare(T o1, T o2)",
    "source_code": "\tpublic int compare(T o1, T o2) {\n\t\tObject v1 = getPropertyValue(o1);\n\t\tObject v2 = getPropertyValue(o2);\n\t\tif (this.sortDefinition.isIgnoreCase() && (v1 instanceof String text1) && (v2 instanceof String text2)) {\n\t\t\tv1 = text1.toLowerCase();\n\t\t\tv2 = text2.toLowerCase();\n\t\t}\n\n\t\tint result;\n\n\t\t// Put an object with null property at the end of the sort result.\n\t\ttry {\n\t\t\tif (v1 != null) {\n\t\t\t\tresult = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (v2 != null ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not sort objects [\" + o1 + \"] and [\" + o2 + \"]\", ex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (this.sortDefinition.isAscending() ? result : -result);\n\t}"
  },
  "org.springframework.beans.support.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given custom property editor for all properties of the given type.\n\t * <p>Typically used in conjunction with the default\n\t * {@link org.springframework.beans.SimpleTypeConverter}; will work with any\n\t * TypeConverter that implements the PropertyEditorRegistry interface as well.\n\t * @param requiredType type of the property\n\t * @param propertyEditor editor to register\n\t * @see #setTypeConverter\n\t * @see org.springframework.beans.PropertyEditorRegistry#registerCustomEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (!(converter instanceof PropertyEditorRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"TypeConverter does not implement PropertyEditorRegistry interface: \" + converter);\n\t\t}\n\t\tregistry.registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.beans.support.<unknown>#sort(source,sortDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Sort the given source according to the given sort definition.\n\t * <p>Note: Contained objects have to provide the given property\n\t * in the form of a bean property, i.e. a getXXX method.\n\t * @param source input source\n\t * @param sortDefinition the parameters to sort by\n\t * @throws java.lang.IllegalArgumentException in case of a missing propertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sortDefinition"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void sort(Object[] source, SortDefinition sortDefinition)",
    "source_code": "\tpublic static void sort(Object[] source, SortDefinition sortDefinition) throws BeansException {\n\t\tif (StringUtils.hasText(sortDefinition.getProperty())) {\n\t\t\tArrays.sort(source, new PropertyComparator<>(sortDefinition));\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#checkCandidate(beanName,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given candidate's bean name, determining whether the corresponding\n\t * bean definition needs to be registered or conflicts with an existing definition.\n\t * @param beanName the suggested name for the bean\n\t * @param beanDefinition the corresponding bean definition\n\t * @return {@code true} if the bean can be registered as-is;\n\t * {@code false} if it should be skipped because there is an\n\t * existing, compatible bean definition for the specified name\n\t * @throws ConflictingBeanDefinitionException if an existing, incompatible\n\t * bean definition has been found for the specified name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "boolean",
    "signature": "protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tBeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n\t\tBeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n\t\tif (originatingDef != null) {\n\t\t\texistingDef = originatingDef;\n\t\t}\n\t\tif (isCompatible(beanDefinition, existingDef)) {\n\t\t\treturn false;\n\t\t}\n\t\tthrow new ConflictingBeanDefinitionException(\"Annotation-specified bean name '\" + beanName +\n\t\t\t\t\"' for bean class [\" + beanDefinition.getBeanClassName() + \"] conflicts with existing, \" +\n\t\t\t\t\"non-compatible bean definition of same name and class [\" + existingDef.getBeanClassName() + \"]\");\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#isCompatible(newDefinition,existingDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDefinition the new bean definition, originated from scanning\n\t * @param existingDefinition the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "newDefinition",
      "existingDefinition"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "boolean",
    "signature": "protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition)",
    "source_code": "\tprotected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) {\n\t\treturn (!(existingDefinition instanceof ScannedGenericBeanDefinition) ||  // explicitly registered overriding bean\n\t\t\t\t(newDefinition.getSource() != null && newDefinition.getSource().equals(existingDefinition.getSource())) ||  // scanned same file twice\n\t\t\t\tnewDefinition.equals(existingDefinition));  // scanned equivalent class twice\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeanDefinition(beanDefinition,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply further settings to the given bean definition,\n\t * beyond the contents retrieved from scanning the component class.\n\t * @param beanDefinition the scanned bean definition\n\t * @param beanName the generated bean name for the given bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName)",
    "source_code": "\tprotected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {\n\t\tbeanDefinition.applyDefaults(this.beanDefinitionDefaults);\n\t\tif (this.autowireCandidatePatterns != null) {\n\t\t\tbeanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name) {\n\t\tdoRegisterBean(beanClass, name, null, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,qualifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers) {\n\n\t\tdoRegisterBean(beanClass, name, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, name, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier,customizers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, e.g. setting a lazy-init or primary flag\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers) {\n\n\t\tdoRegisterBean(beanClass, name, null, supplier, customizers);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,qualifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers) {\n\t\tdoRegisterBean(beanClass, null, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,supplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, null, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBeanDefinition(definitionHolder,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified bean with the given registry.\n\t * <p>Can be overridden in subclasses, e.g. to adapt the registration\n\t * process or to register further bean definitions for each scanned bean.\n\t * @param definitionHolder the bean definition plus bean name for the bean\n\t * @param registry the BeanDefinitionRegistry to register the bean with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definitionHolder",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#shouldSkip(metadata,phase)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * @param metadata the meta data\n\t * @param phase the phase of the call\n\t * @return if the item should be skipped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)",
    "source_code": "\tpublic boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {\n\t\tif (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (phase == null) {\n\t\t\tif (metadata instanceof AnnotationMetadata annotationMetadata &&\n\t\t\t\t\tConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) {\n\t\t\t\treturn shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t\t}\n\t\t\treturn shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n\t\t}\n\n\t\tList<Condition> conditions = new ArrayList<>();\n\t\tfor (String[] conditionClasses : getConditionClasses(metadata)) {\n\t\t\tfor (String conditionClass : conditionClasses) {\n\t\t\t\tCondition condition = getCondition(conditionClass, this.context.getClassLoader());\n\t\t\t\tconditions.add(condition);\n\t\t\t}\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(conditions);\n\n\t\tfor (Condition condition : conditions) {\n\t\t\tConfigurationPhase requiredPhase = null;\n\t\t\tif (condition instanceof ConfigurationCondition configurationCondition) {\n\t\t\t\trequiredPhase = configurationCondition.getConfigurationPhase();\n\t\t\t}\n\t\t\tif ((requiredPhase == null || requiredPhase == phase) && !condition.matches(this.context, metadata)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.codec.<unknown>#parseSseLines(state,blackhole)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void parseSseLines(SseLinesState state, Blackhole blackhole)",
    "source_code": "\tpublic void parseSseLines(SseLinesState state, Blackhole blackhole) {\n\t\tblackhole.consume(state.parseLines().blockLast());\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(read,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 998
    },
    "return": "void",
    "signature": "public void completed(Integer read, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer read, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\t\t\tDataBuffer dataBuffer = attachment.dataBuffer();\n\n\t\t\tif (this.state.get().equals(State.DISPOSED)) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\t\t\tdataBuffer.writePosition(read);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(read,byteBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 988
    },
    "return": "void",
    "signature": "public void completed(Integer read, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void completed(Integer read, ByteBuffer byteBuffer) {\n\t\t\tif (this.state.get().equals(State.DISPOSED)) {\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\n\t\t\tbyteBuffer.flip();\n\t\t\tDataBuffer dataBuffer = this.dataBufferFactory.wrap(byteBuffer);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(written,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1161
    },
    "return": "void",
    "signature": "public void completed(Integer written, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer written, Attachment attachment) {\n\t\t\tDataBuffer.ByteBufferIterator iterator = attachment.iterator();\n\t\t\titerator.close();\n\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tByteBuffer byteBuffer = attachment.byteBuffer();\n\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, attachment, this);\n\t\t\t}\n\t\t\telse if (iterator.hasNext()) {\n\t\t\t\tByteBuffer next = iterator.next();\n\t\t\t\tthis.channel.write(next, pos, attachment, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\t\tthis.writing.set(false);\n\n\t\t\t\tThrowable throwable = this.error.get();\n\t\t\t\tif (throwable != null) {\n\t\t\t\t\tthis.sink.error(throwable);\n\t\t\t\t}\n\t\t\t\telse if (this.completed.get()) {\n\t\t\t\t\tthis.sink.complete();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trequest(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(written,byteBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1138
    },
    "return": "void",
    "signature": "public void completed(Integer written, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void completed(Integer written, ByteBuffer byteBuffer) {\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, byteBuffer, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsinkDataBuffer();\n\n\t\t\tThrowable throwable = this.error.get();\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.sink.error(throwable);\n\t\t\t}\n\t\t\telse if (this.completed.get()) {\n\t\t\t\tthis.sink.complete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequest(1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(exc,attachment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1193
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, Attachment attachment)",
    "source_code": "\t\tpublic void failed(Throwable exc, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\n\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\tthis.writing.set(false);\n\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(exc,byteBuffer)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void failed(Throwable exc, ByteBuffer byteBuffer) {\n\t\t\tsinkDataBuffer();\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tcheckIndex(srcPos, length);\n\t\tAssert.notNull(dest, \"Dest must not be null\");\n\n\t\tdest = dest.duplicate().clear();\n\t\tdest.put(destPos, this.byteBuffer, srcPos, length);\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#areBoxingCompatible(desc1,desc2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether boxing/unboxing can get from one type to the other.\n\t * <p>Assumes at least one of the types is in boxed form (i.e. single char descriptor).\n\t * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "boolean",
    "signature": "public boolean areBoxingCompatible(String desc1, String desc2)",
    "source_code": "\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n\t\tif (desc1.equals(desc2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (desc1.length() == 1) {\n\t\t\treturn checkPairs(desc1, desc2);\n\t\t}\n\t\telse if (desc2.length() == 1) {\n\t\t\treturn checkPairs(desc2, desc1);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertAnyNecessaryTypeConversionBytecodes(mv,targetDescriptor,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary numeric conversion bytecodes based upon what is on the\n\t * stack and the desired target type.\n\t * @param mv the method visitor into which instructions should be placed\n\t * @param targetDescriptor the (primitive) descriptor of the target type\n\t * @param stackDescriptor the descriptor of the operand on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "void",
    "signature": "public void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor)",
    "source_code": "\tpublic static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\treturn;\n\t\t}\n\t\tchar stackTop = stackDescriptor.charAt(0);\n\t\tswitch (stackTop){\n\t\t\tcase 'I', 'B', 'S', 'C' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(I2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(I2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(I2L);\n\t\t\t\t\tcase 'I' -> { /* no-op */ }\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(L2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(L2F);\n\t\t\t\t\tcase 'J' -> { /* no-op */ }\n\t\t\t\t\tcase 'I' -> mv.visitInsn(L2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(F2D);\n\t\t\t\t\tcase 'F' -> { /* no-op */ }\n\t\t\t\t\tcase 'J' -> mv.visitInsn(F2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(F2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> { /* no-op */ }\n\t\t\t\t\tcase 'F' -> mv.visitInsn(D2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(D2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(D2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackDescriptor + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertArrayStore(mv,arrayElementType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array. The\n\t * instruction to use varies depending on whether the type\n\t * is a primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayElementType the type of the array elements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayElementType"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayElementType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayElementType) {\n\t\tif (arrayElementType.length() == 1) {\n\t\t\tswitch (arrayElementType.charAt(0)) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array type \" + arrayElementType.charAt(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertBoxIfNecessary(mv,ch)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param ch the descriptor of the type that might need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, char ch)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, char ch) {\n\t\tswitch (ch) {\n\t\t\tcase 'Z' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\", false);\n\t\t\tcase 'B' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\", false);\n\t\t\tcase 'C' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\", false);\n\t\t\tcase 'D' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\", false);\n\t\t\tcase 'F' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\", false);\n\t\t\tcase 'I' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false);\n\t\t\tcase 'J' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false);\n\t\t\tcase 'S' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\", false);\n\t\t\tcase 'L', 'V', '[' -> {\n\t\t\t\t// no box needed\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Boxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertBoxIfNecessary(mv,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param descriptor the descriptor of a type that may or may not need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() == 1) {\n\t\t\tinsertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertCheckCast(mv,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n\t * @param mv the method visitor into which the instruction should be inserted\n\t * @param descriptor the descriptor of the type to cast to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "void",
    "signature": "public void insertCheckCast(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() != 1) {\n\t\t\tif (descriptor.charAt(0) == '[') {\n\t\t\t\tif (isPrimitiveArray(descriptor)) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor + \";\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!descriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertNewArrayCode(mv,size,arrayType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Produce the correct bytecode to build an array. The opcode to use and the\n\t * signature to pass along with the opcode can vary depending on the signature\n\t * of the array type.\n\t * @param mv the method visitor into which code should be inserted\n\t * @param size the size of the array\n\t * @param arrayType the type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "size",
      "arrayType"
    ],
    "position": {
      "column": 1,
      "line": 891
    },
    "return": "void",
    "signature": "public void insertNewArrayCode(MethodVisitor mv, int size, String arrayType)",
    "source_code": "\tpublic static void insertNewArrayCode(MethodVisitor mv, int size, String arrayType) {\n\t\tinsertOptimalLoad(mv, size);\n\t\tif (arrayType.length() == 1) {\n\t\t\tmv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arrayType));\n\t\t}\n\t\telse {\n\t\t\tif (arrayType.charAt(0) == '[') {\n\t\t\t\t// Handling the nested array case here.\n\t\t\t\t// If vararg is [[I then we want [I and not [I;\n\t\t\t\tif (CodeFlow.isReferenceTypeArray(arrayType)) {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType + \";\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType.substring(1));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertNumericUnboxOrPrimitiveTypeCoercion(mv,stackDescriptor,targetDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * For use in mathematical operators, handles converting from a (possibly boxed)\n\t * number on the stack to a primitive numeric type.\n\t * <p>For example, from an Integer to a double, just need to call 'Number.doubleValue()'\n\t * but from an int to a double, need to use the bytecode 'i2d'.\n\t * @param mv the method visitor when instructions should be appended\n\t * @param stackDescriptor a descriptor of the operand on the stack\n\t * @param targetDescriptor a primitive type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "stackDescriptor",
      "targetDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "public void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor)",
    "source_code": "\tpublic static void insertNumericUnboxOrPrimitiveTypeCoercion(\n\t\t\tMethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {\n\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\tCodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t\telse {\n\t\t\tCodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertOptimalLoad(mv,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the optimal instruction for loading a number on the stack.\n\t * @param mv where to insert the bytecode\n\t * @param value the value to be loaded\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "void",
    "signature": "public void insertOptimalLoad(MethodVisitor mv, int value)",
    "source_code": "\tpublic static void insertOptimalLoad(MethodVisitor mv, int value) {\n\t\tif (value < 6) {\n\t\t\tmv.visitInsn(ICONST_0+value);\n\t\t}\n\t\telse if (value < Byte.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(BIPUSH, value);\n\t\t}\n\t\telse if (value < Short.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(SIPUSH, value);\n\t\t}\n\t\telse {\n\t\t\tmv.visitLdcInsn(value);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxInsns(mv,ch,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary cast and value call to convert from a boxed type to a\n\t * primitive value.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param ch the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "void",
    "signature": "public void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (ch) {\n\t\t\tcase 'Z' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Boolean\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t\t}\n\t\t\tcase 'B' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Byte\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Byte\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\", false);\n\t\t\t}\n\t\t\tcase 'C' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Character\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Character\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\", false);\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Double\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Double\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Float\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Float\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Integer\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Integer\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Long\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Long\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'S' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Short\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Short\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\", false);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxNumberInsns(mv,targetDescriptor,stackDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * For numbers, use the appropriate method on the number to convert it to the primitive type requested.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param targetDescriptor the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "public void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxNumberInsns(\n\t\t\tMethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {\n\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (targetDescriptor) {\n\t\t\tcase 'D' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\t// does not handle Z, B, C, S\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + targetDescriptor + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#constructMappedInstance(rs,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current row.\n\t * @param rs the ResultSet to map (pre-initialized for the current row)\n\t * @param tc a TypeConverter with this RowMapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t * @throws SQLException if an SQLException is encountered\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(ResultSet rs, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException  {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values return from {@code getResultSetValue}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @since 5.3\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, Class<?> paramType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, Class<?> paramType) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, paramType);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,pd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation delegates to\n\t * {@link #getColumnValue(ResultSet, int, Class)}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see #getColumnValue(ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#mapRow(rs,rowNumber)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the values for all columns in the current row.\n\t * <p>Utilizes public setters and result set meta-data.\n\t * @see java.sql.ResultSetMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tinitBeanWrapper(bw);\n\n\t\tT mappedObject = constructMappedInstance(rs, bw);\n\t\tbw.setBeanInstance(mappedObject);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tSet<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null);\n\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tString column = JdbcUtils.lookupColumnName(rsmd, index);\n\t\t\tString property = lowerCaseName(StringUtils.delete(column, \" \"));\n\t\t\tPropertyDescriptor pd = (this.mappedProperties != null ? this.mappedProperties.get(property) : null);\n\t\t\tif (pd != null) {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = getColumnValue(rs, index, pd);\n\t\t\t\t\tif (rowNumber == 0 && logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Mapping column '\" + column + \"' to property '\" + pd.getName() +\n\t\t\t\t\t\t\t\t\"' of type '\" + ClassUtils.getQualifiedName(pd.getPropertyType()) + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbw.setPropertyValue(pd.getName(), value);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tif (value == null && this.primitivesDefaultedForNullValue) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tString propertyType = ClassUtils.getQualifiedName(pd.getPropertyType());\n\t\t\t\t\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\t\t\t\t\tIgnoring intercepted TypeMismatchException for row %d and column '%s' \\\n\t\t\t\t\t\t\t\t\t\twith null value when setting property '%s' of type '%s' on object: %s\"\n\t\t\t\t\t\t\t\t\t\t\"\"\".formatted(rowNumber, column, pd.getName(), propertyType, mappedObject), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (populatedProperties != null) {\n\t\t\t\t\t\tpopulatedProperties.add(pd.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotWritablePropertyException ex) {\n\t\t\t\t\tthrow new DataRetrievalFailureException(\n\t\t\t\t\t\t\t\"Unable to map column '\" + column + \"' to property '\" + pd.getName() + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (populatedProperties != null && !populatedProperties.equals(this.mappedPropertyNames)) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\"Given ResultSet does not contain all properties \" +\n\t\t\t\t\t\"necessary to populate object of \" + this.mappedClass + \": \" + this.mappedPropertyNames);\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(mappedClass,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @since 5.2.3\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#createInvocableHandlerMethod(bean,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\t\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\t\treturn getMessageHandlerMethodFactory().createInvocableHandlerMethod(bean, method);\n\t\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory ||\n\t\t\t\tbean instanceof JmsListenerEndpointRegistry) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, JmsListener.class)) {\n\t\t\tMap<Method, Set<JmsListener>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<JmsListener>>) method -> {\n\t\t\t\t\t\tSet<JmsListener> listenerMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, JmsListener.class, JmsListeners.class);\n\t\t\t\t\t\treturn (!listenerMethods.isEmpty() ? listenerMethods : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @JmsListener annotations found on bean type: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, listeners) ->\n\t\t\t\t\t\tlisteners.forEach(listener -> processJmsListener(listener, method, bean)));\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(annotatedMethods.size() + \" @JmsListener methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#processJmsListener(jmsListener,mostSpecificMethod,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@link JmsListener} annotation on the given method,\n\t * registering a corresponding endpoint for the given bean instance.\n\t * @param jmsListener the annotation to process\n\t * @param mostSpecificMethod the annotated method\n\t * @param bean the instance to invoke the method on\n\t * @see #createMethodJmsListenerEndpoint()\n\t * @see JmsListenerEndpointRegistrar#registerEndpoint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jmsListener",
      "mostSpecificMethod",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean)",
    "source_code": "\tprotected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean) {\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(mostSpecificMethod, bean.getClass());\n\n\t\tMethodJmsListenerEndpoint endpoint = createMethodJmsListenerEndpoint();\n\t\tendpoint.setBean(bean);\n\t\tendpoint.setMethod(invocableMethod);\n\t\tendpoint.setMostSpecificMethod(mostSpecificMethod);\n\t\tendpoint.setMessageHandlerMethodFactory(this.messageHandlerMethodFactory);\n\t\tendpoint.setEmbeddedValueResolver(this.embeddedValueResolver);\n\t\tendpoint.setBeanFactory(this.beanFactory);\n\t\tendpoint.setId(getEndpointId(jmsListener));\n\t\tendpoint.setDestination(resolve(jmsListener.destination()));\n\t\tif (StringUtils.hasText(jmsListener.selector())) {\n\t\t\tendpoint.setSelector(resolve(jmsListener.selector()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.subscription())) {\n\t\t\tendpoint.setSubscription(resolve(jmsListener.subscription()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.concurrency())) {\n\t\t\tendpoint.setConcurrency(resolve(jmsListener.concurrency()));\n\t\t}\n\n\t\tJmsListenerContainerFactory<?> factory = null;\n\t\tString containerFactoryBeanName = resolve(jmsListener.containerFactory());\n\t\tif (StringUtils.hasText(containerFactoryBeanName)) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\ttry {\n\t\t\t\tfactory = this.beanFactory.getBean(containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Could not register JMS listener endpoint on [\" +\n\t\t\t\t\t\tmostSpecificMethod + \"], no \" + JmsListenerContainerFactory.class.getSimpleName() +\n\t\t\t\t\t\t\" with id '\" + containerFactoryBeanName + \"' was found in the application context\", ex);\n\t\t\t}\n\t\t}\n\n\t\tthis.registrar.registerEndpoint(endpoint, factory);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#createListenerContainer(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create and start a new container using the specified factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "MessageListenerContainer",
    "signature": "protected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory)",
    "source_code": "\tprotected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory) {\n\n\t\tMessageListenerContainer listenerContainer = factory.createListenerContainer(endpoint);\n\n\t\tif (listenerContainer instanceof InitializingBean initializingBean) {\n\t\t\ttry {\n\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Failed to initialize message listener container\", ex);\n\t\t\t}\n\t\t}\n\n\t\tint containerPhase = listenerContainer.getPhase();\n\t\tif (containerPhase < Integer.MAX_VALUE) {  // a custom phase value\n\t\t\tif (this.phase < Integer.MAX_VALUE && this.phase != containerPhase) {\n\t\t\t\tthrow new IllegalStateException(\"Encountered phase mismatch between container factory definitions: \" +\n\t\t\t\t\t\tthis.phase + \" vs \" + containerPhase);\n\t\t\t}\n\t\t\tthis.phase = listenerContainer.getPhase();\n\t\t}\n\n\t\treturn listenerContainer;\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerEndpoint(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a new {@link JmsListenerEndpoint} alongside the\n\t * {@link JmsListenerContainerFactory} to use to create the underlying container.\n\t * <p>The {@code factory} may be {@code null} if the default factory should be\n\t * used for the supplied endpoint.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerEndpoint(JmsListenerEndpoint endpoint, @Nullable JmsListenerContainerFactory<?> factory) {\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.hasText(endpoint.getId(), \"Endpoint id must be set\");\n\n\t\t// Factory may be null, we defer the resolution right before actually creating the container\n\t\tJmsListenerEndpointDescriptor descriptor = new JmsListenerEndpointDescriptor(endpoint, factory);\n\n\t\tsynchronized (this.mutex) {\n\t\t\tif (this.startImmediately) {  // register and start immediately\n\t\t\t\tAssert.state(this.endpointRegistry != null, \"No JmsListenerEndpointRegistry set\");\n\t\t\t\tthis.endpointRegistry.registerListenerContainer(descriptor.endpoint,\n\t\t\t\t\t\tresolveContainerFactory(descriptor), true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.endpointDescriptors.add(descriptor);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @see #registerListenerContainer(JmsListenerEndpoint, JmsListenerContainerFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory) {\n\t\tregisterListenerContainer(endpoint, factory, false);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory,startImmediately)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * <p>The {@code startImmediately} flag determines if the container should be\n\t * started immediately.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @param startImmediately start the container immediately if necessary\n\t * @see #getListenerContainers()\n\t * @see #getListenerContainer(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory",
      "startImmediately"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately) {\n\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.notNull(factory, \"Factory must not be null\");\n\t\tString id = endpoint.getId();\n\t\tAssert.hasText(id, \"Endpoint id must be set\");\n\n\t\tsynchronized (this.listenerContainers) {\n\t\t\tif (this.listenerContainers.containsKey(id)) {\n\t\t\t\tthrow new IllegalStateException(\"Another endpoint is already registered with id '\" + id + \"'\");\n\t\t\t}\n\t\t\tMessageListenerContainer container = createListenerContainer(endpoint, factory);\n\t\t\tthis.listenerContainers.put(id, container);\n\t\t\tif (startImmediately) {\n\t\t\t\tstartIfNecessary(container);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createSession(con,mode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default Session for this ConnectionFactory,\n\t * adapting to JMS 1.0.2 style queue/topic mode if necessary.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the newly created Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "Session",
    "signature": "protected Session createSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session createSession(Connection con, Integer mode) throws JMSException {\n\t\t// Determine JMS API arguments...\n\t\tboolean transacted = (mode == Session.SESSION_TRANSACTED);\n\t\tint ackMode = (transacted ? Session.AUTO_ACKNOWLEDGE : mode);\n\t\t// Now actually call the appropriate JMS factory method...\n\t\tif (Boolean.FALSE.equals(this.pubSubMode) && con instanceof QueueConnection queueConnection) {\n\t\t\treturn queueConnection.createQueueSession(transacted, ackMode);\n\t\t}\n\t\telse if (Boolean.TRUE.equals(this.pubSubMode) && con instanceof TopicConnection topicConnection) {\n\t\t\treturn topicConnection.createTopicSession(transacted, ackMode);\n\t\t}\n\t\telse {\n\t\t\treturn con.createSession(transacted, ackMode);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doBegin(transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tthrow new InvalidIsolationLevelException(\"JMS does not support an isolation level concept\");\n\t\t}\n\n\t\tConnectionFactory connectionFactory = obtainConnectionFactory();\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\tConnection con = null;\n\t\tSession session = null;\n\t\ttry {\n\t\t\tJmsResourceHolder resourceHolder;\n\t\t\tif (this.lazyResourceRetrieval) {\n\t\t\t\tresourceHolder = new LazyJmsResourceHolder(connectionFactory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon = createConnection();\n\t\t\t\tsession = createSession(con);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Created JMS transaction on Session [\" + session + \"] from Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tresourceHolder = new JmsResourceHolder(connectionFactory, con, session);\n\t\t\t}\n\t\t\tresourceHolder.setSynchronizedWithTransaction(true);\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\tresourceHolder.setTimeoutInSeconds(timeout);\n\t\t\t}\n\t\t\ttxObject.setResourceHolder(resourceHolder);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolder);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not create JMS transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doGetTransactionalSession(connectionFactory,resourceFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * <p>This {@code doGetTransactionalSession} variant always starts the underlying\n\t * JMS Connection, assuming that the Session will be used for receiving messages.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t * @see #doGetTransactionalSession(jakarta.jms.ConnectionFactory, ResourceFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory)",
    "source_code": "\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {\n\n\t\treturn doGetTransactionalSession(connectionFactory, resourceFactory, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doGetTransactionalSession(connectionFactory,resourceFactory,startConnection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @param startConnection whether the underlying JMS Connection approach should be\n\t * started in order to allow for receiving messages. Note that a reused Connection\n\t * may already have been started before, even if this flag is {@code false}.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)",
    "source_code": "\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\tAssert.notNull(resourceFactory, \"ResourceFactory must not be null\");\n\n\t\tJmsResourceHolder resourceHolder =\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\tif (resourceHolder != null) {\n\t\t\tSession session = resourceFactory.getSession(resourceHolder);\n\t\t\tif (session != null) {\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tConnection con = resourceFactory.getConnection(resourceHolder);\n\t\t\t\t\tif (con != null) {\n\t\t\t\t\t\tcon.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn session;\n\t\t\t}\n\t\t\tif (resourceHolder.isFrozen()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\treturn null;\n\t\t}\n\t\tJmsResourceHolder resourceHolderToUse = resourceHolder;\n\t\tif (resourceHolderToUse == null) {\n\t\t\tresourceHolderToUse = new JmsResourceHolder(connectionFactory);\n\t\t}\n\t\tConnection con = resourceFactory.getConnection(resourceHolderToUse);\n\t\tSession session = null;\n\t\ttry {\n\t\t\tboolean isExistingCon = (con != null);\n\t\t\tif (!isExistingCon) {\n\t\t\t\tcon = resourceFactory.createConnection();\n\t\t\t\tresourceHolderToUse.addConnection(con);\n\t\t\t}\n\t\t\tsession = resourceFactory.createSession(con);\n\t\t\tresourceHolderToUse.addSession(session, con);\n\t\t\tif (startConnection) {\n\t\t\t\tcon.start();\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tif (resourceHolderToUse != resourceHolder) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\tnew JmsResourceSynchronization(resourceHolderToUse, connectionFactory,\n\t\t\t\t\t\t\tresourceFactory.isSynchedLocalTransactionAllowed()));\n\t\t\tresourceHolderToUse.setSynchronizedWithTransaction(true);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse);\n\t\t}\n\t\treturn session;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getSession(sessionType,connection)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType, @Nullable Connection connection)",
    "source_code": "\t\tpublic <S extends Session> S getSession(Class<S> sessionType, @Nullable Connection connection) {\n\t\t\tinitializeSession();\n\t\t\treturn super.getSession(sessionType, connection);\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalQueueSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "QueueSession",
    "signature": "public QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(QueueSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createQueueConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Session",
    "signature": "public Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(Session.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalTopicSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "TopicSession",
    "signature": "public TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(TopicSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createTopicConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((TopicConnection) con).createTopicSession(\n\t\t\t\t\t\tsynchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#isSessionTransactional(session,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given JMS Session is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param session the JMS Session to check\n\t * @param cf the JMS ConnectionFactory that the Session originated from\n\t * @return whether the Session is transactional\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf)",
    "source_code": "\tpublic static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {\n\t\tif (session == null || cf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf);\n\t\treturn (resourceHolder != null && resourceHolder.containsSession(session));\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#releaseConnection(con,cf,started)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Release the given Connection, stopping it (if necessary) and eventually closing it.\n\t * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.\n\t * This is essentially a more sophisticated version of\n\t * {@link org.springframework.jms.support.JmsUtils#closeConnection}.\n\t * @param con the Connection to release\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (may be {@code null})\n\t * @param started whether the Connection might have been started by the application\n\t * @see SmartConnectionFactory#shouldStop\n\t * @see org.springframework.jms.support.JmsUtils#closeConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "cf",
      "started"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started)",
    "source_code": "\tpublic static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (started && cf instanceof SmartConnectionFactory smartFactory && smartFactory.shouldStop(con)) {\n\t\t\ttry {\n\t\t\t\tcon.stop();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not stop JMS Connection before closing it\", ex);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tcon.close();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#releaseResource(resourceHolder,resourceKey)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "void",
    "signature": "protected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey)",
    "source_code": "\t\tprotected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey) {\n\t\t\tresourceHolder.closeAll();\n\t\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queue,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 984
    },
    "return": "T",
    "signature": "public T browse(Queue queue, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(Queue queue, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queue, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queueName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 990
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 996
    },
    "return": "T",
    "signature": "public T browseSelected(String messageSelector, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browseSelected(defaultQueue, messageSelector, action);\n\t\t}\n\t\telse {\n\t\t\treturn browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queue,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "T",
    "signature": "public T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queueName,messageSelector,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "T",
    "signature": "public T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 655
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message)",
    "source_code": "\tpublic void convertAndSend(Destination destination, final Object message) throws JmsException {\n\t\tsend(destination, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tDestination destination, final Object message, final MessagePostProcessor postProcessor)\n\t\t\tthrows JmsException {\n\n\t\tsend(destination, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message)",
    "source_code": "\tpublic void convertAndSend(String destinationName, final Object message) throws JmsException {\n\t\tsend(destinationName, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 687
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tString destinationName, final Object message, final MessagePostProcessor postProcessor)\n\t\tthrows JmsException {\n\n\t\tsend(destinationName, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(message,postProcessor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "void",
    "signature": "public void convertAndSend(Object message, MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createBrowser(session,queue,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a QueueBrowser for\n\t * @param queue the JMS Queue to create a QueueBrowser for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS QueueBrowser\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "queue",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1154
    },
    "return": "QueueBrowser",
    "signature": "protected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)",
    "source_code": "\tprotected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn session.createBrowser(queue, messageSelector);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createConsumer(session,destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS MessageConsumer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1127
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\t// Only pass in the NoLocal flag in case of a Topic:\n\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\tif (isPubSubDomain()) {\n\t\t\treturn session.createConsumer(destination, messageSelector, isPubSubNoLocal());\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, messageSelector);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createProducer(session,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer createProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer createProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\tMessageProducer producer = doCreateProducer(session, destination);\n\t\tif (!isMessageIdEnabled()) {\n\t\t\tproducer.setDisableMessageID(true);\n\t\t}\n\t\tif (!isMessageTimestampEnabled()) {\n\t\t\tproducer.setDisableMessageTimestamp(true);\n\t\t}\n\t\treturn producer;\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doCreateProducer(session,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a raw JMS MessageProducer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer doCreateProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer doCreateProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\treturn session.createProducer(destination);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doReceive(session,consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param consumer the JMS MessageConsumer to receive with\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 776
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, MessageConsumer consumer)",
    "source_code": "\tprotected Message doReceive(Session session, MessageConsumer consumer) throws JMSException {\n\t\ttry {\n\t\t\t// Use transaction timeout (if available).\n\t\t\tlong timeout = getReceiveTimeout();\n\t\t\tConnectionFactory connectionFactory = getConnectionFactory();\n\t\t\tJmsResourceHolder resourceHolder = null;\n\t\t\tif (connectionFactory != null) {\n\t\t\t\tresourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\t\t}\n\t\t\tif (resourceHolder != null && resourceHolder.hasTimeout()) {\n\t\t\t\ttimeout = Math.min(timeout, resourceHolder.getTimeToLiveInMillis());\n\t\t\t}\n\t\t\tMessage message = receiveFromConsumer(consumer, timeout);\n\t\t\tif (session.getTransacted()) {\n\t\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\t// Manually acknowledge message, if any.\n\t\t\t\tif (message != null) {\n\t\t\t\t\tmessage.acknowledge();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn message;\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doReceive(session,destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to receive from\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 762
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn doReceive(session, createConsumer(session, destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(producer,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually send the given JMS message.\n\t * @param producer the JMS MessageProducer to send with\n\t * @param message the JMS Message to send\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "void",
    "signature": "protected void doSend(MessageProducer producer, Message message)",
    "source_code": "\tprotected void doSend(MessageProducer producer, Message message) throws JMSException {\n\t\tif (this.deliveryDelay >= 0) {\n\t\t\tproducer.setDeliveryDelay(this.deliveryDelay);\n\t\t}\n\t\tif (isExplicitQosEnabled()) {\n\t\t\tproducer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());\n\t\t}\n\t\telse {\n\t\t\tproducer.send(message);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(session,destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to send to\n\t * @param messageCreator callback to create a JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "protected void doSend(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected void doSend(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tMessageProducer producer = createProducer(session, destination);\n\t\ttry {\n\t\t\tMessage message = messageCreator.createMessage(session);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + message);\n\t\t\t}\n\t\t\tdoSend(producer, message);\n\t\t\t// Check commit - avoid commit call within a JTA transaction.\n\t\t\tif (session.getTransacted() && isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSendAndReceive(session,destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a request message to the given {@link Destination} and block until\n\t * a reply has been received on a temporary queue created on-the-fly.\n\t * <p>Return the response message or {@code null} if no message has\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "Message",
    "signature": "protected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tTemporaryQueue responseQueue = null;\n\t\tMessageProducer producer = null;\n\t\tMessageConsumer consumer = null;\n\t\ttry {\n\t\t\tMessage requestMessage = messageCreator.createMessage(session);\n\t\t\tresponseQueue = session.createTemporaryQueue();\n\t\t\tproducer = session.createProducer(destination);\n\t\t\tconsumer = session.createConsumer(responseQueue);\n\t\t\trequestMessage.setJMSReplyTo(responseQueue);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + requestMessage);\n\t\t\t}\n\t\t\tdoSend(producer, requestMessage);\n\t\t\treturn receiveFromConsumer(consumer, getReceiveTimeout());\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\tif (responseQueue != null) {\n\t\t\t\tresponseQueue.delete();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(action,startConnection)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * JMS Session. Generalized version of {@code execute(SessionCallback)},\n\t * allowing the JMS Connection to be started on the fly.\n\t * <p>Use {@code execute(SessionCallback)} for the general case.\n\t * Starting the JMS Connection is just necessary for receiving messages,\n\t * which is preferably achieved through the {@code receive} methods.\n\t * @param action callback object that exposes the Session\n\t * @param startConnection whether to start the Connection\n\t * @return the result object from working with the Session\n\t * @throws JmsException if there is any problem\n\t * @see #execute(SessionCallback)\n\t * @see #receive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "T",
    "signature": "public T execute(SessionCallback<T> action, boolean startConnection)",
    "source_code": "\tpublic <T> T execute(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, startConnection);\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tconToClose.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + sessionToUse);\n\t\t\t}\n\t\t\treturn action.doInJms(sessionToUse);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destination,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "T",
    "signature": "public T execute(final @Nullable Destination destination, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final @Nullable Destination destination, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destinationName,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "T",
    "signature": "public T execute(final String destinationName, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final String destinationName, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final Destination destination, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> doReceive(session, destination, messageSelector), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destinationName,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 746
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final String destinationName, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doReceive(session, destination, messageSelector);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destination,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(Destination destination, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destinationName,messageSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 846
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(String destinationName, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destinationName, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void send(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destinationName,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void send(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destination,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 887
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> doSendAndReceive(session, destination, messageCreator), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destinationName,messageCreator)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doSendAndReceive(session, destination, messageCreator);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#commitIfNecessary(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a commit or message acknowledgement, as appropriate.\n\t * @param session the JMS Session to commit\n\t * @param message the Message to acknowledge\n\t * @throws jakarta.jms.JMSException in case of commit failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 770
    },
    "return": "void",
    "signature": "protected void commitIfNecessary(Session session, @Nullable Message message)",
    "source_code": "\tprotected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {\n\t\t// Commit session or acknowledge message.\n\t\tif (session.getTransacted()) {\n\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\telse if (message != null && isClientAcknowledge(session)) {\n\t\t\tmessage.acknowledge();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#createConsumer(session,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @return the new JMS MessageConsumer\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 855
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination) throws JMSException {\n\t\tif (isPubSubDomain() && destination instanceof Topic topic) {\n\t\t\tif (isSubscriptionShared()) {\n\t\t\t\treturn (isSubscriptionDurable() ?\n\t\t\t\t\t\tsession.createSharedDurableConsumer(topic, getSubscriptionName(), getMessageSelector()) :\n\t\t\t\t\t\tsession.createSharedConsumer(topic, getSubscriptionName(), getMessageSelector()));\n\t\t\t}\n\t\t\telse if (isSubscriptionDurable()) {\n\t\t\t\treturn session.createDurableSubscriber(\n\t\t\t\t\t\ttopic, getSubscriptionName(), getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Only pass in the NoLocal flag in case of a Topic (pub-sub mode):\n\t\t\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\t\t\treturn session.createConsumer(destination, getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, getMessageSelector());\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doExecuteListener(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #convertJmsAccessException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "void",
    "signature": "protected void doExecuteListener(Session session, Message message)",
    "source_code": "\tprotected void doExecuteListener(Session session, Message message) throws JMSException {\n\t\tif (!isAcceptMessagesWhileStopping() && !isRunning()) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Rejecting received message because of the listener container \" +\n\t\t\t\t\t\t\"having been stopped in the meantime: \" + message);\n\t\t\t}\n\t\t\trollbackIfNecessary(session);\n\t\t\tthrow new MessageRejectedWhileStoppingException();\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeListener(session, message);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\trollbackOnExceptionIfNecessary(session, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcommitIfNecessary(session, message);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doInvokeListener(listener,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as standard JMS MessageListener.\n\t * <p>Default implementation performs a plain invocation of the\n\t * {@code onMessage} method.\n\t * @param listener the JMS MessageListener to invoke\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.MessageListener#onMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "protected void doInvokeListener(MessageListener listener, Message message)",
    "source_code": "\tprotected void doInvokeListener(MessageListener listener, Message message) throws JMSException {\n\t\tlistener.onMessage(message);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doInvokeListener(listener,session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as Spring SessionAwareMessageListener,\n\t * exposing a new JMS Session (potentially with its own transaction)\n\t * to the listener if demanded.\n\t * @param listener the Spring SessionAwareMessageListener to invoke\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see SessionAwareMessageListener\n\t * @see #setExposeListenerSession\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "protected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)",
    "source_code": "\tprotected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)\n\t\t\tthrows JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tif (!isExposeListenerSession()) {\n\t\t\t\t// We need to expose a separate Session.\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\t// Actually invoke the message listener...\n\t\t\tlistener.onMessage(message, sessionToUse);\n\t\t\t// Clean up specially exposed Session, if any.\n\t\t\tif (sessionToUse != session) {\n\t\t\t\tif (sessionToUse.getTransacted() && isSessionLocallyTransacted(sessionToUse)) {\n\t\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(sessionToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tJmsUtils.closeConnection(conToClose);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doReceiveAndExecute(invoker,session,consumer,status)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status)",
    "source_code": "\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status) throws JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\tMessageConsumer consumerToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tboolean transactional = false;\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tsessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, true);\n\t\t\t\ttransactional = (sessionToUse != null);\n\t\t\t}\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tConnection conToUse;\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\tconToUse = getSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconToUse = createConnection();\n\t\t\t\t\tconToClose = conToUse;\n\t\t\t\t\tconToUse.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = createSession(conToUse);\n\t\t\t\tsessionToClose = sessionToUse;\n\t\t\t}\n\t\t\tMessageConsumer consumerToUse = consumer;\n\t\t\tif (consumerToUse == null) {\n\t\t\t\tconsumerToUse = createListenerConsumer(sessionToUse);\n\t\t\t\tconsumerToClose = consumerToUse;\n\t\t\t}\n\t\t\tMessage message = receiveMessage(consumerToUse);\n\t\t\tif (message != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received message of type [\" + message.getClass() + \"] from consumer [\" +\n\t\t\t\t\t\t\tconsumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") + \"session [\" +\n\t\t\t\t\t\t\tsessionToUse + \"]\");\n\t\t\t\t}\n\t\t\t\tmessageReceived(invoker, sessionToUse);\n\t\t\t\tboolean exposeResource = (!transactional && isExposeListenerSession() &&\n\t\t\t\t\t\t!TransactionSynchronizationManager.hasResource(obtainConnectionFactory()));\n\t\t\t\tif (exposeResource) {\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\t\tobtainConnectionFactory(), new LocallyExposedJmsResourceHolder(sessionToUse));\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tdoExecuteListener(sessionToUse, message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Rolling back transaction because of listener exception thrown: \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t}\n\t\t\t\t\thandleListenerException(ex);\n\t\t\t\t\t// Rethrow JMSException to indicate an infrastructure problem\n\t\t\t\t\t// that may have to trigger recovery...\n\t\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\t\tthrow jmsException;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (exposeResource) {\n\t\t\t\t\t\tTransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Indicate that a message has been received.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Consumer [\" + consumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") +\n\t\t\t\t\t\t\t\"session [\" + sessionToUse + \"] did not receive a message\");\n\t\t\t\t}\n\t\t\t\tnoMessageReceived(invoker, sessionToUse);\n\t\t\t\t// Nevertheless call commit, in order to reset the transaction timeout (if any).\n\t\t\t\tif (shouldCommitAfterNoMessageReceived(sessionToUse)) {\n\t\t\t\t\tcommitIfNecessary(sessionToUse, null);\n\t\t\t\t}\n\t\t\t\t// Indicate that no message has been received.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumerToClose);\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#executeListener(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #handleListenerException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "void",
    "signature": "protected void executeListener(Session session, Message message)",
    "source_code": "\tprotected void executeListener(Session session, Message message) {\n\t\ttry {\n\t\t\tdoExecuteListener(session, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleListenerException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#handleListenerSetupFailure(ex,alreadyRecovered)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given exception that arose during setup of a listener.\n\t * Called for every such exception in every concurrent listener.\n\t * <p>The default implementation logs the exception at warn level\n\t * if not recovered yet, and at debug level if already recovered.\n\t * Can be overridden in subclasses.\n\t * @param ex the exception to handle\n\t * @param alreadyRecovered whether a previously executing listener\n\t * already recovered from the present listener setup failure\n\t * (this usually indicates a follow-up failure than can be ignored\n\t * other than for debug log purposes)\n\t * @see #recoverAfterListenerSetupFailure()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "alreadyRecovered"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "void",
    "signature": "protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered)",
    "source_code": "\tprotected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered) {\n\t\tif (ex instanceof JMSException jmsException) {\n\t\t\tinvokeExceptionListener(jmsException);\n\t\t}\n\t\tif (ex instanceof SharedConnectionNotInitializedException) {\n\t\t\tif (!alreadyRecovered) {\n\t\t\t\tlogger.debug(\"JMS message listener invoker needs to establish shared Connection\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Recovery during active operation..\n\t\t\tif (alreadyRecovered) {\n\t\t\t\tlogger.debug(\"Setup of JMS message listener invoker failed - already recovered by other invoker\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Setup of JMS message listener invoker failed for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - trying to recover. Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.warn(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.warn(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#invokeListener(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener: either as standard JMS MessageListener\n\t * or (preferably) as Spring SessionAwareMessageListener.\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 692
    },
    "return": "void",
    "signature": "protected void invokeListener(Session session, Message message)",
    "source_code": "\tprotected void invokeListener(Session session, Message message) throws JMSException {\n\t\tObject listener = getMessageListener();\n\n\t\tif (listener instanceof SessionAwareMessageListener sessionAwareMessageListener) {\n\t\t\tdoInvokeListener(sessionAwareMessageListener, session, message);\n\t\t}\n\t\telse if (listener instanceof MessageListener msgListener) {\n\t\t\tdoInvokeListener(msgListener, message);\n\t\t}\n\t\telse if (listener != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Only MessageListener and SessionAwareMessageListener supported: \" + listener);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"No message listener specified - see property 'messageListener'\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#messageReceived(invoker,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tries scheduling a new invoker, since we know messages are coming in...\n\t * @see #scheduleNewInvokerIfAppropriate()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 786
    },
    "return": "void",
    "signature": "protected void messageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void messageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(false);\n\t\tscheduleNewInvokerIfAppropriate();\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#noMessageReceived(invoker,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marks the affected invoker as idle.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "void",
    "signature": "protected void noMessageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void noMessageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(true);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#receiveAndExecute(invoker,session,consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the listener for a message received from the given consumer,\n\t * wrapping the entire operation in an external transaction if demanded.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doReceiveAndExecute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "boolean",
    "signature": "protected boolean receiveAndExecute(Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer)",
    "source_code": "\tprotected boolean receiveAndExecute(\n\t\t\tObject invoker, @Nullable Session session, @Nullable MessageConsumer consumer)\n\t\t\tthrows JMSException {\n\n\t\tif (this.transactionManager != null) {\n\t\t\t// Execute receive within transaction.\n\t\t\tTransactionStatus status = this.transactionManager.getTransaction(this.transactionDefinition);\n\t\t\tboolean messageReceived;\n\t\t\ttry {\n\t\t\t\tmessageReceived = doReceiveAndExecute(invoker, session, consumer, status);\n\t\t\t}\n\t\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\t\trollbackOnException(this.transactionManager, status, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.transactionManager.commit(status);\n\t\t\t}\n\t\t\tcatch (TransactionException ex) {\n\t\t\t\t// Propagate transaction system exceptions as infrastructure problems.\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t// Typically a late persistence exception from a listener-used resource\n\t\t\t\t// -> handle it as listener exception, not as an infrastructure problem.\n\t\t\t\t// E.g. a database locking failure should not lead to listener shutdown.\n\t\t\t\thandleListenerException(ex);\n\t\t\t}\n\t\t\treturn messageReceived;\n\t\t}\n\n\t\telse {\n\t\t\t// Execute receive outside of transaction.\n\t\t\treturn doReceiveAndExecute(invoker, session, consumer, null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#rollbackOnExceptionIfNecessary(session,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a rollback, handling rollback exceptions properly.\n\t * @param session the JMS Session to rollback\n\t * @param ex the thrown application exception or error\n\t * @throws jakarta.jms.JMSException in case of a rollback error\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 807
    },
    "return": "void",
    "signature": "protected void rollbackOnExceptionIfNecessary(Session session, Throwable ex)",
    "source_code": "\tprotected void rollbackOnExceptionIfNecessary(Session session, Throwable ex) throws JMSException {\n\t\ttry {\n\t\t\tif (session.getTransacted()) {\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this container -> rollback.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Initiating transaction rollback on application exception\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tJmsUtils.rollbackIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\tsession.recover();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ex2) {\n\t\t\tlogger.debug(\"Could not roll back because Session already closed\", ex2);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex2) {\n\t\t\tlogger.error(\"Application exception overridden by rollback error\", ex);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#closeConnection(con,stop)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t * @param stop whether to call {@code stop()} before closing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "stop"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void closeConnection(@Nullable Connection con, boolean stop)",
    "source_code": "\tpublic static void closeConnection(@Nullable Connection con, boolean stop) {\n\t\tif (con != null) {\n\t\t\ttry {\n\t\t\t\tif (stop) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcon.stop();\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcon.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.debug(\"Unexpected exception on closing JMS Connection\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#fromHeaders(headers,jmsMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers",
      "jmsMessage"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage)",
    "source_code": "\tpublic void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\tObject jmsCorrelationId = headers.get(JmsHeaders.CORRELATION_ID);\n\t\t\tif (jmsCorrelationId instanceof Number) {\n\t\t\t\tjmsCorrelationId = jmsCorrelationId.toString();\n\t\t\t}\n\t\t\tif (jmsCorrelationId instanceof String correlationId) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSCorrelationID(correlationId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSCorrelationID - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDestination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);\n\t\t\tif (jmsReplyTo != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSReplyTo(jmsReplyTo);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSReplyTo - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);\n\t\t\tif (jmsType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSType(jmsType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSType - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString headerName = entry.getKey();\n\t\t\t\tif (StringUtils.hasText(headerName) && !headerName.startsWith(JmsHeaders.PREFIX)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value != null && SUPPORTED_PROPERTY_TYPES.contains(value.getClass())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString propertyName = fromHeaderName(headerName);\n\t\t\t\t\t\t\tjmsMessage.setObjectProperty(propertyName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (headerName.startsWith(\"JMSX\")) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping reserved header '\" + headerName +\n\t\t\t\t\t\t\t\t\t\t\t\"' since it cannot be set by client\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to map message header '\" + headerName + \"' to JMS property\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from MessageHeaders to JMS properties\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForByteArray(bytes,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS BytesMessage for the given byte array.\n\t * @param bytes the byte array to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bytes",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage createMessageForByteArray(byte[] bytes, Session session)",
    "source_code": "\tprotected BytesMessage createMessageForByteArray(byte[] bytes, Session session) throws JMSException {\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bytes);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForMap(Map<?,map,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MapMessage for the given Map.\n\t * @param map the Map to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createMapMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "map",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MapMessage",
    "signature": "protected MapMessage createMessageForMap(Map<?, ?> map, Session session)",
    "source_code": "\tprotected MapMessage createMessageForMap(Map<?, ?> map, Session session) throws JMSException {\n\t\tMapMessage message = session.createMapMessage();\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tif (!(key instanceof String str)) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert non-String key of type [\" +\n\t\t\t\t\t\tObjectUtils.nullSafeClassName(key) + \"] to JMS MapMessage entry\");\n\t\t\t}\n\t\t\tmessage.setObject(str, entry.getValue());\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForSerializable(object,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS ObjectMessage for the given Serializable object.\n\t * @param object the Serializable object to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createObjectMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "ObjectMessage",
    "signature": "protected ObjectMessage createMessageForSerializable(Serializable object, Session session)",
    "source_code": "\tprotected ObjectMessage createMessageForSerializable(Serializable object, Session session) throws JMSException {\n\t\treturn session.createObjectMessage(object);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForString(text,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS TextMessage for the given String.\n\t * @param text the String to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createTextMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "TextMessage",
    "signature": "protected TextMessage createMessageForString(String text, Session session)",
    "source_code": "\tprotected TextMessage createMessageForString(String text, Session session) throws JMSException {\n\t\treturn session.createTextMessage(text);\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#createAndConfigureMBean(managedResource,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Creates an MBean that is configured with the appropriate management\n\t * interface for the supplied managed resource.\n\t * @param managedResource the resource that is to be exported as an MBean\n\t * @param beanKey the key associated with the managed bean\n\t * @see #createModelMBean()\n\t * @see #getMBeanInfo(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedResource",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)",
    "source_code": "\tprotected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)\n\t\t\tthrows MBeanExportException {\n\t\ttry {\n\t\t\tModelMBean mbean = createModelMBean();\n\t\t\tmbean.setModelMBeanInfo(getMBeanInfo(managedResource, beanKey));\n\t\t\tmbean.setManagedResource(managedResource, MR_TYPE_OBJECT_REFERENCE);\n\t\t\treturn mbean;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MBeanExportException(\"Could not create ModelMBean for managed resource [\" +\n\t\t\t\t\tmanagedResource + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#getObjectName(bean,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@code ObjectName} for a bean.\n\t * <p>If the bean implements the {@code SelfNaming} interface, then the\n\t * {@code ObjectName} will be retrieved using {@code SelfNaming.getObjectName()}.\n\t * Otherwise, the configured {@code ObjectNamingStrategy} is used.\n\t * @param bean the name of the bean in the {@code BeanFactory}\n\t * @param beanKey the key associated with the bean in the beans map\n\t * @return the {@code ObjectName} for the supplied bean\n\t * @throws javax.management.MalformedObjectNameException\n\t * if the retrieved {@code ObjectName} is malformed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 750
    },
    "return": "ObjectName",
    "signature": "protected ObjectName getObjectName(Object bean, @Nullable String beanKey)",
    "source_code": "\tprotected ObjectName getObjectName(Object bean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tif (bean instanceof SelfNaming) {\n\t\t\treturn ((SelfNaming) bean).getObjectName();\n\t\t}\n\t\telse {\n\t\t\treturn this.namingStrategy.getObjectName(bean, beanKey);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#isBeanDefinitionLazyInit(beanFactory,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the specified bean definition should be considered as lazy-init.\n\t * @param beanFactory the bean factory that is supposed to contain the bean definition\n\t * @param beanName the name of the bean to check\n\t * @see org.springframework.beans.factory.config.ConfigurableListableBeanFactory#getBeanDefinition\n\t * @see org.springframework.beans.factory.config.BeanDefinition#isLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "boolean",
    "signature": "protected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName)",
    "source_code": "\tprotected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName) {\n\t\treturn (beanFactory instanceof ConfigurableListableBeanFactory && beanFactory.containsBeanDefinition(beanName) &&\n\t\t\t\t((ConfigurableListableBeanFactory) beanFactory).getBeanDefinition(beanName).isLazyInit());\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerBeanNameOrInstance(mapValue,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an individual bean with the {@link #setServer MBeanServer}.\n\t * <p>This method is responsible for deciding <strong>how</strong> a bean\n\t * should be exposed to the {@code MBeanServer}. Specifically, if the\n\t * supplied {@code mapValue} is the name of a bean that is configured\n\t * for lazy initialization, then a proxy to the resource is registered with\n\t * the {@code MBeanServer} so that the lazy load behavior is\n\t * honored. If the bean is already an MBean then it will be registered\n\t * directly with the {@code MBeanServer} without any intervention. For\n\t * all other beans or bean names, the resource itself is registered with\n\t * the {@code MBeanServer} directly.\n\t * @param mapValue the value configured for this bean in the beans map;\n\t * may be either the {@code String} name of a bean, or the bean itself\n\t * @param beanKey the key associated with this bean in the beans map\n\t * @return the {@code ObjectName} under which the resource was registered\n\t * @throws MBeanExportException if the export failed\n\t * @see #setBeans\n\t * @see #registerBeanInstance\n\t * @see #registerLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapValue",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "ObjectName",
    "signature": "protected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey)",
    "source_code": "\tprotected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey) throws MBeanExportException {\n\t\ttry {\n\t\t\tif (mapValue instanceof String beanName) {\n\t\t\t\t// Bean name pointing to a potentially lazy-init bean in the factory.\n\t\t\t\tif (this.beanFactory == null) {\n\t\t\t\t\tthrow new MBeanExportException(\"Cannot resolve bean names if not running in a BeanFactory\");\n\t\t\t\t}\n\t\t\t\tif (isBeanDefinitionLazyInit(this.beanFactory, beanName)) {\n\t\t\t\t\tObjectName objectName = registerLazyInit(beanName, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject bean = this.beanFactory.getBean(beanName);\n\t\t\t\t\tObjectName objectName = registerBeanInstance(bean, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Plain bean instance -> register it directly.\n\t\t\t\tif (this.beanFactory != null) {\n\t\t\t\t\tMap<String, ?> beansOfSameType =\n\t\t\t\t\t\t\tthis.beanFactory.getBeansOfType(mapValue.getClass(), false, this.allowEagerInit);\n\t\t\t\t\tfor (Map.Entry<String, ?> entry : beansOfSameType.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue() == mapValue) {\n\t\t\t\t\t\t\tString beanName = entry.getKey();\n\t\t\t\t\t\t\tObjectName objectName = registerBeanInstance(mapValue, beanKey);\n\t\t\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\t\t\treturn objectName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn registerBeanInstance(mapValue, beanKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + mapValue + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerManagedResource(managedResource,objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedResource",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "void",
    "signature": "public void registerManagedResource(Object managedResource, ObjectName objectName)",
    "source_code": "\tpublic void registerManagedResource(Object managedResource, ObjectName objectName) throws MBeanExportException {\n\t\tAssert.notNull(managedResource, \"Managed resource must not be null\");\n\t\tAssert.notNull(objectName, \"ObjectName must not be null\");\n\t\ttry {\n\t\t\tif (isMBean(managedResource.getClass())) {\n\t\t\t\tdoRegister(managedResource, objectName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tModelMBean mbean = createAndConfigureMBean(managedResource, managedResource.getClass().getName());\n\t\t\t\tdoRegister(mbean, objectName);\n\t\t\t\tinjectNotificationPublisherIfNecessary(managedResource, mbean, objectName);\n\t\t\t}\n\t\t}\n\t\tcatch (JMException ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + managedResource + \"] with object name [\" + objectName + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#setBeans(Map<String,beans)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Supply a {@code Map} of beans to be registered with the JMX\n\t * {@code MBeanServer}.\n\t * <p>The String keys are the basis for the creation of JMX object names.\n\t * By default, a JMX {@code ObjectName} will be created straight\n\t * from the given key. This can be customized through specifying a\n\t * custom {@code NamingStrategy}.\n\t * <p>Both bean instances and bean names are allowed as values.\n\t * Bean instances are typically linked in through bean references.\n\t * Bean names will be resolved as beans in the current factory, respecting\n\t * lazy-init markers (that is, not triggering initialization of such beans).\n\t * @param beans a Map with JMX names as keys and bean instances or bean names\n\t * as values\n\t * @see #setNamingStrategy\n\t * @see org.springframework.jmx.export.naming.KeyNamingStrategy\n\t * @see javax.management.ObjectName#ObjectName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "beans"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void setBeans(Map<String, Object> beans)",
    "source_code": "\tpublic void setBeans(Map<String, Object> beans) {\n\t\tthis.beans = beans;\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#setNotificationListenerMappings(Map<?,listeners)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link NotificationListener NotificationListeners} to register\n\t * with the {@link javax.management.MBeanServer}.\n\t * <P>The key of each entry in the {@code Map} is a {@link String}\n\t * representation of the {@link javax.management.ObjectName} or the bean\n\t * name of the MBean the listener should be registered for. Specifying an\n\t * asterisk ({@code *}) for a key will cause the listener to be\n\t * associated with all MBeans registered by this class at startup time.\n\t * <p>The value of each entry is the\n\t * {@link javax.management.NotificationListener} to register. For more\n\t * advanced options such as registering\n\t * {@link javax.management.NotificationFilter NotificationFilters} and\n\t * handback objects see {@link #setNotificationListeners(NotificationListenerBean[])}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "listeners"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "void",
    "signature": "public void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners)",
    "source_code": "\tpublic void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners) {\n\t\tAssert.notNull(listeners, \"'listeners' must not be null\");\n\t\tList<NotificationListenerBean> notificationListeners =\n\t\t\t\tnew ArrayList<>(listeners.size());\n\n\t\tlisteners.forEach((key, listener) -> {\n\t\t\t// Get the listener from the map value.\n\t\t\tNotificationListenerBean bean = new NotificationListenerBean(listener);\n\t\t\t// Get the ObjectName from the map key.\n\t\t\tif (key != null && !WILDCARD.equals(key)) {\n\t\t\t\t// This listener is mapped to a specific ObjectName.\n\t\t\t\tbean.setMappedObjectName(key);\n\t\t\t}\n\t\t\tnotificationListeners.add(bean);\n\t\t});\n\n\t\tthis.notificationListeners = notificationListeners.toArray(new NotificationListenerBean[0]);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#accept(result,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "void",
    "signature": "public void accept(@Nullable Object result, @Nullable Throwable ex)",
    "source_code": "\t\tpublic void accept(@Nullable Object result, @Nullable Throwable ex) {\n\t\t\tif (result != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMethodParameter returnType = this.handlerMethod.getAsyncReturnValueType(result);\n\t\t\t\t\treturnValueHandlers.handleReturnValue(result, returnType, this.message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\thandleFailure(throwable);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ex != null) {\n\t\t\t\thandleFailure(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#createHandlerMethod(handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a HandlerMethod instance from an Object handler that is either a handler\n\t * instance or a String-based bean name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerMethod = new HandlerMethod(beanName, context.getAutowireCapableBeanFactory(), method);\n\t\t}\n\t\telse {\n\t\t\thandlerMethod = new HandlerMethod(handler, method);\n\t\t}\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "InvocableHandlerMethod",
    "signature": "protected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMatchingMapping(mapping,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueListenableFutureCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMessageInternal(message,lookupDestination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "lookupDestination"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message, String lookupDestination)",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleNoMatch(ts,lookupDestination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#processHandlerMethodException(handlerMethod,exception,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "protected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message)",
    "source_code": "\tprotected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message) {\n\t\tInvocableHandlerMethod invocable = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (invocable == null) {\n\t\t\tlogger.error(\"Unhandled exception from message handler method\", exception);\n\t\t\treturn;\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + invocable.getShortLogMessage());\n\t\t}\n\t\ttry {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tObject returnValue = (cause != null ?\n\t\t\t\t\tinvocable.invoke(message, exception, cause, handlerMethod) :\n\t\t\t\t\tinvocable.invoke(message, exception, handlerMethod));\n\t\t\tMethodParameter returnType = invocable.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t}\n\t\tcatch (Throwable ex2) {\n\t\t\tlogger.error(\"Error while processing handler method exception\", ex2);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#registerExceptionHandlerAdvice(bean,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (e.g. to support \"global\" {@code @MessageExceptionHandler}).\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.exceptionHandlerAdviceCache.put(bean, resolver);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupDestinations(mapping)) {\n\t\t\tthis.destinationLookup.add(pattern, mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#createPayload(data,metadata)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Payload from the given metadata and data.\n\t * <p>If at least one is {@link NettyDataBuffer} then {@link ByteBufPayload}\n\t * is created with either obtaining the underlying native {@link ByteBuf}\n\t * or using {@link Unpooled#wrappedBuffer(ByteBuffer...)} if necessary.\n\t * Otherwise, if both are {@link DefaultDataBuffer}, then\n\t * {@link DefaultPayload} is created.\n\t * @param data the data part for the payload\n\t * @param metadata the metadata part for the payload\n\t * @return the created payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Payload",
    "signature": "public Payload createPayload(DataBuffer data, DataBuffer metadata)",
    "source_code": "\tpublic static Payload createPayload(DataBuffer data, DataBuffer metadata) {\n\t\treturn data instanceof NettyDataBuffer || metadata instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data), asByteBuf(metadata)) :\n\t\t\t\tDefaultPayload.create(asByteBuffer(data), asByteBuffer(metadata));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retainDataAndReleasePayload(payload,bufferFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Use this method to slice, retain and wrap the data portion of the\n\t * {@code Payload}, and also to release the {@code Payload}. This assumes\n\t * the Payload metadata has been read by now and ensures downstream code\n\t * need only be aware of {@code DataBuffer}s.\n\t * @param payload the payload to process\n\t * @param bufferFactory the DataBufferFactory to wrap with\n\t * @return the created {@code DataBuffer} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory)",
    "source_code": "\tpublic static DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory) {\n\t\ttry {\n\t\t\tif (bufferFactory instanceof NettyDataBufferFactory) {\n\t\t\t\tByteBuf byteBuf = payload.sliceData().retain();\n\t\t\t\treturn ((NettyDataBufferFactory) bufferFactory).wrap(byteBuf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn bufferFactory.wrap(payload.getData());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (payload.refCnt() > 0) {\n\t\t\t\tpayload.release();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerMethodHints(hints,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\t// Also register non-annotated parameters to handle metadata\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints,\n\t\t\t\t\tMethodParameter.forParameter(parameter).getGenericParameterType());\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReflectionHints(hints,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tthis.registerMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#createMessage(payload,messageHeaders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "messageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Message<T>",
    "signature": "public Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders)",
    "source_code": "\tpublic static <T> Message<T> createMessage(@Nullable T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name. If the provided value is {@code null},\n\t * the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue) {\n\t\tthis.headerAccessor.setHeader(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not already\n\t * associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue) {\n\t\tthis.headerAccessor.setHeaderIfAbsent(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source,\n\t * using the default ClassLoader.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t * @see #createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces) throws EvalError {\n\t\treturn createBshObject(scriptSource, scriptInterfaces, ClassUtils.getDefaultClassLoader());\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces,classLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)\n\t\t\tthrows EvalError {\n\n\t\tObject result = evaluateBshScript(scriptSource, scriptInterfaces, classLoader);\n\t\tif (result instanceof Class<?> clazz) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\treturn (isProxyForSameBshObject(args[0]));\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\treturn this.xt.hashCode();\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"BeanShell object [\" + this.xt + \"]\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tObject result = this.xt.invokeMethod(method.getName(), args);\n\t\t\t\tif (result == Primitive.NULL || result == Primitive.VOID) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (result instanceof Primitive) {\n\t\t\t\t\treturn ((Primitive) result).getValue();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new BshExecutionException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.ui.freemarker.<unknown>#setFreemarkerVariables(Map<String,variables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map that contains well-known FreeMarker objects which will be passed\n\t * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.\n\t * @see freemarker.template.Configuration#setAllSharedVariables\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "variables"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void setFreemarkerVariables(Map<String, Object> variables)",
    "source_code": "\tpublic void setFreemarkerVariables(Map<String, Object> variables) {\n\t\tthis.freemarkerVariables = variables;\n\t}"
  },
  "org.springframework.util.concurrent.<unknown>#get(timeout,unit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\treturn adaptInternal(this.adaptee.get(timeout, unit));\n\t}"
  },
  "org.springframework.util.xml.<unknown>#setFeature(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setFeature(String name, boolean value)",
    "source_code": "\tpublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n\t\tif (NAMESPACES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacesFeature = value;\n\t\t}\n\t\telse if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacePrefixesFeature = value;\n\t\t}\n\t\telse {\n\t\t\tsuper.setFeature(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startPrefixMapping(prefix,namespace)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Start the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix",
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "protected void startPrefixMapping(@Nullable String prefix, String namespace)",
    "source_code": "\tprotected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {\n\t\tif (getContentHandler() != null && StringUtils.hasLength(namespace)) {\n\t\t\tif (prefix == null) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\tif (!namespace.equals(this.namespaces.get(prefix))) {\n\t\t\t\tgetContentHandler().startPrefixMapping(prefix, namespace);\n\t\t\t\tthis.namespaces.put(prefix, namespace);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fieldTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter, applying it to the specified field types only, if any,\n\t * or otherwise to all fields matching the {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add (does not need to generically declare a\n\t * field type if field types are explicitly specified as parameters)\n\t * @param fieldTypes the field types to apply the formatter to, or none if to be\n\t * derived from the given {@link Formatter} implementation class\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fieldTypes"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tif (ObjectUtils.isEmpty(fieldTypes)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (Class<?> fieldType : fieldTypes) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fields"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, String... fields)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 734
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, field);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,methodParam)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, methodParam);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);\n\t}"
  },
  "org.springframework.validation.<unknown>#findCustomEditor(requiredType,propertyPath)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 714
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath)",
    "source_code": "\tpublic PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {\n\t\treturn getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,field,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "field",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 703
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#complete(channel,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void complete(WebSocketChannel channel, Void context)",
    "source_code": "\t\tpublic void complete(WebSocketChannel channel, Void context) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(channel,context,throwable)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void onError(WebSocketChannel channel, Void context, Throwable throwable)",
    "source_code": "\t\tpublic void onError(WebSocketChannel channel, Void context, Throwable throwable) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(throwable);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#connect(adapter,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "void",
    "signature": "public void connect(ReactiveAdapter adapter, Object returnValue)",
    "source_code": "\t\tpublic void connect(ReactiveAdapter adapter, Object returnValue) {\n\t\t\tPublisher<Object> publisher = adapter.toPublisher(returnValue);\n\t\t\tpublisher.subscribe(this);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleValue(returnValue,returnType,mav,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given reactive return value and decide whether to adapt it\n\t * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.\n\t * @return an emitter for streaming, or {@code null} if handled internally\n\t * with a {@link DeferredResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mav",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "ResponseBodyEmitter",
    "signature": "public ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request)",
    "source_code": "\tpublic ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request) throws Exception {\n\n\t\tAssert.notNull(returnValue, \"Expected return value\");\n\t\tClass<?> clazz = returnValue.getClass();\n\t\tReactiveAdapter adapter = this.adapterRegistry.getAdapter(clazz);\n\t\tAssert.state(adapter != null, () -> \"Unexpected return value type: \" + clazz);\n\n\t\tif (isContextPropagationPresent) {\n\t\t\treturnValue = ContextSnapshotHelper.writeReactorContext(returnValue);\n\t\t}\n\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(returnType).getGeneric();\n\t\tClass<?> elementClass = elementType.toClass();\n\n\t\tCollection<MediaType> mediaTypes = getMediaTypes(request);\n\t\tOptional<MediaType> mediaType = mediaTypes.stream().filter(MimeType::isConcrete).findFirst();\n\n\t\tif (adapter.isMultiValue()) {\n\t\t\tif (mediaTypes.stream().anyMatch(MediaType.TEXT_EVENT_STREAM::includes) ||\n\t\t\t\t\tServerSentEvent.class.isAssignableFrom(elementClass)) {\n\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\tSseEmitter emitter = new SseEmitter(STREAMING_TIMEOUT_VALUE);\n\t\t\t\tnew SseEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tif (CharSequence.class.isAssignableFrom(elementClass)) {\n\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\tResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN));\n\t\t\t\tnew TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tfor (MediaType type : mediaTypes) {\n\t\t\t\tfor (MediaType streamingType : JSON_STREAMING_MEDIA_TYPES) {\n\t\t\t\t\tif (streamingType.includes(type)) {\n\t\t\t\t\t\tlogExecutorWarning(returnType);\n\t\t\t\t\t\tResponseBodyEmitter emitter = getEmitter(streamingType);\n\t\t\t\t\t\tnew JsonEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\t\t\treturn emitter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Not streaming...\n\t\tDeferredResult<Object> result = new DeferredResult<>();\n\t\tnew DeferredResultSubscriber(result, adapter, elementType).connect(adapter, returnValue);\n\t\tWebAsyncUtils.getAsyncManager(request).startDeferredResultProcessing(result, mav);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#appendCurrentQueryParams(targetUrl,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append the query string of the current request to the target redirect URL.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param request the current request\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "protected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request)",
    "source_code": "\tprotected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request) {\n\t\tString query = request.getQueryString();\n\t\tif (StringUtils.hasText(query)) {\n\t\t\t// Extract anchor fragment, if any.\n\t\t\tString fragment = null;\n\t\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\t\tif (anchorIndex > -1) {\n\t\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t\t}\n\n\t\t\tif (targetUrl.toString().indexOf('?') < 0) {\n\t\t\t\ttargetUrl.append('?').append(query);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetUrl.append('&').append(query);\n\t\t\t}\n\t\t\t// Append anchor fragment, if any, to end of URL.\n\t\t\tif (fragment != null) {\n\t\t\t\ttargetUrl.append(fragment);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#appendQueryProperties(targetUrl,Map<String,model,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model a Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "void",
    "signature": "protected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)",
    "source_code": "\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Extract anchor fragment, if any.\n\t\tString fragment = null;\n\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\tif (anchorIndex > -1) {\n\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t}\n\n\t\t// If there aren't already some parameters, we need a \"?\".\n\t\tboolean first = (targetUrl.toString().indexOf('?') < 0);\n\t\tfor (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {\n\t\t\tObject rawValue = entry.getValue();\n\t\t\tCollection<?> values;\n\t\t\tif (rawValue != null && rawValue.getClass().isArray()) {\n\t\t\t\tvalues = CollectionUtils.arrayToList(rawValue);\n\t\t\t}\n\t\t\telse if (rawValue instanceof Collection) {\n\t\t\t\tvalues = ((Collection<?>) rawValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = Collections.singleton(rawValue);\n\t\t\t}\n\t\t\tfor (Object value : values) {\n\t\t\t\tif (first) {\n\t\t\t\t\ttargetUrl.append('?');\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetUrl.append('&');\n\t\t\t\t}\n\t\t\t\tString encodedKey = urlEncode(entry.getKey(), encodingScheme);\n\t\t\t\tString encodedValue = (value != null ? urlEncode(value.toString(), encodingScheme) : \"\");\n\t\t\t\ttargetUrl.append(encodedKey).append('=').append(encodedValue);\n\t\t\t}\n\t\t}\n\n\t\t// Append anchor fragment, if any, to end of URL.\n\t\tif (fragment != null) {\n\t\t\ttargetUrl.append(fragment);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#createTargetUrl(Map<String,model,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL by checking if the redirect string is a URI template first,\n\t * expanding it with the given model, and then optionally appending simple type model\n\t * attributes as query String parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tif (this.contextRelative && getUrl().startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(getContextPath(request));\n\t\t}\n\t\ttargetUrl.append(getUrl());\n\n\t\tString enc = this.encodingScheme;\n\t\tif (enc == null) {\n\t\t\tenc = request.getCharacterEncoding();\n\t\t}\n\t\tif (enc == null) {\n\t\t\tenc = WebUtils.DEFAULT_CHARACTER_ENCODING;\n\t\t}\n\n\t\tif (this.expandUriTemplateVariables && StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> variables = getCurrentRequestUriVariables(request);\n\t\t\ttargetUrl = replaceUriTemplateVariables(targetUrl.toString(), model, variables, enc);\n\t\t}\n\t\tif (isPropagateQueryProperties()) {\n\t\t\tappendCurrentQueryParams(targetUrl, request);\n\t\t}\n\t\tif (this.exposeModelAttributes) {\n\t\t\tappendQueryProperties(targetUrl, model, enc);\n\t\t}\n\n\t\treturn targetUrl.toString();\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#getHttp11StatusCode(request,response,targetUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determines the status code to use for HTTP 1.1 compatible requests.\n\t * <p>The default implementation returns the {@link #setStatusCode(HttpStatusCode) statusCode}\n\t * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.\n\t * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).\n\t * @param request the request to inspect\n\t * @param response the servlet response\n\t * @param targetUrl the target URL\n\t * @return the response status\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getHttp11StatusCode(HttpServletRequest request, HttpServletResponse response, String targetUrl)",
    "source_code": "\tprotected HttpStatusCode getHttp11StatusCode(\n\t\t\tHttpServletRequest request, HttpServletResponse response, String targetUrl) {\n\n\t\tif (this.statusCode != null) {\n\t\t\treturn this.statusCode;\n\t\t}\n\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\tif (attributeStatusCode != null) {\n\t\t\treturn attributeStatusCode;\n\t\t}\n\t\treturn HttpStatus.SEE_OTHER;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#isEligibleProperty(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given model element should be exposed\n\t * as a query property.\n\t * <p>The default implementation considers Strings and primitives\n\t * as eligible, and also arrays and Collections/Iterables with\n\t * corresponding elements. This can be overridden in subclasses.\n\t * @param key the key of the model element\n\t * @param value the value of the model element\n\t * @return whether the element is eligible as query property\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleProperty(String key, @Nullable Object value)",
    "source_code": "\tprotected boolean isEligibleProperty(String key, @Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isEligibleValue(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value.getClass().isArray()) {\n\t\t\tint length = Array.getLength(value);\n\t\t\tif (length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tObject element = Array.get(value, i);\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Collection<?> coll) {\n\t\t\tif (coll.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Object element : coll) {\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#queryProperties(Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine name-value pairs for query strings, which will be stringified,\n\t * URL-encoded and formatted by {@link #appendQueryProperties}.\n\t * <p>This implementation filters the model through checking\n\t * {@link #isEligibleProperty(String, Object)} for each element,\n\t * by default accepting Strings, primitives and primitive wrappers only.\n\t * @param model the original model Map\n\t * @return the filtered Map of eligible query properties\n\t * @see #isEligibleProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "Object>",
    "signature": "protected Object> queryProperties(Map<String, Object> model)",
    "source_code": "\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tmodel.forEach((name, value) -> {\n\t\t\tif (isEligibleProperty(name, value)) {\n\t\t\t\tresult.put(name, value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException {\n\n\t\tString targetUrl = createTargetUrl(model, request);\n\t\ttargetUrl = updateTargetUrl(targetUrl, model, request, response);\n\n\t\t// Save flash attributes\n\t\tRequestContextUtils.saveOutputFlashMap(targetUrl, request, response);\n\n\t\t// Redirect\n\t\tsendRedirect(request, response, targetUrl, this.http10Compatible);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#replaceUriTemplateVariables(targetUrl,Map<String,model,Map<String,currentUriVariables,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace URI template variables in the target URL with encoded model\n\t * attributes or URI variables from the current request. Model attributes\n\t * referenced in the URL are removed from the model.\n\t * @param targetUrl the redirect URL\n\t * @param model a Map that contains model attributes\n\t * @param currentUriVariables current request URI variables to use\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "Map<String",
      "currentUriVariables",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder replaceUriTemplateVariables(String targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)",
    "source_code": "\tprotected StringBuilder replaceUriTemplateVariables(\n\t\t\tString targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tMatcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl);\n\t\tint endLastMatch = 0;\n\t\twhile (matcher.find()) {\n\t\t\tString name = matcher.group(1);\n\t\t\tObject value = (model.containsKey(name) ? model.remove(name) : currentUriVariables.get(name));\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Model has no value for key '\" + name + \"'\");\n\t\t\t}\n\t\t\tresult.append(targetUrl, endLastMatch, matcher.start());\n\t\t\tresult.append(UriUtils.encodePathSegment(value.toString(), encodingScheme));\n\t\t\tendLastMatch = matcher.end();\n\t\t}\n\t\tresult.append(targetUrl.substring(endLastMatch));\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#sendRedirect(request,response,targetUrl,http10Compatible)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param request current HTTP request (allows for reacting to request method)\n\t * @param response current HTTP response (for sending response headers)\n\t * @param targetUrl the target URL to redirect to\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t * @throws IOException if thrown by response methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl",
      "http10Compatible"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "void",
    "signature": "protected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible)",
    "source_code": "\tprotected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible) throws IOException {\n\n\t\tString encodedURL = (isRemoteHost(targetUrl) ? targetUrl : response.encodeRedirectURL(targetUrl));\n\t\tif (http10Compatible) {\n\t\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\t\tif (this.statusCode != null) {\n\t\t\t\tresponse.setStatus(this.statusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse if (attributeStatusCode != null) {\n\t\t\t\tresponse.setStatus(attributeStatusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Send status code 302 by default.\n\t\t\t\tresponse.sendRedirect(encodedURL);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tHttpStatusCode statusCode = getHttp11StatusCode(request, response, targetUrl);\n\t\t\tresponse.setStatus(statusCode.value());\n\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#updateTargetUrl(targetUrl,Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the registered {@link RequestDataValueProcessor}, if any, and allow\n\t * it to update the redirect target URL.\n\t * @param targetUrl the given redirect URL\n\t * @return the updated URL or the same as URL as the one passed in\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "String",
    "signature": "protected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac == null) {\n\t\t\twac = RequestContextUtils.findWebApplicationContext(request, getServletContext());\n\t\t}\n\n\t\tif (wac != null && wac.containsBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {\n\t\t\tRequestDataValueProcessor processor = wac.getBean(\n\t\t\t\t\tRequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class);\n\t\t\treturn processor.processUrl(request, targetUrl);\n\t\t}\n\n\t\treturn targetUrl;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#urlEncode(input,encodingScheme)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * URL-encode the given input String with the given encoding scheme.\n\t * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.\n\t * @param input the unencoded input String\n\t * @param encodingScheme the encoding scheme\n\t * @return the encoded output String\n\t * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n\t * @see java.net.URLEncoder#encode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "String",
    "signature": "protected String urlEncode(String input, String encodingScheme)",
    "source_code": "\tprotected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n\t\treturn URLEncoder.encode(input, encodingScheme);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterSessionEnded(session,closeStatus,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel) {\n\t\tthis.decoders.remove(session.getId());\n\n\t\tMessage<byte[]> message = createDisconnectMessage(session);\n\t\tSimpAttributes simpAttributes = SimpAttributes.fromMessage(message);\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\tpublishEvent(this.eventPublisher, new SessionDisconnectEvent(this, message, session.getId(), closeStatus, user));\n\t\t\t}\n\t\t\toutputChannel.send(message);\n\t\t}\n\t\tfinally {\n\t\t\tthis.stompAuthentications.remove(session.getId());\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\tsimpAttributes.sessionCompleted();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterSessionStarted(session,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel) {\n\t\tif (session.getTextMessageSizeLimit() < MINIMUM_WEBSOCKET_MESSAGE_SIZE) {\n\t\t\tsession.setTextMessageSizeLimit(MINIMUM_WEBSOCKET_MESSAGE_SIZE);\n\t\t}\n\t\tthis.decoders.put(session.getId(), new BufferingStompDecoder(this.stompDecoder, getMessageSizeLimit()));\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageFromClient(session,webSocketMessage,outputChannel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel outputChannel) {\n\n\t\tList<Message<byte[]>> messages;\n\t\ttry {\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(((TextMessage) webSocketMessage).asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage) {\n\t\t\t\tbyteBuffer = ((BinaryMessage) webSocketMessage).getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBufferingStompDecoder decoder = this.decoders.get(session.getId());\n\t\t\tif (decoder == null) {\n\t\t\t\tif (!session.isOpen()) {\n\t\t\t\t\tlogger.trace(\"Dropped inbound WebSocket message due to closed session\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new IllegalStateException(\"No decoder for session id '\" + session.getId() + \"'\");\n\t\t\t}\n\n\t\t\tmessages = decoder.decode(byteBuffer);\n\t\t\tif (messages.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received in session \" +\n\t\t\t\t\t\t\tsession + \", bufferSize=\" + decoder.getBufferSize() +\n\t\t\t\t\t\t\t\", bufferSizeLimit=\" + decoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Failed to parse \" + webSocketMessage +\n\t\t\t\t\t\t\" in session \" + session.getId() + \". Sending STOMP ERROR to client.\", ex);\n\t\t\t}\n\t\t\thandleError(session, ex, null);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Message<byte[]> message : messages) {\n\t\t\tStompHeaderAccessor headerAccessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(headerAccessor != null, \"No StompHeaderAccessor\");\n\n\t\t\tStompCommand command = headerAccessor.getCommand();\n\t\t\tboolean isConnect = StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command);\n\n\t\t\tboolean sent = false;\n\t\t\ttry {\n\n\t\t\t\theaderAccessor.setSessionId(session.getId());\n\t\t\t\theaderAccessor.setSessionAttributes(session.getAttributes());\n\t\t\t\theaderAccessor.setUser(getUser(session));\n\t\t\t\tif (isConnect) {\n\t\t\t\t\theaderAccessor.setUserChangeCallback(user -> {\n\t\t\t\t\t\tif (user != null && user != session.getPrincipal()) {\n\t\t\t\t\t\t\tthis.stompAuthentications.put(session.getId(), user);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\theaderAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat());\n\t\t\t\tif (!detectImmutableMessageInterceptor(outputChannel)) {\n\t\t\t\t\theaderAccessor.setImmutable();\n\t\t\t\t}\n\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"From client: \" + headerAccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t}\n\n\t\t\t\tif (isConnect) {\n\t\t\t\t\tthis.stats.incrementConnectCount();\n\t\t\t\t}\n\t\t\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\t\t\tsent = outputChannel.send(message);\n\n\t\t\t\t\tif (sent) {\n\t\t\t\t\t\tif (this.eventPublisher != null) {\n\t\t\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\t\t\tif (isConnect) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.SUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.UNSUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to send message to MessageChannel in session \" + session.getId(), ex);\n\t\t\t\t}\n\t\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\t\t// Skip unsent CONNECT messages (likely auth issues)\n\t\t\t\t\tif (!isConnect || sent) {\n\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" + session.getId() +\n\t\t\t\t\t\t\t\t\":\" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thandleError(session, ex, message);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageToClient(session,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle STOMP messages going back out to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void handleMessageToClient(WebSocketSession session, Message<?> message)",
    "source_code": "\tpublic void handleMessageToClient(WebSocketSession session, Message<?> message) {\n\t\tif (!(message.getPayload() instanceof byte[] payload)) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Expected byte[] payload. Ignoring \" + message + \".\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor accessor = getStompHeaderAccessor(message);\n\t\tStompCommand command = accessor.getCommand();\n\n\t\tif (StompCommand.MESSAGE.equals(command)) {\n\t\t\tif (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"No STOMP \\\"subscription\\\" header in \" + message);\n\t\t\t}\n\t\t\tString origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\tif (origDestination != null) {\n\t\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\t\taccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\t\taccessor.setDestination(origDestination);\n\t\t\t}\n\t\t}\n\t\telse if (StompCommand.CONNECTED.equals(command)) {\n\t\t\tthis.stats.incrementConnectedCount();\n\t\t\taccessor = afterStompSessionConnected(message, accessor, session);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes());\n\t\t\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {\n\t\t\tMessage<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient((Message<byte[]>) message);\n\t\t\tif (errorMessage != null) {\n\t\t\t\taccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\t\tpayload = errorMessage.getPayload();\n\t\t\t}\n\t\t}\n\n\t\tRunnable task = OrderedMessageChannelDecorator.getNextMessageTask(message);\n\t\tif (task != null) {\n\t\t\tAssert.isInstanceOf(ConcurrentWebSocketSessionDecorator.class, session);\n\t\t\t((ConcurrentWebSocketSessionDecorator) session).setMessageCallback(m -> task.run());\n\t\t}\n\n\t\tsendToClient(session, accessor, payload);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#toMutableAccessor(headerAccessor,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerAccessor",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "StompHeaderAccessor",
    "signature": "protected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message)",
    "source_code": "\tprotected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message) {\n\t\treturn (headerAccessor.isMutable() ? headerAccessor : StompHeaderAccessor.wrap(message));\n\t}"
  }
}