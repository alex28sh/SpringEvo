{
  "org.springframework.cglib.beans.<unknown>#newInstance(type,require)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "require"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, int require)",
    "source_code": "            public Object newInstance(Class type, int require);"
  },
  "org.springframework.cglib.beans.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\tpublic Object put(Object key, Object value) {\n        return put(bean, key, value);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#addAllInterfaces(type,list)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 410
    },
    "return": "List",
    "signature": "public List addAllInterfaces(Class type, List list)",
    "source_code": "\tpublic static List addAllInterfaces(Class type, List list) {\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\tlist.addAll(Arrays.asList(type.getInterfaces()));\n\t\t\taddAllInterfaces(superclass, list);\n\t\t}\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#addAllMethods(type,list)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "List",
    "signature": "public List addAllMethods(final Class type, final List list)",
    "source_code": "\tpublic static List addAllMethods(final Class type, final List list) {\n\t\tif (type == Object.class) {\n\t\t\tlist.addAll(OBJECT_METHODS);\n\t\t}\n\t\telse {\n\t\t\tlist.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));\n\t\t}\n\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\taddAllMethods(superclass, list);\n\t\t}\n\t\tClass[] interfaces = type.getInterfaces();\n\t\tfor (Class element : interfaces) {\n\t\t\taddAllMethods(element, list);\n\t\t}\n\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#begin_class(version,access,className,superType,interfaces,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "className",
      "superType",
      "interfaces",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source)",
    "source_code": "    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {\n        final Type classType = Type.getType(\"L\" + className.replace('.', '/') + \";\");\n        classInfo = new ClassInfo() {\n            @Override\n\t\t\tpublic Type getType() {\n                return classType;\n            }\n            @Override\n\t\t\tpublic Type getSuperType() {\n                return (superType != null) ? superType : Constants.TYPE_OBJECT;\n            }\n            @Override\n\t\t\tpublic Type[] getInterfaces() {\n                return interfaces;\n            }\n            @Override\n\t\t\tpublic int getModifiers() {\n                return access;\n            }\n        };\n        cv.visit(version,\n                 access,\n                 classInfo.getType().getInternalName(),\n                 null,\n                 classInfo.getSuperType().getInternalName(),\n                 TypeUtils.toInternalNames(interfaces));\n        if (source != null) {\n\t\t\tcv.visitSource(source, null);\n\t\t}\n        init();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(access,sig,exceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "sig",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions)",
    "source_code": "    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n        if (classInfo == null) {\n\t\t\tthrow new IllegalStateException(\"classInfo is null! \" + this);\n\t\t}\n        MethodVisitor v = cv.visitMethod(access,\n                                         sig.getName(),\n                                         sig.getDescriptor(),\n                                         null,\n                                         TypeUtils.toInternalNames(exceptions));\n        if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {\n            rawStaticInit = v;\n            MethodVisitor wrapped = new MethodVisitor(Constants.ASM_API, v) {\n                @Override\n\t\t\t\tpublic void visitMaxs(int maxStack, int maxLocals) {\n                    // ignore\n                }\n                @Override\n\t\t\t\tpublic void visitInsn(int insn) {\n                    if (insn != Constants.RETURN) {\n                        super.visitInsn(insn);\n                    }\n                }\n            };\n            staticInit = new CodeEmitter(this, wrapped, access, sig, exceptions);\n            if (staticHook == null) {\n                // force static hook creation\n                getStaticHook();\n            } else {\n                staticInit.invoke_static_this(staticHookSig);\n            }\n            return staticInit;\n        } else if (sig.equals(staticHookSig)) {\n            return new CodeEmitter(this, v, access, sig, exceptions) {\n                @Override\n\t\t\t\tpublic boolean isStaticHook() {\n                    return true;\n                }\n            };\n        } else {\n            return new CodeEmitter(this, v, access, sig, exceptions);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#declare_field(access,name,type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void declare_field(int access, String name, Type type, Object value)",
    "source_code": "    public void declare_field(int access, String name, Type type, Object value) {\n        FieldInfo existing = (FieldInfo)fieldInfo.get(name);\n        FieldInfo info = new FieldInfo(access, name, type, value);\n        if (existing != null) {\n            if (!info.equals(existing)) {\n                throw new IllegalArgumentException(\"Field \\\"\" + name + \"\\\" has been declared differently\");\n            }\n        } else {\n            fieldInfo.put(name, info);\n            cv.visitField(access, name, type.getDescriptor(), null, value);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception {\n\t\treturn defineClass(className, b, loader, null, null);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader,protectionDomain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain) throws Exception {\n\n\t\treturn defineClass(className, b, loader, protectionDomain, null);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader,protectionDomain,contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass) throws Exception {\n\n\t\tClass c = null;\n\t\tThrowable t = THROWABLE;\n\n\t\tBiConsumer<String, byte[]> handlerToUse = generatedClassHandler;\n\t\tif (handlerToUse != null) {\n\t\t\thandlerToUse.accept(className, b);\n\t\t}\n\n\t\t// Preferred option: JDK 9+ Lookup.defineClass API if ClassLoader matches\n\t\tif (contextClass != null && contextClass.getClassLoader() == loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (LinkageError | IllegalArgumentException ex) {\n\t\t\t\t// in case of plain LinkageError (class already defined)\n\t\t\t\t// or IllegalArgumentException (class in different package):\n\t\t\t\t// fall through to traditional ClassLoader.defineClass below\n\t\t\t\tt = ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// Direct defineClass attempt on the target Classloader\n\t\tif (c == null) {\n\t\t\tif (protectionDomain == null) {\n\t\t\t\tprotectionDomain = PROTECTION_DOMAIN;\n\t\t\t}\n\n\t\t\t// Look for publicDefineClass(String name, byte[] b, ProtectionDomain protectionDomain)\n\t\t\ttry {\n\t\t\t\tMethod publicDefineClass = loader.getClass().getMethod(\n\t\t\t\t\t\t\"publicDefineClass\", String.class, byte[].class, ProtectionDomain.class);\n\t\t\t\tc = (Class) publicDefineClass.invoke(loader, className, b, protectionDomain);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tif (!(ex.getTargetException() instanceof UnsupportedOperationException)) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\t// in case of UnsupportedOperationException, fall through\n\t\t\t\tt = ex.getTargetException();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// publicDefineClass method not available -> fall through\n\t\t\t\tt = ex;\n\t\t\t}\n\n\t\t\t// Classic option: protected ClassLoader.defineClass method\n\t\t\tif (c == null && classLoaderDefineClassMethod != null) {\n\t\t\t\tObject[] args = new Object[]{className, b, 0, b.length, protectionDomain};\n\t\t\t\ttry {\n\t\t\t\t\tif (!classLoaderDefineClassMethod.isAccessible()) {\n\t\t\t\t\t\tclassLoaderDefineClassMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t\tc = (Class) classLoaderDefineClassMethod.invoke(loader, args);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Fall through if setAccessible fails with InaccessibleObjectException on JDK 9+\n\t\t\t\t\t// (on the module path and/or with a JVM bootstrapped with --illegal-access=deny)\n\t\t\t\t\tif (!ex.getClass().getName().endsWith(\"InaccessibleObjectException\")) {\n\t\t\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tt = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fallback option: JDK 9+ Lookup.defineClass API even if ClassLoader does not match\n\t\tif (c == null && contextClass != null && contextClass.getClassLoader() != loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new CodeGenerationException(ex) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getMessage() {\n\t\t\t\t\t\treturn \"ClassLoader mismatch for [\" + contextClass.getName() +\n\t\t\t\t\t\t\t\t\"]: JVM should be started with --add-opens=java.base/java.lang=ALL-UNNAMED \" +\n\t\t\t\t\t\t\t\t\"for ClassLoader.defineClass to be accessible on \" + loader.getClass().getName();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// No defineClass variant available at all?\n\t\tif (c == null) {\n\t\t\tthrow new CodeGenerationException(t);\n\t\t}\n\n\t\t// Force static initializers to run.\n\t\tClass.forName(className, true, loader);\n\t\treturn c;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findConstructor(desc,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Constructor",
    "signature": "public Constructor findConstructor(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Constructor findConstructor(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tString className = desc.substring(0, lparen).trim();\n\t\t\treturn getClass(className, loader).getConstructor(parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findDeclaredMethod(type,methodName,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)",
    "source_code": "\tpublic static Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tClass cl = type;\n\t\twhile (cl != null) {\n\t\t\ttry {\n\t\t\t\treturn cl.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException e) {\n\t\t\t\tcl = cl.getSuperclass();\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchMethodException(methodName);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findMethod(desc,loader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Method",
    "signature": "public Method findMethod(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Method findMethod(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tint dot = desc.lastIndexOf('.', lparen);\n\t\t\tString className = desc.substring(0, dot).trim();\n\t\t\tString methodName = desc.substring(dot + 1, lparen).trim();\n\t\t\treturn getClass(className, loader).getDeclaredMethod(methodName, parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findMethods(namesAndDescriptors,methods)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namesAndDescriptors",
      "methods"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "Method[]",
    "signature": "public Method[] findMethods(String[] namesAndDescriptors, Method[] methods)",
    "source_code": "\tpublic static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) {\n\t\tMap map = new HashMap();\n\t\tfor (Method method : methods) {\n\t\t\tmap.put(method.getName() + Type.getMethodDescriptor(method), method);\n\t\t}\n\t\tMethod[] result = new Method[namesAndDescriptors.length / 2];\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tresult[i] = (Method) map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);\n\t\t\tif (result[i] == null) {\n\t\t\t\t// TODO: error?\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#get(gen,useCache)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "useCache"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "public Object get(AbstractClassGenerator gen, boolean useCache)",
    "source_code": "\t\tpublic Object get(AbstractClassGenerator gen, boolean useCache) {\n\t\t\tif (!useCache) {\n\t\t\t\treturn gen.generate(ClassLoaderData.this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject cachedValue = generatedClasses.get(gen);\n\t\t\t\treturn gen.unwrapCachedValue(cachedValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cglib.core.<unknown>#getConstructor(type,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Constructor",
    "signature": "public Constructor getConstructor(Class type, Class[] parameterTypes)",
    "source_code": "\tpublic static Constructor getConstructor(Class type, Class[] parameterTypes) {\n\t\ttry {\n\t\t\tConstructor constructor = type.getDeclaredConstructor(parameterTypes);\n\t\t\tconstructor.setAccessible(true);\n\t\t\treturn constructor;\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#getMethodInfo(member,modifiers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member",
      "modifiers"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "MethodInfo",
    "signature": "public MethodInfo getMethodInfo(final Member member, final int modifiers)",
    "source_code": "\tpublic static MethodInfo getMethodInfo(final Member member, final int modifiers) {\n\t\tfinal Signature sig = getSignature(member);\n\t\treturn new MethodInfo() {\n\t\t\tprivate ClassInfo ci;\n\n\t\t\t@Override\n\t\t\tpublic ClassInfo getClassInfo() {\n\t\t\t\tif (ci == null) {\n\t\t\t\t\tci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n\t\t\t\t}\n\t\t\t\treturn ci;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn modifiers;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Signature getSignature() {\n\t\t\t\treturn sig;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Type[] getExceptionTypes() {\n\t\t\t\treturn ReflectUtils.getExceptionTypes(member);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#getPropertyMethods(properties,read,write)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "read",
      "write"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Method[]",
    "signature": "public Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write)",
    "source_code": "\tpublic static Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write) {\n\t\tSet methods = new HashSet();\n\t\tfor (PropertyDescriptor pd : properties) {\n\t\t\tif (read) {\n\t\t\t\tmethods.add(pd.getReadMethod());\n\t\t\t}\n\t\t\tif (write) {\n\t\t\t\tmethods.add(pd.getWriteMethod());\n\t\t\t}\n\t\t}\n\t\tmethods.remove(null);\n\t\treturn (Method[]) methods.toArray(new Method[methods.size()]);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#newInstance(cstruct,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cstruct",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "Object",
    "signature": "public Object newInstance(final Constructor cstruct, final Object[] args)",
    "source_code": "\tpublic static Object newInstance(final Constructor cstruct, final Object[] args) {\n\t\tboolean flag = cstruct.isAccessible();\n\t\ttry {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(true);\n\t\t\t}\n\t\t\tObject result = cstruct.newInstance(args);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow new CodeGenerationException(e.getTargetException());\n\t\t}\n\t\tfinally {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(flag);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#newInstance(type,parameterTypes,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, Class[] parameterTypes, Object[] args)",
    "source_code": "\tpublic static Object newInstance(Class type, Class[] parameterTypes, Object[] args) {\n\t\treturn newInstance(getConstructor(type, parameterTypes), args);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#setGeneratedClassHandler(BiConsumer<String,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void setGeneratedClassHandler(BiConsumer<String, byte[]> handler)",
    "source_code": "\tpublic static void setGeneratedClassHandler(BiConsumer<String, byte[]> handler) {\n\t\tgeneratedClassHandler = handler;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#visit(version,access,name,signature,superName,interfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "name",
      "signature",
      "superName",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces)",
    "source_code": "\tpublic void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces) {\n        begin_class(version,\n                    access,\n                    name.replace('/', '.'),\n                    TypeUtils.fromInternalName(superName),\n                    TypeUtils.fromInternalNames(interfaces),\n                    null); // TODO\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitField(access,name,desc,signature,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "FieldVisitor",
    "signature": "public FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value)",
    "source_code": "\tpublic FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value) {\n        declare_field(access, name, Type.getType(desc), value);\n        return null; // TODO\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitIincInsn(var,increment)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var",
      "increment"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void visitIincInsn(final int var, final int increment)",
    "source_code": "\tpublic void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(remap(var, 1), increment);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitLocalVariable(name,desc,signature,start,end,index)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "desc",
      "signature",
      "start",
      "end",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void visitLocalVariable(final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)",
    "source_code": "\tpublic void visitLocalVariable(\n        final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)\n    {\n        mv.visitLocalVariable(name, desc, signature, start, end, remap(index));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitMaxs(maxStack,maxLocals)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxStack",
      "maxLocals"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void visitMaxs(final int maxStack, final int maxLocals)",
    "source_code": "\tpublic void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, state.nextLocal);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitMethod(access,name,desc,signature,exceptions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions) {\n        return begin_method(access,\n                            new Signature(name, desc),\n                            TypeUtils.fromInternalNames(exceptions));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitVarInsn(opcode,var)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "opcode",
      "var"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void visitVarInsn(final int opcode, final int var)",
    "source_code": "\tpublic void visitVarInsn(final int opcode, final int var) {\n        int size = switch (opcode) {\n\t\t\tcase Opcodes.LLOAD, Opcodes.LSTORE, Opcodes.DLOAD, Opcodes.DSTORE -> 2;\n\t\t\tdefault -> 1;\n\t\t};\n        mv.visitVarInsn(opcode, remap(var, size));\n    }"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArgument(mv,cf,argument,paramDesc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Ask an argument to generate its bytecode and then follow it up\n\t * with any boxing/unboxing/checkcasting to ensure it matches the expected parameter descriptor.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "argument",
      "paramDesc"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc)",
    "source_code": "\tprotected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {\n\t\tcf.enterCompilationScope();\n\t\targument.generateCode(mv, cf);\n\t\tString lastDesc = cf.lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = CodeFlow.isPrimitive(lastDesc);\n\t\t// Check if need to box it for the method reference?\n\t\tif (primitiveOnStack && paramDesc.charAt(0) == 'L') {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, lastDesc.charAt(0));\n\t\t}\n\t\telse if (paramDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, paramDesc.charAt(0), lastDesc);\n\t\t}\n\t\telse if (!paramDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes Number but Integer passed in)\n\t\t\tCodeFlow.insertCheckCast(mv, paramDesc);\n\t\t}\n\t\tcf.exitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArguments(mv,cf,member,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified method.\n\t * This method will take account of whether the invoked method is a varargs method\n\t * and if it is then the argument values will be appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current codeflow\n\t * @param member the method or constructor for which arguments are being setup\n\t * @param arguments the expression nodes for the expression supplied argument values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "member",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {\n\t\tString[] paramDescriptors = null;\n\t\tboolean isVarargs = false;\n\t\tif (member instanceof Constructor<?> ctor) {\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(ctor.getParameterTypes());\n\t\t\tisVarargs = ctor.isVarArgs();\n\t\t}\n\t\telse { // Method\n\t\t\tMethod method = (Method)member;\n\t\t\tparamDescriptors = CodeFlow.toDescriptors(method.getParameterTypes());\n\t\t\tisVarargs = method.isVarArgs();\n\t\t}\n\t\tif (isVarargs) {\n\t\t\t// The final parameter may or may not need packaging into an array, or nothing may\n\t\t\t// have been passed to satisfy the varargs and so something needs to be built.\n\t\t\tint p = 0; // Current supplied argument being processed\n\t\t\tint childCount = arguments.length;\n\n\t\t\t// Fulfill all the parameter requirements except the last one\n\t\t\tfor (p = 0; p < paramDescriptors.length - 1; p++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[p], paramDescriptors[p]);\n\t\t\t}\n\n\t\t\tSpelNodeImpl lastChild = (childCount == 0 ? null : arguments[childCount - 1]);\n\t\t\tString arrayType = paramDescriptors[paramDescriptors.length - 1];\n\t\t\t// Determine if the final passed argument is already suitably packaged in array\n\t\t\t// form to be passed to the method\n\t\t\tif (lastChild != null && arrayType.equals(lastChild.getExitDescriptor())) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, lastChild, paramDescriptors[p]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarrayType = arrayType.substring(1); // trim the leading '[', may leave other '['\n\t\t\t\t// build array big enough to hold remaining arguments\n\t\t\t\tCodeFlow.insertNewArrayCode(mv, childCount - p, arrayType);\n\t\t\t\t// Package up the remaining arguments into the array\n\t\t\t\tint arrayindex = 0;\n\t\t\t\twhile (p < childCount) {\n\t\t\t\t\tSpelNodeImpl child = arguments[p];\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tCodeFlow.insertOptimalLoad(mv, arrayindex++);\n\t\t\t\t\tgenerateCodeForArgument(mv, cf, child, arrayType);\n\t\t\t\t\tCodeFlow.insertArrayStore(mv, arrayType);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < paramDescriptors.length;i++) {\n\t\t\t\tgenerateCodeForArgument(mv, cf, arguments[i], paramDescriptors[i]);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#getValue(state,desiredReturnType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state",
      "desiredReturnType"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "T",
    "signature": "protected T getValue(ExpressionState state, Class<T> desiredReturnType)",
    "source_code": "\tprotected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\treturn ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isSuitable(value,target,argumentTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "target",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "boolean",
    "signature": "public boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes)",
    "source_code": "\t\tpublic boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == value) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes));\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValue(expressionState,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setValue(ExpressionState expressionState, @Nullable Object newValue)",
    "source_code": "\tpublic void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException {\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass());\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isCandidateForInvocation(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for method resolution\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * static methods sand non-user-declared methods on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForInvocation(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForInvocation(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#registerMethodFilter(type,filter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a filter for methods on the given type.\n\t * @param type the type to filter on\n\t * @param filter the corresponding method filter,\n\t * or {@code null} to clear any filter for the given type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter)",
    "source_code": "\tpublic void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter) {\n\t\tif (this.filters == null) {\n\t\t\tthis.filters = new HashMap<>();\n\t\t}\n\t\tif (filter != null) {\n\t\t\tthis.filters.put(type, filter);\n\t\t}\n\t\telse {\n\t\t\tthis.filters.remove(type);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#resolve(context,targetObject,name,argumentTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Locate a method on a type. There are three kinds of match that might occur:\n\t * <ol>\n\t * <li>an exact match where the types of the arguments match the types of the constructor\n\t * <li>an in-exact match where the types we are looking for are subtypes of those defined on the constructor\n\t * <li>a match where we are able to convert the arguments into those expected by the constructor,\n\t * according to the registered type converter\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "targetObject",
      "name",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "MethodExecutor",
    "signature": "public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes)",
    "source_code": "\tpublic MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes) throws AccessException {\n\n\t\ttry {\n\t\t\tTypeConverter typeConverter = context.getTypeConverter();\n\t\t\tClass<?> type = (targetObject instanceof Class<?> clazz ? clazz : targetObject.getClass());\n\t\t\tArrayList<Method> methods = new ArrayList<>(getMethods(type, targetObject));\n\n\t\t\t// If a filter is registered for this type, call it\n\t\t\tMethodFilter filter = (this.filters != null ? this.filters.get(type) : null);\n\t\t\tif (filter != null) {\n\t\t\t\tList<Method> filtered = filter.filter(methods);\n\t\t\t\tmethods = (filtered instanceof ArrayList ? (ArrayList<Method>) filtered : new ArrayList<>(filtered));\n\t\t\t}\n\n\t\t\t// Sort methods into a sensible order\n\t\t\tif (methods.size() > 1) {\n\t\t\t\tmethods.sort((m1, m2) -> {\n\t\t\t\t\tint m1pl = m1.getParameterCount();\n\t\t\t\t\tint m2pl = m2.getParameterCount();\n\t\t\t\t\t// vararg methods go last\n\t\t\t\t\tif (m1pl == m2pl) {\n\t\t\t\t\t\tif (!m1.isVarArgs() && m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (m1.isVarArgs() && !m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Integer.compare(m1pl, m2pl);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Resolve any bridge methods\n\t\t\tfor (int i = 0; i < methods.size(); i++) {\n\t\t\t\tmethods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)));\n\t\t\t}\n\n\t\t\t// Remove duplicate methods (possible due to resolved bridge methods)\n\t\t\tSet<Method> methodsToIterate = new LinkedHashSet<>(methods);\n\n\t\t\tMethod closeMatch = null;\n\t\t\tint closeMatchDistance = Integer.MAX_VALUE;\n\t\t\tMethod matchRequiringConversion = null;\n\t\t\tboolean multipleOptions = false;\n\n\t\t\tfor (Method method : methodsToIterate) {\n\t\t\t\tif (method.getName().equals(name)) {\n\t\t\t\t\tint paramCount = method.getParameterCount();\n\t\t\t\t\tList<TypeDescriptor> paramDescriptors = new ArrayList<>(paramCount);\n\t\t\t\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\t\t\t\tparamDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)));\n\t\t\t\t\t}\n\t\t\t\t\tReflectionHelper.ArgumentsMatchInfo matchInfo = null;\n\t\t\t\t\tif (method.isVarArgs() && argumentTypes.size() >= (paramCount - 1)) {\n\t\t\t\t\t\t// *sigh* complicated\n\t\t\t\t\t\tmatchInfo = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (paramCount == argumentTypes.size()) {\n\t\t\t\t\t\t// Name and parameter number match, check the arguments\n\t\t\t\t\t\tmatchInfo = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t\t}\n\t\t\t\t\tif (matchInfo != null) {\n\t\t\t\t\t\tif (matchInfo.isExactMatch()) {\n\t\t\t\t\t\t\treturn new ReflectiveMethodExecutor(method, type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (matchInfo.isCloseMatch()) {\n\t\t\t\t\t\t\tif (this.useDistance) {\n\t\t\t\t\t\t\t\tint matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes);\n\t\t\t\t\t\t\t\tif (closeMatch == null || matchDistance < closeMatchDistance) {\n\t\t\t\t\t\t\t\t\t// This is a better match...\n\t\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\t\tcloseMatchDistance = matchDistance;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Take this as a close match if there isn't one already\n\t\t\t\t\t\t\t\tif (closeMatch == null) {\n\t\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (matchInfo.isMatchRequiringConversion()) {\n\t\t\t\t\t\t\tif (matchRequiringConversion != null) {\n\t\t\t\t\t\t\t\tmultipleOptions = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatchRequiringConversion = method;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (closeMatch != null) {\n\t\t\t\treturn new ReflectiveMethodExecutor(closeMatch, type);\n\t\t\t}\n\t\t\telse if (matchRequiringConversion != null) {\n\t\t\t\tif (multipleOptions) {\n\t\t\t\t\tthrow new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name);\n\t\t\t\t}\n\t\t\t\treturn new ReflectiveMethodExecutor(matchRequiringConversion, type);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (EvaluationException ex) {\n\t\t\tthrow new AccessException(\"Failed to resolve method\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.<unknown>#forStatusAndDetail(status,detail)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code ProblemDetail} instance with the given status and detail.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "detail"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail)",
    "source_code": "\tpublic static ProblemDetail forStatusAndDetail(HttpStatusCode status, String detail) {\n\t\tAssert.notNull(status, \"HttpStatusCode is required\");\n\t\tProblemDetail problemDetail = forStatus(status.value());\n\t\tproblemDetail.setDetail(detail);\n\t\treturn problemDetail;\n\t}"
  },
  "org.springframework.http.<unknown>#setProperty(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a \"dynamic\" property to be added to a generic {@link #getProperties()\n\t * properties map}.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param name the property name\n\t * @param value the property value\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setProperty(String name, Object value)",
    "source_code": "\tpublic void setProperty(String name, Object value) {\n\t\tthis.properties = (this.properties != null ? this.properties : new LinkedHashMap<>());\n\t\tthis.properties.put(name, value);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#canWrite(elementType,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (Part.class.isAssignableFrom(elementType.toClass())) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : getWritableMediaTypes()) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation simple delegates to {@link #readInternal(Class, HttpInputMessage)}.\n\t * Future implementations might add some default behavior, however.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "T",
    "signature": "public T read(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic final T read(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn readInternal(clazz, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that reads the actual object. Invoked from {@link #read}.\n\t * @param clazz the type of object to return\n\t * @param inputMessage the HTTP input message to read from\n\t * @return the converted object\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotReadableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "T",
    "signature": "protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected abstract T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}."
  },
  "org.springframework.jdbc.core.<unknown>#convertValueToRequiredType(value,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given column value to the specified required type.\n\t * Only called if the extracted column value does not match already.\n\t * <p>If the required type is String, the value will simply get stringified\n\t * via {@code toString()}. In case of a Number, the value will be\n\t * converted into a Number, either through number conversion or through\n\t * String parsing (depending on the value type). Otherwise, the value will\n\t * be converted to a required type using the {@link ConversionService}.\n\t * @param value the column value as extracted from {@code getColumnValue()}\n\t * (never {@code null})\n\t * @param requiredType the type that each result object is expected to match\n\t * (never {@code null})\n\t * @return the converted value\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Object",
    "signature": "protected Object convertValueToRequiredType(Object value, Class<?> requiredType)",
    "source_code": "\tprotected Object convertValueToRequiredType(Object value, Class<?> requiredType) {\n\t\tif (String.class == requiredType) {\n\t\t\treturn value.toString();\n\t\t}\n\t\telse if (Number.class.isAssignableFrom(requiredType)) {\n\t\t\tif (value instanceof Number number) {\n\t\t\t\t// Convert original Number to target Number class.\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, (Class<Number>) requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Convert stringified value to target Number class.\n\t\t\t\treturn NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType);\n\t\t\t}\n\t\t}\n\t\telse if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {\n\t\t\treturn this.conversionService.convert(value, requiredType);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Value [\" + value + \"] is of type [\" + value.getClass().getName() +\n\t\t\t\t\t\"] and cannot be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column, using the most\n\t * appropriate value type. Called if no required type has been specified.\n\t * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},\n\t * which uses the {@code ResultSet.getObject(index)} method. Additionally,\n\t * it includes a \"hack\" to get around Oracle returning a non-standard object for\n\t * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}\n\t * javadoc for details.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * If no required type has been specified, this method delegates to\n\t * {@code getColumnValue(rs, index)}, which basically calls\n\t * {@code ResultSet.getObject(index)} but applies some additional\n\t * default conversion to appropriate value types.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the type that each result object is expected to match\n\t * (or {@code null} if none specified)\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t * @see #getColumnValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType != null) {\n\t\t\treturn JdbcUtils.getResultSetValue(rs, index, requiredType);\n\t\t}\n\t\telse {\n\t\t\t// No required type specified -> perform default extraction.\n\t\t\treturn getColumnValue(rs, index);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a value for the single column in the current row.\n\t * <p>Validates that there is only one column selected,\n\t * then delegates to {@code getColumnValue()} and also\n\t * {@code convertValueToRequiredType}, if necessary.\n\t * @see java.sql.ResultSetMetaData#getColumnCount()\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t * @see #convertValueToRequiredType(Object, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t// Validate column count.\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint nrOfColumns = rsmd.getColumnCount();\n\t\tif (nrOfColumns != 1) {\n\t\t\tthrow new IncorrectResultSetColumnCountException(1, nrOfColumns);\n\t\t}\n\n\t\t// Extract column value from JDBC ResultSet.\n\t\tObject result = getColumnValue(rs, 1, this.requiredType);\n\t\tif (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {\n\t\t\t// Extracted value does not match already: try to convert it.\n\t\t\ttry {\n\t\t\t\treturn (T) convertValueToRequiredType(result, this.requiredType);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Type mismatch affecting row number \" + rowNum + \" and column type '\" +\n\t\t\t\t\t\trsmd.getColumnTypeName(1) + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(requiredType,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @param conversionService the {@link ConversionService} for converting a\n\t * fetched value, or {@code null} for none\n\t * @since 5.0.4\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "SingleColumnRowMapper<T>",
    "signature": "public SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> SingleColumnRowMapper<T> newInstance(\n\t\t\tClass<T> requiredType, @Nullable ConversionService conversionService) {\n\n\t\tSingleColumnRowMapper<T> rowMapper = newInstance(requiredType);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createReturnResultSetParameter(parameterName,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a ReturnResultSetParameter/SqlOutParameter depending on the support provided\n\t * by the JDBC driver used for the database in use.\n\t * @param parameterName the name of the parameter (also used as the name of the List returned in the output)\n\t * @param rowMapper a RowMapper implementation used to map the data returned in the result set\n\t * @return the appropriate SqlParameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (provider.isReturnResultSetSupported()) {\n\t\t\treturn new SqlReturnResultSet(parameterName, rowMapper);\n\t\t}\n\t\telse {\n\t\t\tif (provider.isRefCursorSupported()) {\n\t\t\t\treturn new SqlOutParameter(parameterName, provider.getRefCursorSqlType(), rowMapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Return of a ResultSet from a stored procedure is not supported\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#registerSqlType(paramName,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void registerSqlType(String paramName, int sqlType)",
    "source_code": "\tpublic void registerSqlType(String paramName, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.sqlTypes.put(paramName, sqlType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#registerTypeName(paramName,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param typeName the type name of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void registerTypeName(String paramName, String typeName)",
    "source_code": "\tpublic void registerTypeName(String paramName, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.typeNames.put(paramName, typeName);\n\t}"
  },
  "org.springframework.jdbc.core.support.<unknown>#setTypeValue(ps,paramIndex,sqlType,typeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the specified content via the LobCreator.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)",
    "source_code": "\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.BLOB) {\n\t\t\tif (this.content instanceof byte[] || this.content == null) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, (byte[]) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof String string) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, string.getBytes());\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setBlobAsBinaryStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for BLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse if (sqlType == Types.CLOB) {\n\t\t\tif (this.content instanceof String || this.content == null) {\n\t\t\t\tthis.lobCreator.setClobAsString(ps, paramIndex, (String) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setClobAsAsciiStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse if (this.content instanceof Reader reader) {\n\t\t\t\tthis.lobCreator.setClobAsCharacterStream(ps, paramIndex, reader, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for CLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"SqlLobValue only supports SQL types BLOB and CLOB\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doBegin(transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t\tConnection con = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasConnectionHolder() ||\n\t\t\t\t\ttxObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tConnection newCon = obtainDataSource().getConnection();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n\t\t\t}\n\n\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\tcon = txObject.getConnectionHolder().getConnection();\n\n\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n\t\t\t// so we don't want to do it unnecessarily (for example if we've explicitly\n\t\t\t// configured the connection pool to set it already).\n\t\t\tif (con.getAutoCommit()) {\n\t\t\t\ttxObject.setMustRestoreAutoCommit(true);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\n\t\t\t\t}\n\t\t\t\tcon.setAutoCommit(false);\n\t\t\t}\n\n\t\t\tprepareTransactionalConnection(con, definition);\n\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n\t\t\t}\n\n\t\t\t// Bind the connection holder to the thread.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\n\t\t\t}\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tDataSourceUtils.releaseConnection(con, obtainDataSource());\n\t\t\t\ttxObject.setConnectionHolder(null, false);\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only considered as equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"toString\":\n\t\t\t\t\t// Allow for differentiating between the proxy and the raw Connection.\n\t\t\t\t\tStringBuilder sb = new StringBuilder(\"Transaction-aware proxy for target Connection \");\n\t\t\t\t\tif (this.target != null) {\n\t\t\t\t\t\tsb.append('[').append(this.target.toString()).append(']');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsb.append(\" from DataSource [\").append(this.targetDataSource).append(']');\n\t\t\t\t\t}\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: only close if not within a transaction.\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(this.target, this.targetDataSource);\n\t\t\t\t\tthis.closed = true;\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isClosed\":\n\t\t\t\t\treturn this.closed;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"isWrapperFor\":\n\t\t\t\t\tif (((Class<?>) args[0]).isInstance(proxy)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (this.target == null) {\n\t\t\t\tif (method.getName().equals(\"getWarnings\") || method.getName().equals(\"clearWarnings\")) {\n\t\t\t\t\t// Avoid creation of target Connection on pre-close cleanup (e.g. Hibernate Session)\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tthrow new SQLException(\"Connection handle already closed\");\n\t\t\t\t}\n\t\t\t\tif (shouldObtainFixedConnection(this.targetDataSource)) {\n\t\t\t\t\tthis.target = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConnection actualTarget = this.target;\n\t\t\tif (actualTarget == null) {\n\t\t\t\tactualTarget = DataSourceUtils.doGetConnection(this.targetDataSource);\n\t\t\t}\n\n\t\t\tif (method.getName().equals(\"getTargetConnection\")) {\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\treturn actualTarget;\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(actualTarget, args);\n\n\t\t\t\t// If return value is a Statement, apply transaction timeout.\n\t\t\t\t// Applies to createStatement, prepareStatement, prepareCall.\n\t\t\t\tif (retVal instanceof Statement statement) {\n\t\t\t\t\tDataSourceUtils.applyTransactionTimeout(statement, this.targetDataSource);\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (actualTarget != this.target) {\n\t\t\t\t\tDataSourceUtils.doReleaseConnection(actualTarget, this.targetDataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#prepareTransactionalConnection(con,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@code Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement\n\t * if the {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true}\n\t * and the transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional JDBC Connection\n\t * @param definition the current transaction definition\n\t * @throws SQLException if thrown by JDBC API\n\t * @since 4.3.7\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)",
    "source_code": "\tprotected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)\n\t\t\tthrows SQLException {\n\n\t\tif (isEnforceReadOnly() && definition.isReadOnly()) {\n\t\t\ttry (Statement stmt = con.createStatement()) {\n\t\t\t\tstmt.executeUpdate(\"SET TRANSACTION READ ONLY\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#setConnectionHolder(connectionHolder,newConnectionHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionHolder",
      "newConnectionHolder"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "void",
    "signature": "public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder)",
    "source_code": "\t\tpublic void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder) {\n\t\t\tsuper.setConnectionHolder(connectionHolder);\n\t\t\tthis.newConnectionHolder = newConnectionHolder;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#translateException(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given JDBC commit/rollback exception to a common Spring\n\t * exception to propagate from the {@link #commit}/{@link #rollback} call.\n\t * <p>The default implementation throws a {@link TransactionSystemException}.\n\t * Subclasses may specifically identify concurrency failures etc.\n\t * @param task the task description (commit or rollback)\n\t * @param ex the SQLException thrown from commit/rollback\n\t * @return the translated exception to throw, either a\n\t * {@link org.springframework.dao.DataAccessException} or a\n\t * {@link org.springframework.transaction.TransactionException}\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, SQLException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, SQLException ex) {\n\t\treturn new TransactionSystemException(task + \" failed\", ex);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script using default settings for statement\n\t * separators, comment delimiters, and exception handling flags.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #DEFAULT_COMMENT_PREFIX\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource) throws ScriptException {\n\t\texecuteSqlScript(connection, resource, false, false, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefix,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefix the prefix that identifies single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefix",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\texecuteSqlScript(connection, resource, continueOnError, ignoreFailedDrops,\n\t\t\t\tnew String[] { commentPrefix }, separator, blockCommentStartDelimiter,\n\t\t\t\tblockCommentEndDelimiter);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefixes,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefixes the prefixes that identify single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @since 5.2\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefixes",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing SQL script from \" + resource);\n\t\t\t}\n\t\t\tlong startTime = System.currentTimeMillis();\n\n\t\t\tString script;\n\t\t\ttry {\n\t\t\t\tscript = readScript(resource, separator, commentPrefixes, blockCommentEndDelimiter);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new CannotReadScriptException(resource, ex);\n\t\t\t}\n\n\t\t\tif (separator == null) {\n\t\t\t\tseparator = DEFAULT_STATEMENT_SEPARATOR;\n\t\t\t}\n\t\t\tif (!EOF_STATEMENT_SEPARATOR.equals(separator) &&\n\t\t\t\t\t!containsStatementSeparator(resource, script, separator, commentPrefixes,\n\t\t\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter)) {\n\t\t\t\tseparator = FALLBACK_STATEMENT_SEPARATOR;\n\t\t\t}\n\n\t\t\tList<String> statements = new ArrayList<>();\n\t\t\tsplitSqlScript(resource, script, separator, commentPrefixes, blockCommentStartDelimiter,\n\t\t\t\t\tblockCommentEndDelimiter, statements);\n\n\t\t\tint stmtNumber = 0;\n\t\t\tStatement stmt = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tfor (String statement : statements) {\n\t\t\t\t\tstmtNumber++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstmt.execute(statement);\n\t\t\t\t\t\tint rowsAffected = stmt.getUpdateCount();\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(rowsAffected + \" returned as update count for SQL: \" + statement);\n\t\t\t\t\t\t\tSQLWarning warningToLog = stmt.getWarnings();\n\t\t\t\t\t\t\twhile (warningToLog != null) {\n\t\t\t\t\t\t\t\tlogger.debug(\"SQLWarning ignored: SQL state '\" + warningToLog.getSQLState() +\n\t\t\t\t\t\t\t\t\t\t\"', error code '\" + warningToLog.getErrorCode() +\n\t\t\t\t\t\t\t\t\t\t\"', message [\" + warningToLog.getMessage() + \"]\");\n\t\t\t\t\t\t\t\twarningToLog = warningToLog.getNextWarning();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t\tboolean dropStatement = StringUtils.startsWithIgnoreCase(statement.trim(), \"drop\");\n\t\t\t\t\t\tif (continueOnError || (dropStatement && ignoreFailedDrops)) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(ScriptStatementFailedException.buildErrorMessage(statement, stmtNumber, resource), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new ScriptStatementFailedException(statement, stmtNumber, resource, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.trace(\"Could not close JDBC Statement\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executed SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof ScriptException scriptException) {\n\t\t\t\tthrow scriptException;\n\t\t\t}\n\t\t\tthrow new UncategorizedScriptException(\n\t\t\t\t\"Failed to execute database script from resource [\" + resource + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString[] commentPrefixes = (commentPrefix != null) ? new String[] { commentPrefix } : null;\n\t\treturn readScript(lineNumberReader, commentPrefixes, separator, blockCommentEndDelimiter);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString currentStatement = lineNumberReader.readLine();\n\t\tStringBuilder scriptBuilder = new StringBuilder();\n\t\twhile (currentStatement != null) {\n\t\t\tif ((blockCommentEndDelimiter != null && currentStatement.contains(blockCommentEndDelimiter)) ||\n\t\t\t\t(commentPrefixes != null && !startsWithAny(currentStatement, commentPrefixes, 0))) {\n\t\t\t\tif (scriptBuilder.length() > 0) {\n\t\t\t\t\tscriptBuilder.append('\\n');\n\t\t\t\t}\n\t\t\t\tscriptBuilder.append(currentStatement);\n\t\t\t}\n\t\t\tcurrentStatement = lineNumberReader.readLine();\n\t\t}\n\t\tappendSeparatorToScriptIfNecessary(scriptBuilder, separator);\n\t\treturn scriptBuilder.toString();\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(commentPrefix, \"'commentPrefix' must not be null or empty\");\n\t\tsplitSqlScript(resource, script, separator, new String[] { commentPrefix },\n\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter, statements);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(script, \"'script' must not be null or empty\");\n\t\tAssert.notNull(separator, \"'separator' must not be null\");\n\t\tAssert.notEmpty(commentPrefixes, \"'commentPrefixes' must not be null or empty\");\n\t\tfor (String commentPrefix : commentPrefixes) {\n\t\t\tAssert.hasText(commentPrefix, \"'commentPrefixes' must not contain null or empty elements\");\n\t\t}\n\t\tAssert.hasText(blockCommentStartDelimiter, \"'blockCommentStartDelimiter' must not be null or empty\");\n\t\tAssert.hasText(blockCommentEndDelimiter, \"'blockCommentEndDelimiter' must not be null or empty\");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean inSingleQuote = false;\n\t\tboolean inDoubleQuote = false;\n\t\tboolean inEscape = false;\n\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = script.charAt(i);\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inDoubleQuote && (c == '\\'')) {\n\t\t\t\tinSingleQuote = !inSingleQuote;\n\t\t\t}\n\t\t\telse if (!inSingleQuote && (c == '\"')) {\n\t\t\t\tinDoubleQuote = !inDoubleQuote;\n\t\t\t}\n\t\t\tif (!inSingleQuote && !inDoubleQuote) {\n\t\t\t\tif (script.startsWith(separator, i)) {\n\t\t\t\t\t// We've reached the end of the current statement\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\tstatements.add(sb.toString());\n\t\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\t}\n\t\t\t\t\ti += separator.length() - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (startsWithAny(script, commentPrefixes, i)) {\n\t\t\t\t\t// Skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf('\\n', i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// If there's no EOL, we must be at the end of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentStartDelimiter, i)) {\n\t\t\t\t\t// Skip over any block comments\n\t\t\t\t\tint indexOfCommentEnd = script.indexOf(blockCommentEndDelimiter, i);\n\t\t\t\t\tif (indexOfCommentEnd > i) {\n\t\t\t\t\t\ti = indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptParseException(\n\t\t\t\t\t\t\t\t\"Missing block comment end delimiter: \" + blockCommentEndDelimiter, resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t') {\n\t\t\t\t\t// Avoid multiple adjacent whitespace characters\n\t\t\t\t\tif (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\n\t\tif (StringUtils.hasText(sb)) {\n\t\t\tstatements.add(sb.toString());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(script,separator,statements)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#mapRow(rs,rowNum)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation of this method extracts a single value from the\n\t * single row returned by the function. If there are a different number\n\t * of rows returned, this is treated as an error.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\treturn this.rowMapper.mapRow(rs, rowNum);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getListenerMethodName(originalMessage,extractedMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the listener method that is supposed to\n\t * handle the given message.\n\t * <p>The default implementation simply returns the configured\n\t * default listener method, if any.\n\t * @param originalMessage the JMS request message\n\t * @param extractedMessage the converted JMS request message,\n\t * to be passed into the listener method as argument\n\t * @return the name of the listener method (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setDefaultListenerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "originalMessage",
      "extractedMessage"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getListenerMethodName(Message originalMessage, Object extractedMessage)",
    "source_code": "\tprotected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws JMSException {\n\t\treturn getDefaultListenerMethod();\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#invokeListenerMethod(methodName,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener method.\n\t * @param methodName the name of the listener method\n\t * @param arguments the message arguments to be passed in\n\t * @return the result returned from the listener method\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #getListenerMethodName\n\t * @see #buildListenerArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Object",
    "signature": "protected Object invokeListenerMethod(String methodName, Object[] arguments)",
    "source_code": "\tprotected Object invokeListenerMethod(String methodName, Object[] arguments) throws JMSException {\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(getDelegate());\n\t\t\tmethodInvoker.setTargetMethod(methodName);\n\t\t\tmethodInvoker.setArguments(arguments);\n\t\t\tmethodInvoker.prepare();\n\t\t\treturn methodInvoker.invoke();\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof JMSException jmsException) {\n\t\t\t\tthrow jmsException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ListenerExecutionFailedException(\n\t\t\t\t\t\t\"Listener method '\" + methodName + \"' threw exception\", targetEx);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Failed to invoke target method '\" + methodName +\n\t\t\t\t\t\"' with arguments \" + ObjectUtils.nullSafeToString(arguments), ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#onMessage(jmsMessage,session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsMessage",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session)",
    "source_code": "\tpublic void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session) throws JMSException {\n\t\tMessage<?> message = toMessagingMessage(jmsMessage);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing [\" + message + \"]\");\n\t\t}\n\t\tObject result = invokeHandler(jmsMessage, session, message);\n\t\tif (result != null) {\n\t\t\thandleResult(result, jmsMessage, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#forward(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void forward(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void forward(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.state(!response.isCommitted(), \"Cannot perform forward - response is already committed\");\n\t\tgetMockHttpServletResponse(response).setForwardedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: forwarding to [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#include(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void include(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void include(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tgetMockHttpServletResponse(response).addIncludedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: including [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#write(value,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void write(char[] value, int offset, int length)",
    "source_code": "\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetTargetWriter().write(value, offset, length);\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestExecution(testInstance,testMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>immediately after</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called before framework-specific\n\t * <em>after</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * order in which they were registered.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the\n\t * test method or by a TestExecutionListener, or {@code null} if none\n\t * was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "void",
    "signature": "public void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestExecution\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestExecutionException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestExecutionException == null) {\n\t\t\t\t\tafterTestExecutionException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestExecutionException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestExecutionException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestExecutionException);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestMethod(testInstance,testMethod,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>after</em> execution of <em>after</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * tearing down test fixtures, ending a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately after\n\t * framework-specific <em>after</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * For historical reasons, this method is named {@code afterTestMethod}. Since\n\t * the introduction of {@link #afterTestExecution}, a more suitable name for\n\t * this method might be something like {@code afterTestTearDown} or\n\t * {@code afterEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the test\n\t * method or by a TestExecutionListener, or {@code null} if none was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #beforeTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\tString callbackName = \"afterTestMethod\";\n\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\tThrowable afterTestMethodException = null;\n\n\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t// \"wrapper\"-style execution of listeners.\n\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.afterTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\tif (afterTestMethodException == null) {\n\t\t\t\t\tafterTestMethodException = ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tafterTestMethodException.addSuppressed(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (afterTestMethodException != null) {\n\t\t\tReflectionUtils.rethrowException(afterTestMethodException);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestExecution(testInstance,testMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>immediately before</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called after framework-specific\n\t * <em>before</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "public void beforeTestExecution(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestExecution\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestExecution(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestMethod(testInstance,testMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>before</em> execution of <em>before</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * setting up test fixtures, starting a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately prior to\n\t * framework-specific <em>before</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * For historical reasons, this method is named {@code beforeTestMethod}. Since\n\t * the introduction of {@link #beforeTestExecution}, a more suitable name for\n\t * this method might be something like {@code beforeTestSetUp} or\n\t * {@code beforeEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void beforeTestMethod(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestMethod(Object testInstance, Method testMethod) throws Exception {\n\t\tString callbackName = \"beforeTestMethod\";\n\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\ttry {\n\t\t\t\ttestExecutionListener.beforeTestMethod(getTestContext());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#put(key,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void put(MergedContextConfiguration key, ApplicationContext context)",
    "source_code": "\tpublic void put(MergedContextConfiguration key, ApplicationContext context) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tAssert.notNull(context, \"ApplicationContext must not be null\");\n\n\t\tthis.contextMap.put(key, context);\n\t\tMergedContextConfiguration child = key;\n\t\tMergedContextConfiguration parent = child.getParent();\n\t\twhile (parent != null) {\n\t\t\tSet<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>());\n\t\t\tlist.add(child);\n\t\t\tchild = parent;\n\t\t\tparent = child.getParent();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#remove(key,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\n\t\t// startKey is the level at which to begin clearing the cache,\n\t\t// depending on the configured hierarchy mode.s\n\t\tMergedContextConfiguration startKey = key;\n\t\tif (hierarchyMode == HierarchyMode.EXHAUSTIVE) {\n\t\t\tMergedContextConfiguration parent = startKey.getParent();\n\t\t\twhile (parent != null) {\n\t\t\t\tstartKey = parent;\n\t\t\t\tparent = startKey.getParent();\n\t\t\t}\n\t\t}\n\n\t\tList<MergedContextConfiguration> removedContexts = new ArrayList<>();\n\t\tremove(removedContexts, startKey);\n\n\t\t// Remove all remaining references to any removed contexts from the\n\t\t// hierarchy map.\n\t\tfor (MergedContextConfiguration currentKey : removedContexts) {\n\t\t\tfor (Set<MergedContextConfiguration> children : this.hierarchyMap.values()) {\n\t\t\t\tchildren.remove(currentKey);\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty entries from the hierarchy map.\n\t\tfor (Map.Entry<MergedContextConfiguration, Set<MergedContextConfiguration>> entry : this.hierarchyMap.entrySet()) {\n\t\t\tif (entry.getValue().isEmpty()) {\n\t\t\t\tthis.hierarchyMap.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#removeEldestEntry(Map.Entry<MergedContextConfiguration,eldest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<MergedContextConfiguration",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {\n\t\t\tif (this.size() > DefaultContextCache.this.getMaxSize()) {\n\t\t\t\t// Do NOT delete \"DefaultContextCache.this.\"; otherwise, we accidentally\n\t\t\t\t// invoke java.util.Map.remove(Object, Object).\n\t\t\t\tDefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL);\n\t\t\t}\n\n\t\t\t// Return false since we invoke a custom eviction algorithm.\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#evaluateAnnotation(annotationType,Function<A,expressionExtractor,Function<A,reasonExtractor,Function<A,loadContextExtractor,enabledOnTrue,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the expression configured via the supplied annotation type on\n\t * the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.\n\t * @param annotationType the type of annotation to process\n\t * @param expressionExtractor a function that extracts the expression from\n\t * the annotation\n\t * @param reasonExtractor a function that extracts the reason from the\n\t * annotation\n\t * @param loadContextExtractor a function that extracts the {@code loadContext}\n\t * flag from the annotation\n\t * @param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}\n\t * should be {@link ConditionEvaluationResult#enabled enabled} if the expression\n\t * evaluates to {@code true}\n\t * @param context the {@code ExtensionContext}\n\t * @return {@link ConditionEvaluationResult#enabled enabled} if the container\n\t * or test should be enabled; otherwise {@link ConditionEvaluationResult#disabled disabled}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "Function<A",
      "expressionExtractor",
      "Function<A",
      "reasonExtractor",
      "Function<A",
      "loadContextExtractor",
      "enabledOnTrue",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "ConditionEvaluationResult",
    "signature": "protected ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context)",
    "source_code": "\tprotected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {\n\n\t\tAssert.state(context.getElement().isPresent(), \"No AnnotatedElement\");\n\t\tAnnotatedElement element = context.getElement().get();\n\t\tOptional<A> annotation = findMergedAnnotation(element, annotationType);\n\n\t\tif (annotation.isEmpty()) {\n\t\t\tString reason = String.format(\"%s is enabled since @%s is not present\", element,\n\t\t\t\t\tannotationType.getSimpleName());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(reason);\n\t\t\t}\n\t\t\treturn ConditionEvaluationResult.enabled(reason);\n\t\t}\n\n\t\tString expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)\n\t\t\t\t.orElseThrow(() -> new IllegalStateException(String.format(\n\t\t\t\t\t\t\"The expression in @%s on [%s] must not be blank\", annotationType.getSimpleName(), element)));\n\n\t\tboolean loadContext = loadContextExtractor.apply(annotation.get());\n\t\tboolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context);\n\t\tConditionEvaluationResult result;\n\n\t\tif (evaluatedToTrue) {\n\t\t\tString adjective = (enabledOnTrue ? \"enabled\" : \"disabled\");\n\t\t\tString reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(\n\t\t\t\t\t() -> String.format(\"%s is %s because @%s(\\\"%s\\\") evaluated to true\", element, adjective,\n\t\t\t\t\t\tannotationType.getSimpleName(), expression));\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(reason);\n\t\t\t}\n\t\t\tresult = (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)\n\t\t\t\t\t: ConditionEvaluationResult.disabled(reason));\n\t\t}\n\t\telse {\n\t\t\tString adjective = (enabledOnTrue ? \"disabled\" : \"enabled\");\n\t\t\tString reason = String.format(\"%s is %s because @%s(\\\"%s\\\") did not evaluate to true\",\n\t\t\t\t\telement, adjective, annotationType.getSimpleName(), expression);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(reason);\n\t\t\t}\n\t\t\tresult = (enabledOnTrue ? ConditionEvaluationResult.disabled(reason) :\n\t\t\t\t\tConditionEvaluationResult.enabled(reason));\n\t\t}\n\n\t\t// If we eagerly loaded the ApplicationContext to evaluate SpEL expressions\n\t\t// and the test class ends up being disabled, we have to check if the\n\t\t// user asked for the ApplicationContext to be closed via @DirtiesContext,\n\t\t// since the DirtiesContextTestExecutionListener will never be invoked for\n\t\t// a disabled test class.\n\t\t// See https://github.com/spring-projects/spring-framework/issues/26694\n\t\tif (loadContext && result.isDisabled() && element instanceof Class<?> testClass) {\n\t\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\t\tif (dirtiesContext != null) {\n\t\t\t\tHierarchyMode hierarchyMode = dirtiesContext.hierarchyMode();\n\t\t\t\tSpringExtension.getTestContextManager(context).getTestContext().markApplicationContextDirty(hierarchyMode);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(constructor,testClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the constructor is autowirable\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(constructor, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(constructor,testClass,fallbackPropertyProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t *\n\t * <p>A constructor is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t *\n\t * <ol>\n\t * <li>The constructor is annotated with {@link Autowired @Autowired}.</li>\n\t * <li>{@link TestConstructor @TestConstructor} is <em>present</em> or\n\t * <em>meta-present</em> on the test class with\n\t * {@link TestConstructor#autowireMode() autowireMode} set to\n\t * {@link AutowireMode#ALL ALL}.</li>\n\t * <li>The default <em>test constructor autowire mode</em> has been set to\n\t * {@code ALL} in {@link SpringProperties} or in the supplied fallback\n\t * {@link PropertyProvider} (see\n\t * {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}).</li>\n\t * </ol>\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for the default <em>test constructor autowire mode</em> if no\n\t * such value is found in {@link SpringProperties}\n\t * @return {@code true} if the constructor is autowirable\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\t// Is the constructor annotated with @Autowired?\n\t\tif (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tAutowireMode autowireMode = null;\n\n\t\t// Is the test class annotated with @TestConstructor?\n\t\tTestConstructor testConstructor = TestContextAnnotationUtils.findMergedAnnotation(testClass, TestConstructor.class);\n\t\tif (testConstructor != null) {\n\t\t\tautowireMode = testConstructor.autowireMode();\n\t\t}\n\t\telse {\n\t\t\t// Custom global default from SpringProperties?\n\t\t\tString value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\tautowireMode = AutowireMode.from(value);\n\n\t\t\t// Use fallback provider?\n\t\t\tif (autowireMode == null && fallbackPropertyProvider != null) {\n\t\t\t\tvalue = fallbackPropertyProvider.get(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\t\tautowireMode = AutowireMode.from(value);\n\t\t\t}\n\t\t}\n\n\t\treturn (autowireMode == AutowireMode.ALL);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(executable,testClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Executable, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @see #isAutowirableConstructor(Executable, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(executable, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(executable,testClass,fallbackPropertyProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * if the supplied executable is a constructor and otherwise returns {@code false}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}\n\t * if no such value is found in {@link SpringProperties}\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @since 5.3\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\treturn (executable instanceof Constructor<?> constructor &&\n\t\t\t\tisAutowirableConstructor(constructor, testClass, fallbackPropertyProvider));\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formData(MultiValueMap<String,expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as form data and compare to the given {@code MultiValueMap}.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formData(MultiValueMap<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formData(MultiValueMap<String, String> expected) {\n\t\treturn formData(expected, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formDataContains(Map<String,expected)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formData(MultiValueMap)} that matches the given subset\n\t * of expected form parameters.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formDataContains(Map<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formDataContains(Map<String, String> expected) {\n\t\tMultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>(expected.size());\n\t\texpected.forEach(multiValueMap::add);\n\t\treturn formData(multiValueMap, false);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,strict)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, boolean strict)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tthis.jsonHelper.assertJsonEqual(expectedJsonContent, mockRequest.getBodyAsString(), strict);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartData(MultiValueMap<String,expectedMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as multipart data and assert it contains exactly the\n\t * values from the given {@code MultiValueMap}. Values may be of type:\n\t * <ul>\n\t * <li>{@code String} - form field\n\t * <li>{@link Resource} - content from a file\n\t * <li>{@code byte[]} - other raw content\n\t * </ul>\n\t * <p><strong>Note:</strong> This method uses the Apache Commons FileUpload\n\t * library to parse the multipart data and it must be on the test classpath.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap) {\n\t\treturn multipartData(expectedMap, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartDataContains(Map<String,expectedMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} that does the same but\n\t * only for a subset of the actual values.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartDataContains(Map<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartDataContains(Map<String, ?> expectedMap) {\n\t\tMultiValueMap<String, Object> map = new LinkedMultiValueMap<>(expectedMap.size());\n\t\texpectedMap.forEach(map::add);\n\t\treturn multipartData(map, false);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tAtomicReference<WiretapClientHttpRequest> requestRef = new AtomicReference<>();\n\n\t\treturn this.delegate\n\t\t\t\t.connect(method, uri, request -> {\n\t\t\t\t\tWiretapClientHttpRequest wrapped = new WiretapClientHttpRequest(request);\n\t\t\t\t\trequestRef.set(wrapped);\n\t\t\t\t\treturn requestCallback.apply(wrapped);\n\t\t\t\t})\n\t\t\t\t.map(response ->  {\n\t\t\t\t\tWiretapClientHttpRequest wrappedRequest = requestRef.get();\n\t\t\t\t\tString header = WebTestClient.WEBTESTCLIENT_REQUEST_ID;\n\t\t\t\t\tString requestId = wrappedRequest.getHeaders().getFirst(header);\n\t\t\t\t\tAssert.state(requestId != null, () -> \"No \\\"\" + header + \"\\\" header\");\n\t\t\t\t\tWiretapClientHttpResponse wrappedResponse = new WiretapClientHttpResponse(response);\n\t\t\t\t\tthis.exchanges.put(requestId, new ClientExchangeInfo(wrappedRequest, wrappedResponse));\n\t\t\t\t\treturn wrappedResponse;\n\t\t\t\t});\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,result,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "result",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value) {\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,task,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "task",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, Callable<T> task, Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, Callable<T> task, Object value) {\n\t\t\t\t\t\t// We got the result, must also wait for the dispatch\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\tModelAndView mav = super.processHandlerException(request, response, handler, ex);\n\n\t\t// We got this far, exception was processed..\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setResolvedException(ex);\n\t\tmvcResult.setModelAndView(mav);\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#render(mv,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setModelAndView(mv);\n\t\tsuper.render(mv, request, response);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#service(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tregisterAsyncResultInterceptors(request);\n\n\t\tsuper.service(request, response);\n\n\t\tif (request.getAsyncContext() != null) {\n\t\t\tMockAsyncContext asyncContext;\n\t\t\tif (request.getAsyncContext() instanceof MockAsyncContext mockAsyncContext) {\n\t\t\t\tasyncContext = mockAsyncContext;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMockHttpServletRequest mockRequest = WebUtils.getNativeRequest(request, MockHttpServletRequest.class);\n\t\t\t\tAssert.notNull(mockRequest, \"Expected MockHttpServletRequest\");\n\t\t\t\tasyncContext = (MockAsyncContext) mockRequest.getAsyncContext();\n\t\t\t\tString requestClassName = request.getClass().getName();\n\t\t\t\tAssert.notNull(asyncContext, () ->\n\t\t\t\t\t\t\"Outer request wrapper \" + requestClassName + \" has an AsyncContext,\" +\n\t\t\t\t\t\t\t\t\"but it is not a MockAsyncContext, while the nested \" +\n\t\t\t\t\t\t\t\tmockRequest.getClass().getName() + \" does not have an AsyncContext at all.\");\n\t\t\t}\n\n\t\t\tCountDownLatch dispatchLatch = new CountDownLatch(1);\n\t\t\tasyncContext.addDispatchHandler(dispatchLatch::countDown);\n\t\t\tgetMvcResult(request).setAsyncDispatchLatch(dispatchLatch);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(\n\t\t\tHttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tRequestBuilder requestBuilder = adaptRequest(method, uri, requestCallback);\n\t\ttry {\n\t\t\tMvcResult mvcResult = this.mockMvc.perform(requestBuilder).andReturn();\n\t\t\tif (mvcResult.getRequest().isAsyncStarted()) {\n\t\t\t\tmvcResult.getAsyncResult();\n\t\t\t\tmvcResult = this.mockMvc.perform(asyncDispatch(mvcResult)).andReturn();\n\t\t\t}\n\t\t\treturn Mono.just(adaptResponse(mvcResult));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value with the given Hamcrest {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> ResultMatcher attribute(String name, Matcher<? super T> matcher) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertThat(\"Model attribute '\" + name + \"'\", (T) mav.getModel().get(name), matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ResultMatcher attribute(String name, @Nullable Object value) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertEquals(\"Model attribute '\" + name + \"'\", value, mav.getModel().get(name));\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeErrorCount(name,expectedCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeErrorCount(String name, int expectedCount)",
    "source_code": "\tpublic ResultMatcher attributeErrorCount(String name, int expectedCount) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tErrors errors = getBindingResult(mav, name);\n\t\t\tassertEquals(\"Binding/validation error count for attribute '\" + name + \"',\",\n\t\t\t\t\texpectedCount, errors.getErrorCount());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrorCode(name,fieldName,error)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using exact String match.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "error"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertEquals(\"Field error code\", error, code);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrorCode(name,fieldName,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using a {@link org.hamcrest.Matcher}.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher) {\n\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertThat(\"Field name '\" + fieldName + \"' of attribute '\" + name + \"'\", code, matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrors(name,fieldNames)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute field(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldNames"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrors(String name, String... fieldNames)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrors(String name, String... fieldNames) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tfor (String fieldName : fieldNames) {\n\t\t\t\tboolean hasFieldErrors = result.hasFieldErrors(fieldName);\n\t\t\t\tassertTrue(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", hasFieldErrors);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addFilter(filter,urlPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, String... urlPatterns)",
    "source_code": "\tpublic final <T extends B> T addFilter(Filter filter, String... urlPatterns) {\n\t\tAssert.notNull(filter, \"filter cannot be null\");\n\t\tAssert.notNull(urlPatterns, \"urlPatterns cannot be null\");\n\t\tif (urlPatterns.length > 0) {\n\t\t\tfilter = new PatternMappingFilterProxy(filter, urlPatterns);\n\t\t}\n\t\tthis.filters.add(filter);\n\t\treturn self();\n\t}"
  },
  "org.springframework.web.bind.<unknown>#resolveErrorMessages(messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolves messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(MultiValueMap<String,formData)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formData"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(MultiValueMap<String, String> formData)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given key-value pair as\n\t * URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * @param name the key to add to the form\n\t * @param value the value to add to the form\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(String name, String value)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(String name, String value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultFormInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartAsyncData(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given asynchronous parts,\n\t * as multipart data.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param elementClass the class contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, elementClass);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartAsyncData(name,publisher,typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #fromMultipartAsyncData(String, Publisher, Class)} that\n\t * accepts a {@link ParameterizedTypeReference} for the element type, which\n\t * allows specifying generic type information.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param typeReference the type contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, typeReference);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartData(MultiValueMap<String,multipartData)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given\n\t * {@code MultiValueMap} as multipart data. Values in the map can be an\n\t * Object or an {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param multipartData the form data to write to the output message\n\t * @return the inserter that allows adding more parts\n\t * @see MultipartBodyBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "multipartData"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData) {\n\t\tAssert.notNull(multipartData, \"'multipartData' must not be null\");\n\t\treturn new DefaultMultipartInserter().withInternal(multipartData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartData(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given parts,\n\t * as multipart data. Values in the map can be an Object or an\n\t * {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param value the part value, an Object or {@code HttpEntity}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(String name, Object value)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(String name, Object value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultMultipartInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementClass the class of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass) {\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forClass(elementClass), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementTypeRef the type of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(\n\t\t\tT producer, ParameterizedTypeReference<?> elementTypeRef) {\n\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forType(elementTypeRef), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromPublisher(publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementClass the class of elements in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, Class<T> elementClass) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forClass(elementClass), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromPublisher(publisher,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementTypeRef the type of elements contained in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, ParameterizedTypeReference<T> elementTypeRef)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, ParameterizedTypeReference<T> elementTypeRef) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forType(elementTypeRef.getType()), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#insert(outputMessage,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputMessage",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> insert(ClientHttpRequest outputMessage, Context context)",
    "source_code": "\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, HttpEntity<?>>> messageWriter =\n\t\t\t\t\tfindWriter(context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);\n\t\t\tMultiValueMap<String, HttpEntity<?>> body = this.builder.build();\n\t\t\treturn messageWriter.write(Mono.just(body), MULTIPART_DATA_TYPE,\n\t\t\t\t\tMediaType.MULTIPART_FORM_DATA, outputMessage, context.hints());\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#with(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(MultiValueMap<String, Object> values)",
    "source_code": "\t\tpublic MultipartInserter with(MultiValueMap<String, Object> values) {\n\t\t\treturn withInternal(values);\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#with(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(String key, Object value)",
    "source_code": "\t\tpublic MultipartInserter with(String key, Object value) {\n\t\t\tthis.builder.part(key, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, Class<T> elementClass)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, elementClass);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, typeReference);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyExtractor<T,extractor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 1018
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {\n\t\t\treturn this.request.body(extractor);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyExtractor<T,extractor,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 1023
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {\n\t\t\treturn this.request.body(extractor, hints);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#queryParam(name,predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's query parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the query parameter to test against\n\t * @param predicate the predicate to test against the query parameter value\n\t * @return a predicate that matches the given predicate against the query parameter of the given name\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, Predicate<String> predicate) {\n\t\treturn new QueryParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#queryParam(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name\n\t * has the given value.\n\t * @param name the name of the query parameter to test against\n\t * @param value the value of the query parameter to test against\n\t * @return a predicate that matches if the query parameter has the given value\n\t * @since 5.0.7\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, String value)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, String value) {\n\t\treturn new QueryParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#getCorsConfiguration(handler,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the CORS configuration for the given handler.\n\t * @param handler the handler to check (never {@code null})\n\t * @param exchange the current exchange\n\t * @return the CORS configuration for the handler, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tif (handler instanceof CorsConfigurationSource ccs) {\n\t\t\treturn ccs.getCorsConfiguration(exchange);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandlers(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, Object> entry : urlMap.entrySet()) {\n\t\t\t\tString url = entry.getKey();\n\t\t\t\tObject handler = entry.getValue();\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t}\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setCorsConfigurations(Map<String,corsConfigurations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the \"global\" CORS configurations based on URL patterns. By default, the\n\t * first matching URL pattern is combined with handler-level CORS configuration if any.\n\t * @see #setCorsConfigurationSource(CorsConfigurationSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tAssert.notNull(corsConfigurations, \"corsConfigurations must not be null\");\n\t\tif (!corsConfigurations.isEmpty()) {\n\t\t\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(this.patternParser);\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tthis.corsConfigurationSource = source;\n\t\t}\n\t\telse {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setUrlMap(Map<String,urlMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#registerExtension(coding,extension)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setExtensions(Map<String,extensions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#bindRequestParameters(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createRequestMappingInfo(requestMapping,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, which is either\n\t * a directly declared annotation, a meta-annotation, or the synthesized\n\t * result of merging annotation attributes within an annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tRequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n\t\t\t\t.methods(requestMapping.method())\n\t\t\t\t.params(requestMapping.params())\n\t\t\t\t.headers(requestMapping.headers())\n\t\t\t\t.consumes(requestMapping.consumes())\n\t\t\t\t.produces(requestMapping.produces())\n\t\t\t\t.mappingName(requestMapping.name());\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Predicate<Class<?>>> entry : this.pathPrefixes.entrySet()) {\n\t\t\t\tif (entry.getValue().test(handlerType)) {\n\t\t\t\t\tString prefix = entry.getKey();\n\t\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\t\tprefix = this.embeddedValueResolver.resolveStringValue(prefix);\n\t\t\t\t\t}\n\t\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getValuesToBind(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#registerMapping(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgument(parameter,context,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgumentValue(methodParameter,context,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter methodParameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Object resolveArgumentValue(\n\t\t\tMethodParameter methodParameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tClass<?> paramType = methodParameter.getParameterType();\n\t\tif (ServerWebExchange.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange;\n\t\t}\n\t\telse if (ServerHttpRequest.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getRequest();\n\t\t}\n\t\telse if (ServerHttpResponse.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getResponse();\n\t\t}\n\t\telse if (HttpMethod.class == paramType) {\n\t\t\treturn exchange.getRequest().getMethod();\n\t\t}\n\t\telse if (Locale.class == paramType) {\n\t\t\treturn exchange.getLocaleContext().getLocale();\n\t\t}\n\t\telse if (TimeZone.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone : TimeZone.getDefault());\n\t\t}\n\t\telse if (ZoneId.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault());\n\t\t}\n\t\telse if (UriBuilder.class == paramType || UriComponentsBuilder.class == paramType) {\n\t\t\tURI uri = exchange.getRequest().getURI();\n\t\t\tString contextPath = exchange.getRequest().getPath().contextPath().value();\n\t\t\treturn UriComponentsBuilder.fromUri(uri).replacePath(contextPath).replaceQuery(null);\n\t\t}\n\t\telse {\n\t\t\t// should never happen...\n\t\t\tthrow new IllegalArgumentException(\"Unknown parameter type: \" +\n\t\t\t\t\tparamType + \" in method: \" + methodParameter.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#setPathPrefixes(Map<String,prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method whose controller type is matched by a corresponding\n\t * {@code Predicate} in the map. The prefix for the first matching predicate\n\t * is used, assuming the input map has predictable order.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t * @see org.springframework.web.method.HandlerTypePredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes.clear();\n\t\tprefixes.entrySet().stream()\n\t\t\t\t.filter(entry -> StringUtils.hasText(entry.getKey()))\n\t\t\t\t.forEach(entry -> this.pathPrefixes.put(entry.getKey(), entry.getValue()));\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#applyLifecycleMethods(viewName,view)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#canHandle(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link ViewResolver} can handle the supplied\n\t * view name. If not, an empty result is returned. The default implementation\n\t * checks against the configured {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#handleResult(exchange,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tMono<Object> valueMono;\n\t\tResolvableType valueType;\n\t\tReactiveAdapter adapter = getAdapter(result);\n\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Multi-value reactive types not supported in view resolution: \" + result.getReturnType());\n\t\t\t}\n\n\t\t\tvalueMono = (result.getReturnValue() != null ?\n\t\t\t\t\tMono.from(adapter.toPublisher(result.getReturnValue())) : Mono.empty());\n\n\t\t\tvalueType = (adapter.isNoValue() ? ResolvableType.forClass(Void.class) :\n\t\t\t\t\tresult.getReturnType().getGeneric());\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\tvalueType = result.getReturnType();\n\t\t}\n\n\t\treturn valueMono\n\t\t\t\t.switchIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO)\n\t\t\t\t.flatMap(returnValue -> {\n\n\t\t\t\t\tMono<List<View>> viewsMono;\n\t\t\t\t\tModel model = result.getModel();\n\t\t\t\t\tMethodParameter parameter = result.getReturnTypeSource();\n\t\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\n\t\t\t\t\tClass<?> clazz = valueType.toClass();\n\t\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\t\tclazz = returnValue.getClass();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnValue == NO_VALUE || clazz == void.class || clazz == Void.class) {\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tviewsMono = resolveViews(returnValue.toString(), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Rendering.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tRendering render = (Rendering) returnValue;\n\t\t\t\t\t\tHttpStatusCode status = render.status();\n\t\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texchange.getResponse().getHeaders().putAll(render.headers());\n\t\t\t\t\t\tmodel.addAllAttributes(render.modelAttributes());\n\t\t\t\t\t\tObject view = render.view();\n\t\t\t\t\t\tif (view == null) {\n\t\t\t\t\t\t\tview = getDefaultViewName(exchange);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tviewsMono = (view instanceof String viewName ? resolveViews(viewName, locale) :\n\t\t\t\t\t\t\t\tMono.just(Collections.singletonList((View) view)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (Model.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tmodel.addAllAttributes(((Model) returnValue).asMap());\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tmodel.addAllAttributes((Map<String, ?>) returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (View.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tviewsMono = Mono.just(Collections.singletonList((View) returnValue));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString name = getNameForReturnValue(parameter);\n\t\t\t\t\t\tmodel.addAttribute(name, returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\tBindingContext bindingContext = result.getBindingContext();\n\t\t\t\t\tupdateBindingResult(bindingContext, exchange);\n\t\t\t\t\treturn viewsMono.flatMap(views -> render(views, model.asMap(), bindingContext, exchange));\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#resolveViewName(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "Mono<View>",
    "signature": "public Mono<View> resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic Mono<View> resolveViewName(String viewName, Locale locale) {\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tAbstractUrlBasedView urlBasedView;\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\turlBasedView = this.redirectViewProvider.apply(redirectUrl);\n\t\t}\n\t\telse {\n\t\t\turlBasedView = createView(viewName);\n\t\t}\n\n\t\tView view = applyLifecycleMethods(viewName, urlBasedView);\n\t\ttry {\n\t\t\treturn (urlBasedView.checkResourceExists(locale) ? Mono.just(view) : Mono.empty());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#setRedirectViewProvider(Function<String,redirectViewProvider)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * URL based {@link RedirectView} provider which can be used to provide, for example,\n\t * redirect views with a custom default status code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "redirectViewProvider"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider)",
    "source_code": "\tpublic void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider) {\n\t\tthis.redirectViewProvider = redirectViewProvider;\n\t}"
  },
  "org.springframework.web.reactive.socket.server.support.<unknown>#handleRequest(exchange,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler)",
    "source_code": "\tpublic Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tHttpMethod method = request.getMethod();\n\t\tHttpHeaders headers = request.getHeaders();\n\n\t\tif (HttpMethod.GET != method) {\n\t\t\treturn Mono.error(new MethodNotAllowedException(\n\t\t\t\t\trequest.getMethod(), Collections.singleton(HttpMethod.GET)));\n\t\t}\n\n\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Upgrade' header: \" + headers);\n\t\t}\n\n\t\tList<String> connectionValue = headers.getConnection();\n\t\tif (!connectionValue.contains(\"Upgrade\") && !connectionValue.contains(\"upgrade\")) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Connection' header: \" + headers);\n\t\t}\n\n\t\tString key = headers.getFirst(SEC_WEBSOCKET_KEY);\n\t\tif (key == null) {\n\t\t\treturn handleBadRequest(exchange, \"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t}\n\n\t\tString protocol = selectProtocol(headers, handler);\n\n\t\treturn initAttributes(exchange).flatMap(attributes ->\n\t\t\t\tthis.upgradeStrategy.upgrade(exchange, handler, protocol,\n\t\t\t\t\t\t() -> createHandshakeInfo(exchange, request, protocol, attributes))\n\t\t);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Context context)",
    "source_code": "\t\tprotected ModelAndView writeToInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Context context) {\n\n\t\t\tModelAndView mav = new ModelAndView(this.name, this.statusCode());\n\t\t\tmav.addAllObjects(this.model);\n\t\t\treturn mav;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createRequestMappingInfo(requestMapping,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, which is either\n\t * a directly declared annotation, a meta-annotation, or the synthesized\n\t * result of merging annotation attributes within an annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tRequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n\t\t\t\t.methods(requestMapping.method())\n\t\t\t\t.params(requestMapping.params())\n\t\t\t\t.headers(requestMapping.headers())\n\t\t\t\t.consumes(requestMapping.consumes())\n\t\t\t\t.produces(requestMapping.produces())\n\t\t\t\t.mappingName(requestMapping.name());\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Uses method and type-level @{@link RequestMapping} annotations to create\n\t * the RequestMappingInfo.\n\t * @return the created RequestMappingInfo, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} annotation.\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tString prefix = getPathPrefix(handlerType);\n\t\t\tif (prefix != null) {\n\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#match(request,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.state(getPatternParser() == null, \"This HandlerMapping uses PathPatterns.\");\n\t\tRequestMappingInfo info = RequestMappingInfo.paths(pattern).options(this.config).build();\n\t\tRequestMappingInfo match = info.getMatchingCondition(request);\n\t\treturn (match != null && match.getPatternsCondition() != null ?\n\t\t\t\tnew RequestMatchResult(\n\t\t\t\t\t\tmatch.getPatternsCondition().getPatterns().iterator().next(),\n\t\t\t\t\t\tUrlPathHelper.getResolvedLookupPath(request),\n\t\t\t\t\t\tgetPathMatcher()) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p><strong>Note:</strong> To create the {@link RequestMappingInfo},\n\t * please use {@link #getBuilderConfiguration()} and set the options on\n\t * {@link RequestMappingInfo.Builder#options(RequestMappingInfo.BuilderConfiguration)}\n\t * to match how this {@code HandlerMapping} is configured. This\n\t * is important for example to ensure use of\n\t * {@link org.springframework.web.util.pattern.PathPattern} or\n\t * {@link org.springframework.util.PathMatcher} based matching.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#registerMapping(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#setPathPrefixes(Map<String,prefixes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method whose controller type is matched by the corresponding\n\t * {@code Predicate}. The prefix for the first matching predicate is used.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes = (!prefixes.isEmpty() ?\n\t\t\t\tCollections.unmodifiableMap(new LinkedHashMap<>(prefixes)) :\n\t\t\t\tCollections.emptyMap());\n\t}"
  }
}