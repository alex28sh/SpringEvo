{
  "org.springframework.aop.interceptor.<unknown>#invokeUnderTrace(invocation,logger)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "logger"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Object",
    "signature": "protected Object invokeUnderTrace(MethodInvocation invocation, Log logger)",
    "source_code": "\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#replacePlaceholders(message,methodInvocation,returnValue,throwable,invocationTime)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "methodInvocation",
      "returnValue",
      "throwable",
      "invocationTime"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "protected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime)",
    "source_code": "\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {\n\n\t\tObject target = methodInvocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\tStringBuilder output = new StringBuilder();\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tswitch (match) {\n\t\t\t\tcase PLACEHOLDER_METHOD_NAME -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(methodInvocation.getMethod().getName()));\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_NAME -> {\n\t\t\t\t\tString className = getClassForLogging(target).getName();\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(className));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_SHORT_NAME -> {\n\t\t\t\t\tString shortName = ClassUtils.getShortName(getClassForLogging(target));\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(shortName));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_ARGUMENTS -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())));\n\t\t\t\tcase PLACEHOLDER_ARGUMENT_TYPES -> appendArgumentTypes(methodInvocation, matcher, output);\n\t\t\t\tcase PLACEHOLDER_RETURN_VALUE -> appendReturnValue(methodInvocation, matcher, output, returnValue);\n\t\t\t\tcase PLACEHOLDER_EXCEPTION -> {\n\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_INVOCATION_TIME -> matcher.appendReplacement(output, Long.toString(invocationTime));\n\t\t\t\tdefault -> {\n\t\t\t\t\t// Should not happen since placeholders are checked earlier.\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown placeholder [\" + match + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatcher.appendTail(output);\n\n\t\treturn output.toString();\n\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut) {\n\n\t\t\tGeneratedMethod generatedMethod = beanRegistrationCode.getMethods()\n\t\t\t\t\t.add(\"getScopedProxyInstance\", method -> {\n\t\t\t\t\t\tmethod.addJavadoc(\n\t\t\t\t\t\t\t\t\"Create the scoped proxy bean instance for '$L'.\",\n\t\t\t\t\t\t\t\tthis.registeredBean.getBeanName());\n\t\t\t\t\t\tmethod.addModifiers(Modifier.PRIVATE, Modifier.STATIC);\n\t\t\t\t\t\tmethod.returns(ScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addParameter(RegisteredBean.class,\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"$T factory = new $T()\",\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class,\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addStatement(\"factory.setTargetBeanName($S)\",\n\t\t\t\t\t\t\t\tthis.targetBeanName);\n\t\t\t\t\t\tmethod.addStatement(\n\t\t\t\t\t\t\t\t\"factory.setBeanFactory($L.getBeanFactory())\",\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"return factory\");\n\t\t\t\t\t});\n\t\t\treturn CodeBlock.of(\"$T.of($L)\", InstanceSupplier.class,\n\t\t\t\t\tgeneratedMethod.toMethodReference().toCodeBlock());\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tExecutable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tExecutable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\n\t\t\tGeneratedMethod generatedMethod = beanRegistrationCode.getMethods()\n\t\t\t\t\t.add(\"getScopedProxyInstance\", method -> {\n\t\t\t\t\t\tmethod.addJavadoc(\n\t\t\t\t\t\t\t\t\"Create the scoped proxy bean instance for '$L'.\",\n\t\t\t\t\t\t\t\tthis.registeredBean.getBeanName());\n\t\t\t\t\t\tmethod.addModifiers(Modifier.PRIVATE, Modifier.STATIC);\n\t\t\t\t\t\tmethod.returns(ScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addParameter(RegisteredBean.class,\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"$T factory = new $T()\",\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class,\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addStatement(\"factory.setTargetBeanName($S)\",\n\t\t\t\t\t\t\t\tthis.targetBeanName);\n\t\t\t\t\t\tmethod.addStatement(\n\t\t\t\t\t\t\t\t\"factory.setBeanFactory($L.getBeanFactory())\",\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"return factory\");\n\t\t\t\t\t});\n\t\t\treturn CodeBlock.of(\"$T.of($L)\", InstanceSupplier.class,\n\t\t\t\t\tgeneratedMethod.toMethodReference().toCodeBlock());\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\t\tpublic ClassName getTarget(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\t\treturn ClassName.get(this.targetBeanDefinition.getResolvableType().toClass());\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(registeredBean,constructorOrFactoryMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param constructorOrFactoryMethod the executable to use to create the bean\n\t * @return the generated code\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\tpublic CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\tregisterRuntimeHintsIfNecessary(registeredBean, constructorOrFactoryMethod);\n\t\tif (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\treturn generateCodeForConstructor(registeredBean, constructor);\n\t\t}\n\t\tif (constructorOrFactoryMethod instanceof Method method) {\n\t\t\treturn generateCodeForFactoryMethod(registeredBean, method);\n\t\t}\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"No suitable executor found for \" + registeredBean.getBeanName());\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut) {\n\t\tif (hasInstanceSupplier()) {\n\t\t\tthrow new IllegalStateException(\"Default code generation is not supported for bean definitions declaring \"\n\t\t\t\t\t+ \"an instance supplier callback: \" + this.registeredBean.getMergedBeanDefinition());\n\t\t}\n\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\tbeanRegistrationCode.getClassName(), beanRegistrationCode.getMethods(), allowDirectSupplierShortcut)\n\t\t\t\t.generateCode(this.registeredBean,this.constructorOrFactoryMethod.get());\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut) {\n\n\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\tbeanRegistrationCode.getClassName(), beanRegistrationCode.getMethods(), allowDirectSupplierShortcut)\n\t\t\t\t.generateCode(this.registeredBean, constructorOrFactoryMethod);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getTarget(registeredBean,constructorOrFactoryMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "ClassName",
    "signature": "public ClassName getTarget(RegisteredBean registeredBean,\n\t\t\tExecutable constructorOrFactoryMethod)",
    "source_code": "\tpublic ClassName getTarget(RegisteredBean registeredBean,\n\t\t\tExecutable constructorOrFactoryMethod) {\n\n\t\tClass<?> target = extractDeclaringClass(registeredBean.getBeanType(), constructorOrFactoryMethod);\n\t\twhile (target.getName().startsWith(\"java.\") && registeredBean.isInnerBean()) {\n\t\t\tRegisteredBean parent = registeredBean.getParent();\n\t\t\tAssert.state(parent != null, \"No parent available for inner bean\");\n\t\t\ttarget = parent.getBeanClass();\n\t\t}\n\t\treturn ClassName.get(target);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#await(destroyMethod,returnValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "boolean",
    "signature": "public boolean await(Method destroyMethod, Object returnValue)",
    "source_code": "\t\tpublic boolean await(Method destroyMethod, Object returnValue) throws InterruptedException {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnValue.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\t\tadapter.toPublisher(returnValue).subscribe(new DestroyMethodSubscriber(destroyMethod, latch));\n\t\t\t\tlatch.await();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#adaptCaffeineCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#adaptCaffeineCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#registerCustomCache(name,AsyncCache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#registerCustomCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#retrieve(key,valueLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\treturn (CompletableFuture<T>) getAsyncCache().get(key, (k, e) -> valueLoader.get());\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#setAsyncCacheLoader(AsyncCacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AsyncCacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#setCacheLoader(CacheLoader<Object,cacheLoader)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "CacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void setCacheLoader(CacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#setCaffeine(Caffeine<Object,caffeine)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Caffeine<Object",
      "caffeine"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void setCaffeine(Caffeine<Object, Object> caffeine)",
    "source_code": "\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#executeSynchronized(invoker,method,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invoker",
      "method",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1010
    },
    "return": "Object",
    "signature": "public Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key)",
    "source_code": "\t\tpublic Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(method.getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\t// Flux or similar\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Flux.from(adapter.toPublisher(invokeOperation(invoker))).collectList().toFuture())))\n\t\t\t\t\t\t\t.flatMap(Flux::fromIterable));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mono or similar\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Mono.from(adapter.toPublisher(invokeOperation(invoker))).toFuture())));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#findInCaches(context,cache,key)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1041
    },
    "return": "Object",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key)",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(context.getMethod().getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tCompletableFuture<?> cachedFuture = cache.retrieve(key);\n\t\t\t\tif (cachedFuture == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(cachedFuture))\n\t\t\t\t\t\t\t.flatMap(v -> (v instanceof Iterable<?> iv ? Flux.fromIterable(iv) : Flux.just(v))));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(cachedFuture));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#processCacheEvicts(contexts,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contexts",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1031
    },
    "return": "Object",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, result)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#processPutRequest(request,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "Object",
    "signature": "public Object processPutRequest(CachePutRequest request, @Nullable Object result)",
    "source_code": "\t\tpublic Object processPutRequest(CachePutRequest request, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\tFlux<?> source = Flux.from(adapter.toPublisher(result));\n\t\t\t\t\tsource.subscribe(new CachePutListSubscriber(request));\n\t\t\t\t\treturn adapter.fromPublisher(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.doOnSuccess(request::performPut).doOnError(request::performEvict));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 775
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\n\t\t\tExecutable executableToUse = proxyExecutable(generationContext.getRuntimeHints(),\n\t\t\t\t\tthis.registeredBean.resolveConstructorOrFactoryMethod());\n\t\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\t\tbeanRegistrationCode.getClassName(), beanRegistrationCode.getMethods(), allowDirectSupplierShortcut)\n\t\t\t\t\t.generateCode(this.registeredBean, executableToUse);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 771
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, Executable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode, Executable constructorOrFactoryMethod,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\t\t\tExecutable executableToUse = proxyExecutable(generationContext.getRuntimeHints(), constructorOrFactoryMethod);\n\t\t\treturn super.generateInstanceSupplierCode(generationContext, beanRegistrationCode,\n\t\t\t\t\texecutableToUse, allowDirectSupplierShortcut);\n\t\t}"
  },
  "org.springframework.core.<unknown>#forFieldAwareConstructor(ctor,parameterIndex,fieldName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * e.g. on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "parameterIndex",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 873
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName)",
    "source_code": "\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,targetType)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "T",
    "signature": "public T convert(@Nullable Object source, Class<T> targetType)",
    "source_code": "\tpublic <T> T convert(@Nullable Object source, Class<T> targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));\n\t}"
  },
  "org.springframework.core.task.support.<unknown>#execute(task,startTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isKotlinProperty(method,methodSuffix)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "methodSuffix"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "boolean",
    "signature": "public boolean isKotlinProperty(Method method, String methodSuffix)",
    "source_code": "\t\tpublic static boolean isKotlinProperty(Method method, String methodSuffix) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(method.getDeclaringClass());\n\t\t\tfor (KProperty<?> property : KClasses.getMemberProperties(kClass)) {\n\t\t\t\tif (methodSuffix.equalsIgnoreCase(property.getName()) &&\n\t\t\t\t\t\t(method.equals(ReflectJvmMapping.getJavaGetter(property)) ||\n\t\t\t\t\t\t\t\tproperty instanceof KMutableProperty<?> mutableProperty &&\n\t\t\t\t\t\t\t\t\t\tmethod.equals(ReflectJvmMapping.getJavaSetter(mutableProperty)))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\tif (!headers.isEmpty()) {\n\t\t\tthis.request.headers(httpFields -> {\n\t\t\t\theaders.forEach((headerName, headerValues) -> {\n\t\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\t\thttpFields.add(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tString contentType = null;\n\t\tif (headers.getContentType() != null) {\n\t\t\tcontentType = headers.getContentType().toString();\n\t\t}\n\t\ttry {\n\t\t\tInputStreamResponseListener responseListener = new InputStreamResponseListener();\n\t\t\tif (body != null) {\n\t\t\t\tOutputStreamRequestContent requestContent = new OutputStreamRequestContent(contentType);\n\t\t\t\tthis.request.body(requestContent)\n\t\t\t\t\t\t.send(responseListener);\n\t\t\t\ttry (OutputStream outputStream = requestContent.getOutputStream()) {\n\t\t\t\t\tbody.writeTo(StreamUtils.nonClosing(outputStream));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.request.send(responseListener);\n\t\t\t}\n\t\t\tResponse response = responseListener.get(this.readTimeout, TimeUnit.MILLISECONDS);\n\t\t\treturn new JettyClientHttpResponse(response, responseListener.getInputStream());\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\tthrow new IOException(\"Request was interrupted: \" + ex.getMessage(), ex);\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\tif (cause instanceof RuntimeException rtEx) {\n\t\t\t\tthrow rtEx;\n\t\t\t}\n\t\t\telse if (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(cause.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t\tcatch (TimeoutException ex) {\n\t\t\tthrow new IOException(\"Request timed out: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuf map(byte[] b, int off, int len) {\n\t\t\tByteBuf byteBuf = this.allocator.buffer(len);\n\t\t\tbyteBuf.writeBytes(b, off, len);\n\t\t\treturn byteBuf;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#add(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tif (!uri.isAbsolute()) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n\t\t}\n\n\t\tif (!this.httpClient.isStarted()) {\n\t\t\ttry {\n\t\t\t\tthis.httpClient.start();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t}\n\n\t\tRequest jettyRequest = this.httpClient.newRequest(uri).method(method.toString());\n\t\tJettyClientHttpRequest request = new JettyClientHttpRequest(jettyRequest, this.bufferFactory);\n\n\t\treturn requestCallback.apply(request).then(execute(request));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#set(key,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(IMMUTABLE_HEADER_ERROR);\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setAll(Map<String,values)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\tthis.chunk.retain();\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.chunk);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.codec.<unknown>#addDefaultHeaders(message,resource,contentType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\treturn Mono.defer(() -> {\n\t\t\tHttpHeaders headers = message.getHeaders();\n\t\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\t\theaders.setContentType(resourceMediaType);\n\t\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t\t// server side\n\t\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t}\n\n\t\t\tif (headers.getContentLength() < 0) {\n\t\t\t\treturn lengthOf(resource)\n\t\t\t\t\t\t.flatMap(contentLength -> {\n\t\t\t\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t\t\t\t\treturn Mono.empty();\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\t// we're relying on doOnDiscard in base class\n\t\treturn Mono.fromCallable(() -> encodeValue(value, bufferFactory, valueType, mimeType, hints)).flux();\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Encoding [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\n\t\tboolean release = true;\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(1024);\n\t\ttry {\n\t\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = initMarshaller(clazz);\n\t\t\tmarshaller.marshal(value, outputStream);\n\t\t\trelease = false;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow new EncodingException(\"Could not marshal \" + value.getClass() + \" to XML\", ex);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new CodecException(\"Invalid JAXB configuration\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (release) {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#setMarshallerProcessor(Function<Marshaller,processor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Marshaller",
      "processor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setMarshallerProcessor(Function<Marshaller, Marshaller> processor)",
    "source_code": "\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "BufferedImage",
    "signature": "public BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tImageInputStream imageInputStream = null;\n\t\tImageReader imageReader = null;\n\t\t// We cannot use try-with-resources here for the ImageInputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\timageInputStream = createImageInputStream(inputMessage.getBody());\n\t\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\t\tif (contentType == null) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"No Content-Type header\", inputMessage);\n\t\t\t}\n\t\t\tIterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(contentType.toString());\n\t\t\tif (imageReaders.hasNext()) {\n\t\t\t\timageReader = imageReaders.next();\n\t\t\t\tImageReadParam irp = imageReader.getDefaultReadParam();\n\t\t\t\tprocess(irp);\n\t\t\t\timageReader.setInput(imageInputStream, true);\n\t\t\t\treturn imageReader.read(0, irp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\"Could not find javax.imageio.ImageReader for Content-Type [\" + contentType + \"]\",\n\t\t\t\t\t\tinputMessage);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (imageReader != null) {\n\t\t\t\timageReader.dispose();\n\t\t\t}\n\t\t\tif (imageInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\timageInputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "signature_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(b,off,let)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "let"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int let)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int let) throws IOException {\n\t\t\tthis.out.write(b, off, let);\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createRequest(request,context)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)\n\t\t\tthrows IOException, URISyntaxException {\n\n\t\tif (jetty11Present) {\n\t\t\tAssert.state(getServletPath() != null, \"Servlet path is not initialized\");\n\t\t\treturn new Jetty11ServerHttpRequest(\n\t\t\t\t\trequest, context, getServletPath(), getDataBufferFactory(), getBufferSize());\n\t\t}\n\t\telse {\n\t\t\treturn super.createRequest(request, context);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.<unknown>#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tmutableHttpFields.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.<unknown>#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.<unknown>#put(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.<unknown>#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createMetaDataProvider(dataSource,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CallMetaDataProvider} based on the database meta-data.\n\t * @param dataSource the JDBC DataSource to use for retrieving meta-data\n\t * @param context the class that holds configuration and meta-data\n\t * @return instance of the CallMetaDataProvider implementation to be used\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "CallMetaDataProvider",
    "signature": "public CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context)",
    "source_code": "\tpublic static CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context) {\n\t\ttry {\n\t\t\treturn JdbcUtils.extractDatabaseMetaData(dataSource, databaseMetaData -> {\n\t\t\t\tString databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\n\t\t\t\tboolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\n\t\t\t\tif (context.isFunction()) {\n\t\t\t\t\tif (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for function calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForFunctions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for procedure calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForProcedures);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCallMetaDataProvider provider = switch (databaseProductName) {\n\t\t\t\t\tcase ORACLE -> new OracleCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase POSTGRES -> new PostgresCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DERBY -> new DerbyCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DB2 -> new Db2CallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase HANA -> new HanaCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase MS_SQL_SERVER -> new SqlServerCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase SYBASE -> new SybaseCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tdefault -> new GenericCallMetaDataProvider(databaseMetaData);\n\t\t\t\t};\n\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using \" + provider.getClass().getName());\n\t\t\t\t}\n\t\t\t\tprovider.initializeWithMetaData(databaseMetaData);\n\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\tprovider.initializeWithProcedureColumnMetaData(databaseMetaData,\n\t\t\t\t\t\t\tcontext.getCatalogName(), context.getSchemaName(), context.getProcedureName());\n\t\t\t\t}\n\t\t\t\treturn provider;\n\t\t\t});\n\t\t}\n\t\tcatch (MetaDataAccessException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Error retrieving database meta-data\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value) {\n\t\t\tif (jdbcIndex < 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid JDBC index: needs to start at 1\");\n\t\t\t}\n\t\t\tvalidateIndexedParamValue(value);\n\t\t\tint index = jdbcIndex - 1;\n\t\t\tint size = this.indexedParams.size();\n\t\t\tif (index < size) {\n\t\t\t\tthis.indexedParams.set(index, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = size; i < index; i++) {\n\t\t\t\t\tthis.indexedParams.add(null);\n\t\t\t\t}\n\t\t\t\tthis.indexedParams.add(value);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType) {\n\t\t\treturn param(jdbcIndex, new SqlParameterValue(sqlType, value));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value) {\n\t\t\tthis.namedParams.addValue(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value,sqlType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value, int sqlType) {\n\t\t\tthis.namedParams.addValue(name, value, sqlType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(Map<String, ?> paramMap)",
    "source_code": "\t\tpublic StatementSpec params(Map<String, ?> paramMap) {\n\t\t\tthis.namedParams.addValues(paramMap);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#containsSqlScriptDelimiters(script,delimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * <p>This method is intended to be used to find the string delimiting each\n\t * SQL statement &mdash; for example, a ';' character.\n\t * <p>Any occurrence of the delimiter within the script will be ignored if it\n\t * is within a <em>literal</em> block of text enclosed in single quotes\n\t * ({@code '}) or double quotes ({@code \"}), if it is escaped with a backslash\n\t * ({@code \\}), or if it is within a single-line comment or block comment.\n\t * @param script the SQL script to search within\n\t * @param delimiter the statement delimiter to search for\n\t * @see #DEFAULT_COMMENT_PREFIXES\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "boolean",
    "signature": "public boolean containsSqlScriptDelimiters(String script, String delimiter)",
    "source_code": "\tpublic static boolean containsSqlScriptDelimiters(String script, String delimiter) {\n\t\treturn containsStatementSeparator(null, script, delimiter, DEFAULT_COMMENT_PREFIXES,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#readScript(lineNumberReader,commentPrefix,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefix",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String commentPrefix,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString[] commentPrefixes = (commentPrefix != null) ? new String[] { commentPrefix } : null;\n\t\treturn readScript(lineNumberReader, commentPrefixes, separator, blockCommentEndDelimiter);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#readScript(lineNumberReader,commentPrefixes,separator,blockCommentEndDelimiter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Read a script from the provided {@code LineNumberReader}, using the supplied\n\t * comment prefixes and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning</em> with one of the comment prefixes are excluded\n\t * from the results; however, line comments anywhere else &mdash; for example,\n\t * within a statement &mdash; will be included in the results.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @param commentPrefixes the prefixes that identify comments in the SQL script\n\t * (typically \"--\")\n\t * @param separator the statement separator in the SQL script (typically \";\")\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @return a {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lineNumberReader",
      "commentPrefixes",
      "separator",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "String",
    "signature": "public String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter)",
    "source_code": "\tpublic static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,\n\t\t\t@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {\n\n\t\tString currentStatement = lineNumberReader.readLine();\n\t\tStringBuilder scriptBuilder = new StringBuilder();\n\t\twhile (currentStatement != null) {\n\t\t\tif ((blockCommentEndDelimiter != null && currentStatement.contains(blockCommentEndDelimiter)) ||\n\t\t\t\t(commentPrefixes != null && !startsWithAny(currentStatement, commentPrefixes, 0))) {\n\t\t\t\tif (scriptBuilder.length() > 0) {\n\t\t\t\t\tscriptBuilder.append('\\n');\n\t\t\t\t}\n\t\t\t\tscriptBuilder.append(currentStatement);\n\t\t\t}\n\t\t\tcurrentStatement = lineNumberReader.readLine();\n\t\t}\n\t\tappendSeparatorToScriptIfNecessary(scriptBuilder, separator);\n\t\treturn scriptBuilder.toString();\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefix,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefix the prefix that identifies SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefix",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String commentPrefix, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(commentPrefix, \"'commentPrefix' must not be null or empty\");\n\t\tsplitSqlScript(resource, script, separator, new String[] { commentPrefix },\n\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter, statements);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(resource,script,separator,commentPrefixes,blockCommentStartDelimiter,blockCommentEndDelimiter,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefixes} will be honored:\n\t * any text beginning with one of the comment prefixes and extending to the\n\t * end of the line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param commentPrefixes the prefixes that identify SQL line comments\n\t * (typically \"--\")\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @since 5.2\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "script",
      "separator",
      "commentPrefixes",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(@Nullable EncodedResource resource, String script,\n\t\t\tString separator, String[] commentPrefixes, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter, List<String> statements) throws ScriptException {\n\n\t\tAssert.hasText(script, \"'script' must not be null or empty\");\n\t\tAssert.notNull(separator, \"'separator' must not be null\");\n\t\tAssert.notEmpty(commentPrefixes, \"'commentPrefixes' must not be null or empty\");\n\t\tfor (String commentPrefix : commentPrefixes) {\n\t\t\tAssert.hasText(commentPrefix, \"'commentPrefixes' must not contain null or empty elements\");\n\t\t}\n\t\tAssert.hasText(blockCommentStartDelimiter, \"'blockCommentStartDelimiter' must not be null or empty\");\n\t\tAssert.hasText(blockCommentEndDelimiter, \"'blockCommentEndDelimiter' must not be null or empty\");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean inSingleQuote = false;\n\t\tboolean inDoubleQuote = false;\n\t\tboolean inEscape = false;\n\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = script.charAt(i);\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inDoubleQuote && (c == '\\'')) {\n\t\t\t\tinSingleQuote = !inSingleQuote;\n\t\t\t}\n\t\t\telse if (!inSingleQuote && (c == '\"')) {\n\t\t\t\tinDoubleQuote = !inDoubleQuote;\n\t\t\t}\n\t\t\tif (!inSingleQuote && !inDoubleQuote) {\n\t\t\t\tif (script.startsWith(separator, i)) {\n\t\t\t\t\t// We've reached the end of the current statement\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\tstatements.add(sb.toString());\n\t\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\t}\n\t\t\t\t\ti += separator.length() - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (startsWithAny(script, commentPrefixes, i)) {\n\t\t\t\t\t// Skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf('\\n', i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// If there's no EOL, we must be at the end of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentStartDelimiter, i)) {\n\t\t\t\t\t// Skip over any block comments\n\t\t\t\t\tint indexOfCommentEnd = script.indexOf(blockCommentEndDelimiter, i);\n\t\t\t\t\tif (indexOfCommentEnd > i) {\n\t\t\t\t\t\ti = indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptParseException(\n\t\t\t\t\t\t\t\t\"Missing block comment end delimiter: \" + blockCommentEndDelimiter, resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t') {\n\t\t\t\t\t// Avoid multiple adjacent whitespace characters\n\t\t\t\t\tif (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\n\t\tif (StringUtils.hasText(sb)) {\n\t\t\tstatements.add(sb.toString());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#splitSqlScript(script,separator,statements)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * separator string. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start</em> and <em>end</em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param separator text separating each statement\n\t * (typically a ';' or newline character)\n\t * @param statements the list that will contain the individual statements\n\t * @throws ScriptException if an error occurred while splitting the SQL script\n\t * @see #splitSqlScript(String, char, List)\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t * @deprecated as of Spring Framework 5.2.16 with no plans for replacement.\n\t * This is an internal API and will likely be removed in Spring Framework 6.0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "separator",
      "statements"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void splitSqlScript(String script, String separator, List<String> statements)",
    "source_code": "\tpublic static void splitSqlScript(String script, String separator, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, separator, DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#sendInternal(message,timeout)": {
    "change": "modifier_changed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor == null) {\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindValues(Map<String,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "GenericExecuteSpec",
    "signature": "public GenericExecuteSpec bindValues(Map<String, ?> source)",
    "source_code": "\t\tpublic GenericExecuteSpec bindValues(Map<String, ?> source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> target = new LinkedHashMap<>(this.byName);\n\t\t\tsource.forEach((name, value) -> target.put(name, resolveParameter(value)));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, target, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#constructMappedInstance(readable,itemMetadatas,tc)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemMetadatas",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#getItemValue(readable,itemIndex,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createRunnable(target,method,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method, @Nullable String qualifier)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method, @Nullable String qualifier) {\n\t\tRunnable runnable = createRunnable(target, method);\n\t\tif (runnable != null) {\n\t\t\treturn runnable;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod, qualifier, this.registrar::getObservationRegistry);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createSubscriptionRunnable(method,targetBean,scheduled,observationRegistrySupplier,subscriptionTrackerRegistry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the Scheduled infrastructure, allowing for scheduled\n\t * subscription to the publisher produced by a reactive method.\n\t * <p>Note that the reactive method is invoked once, but the resulting {@code Publisher}\n\t * is subscribed to repeatedly, once per each invocation of the {@code Runnable}.\n\t * <p>In the case of a fixed-delay configuration, the subscription inside the\n\t * {@link Runnable} is turned into a blocking call in order to maintain fixed-delay\n\t * semantics (i.e. the task blocks until completion of the Publisher, and the\n\t * delay is applied until the next iteration).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetBean",
      "scheduled",
      "observationRegistrySupplier",
      "subscriptionTrackerRegistry"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Runnable",
    "signature": "public Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry)",
    "source_code": "\tpublic static Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry) {\n\n\t\tboolean shouldBlock = (scheduled.fixedDelay() > 0 || StringUtils.hasText(scheduled.fixedDelayString()));\n\t\tPublisher<?> publisher = getPublisherFor(method, targetBean);\n\t\tSupplier<ScheduledTaskObservationContext> contextSupplier =\n\t\t\t\t() -> new ScheduledTaskObservationContext(targetBean, method);\n\t\treturn new SubscribingRunnable(publisher, shouldBlock, scheduled.scheduler(),\n\t\t\t\tsubscriptionTrackerRegistry, observationRegistrySupplier, contextSupplier);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#afterExecute(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, Throwable ex)",
    "source_code": "\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskExecutor.this.afterExecute(task, ex);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#beforeExecute(thread,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskExecutor.this.beforeExecute(thread, task);\n\t\t\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addFixedDelayTask(task,delay)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "delay"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration delay)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration delay) {\n\t\taddFixedDelayTask(new IntervalTask(task, delay));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addFixedDelayTask(task,interval)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration interval)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration interval) {\n\t\taddFixedDelayTask(new IntervalTask(task, interval));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addOneTimeTask(task,initialDelay)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered once after the given initial delay.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "initialDelay"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void addOneTimeTask(Runnable task, Duration initialDelay)",
    "source_code": "\tpublic void addOneTimeTask(Runnable task, Duration initialDelay) {\n\t\taddOneTimeTask(new OneTimeTask(task, initialDelay));\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#closeContext(mergedConfig,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(replaceIfNecessary(mergedContextConfiguration), hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#postProcessTestInstance(testInstance,context)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#prepareTestInstance}.\n\t * <p>As of Spring Framework 5.3.2, this method also validates that test\n\t * methods and test lifecycle methods are not annotated with\n\t * {@link Autowired @Autowired}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void postProcessTestInstance(Object testInstance, ExtensionContext context)",
    "source_code": "\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {\n\t\tvalidateAutowiredConfig(context);\n\t\tvalidateRecordApplicationEventsConfig(context);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.prepareTestInstance(testInstance);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#resolveParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by\n\t * retrieving the corresponding dependency from the test's {@link ApplicationContext}.\n\t * <p>Delegates to {@link ParameterResolutionDelegate#resolveDependency}.\n\t * @see #supportsParameter\n\t * @see ParameterResolutionDelegate#resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "Object",
    "signature": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tint index = parameterContext.getIndex();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tApplicationContext applicationContext = getApplicationContext(extensionContext);\n\t\treturn ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,\n\t\t\t\tapplicationContext.getAutowireCapableBeanFactory());\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#supportsParameter(parameterContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}\n\t * should be autowired from the test's {@link ApplicationContext}.\n\t * <p>A parameter is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t * <ol>\n\t * <li>The {@linkplain ParameterContext#getDeclaringExecutable() declaring\n\t * executable} is a {@link Constructor} and\n\t * {@link TestConstructorUtils#isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * returns {@code true}. Note that {@code isAutowirableConstructor()} will be\n\t * invoked with a fallback {@link PropertyProvider} that delegates its lookup\n\t * to {@link ExtensionContext#getConfigurationParameter(String)}.</li>\n\t * <li>The parameter is of type {@link ApplicationContext} or a sub-type thereof.</li>\n\t * <li>The parameter is of type {@link ApplicationEvents} or a sub-type thereof.</li>\n\t * <li>{@link ParameterResolutionDelegate#isAutowirable} returns {@code true}.</li>\n\t * </ol>\n\t * <p><strong>WARNING</strong>: If a test class {@code Constructor} is annotated\n\t * with {@code @Autowired} or automatically autowirable (see {@link TestConstructor}),\n\t * Spring will assume the responsibility for resolving all parameters in the\n\t * constructor. Consequently, no other registered {@link ParameterResolver}\n\t * will be able to resolve parameters.\n\t * @see #resolveParameter\n\t * @see TestConstructorUtils#isAutowirableConstructor(Constructor, Class)\n\t * @see ParameterResolutionDelegate#isAutowirable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tPropertyProvider junitPropertyProvider = propertyName ->\n\t\t\t\textensionContext.getConfigurationParameter(propertyName).orElse(null);\n\t\treturn (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||\n\t\t\t\tApplicationContext.class.isAssignableFrom(parameter.getType()) ||\n\t\t\t\tsupportsApplicationEvents(parameterContext) ||\n\t\t\t\tParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addInlinedPropertiesToEnvironment(context,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addInlinedPropertiesToEnvironment(environment,inlinedProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertiesFilesToEnvironment(context,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertiesFilesToEnvironment(environment,resourceLoader,locations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations) {\n\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertySourcesToEnvironment(environment, resourceLoader,\n\t\t\t\tList.of(new PropertySourceDescriptor(locations)));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertySourcesToEnvironment(context,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\taddPropertySourcesToEnvironment(context.getEnvironment(), context, descriptors);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertySourcesToEnvironment(environment,resourceLoader,descriptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(resourceLoader, \"'resourceLoader' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\tResourcePatternResolver resourcePatternResolver =\n\t\t\t\tResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tMutablePropertySources propertySources = environment.getPropertySources();\n\t\ttry {\n\t\t\tfor (PropertySourceDescriptor descriptor : descriptors) {\n\t\t\t\tif (!descriptor.locations().isEmpty()) {\n\t\t\t\t\tClass<? extends PropertySourceFactory> factoryClass = descriptor.propertySourceFactory();\n\t\t\t\t\tPropertySourceFactory factory = (factoryClass != null ?\n\t\t\t\t\t\t\tBeanUtils.instantiateClass(factoryClass) : defaultPropertySourceFactory);\n\n\t\t\t\t\tfor (String location : descriptor.locations()) {\n\t\t\t\t\t\tString resolvedLocation = environment.resolveRequiredPlaceholders(location);\n\t\t\t\t\t\tfor (Resource resource : resourcePatternResolver.getResources(resolvedLocation)) {\n\t\t\t\t\t\t\tPropertySource<?> propertySource = factory.createPropertySource(descriptor.name(),\n\t\t\t\t\t\t\t\t\tnew EncodedResource(resource, descriptor.encoding()));\n\t\t\t\t\t\t\tpropertySources.addFirst(propertySource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to add PropertySource to Environment\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\t\tpublic Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\treturn this.map.put(str, value);\n\t\t\t}\n\t\t\t// No need to invoke super.put(key, value);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#register(event,listener,callbacks)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "listener",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean register(E event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks)",
    "source_code": "\tpublic static <E extends ApplicationEvent> boolean register(\n\t\t\tE event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks) {\n\n\t\tif (org.springframework.transaction.support.TransactionSynchronizationManager.isSynchronizationActive() &&\n\t\t\t\torg.springframework.transaction.support.TransactionSynchronizationManager.isActualTransactionActive()) {\n\t\t\torg.springframework.transaction.support.TransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\tnew PlatformSynchronization<>(event, listener, callbacks));\n\t\t\treturn true;\n\t\t}\n\t\telse if (event.getSource() instanceof TransactionContext txContext) {\n\t\t\torg.springframework.transaction.reactive.TransactionSynchronizationManager rtsm =\n\t\t\t\t\tnew org.springframework.transaction.reactive.TransactionSynchronizationManager(txContext);\n\t\t\tif (rtsm.isSynchronizationActive() && rtsm.isActualTransactionActive()) {\n\t\t\t\trtsm.registerSynchronization(new ReactiveSynchronization<>(event, listener, callbacks));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#findFieldIgnoreCase(clazz,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "Field",
    "signature": "public Field findFieldIgnoreCase(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int compare(@Nullable T left, @Nullable T right)",
    "source_code": "\tpublic int compare(@Nullable T left, @Nullable T right) {\n\t\tComparator<T> comparator = this.nullsLow ? Comparator.nullsFirst(this.nonNullComparator) : Comparator.nullsLast(this.nonNullComparator);\n\t\treturn comparator.compare(left, right);\n\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(o1,o2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "int",
    "signature": "public int compare(@Nullable T o1, @Nullable T o2)",
    "source_code": "\tpublic int compare(@Nullable T o1, @Nullable T o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (o1 == null) {\n\t\t\treturn (this.nullsLow ? -1 : 1);\n\t\t}\n\t\tif (o2 == null) {\n\t\t\treturn (this.nullsLow ? 1 : -1);\n\t\t}\n\t\treturn this.nonNullComparator.compare(o1, o2);\n\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(v1,v2)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "v1",
      "v2"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "int",
    "signature": "public int compare(Boolean v1, Boolean v2)",
    "source_code": "\tpublic int compare(Boolean v1, Boolean v2) {\n\t\treturn (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#compare(result1,result2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result1",
      "result2"
    ],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "int",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#insertAsyncValidation(validatorAdapterSupplier,adaptViolations,target,method,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validatorAdapterSupplier",
      "adaptViolations",
      "target",
      "method",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "Object[]",
    "signature": "public Object[] insertAsyncValidation(Supplier<SpringValidatorAdapter> validatorAdapterSupplier, boolean adaptViolations,\n\t\t\t\tObject target, Method method, Object[] arguments)",
    "source_code": "\t\tpublic static Object[] insertAsyncValidation(\n\t\t\t\tSupplier<SpringValidatorAdapter> validatorAdapterSupplier, boolean adaptViolations,\n\t\t\t\tObject target, Method method, Object[] arguments) {\n\n\t\t\tfor (int i = 0; i < method.getParameterCount(); i++) {\n\t\t\t\tif (arguments[i] == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tClass<?> parameterType = method.getParameterTypes()[i];\n\t\t\t\tReactiveAdapter reactiveAdapter = reactiveAdapterRegistry.getAdapter(parameterType);\n\t\t\t\tif (reactiveAdapter == null || reactiveAdapter.isNoValue()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tClass<?>[] groups = determineValidationGroups(method.getParameters()[i]);\n\t\t\t\tif (groups == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSpringValidatorAdapter validatorAdapter = validatorAdapterSupplier.get();\n\t\t\t\tMethodParameter param = new MethodParameter(method, i);\n\t\t\t\targuments[i] = (reactiveAdapter.isMultiValue() ?\n\t\t\t\t\t\tFlux.from(reactiveAdapter.toPublisher(arguments[i])).doOnNext(value ->\n\t\t\t\t\t\t\t\tvalidate(validatorAdapter, adaptViolations, target, method, param, value, groups)) :\n\t\t\t\t\t\tMono.from(reactiveAdapter.toPublisher(arguments[i])).doOnNext(value ->\n\t\t\t\t\t\t\t\tvalidate(validatorAdapter, adaptViolations, target, method, param, value, groups)));\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#invokeValidatorForArguments(target,method,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForArguments(Object target, Method method, Object[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments(\n\t\t\tObject target, Method method, Object[] arguments, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\tSet<ConstraintViolation<Object>> violations;\n\t\ttry {\n\t\t\tviolations = execVal.validateParameters(target, method, arguments, groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tMethod mostSpecificMethod = ClassUtils.getMostSpecificMethod(method, target.getClass());\n\t\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(mostSpecificMethod);\n\t\t\tviolations = execVal.validateParameters(target, bridgedMethod, arguments, groups);\n\t\t}\n\t\treturn violations;\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#invokeValidatorForReturnValue(target,method,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(Object target, Method method, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(\n\t\t\tObject target, Method method, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\treturn execVal.validateReturnValue(target, method, returnValue, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#resolveName(parameter,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter parameter, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters, Object[] arguments,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForArguments(target, method, arguments, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (parameters != null ? parameters[i] : initMethodParameter(method, i)),\n\t\t\t\ti -> arguments[i]);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType, @Nullable Object returnValue,\n\t\t\tClass<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForReturnValue(target, method, returnValue, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (returnType != null ? returnType : initMethodParameter(method, -1)),\n\t\t\t\ti -> returnValue);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#errorsToStringList(errors,source,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #errorsToStringList(List)} that uses a\n\t * {@link MessageSource} to resolve the message code of the error, or fall\n\t * back on the error's default message.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "source",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "List<String>",
    "signature": "public List<String> errorsToStringList(List<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale)",
    "source_code": "\tpublic static List<String> errorsToStringList(\n\t\t\tList<? extends ObjectError> errors, @Nullable MessageSource source, Locale locale) {\n\n\t\treturn (source != null ?\n\t\t\t\terrorsToStringList(errors, error -> source.getMessage(error, locale)) :\n\t\t\t\terrorsToStringList(errors));\n\t}"
  },
  "org.springframework.web.bind.<unknown>#getDetailMessageArguments(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object[]",
    "signature": "public Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Object[] getDetailMessageArguments(MessageSource messageSource, Locale locale) {\n\t\treturn new Object[] {\n\t\t\t\terrorsToStringList(getGlobalErrors(), messageSource, locale),\n\t\t\t\terrorsToStringList(getFieldErrors(), messageSource, locale)\n\t\t};\n\t}"
  },
  "org.springframework.web.bind.<unknown>#resolveErrorMessages(messageSource,locale)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve global and field errors to messages with the given\n\t * {@link MessageSource} and {@link Locale}.\n\t * @return a Map with errors as key and resolved messages as value\n\t * @since 6.0.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "String>",
    "signature": "public String> resolveErrorMessages(MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic Map<ObjectError, String> resolveErrorMessages(MessageSource messageSource, Locale locale) {\n\t\tMap<ObjectError, String> map = new LinkedHashMap<>();\n\t\taddMessages(map, getGlobalErrors(), messageSource, locale);\n\t\taddMessages(map, getFieldErrors(), messageSource, locale);\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#createBinder(webRequest,target,objectName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)",
    "source_code": "\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, null);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#createBinder(webRequest,target,objectName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}.\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type)",
    "source_code": "\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, type);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#createBinderInstance(target,objectName,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "objectName",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "WebDataBinder",
    "signature": "protected WebDataBinder createBinderInstance(@Nullable Object target, String objectName, NativeWebRequest webRequest)",
    "source_code": "\tprotected WebDataBinder createBinderInstance(\n\t\t\t@Nullable Object target, String objectName, NativeWebRequest webRequest) throws Exception {\n\n\t\treturn new WebRequestDataBinder(target, objectName);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.bind.support.<unknown>#initBinder(dataBinder,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (e.g. with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBinder",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "protected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)",
    "source_code": "\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#resolveValue(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Object",
    "signature": "public Object resolveValue(String name, Class<?> type)",
    "source_code": "\t\tpublic Object resolveValue(String name, Class<?> type) {\n\t\t\treturn this.map.get(name);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType) {\n\t\t\tthis.body = clientHttpRequest -> writeWithMessageConverters(body, bodyType.getType(), clientHttpRequest);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(exchangeFunction,close)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction",
      "close"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "T",
    "signature": "public T exchange(ExchangeFunction<T> exchangeFunction, boolean close)",
    "source_code": "\t\tpublic <T> T exchange(ExchangeFunction<T> exchangeFunction, boolean close) {\n\t\t\treturn exchangeInternal(exchangeFunction, close);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(statusPredicate,errorHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler) {\n\t\t\tAssert.notNull(statusPredicate, \"StatusPredicate must not be null\");\n\t\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.of(statusPredicate, errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.uriString(uriTemplate)));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.method.<unknown>#checkArguments(beanType,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "boolean",
    "signature": "public boolean checkArguments(Class<?> beanType, MethodParameter[] parameters)",
    "source_code": "\t\tpublic static boolean checkArguments(Class<?> beanType, MethodParameter[] parameters) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tfor (MethodParameter parameter : parameters) {\n\t\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(parameter.getParameterAnnotations());\n\t\t\t\t\tif (merged.stream().anyMatch(CONSTRAINT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tClass<?> type = parameter.getParameterType();\n\t\t\t\t\t\tif (merged.stream().anyMatch(VALID_PREDICATE) && List.class.isAssignableFrom(type)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.<unknown>#checkReturnValue(beanType,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean checkReturnValue(Class<?> beanType, Method method)",
    "source_code": "\t\tpublic static boolean checkReturnValue(Class<?> beanType, Method method) {\n\t\t\tif (AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n\t\t\t\treturn merged.stream().anyMatch(CONSTRAINT_PREDICATE.or(VALID_PREDICATE));\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.<unknown>#formatArgumentError(param,message)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#applyArgumentValidation(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void applyArgumentValidation(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic void applyArgumentValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateArguments(target, method, parameters, arguments, groups);\n\t\tif (!result.hasErrors()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.getBeanResults().isEmpty()) {\n\t\t\tint bindingResultCount = 0;\n\t\t\tfor (ParameterErrors errors : result.getBeanResults()) {\n\t\t\t\tfor (Object arg : arguments) {\n\t\t\t\t\tif (arg instanceof BindingResult bindingResult) {\n\t\t\t\t\t\tif (bindingResult.getObjectName().equals(errors.getObjectName())) {\n\t\t\t\t\t\t\tbindingResult.addAllErrors(errors);\n\t\t\t\t\t\t\tbindingResultCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.getAllValidationResults().size() == bindingResultCount) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new HandlerMethodValidationException(\n\t\t\t\tresult, this.modelAttribitePredicate, this.requestParamPredicate);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#applyReturnValueValidation(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void applyReturnValueValidation(Object target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic void applyReturnValueValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateReturnValue(target, method, returnType, returnValue, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new HandlerMethodValidationException(result);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#bindRequestParameters(binder,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request)",
    "source_code": "\tprotected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n\t\t((WebRequestDataBinder) binder).bind(request);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#constructAttribute(ctor,attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Construct a new attribute instance with the given constructor.\n\t * <p>Called from\n\t * {@link #createAttribute(String, MethodParameter, WebDataBinderFactory, NativeWebRequest)}\n\t * after constructor resolution.\n\t * @param ctor the constructor to use\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ctor",
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "Object",
    "signature": "protected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object constructAttribute(Constructor<?> ctor, String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (ctor.getParameterCount() == 0) {\n\t\t\t// A single default constructor -> clearly a standard JavaBeans arrangement.\n\t\t\treturn BeanUtils.instantiateClass(ctor);\n\t\t}\n\n\t\t// A single data class constructor -> resolve constructor arguments from request parameters.\n\t\tString[] paramNames = BeanUtils.getParameterNames(ctor);\n\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, null, attributeName);\n\t\tString fieldDefaultPrefix = binder.getFieldDefaultPrefix();\n\t\tString fieldMarkerPrefix = binder.getFieldMarkerPrefix();\n\t\tboolean bindingFailure = false;\n\t\tSet<String> failedParams = new HashSet<>(4);\n\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString paramName = paramNames[i];\n\t\t\tClass<?> paramType = paramTypes[i];\n\t\t\tObject value = webRequest.getParameterValues(paramName);\n\n\t\t\t// Since WebRequest#getParameter exposes a single-value parameter as an array\n\t\t\t// with a single element, we unwrap the single value in such cases, analogous\n\t\t\t// to WebExchangeDataBinder.addBindValue(Map<String, Object>, String, List<?>).\n\t\t\tif (ObjectUtils.isArray(value) && Array.getLength(value) == 1) {\n\t\t\t\tvalue = Array.get(value, 0);\n\t\t\t}\n\n\t\t\tif (value == null) {\n\t\t\t\tif (fieldDefaultPrefix != null) {\n\t\t\t\t\tvalue = webRequest.getParameter(fieldDefaultPrefix + paramName);\n\t\t\t\t}\n\t\t\t\tif (value == null) {\n\t\t\t\t\tif (fieldMarkerPrefix != null && webRequest.getParameter(fieldMarkerPrefix + paramName) != null) {\n\t\t\t\t\t\tvalue = binder.getEmptyValue(paramType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = resolveConstructorArgument(paramName, paramType, webRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMethodParameter methodParam = new FieldAwareConstructorParameter(ctor, i, paramName);\n\t\t\t\tif (value == null && methodParam.isOptional()) {\n\t\t\t\t\targs[i] = (methodParam.getParameterType() == Optional.class ? Optional.empty() : null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targs[i] = binder.convertIfNecessary(value, paramType, methodParam);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tex.initPropertyName(paramName);\n\t\t\t\targs[i] = null;\n\t\t\t\tfailedParams.add(paramName);\n\t\t\t\tbinder.getBindingResult().recordFieldValue(paramName, paramType, value);\n\t\t\t\tbinder.getBindingErrorProcessor().processPropertyAccessException(ex, binder.getBindingResult());\n\t\t\t\tbindingFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (bindingFailure) {\n\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\t\tString paramName = paramNames[i];\n\t\t\t\tif (!failedParams.contains(paramName)) {\n\t\t\t\t\tObject value = args[i];\n\t\t\t\t\tresult.recordFieldValue(paramName, paramTypes[i], value);\n\t\t\t\t\tvalidateValueIfApplicable(binder, parameter, ctor.getDeclaringClass(), paramName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parameter.isOptional()) {\n\t\t\t\ttry {\n\t\t\t\t\tObject target = BeanUtils.instantiateClass(ctor, args);\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getTarget() {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcatch (BeanInstantiationException ex) {\n\t\t\t\t\t// swallow and proceed without target instance\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t}\n\n\t\ttry {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\tcatch (BeanInstantiationException ex) {\n\t\t\tif (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) &&\n\t\t\t\t\tex.getCause() instanceof NullPointerException cause) {\n\t\t\t\tBindingResult result = binder.getBindingResult();\n\t\t\t\tObjectError error = new ObjectError(ctor.getName(), cause.getMessage());\n\t\t\t\tresult.addError(error);\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#createAttribute(attributeName,parameter,binderFactory,webRequest)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the model attribute if not found in the model,\n\t * with subsequent parameter binding through bean properties (unless suppressed).\n\t * <p>The default implementation typically uses the unique public no-arg constructor\n\t * if available but also handles a \"primary constructor\" approach for data classes:\n\t * It understands the JavaBeans {@code ConstructorProperties} annotation as well as\n\t * runtime-retained parameter names in the bytecode, associating request parameters\n\t * with constructor arguments by name. If no such constructor is found, the default\n\t * constructor will be used (even if not public), assuming subsequent bean property\n\t * bindings through setter methods.\n\t * @param attributeName the name of the attribute (never {@code null})\n\t * @param parameter the method parameter declaration\n\t * @param binderFactory for creating WebDataBinder instance\n\t * @param webRequest the current request\n\t * @return the created model attribute (never {@code null})\n\t * @throws BindException in case of constructor argument binding failure\n\t * @throws Exception in case of constructor invocation failure\n\t * @see #constructAttribute(Constructor, String, MethodParameter, WebDataBinderFactory, NativeWebRequest)\n\t * @see BeanUtils#findPrimaryConstructor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "parameter",
      "binderFactory",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Object",
    "signature": "protected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest)",
    "source_code": "\tprotected Object createAttribute(String attributeName, MethodParameter parameter,\n\t\t\tWebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {\n\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\t\tClass<?> clazz = nestedParameter.getNestedParameterType();\n\n\t\tConstructor<?> ctor = BeanUtils.getResolvableConstructor(clazz);\n\t\tObject attribute = constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);\n\t\tif (parameter != nestedParameter) {\n\t\t\tattribute = Optional.of(attribute);\n\t\t}\n\t\treturn attribute;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#from(initializer,paramNameDiscoverer,modelAttribitePredicate,requestParamPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initializer",
      "paramNameDiscoverer",
      "modelAttribitePredicate",
      "requestParamPredicate"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "MethodValidator",
    "signature": "public MethodValidator from(@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate)",
    "source_code": "\tpublic static MethodValidator from(\n\t\t\t@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttribitePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tif (initializer instanceof ConfigurableWebBindingInitializer configurableInitializer) {\n\t\t\tValidator validator = getValidator(configurableInitializer);\n\t\t\tif (validator != null) {\n\t\t\t\tMethodValidationAdapter adapter = new MethodValidationAdapter(validator);\n\t\t\t\tadapter.setObjectNameResolver(objectNameResolver);\n\t\t\t\tif (paramNameDiscoverer != null) {\n\t\t\t\t\tadapter.setParameterNameDiscoverer(paramNameDiscoverer);\n\t\t\t\t}\n\t\t\t\tMessageCodesResolver codesResolver = configurableInitializer.getMessageCodesResolver();\n\t\t\t\tif (codesResolver != null) {\n\t\t\t\t\tadapter.setMessageCodesResolver(codesResolver);\n\t\t\t\t}\n\t\t\t\treturn new HandlerMethodValidator(adapter, modelAttribitePredicate, requestParamPredicate);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * <p>The default implementation delegates to {@link #isBindExceptionRequired(MethodParameter)}.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter declaration\n\t * @return {@code true} if the next method parameter is not of type {@link Errors}\n\t * @see #isBindExceptionRequired(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\treturn isBindExceptionRequired(parameter);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveConstructorArgument(paramName,paramType,request)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "paramType",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "Object",
    "signature": "public Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)",
    "source_code": "\tpublic Object resolveConstructorArgument(String paramName, Class<?> paramType, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(paramName);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\treturn (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.startsWithIgnoreCase(\n\t\t\t\trequest.getHeader(HttpHeaders.CONTENT_TYPE), MediaType.MULTIPART_FORM_DATA_VALUE)) {\n\t\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (servletRequest != null && HttpMethod.POST.matches(servletRequest.getMethod())) {\n\t\t\t\tList<Part> parts = StandardServletPartUtils.getParts(servletRequest, paramName);\n\t\t\t\tif (!parts.isEmpty()) {\n\t\t\t\t\treturn (parts.size() == 1 ? parts.get(0) : parts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveName(param,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter param, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateArguments(target,method,parameters,arguments,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateArguments(target, method, parameters, arguments, groups);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateIfApplicable(binder,parameter)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the model attribute if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @see WebDataBinder#validate(Object...)\n\t * @see SmartValidator#validate(Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateReturnValue(target, method, returnType, returnValue, groups);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateValueIfApplicable(binder,parameter,targetType,fieldName,value)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the specified candidate value if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter declaration\n\t * @param targetType the target type\n\t * @param fieldName the name of the field\n\t * @param value the candidate value\n\t * @since 5.1\n\t * @see #validateIfApplicable(WebDataBinder, MethodParameter)\n\t * @see SmartValidator#validateValue(Class, String, Object, Errors, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter",
      "targetType",
      "fieldName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "void",
    "signature": "protected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value)",
    "source_code": "\tprotected void validateValueIfApplicable(WebDataBinder binder, MethodParameter parameter,\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value) {\n\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tfor (Validator validator : binder.getValidators()) {\n\t\t\t\t\tif (validator instanceof SmartValidator smartValidator) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsmartValidator.validateValue(targetType, fieldName, value,\n\t\t\t\t\t\t\t\t\tbinder.getBindingResult(), validationHints);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t// No corresponding field on the target class...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#invokeFunction(method,target,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args) {\n\t\t\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\n\t\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t}\n\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\tint index = 0;\n\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\tcase VALUE -> {\n\t\t\t\t\t\tif (!parameter.isOptional() || args[index] != null) {\n\t\t\t\t\t\t\targMap.put(parameter, args[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function.callBy(argMap);\n\t\t}"
  },
  "org.springframework.web.reactive.<unknown>#createDataBinder(exchange,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#createDataBinder(exchange,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#createDataBinder(exchange,target,name,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(\n\t\t\tServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType) {\n\n\t\tWebExchangeDataBinder dataBinder = new ExtendedWebExchangeDataBinder(target, name);\n\t\tdataBinder.setNameResolver(new BindParamNameResolver());\n\n\t\tif (target == null && targetType != null) {\n\t\t\tdataBinder.setTargetType(targetType);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\n\t\tdataBinder = initDataBinder(dataBinder, exchange);\n\n\t\tif (this.methodValidationApplicable && targetType != null) {\n\t\t\tif (targetType.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#initBinder(binder,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(validator -> validator instanceof jakarta.validation.Validator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.<unknown>#initDataBinder(binder,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForBodyFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForBodyMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForEntityFlux(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForEntityMono(requestValues,bodyType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1149
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) {\n\t\t\treturn this.request.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#of(value,commit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "commit"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<ServerRequest> commit)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<ServerRequest> commit) {\n\t\t\t\tif (commit == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, commit);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#invokeFunction(method,target,args,isSuspendingFunction,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args",
      "isSuspendingFunction",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,\n\t\t\t\tServerWebExchange exchange) {\n\n\t\t\tif (isSuspendingFunction) {\n\t\t\t\tObject coroutineContext = exchange.getAttribute(COROUTINE_CONTEXT_ATTRIBUTE);\n\t\t\t\tif (coroutineContext == null) {\n\t\t\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(method, target, args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn CoroutinesUtils.invokeSuspendingFunction((CoroutineContext) coroutineContext, method, target, args);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\n\t\t\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n\t\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t\t}\n\t\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\t\tint index = 0;\n\t\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\t\tcase VALUE -> {\n\t\t\t\t\t\t\tif (!parameter.isOptional() || args[index] != null) {\n\t\t\t\t\t\t\t\targMap.put(parameter, args[index]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn function.callBy(argMap);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#bindRequestParameters(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to bind the request to the target object.\n\t * @param binder the data binder instance to use for the binding\n\t * @param exchange the current request\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<Void> bindRequestParameters(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.bind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, or meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tHttpExchange httpExchange, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(toStringArray(httpExchange.value())))\n\t\t\t\t.methods(toMethodArray(httpExchange.method()))\n\t\t\t\t.consumes(toStringArray(httpExchange.contentType()))\n\t\t\t\t.produces(httpExchange.accept());\n\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getValuesToBind(binder,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method to obtain the values for data binding. By default this\n\t * method delegates to {@link WebExchangeDataBinder#getValuesToBind}.\n\t * @param binder the data binder in use\n\t * @param exchange the current exchange\n\t * @return a map of bind values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object>>",
    "signature": "public Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Map<String, Object>> getValuesToBind(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder.getValuesToBind(exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleHandlerMethodValidationException(ex,headers,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(\n\t\t\tHandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMethodValidationException(ex,status,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodValidationException(MethodValidationException ex, HttpStatus status, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodValidationException(\n\t\t\tMethodValidationException ex, HttpStatus status, ServerWebExchange exchange) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Validation failed\", null, null, exchange);\n\t\treturn handleExceptionInternal(ex, body, null, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgument(parameter,context,exchange)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\tClass<?> resolvedType = type.resolve();\n\t\tReactiveAdapter adapter = (resolvedType != null ? getAdapterRegistry().getAdapter(resolvedType) : null);\n\t\tResolvableType valueType = (adapter != null ? type.getGeneric() : type);\n\n\t\tAssert.state(adapter == null || !adapter.isMultiValue(),\n\t\t\t\t() -> getClass().getSimpleName() + \" does not support multi-value reactive type wrapper: \" +\n\t\t\t\t\t\tparameter.getGenericParameterType());\n\n\t\tString name = ModelInitializer.getNameForParameter(parameter);\n\t\tMono<?> valueMono = prepareAttributeMono(name, valueType, context, exchange);\n\n\t\t// unsafe(): we're intercepting, already serialized Publisher signals\n\t\tSinks.One<BindingResult> bindingResultSink = Sinks.unsafe().one();\n\n\t\tMap<String, Object> model = context.getModel().asMap();\n\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResultSink.asMono());\n\n\t\treturn valueMono.flatMap(value -> {\n\t\t\tWebExchangeDataBinder binder = context.createDataBinder(exchange, value, name);\n\t\t\treturn (bindingDisabled(parameter) ? Mono.empty() : bindRequestParameters(binder, exchange))\n\t\t\t\t\t.doOnError(bindingResultSink::tryEmitError)\n\t\t\t\t\t.doOnSuccess(aVoid -> {\n\t\t\t\t\t\tvalidateIfApplicable(binder, parameter, exchange);\n\t\t\t\t\t\tBindingResult bindingResult = binder.getBindingResult();\n\t\t\t\t\t\tmodel.put(BindingResult.MODEL_KEY_PREFIX + name, bindingResult);\n\t\t\t\t\t\tmodel.put(name, value);\n\t\t\t\t\t\t// Ignore result: serialized and buffered (should never fail)\n\t\t\t\t\t\tbindingResultSink.tryEmitValue(bindingResult);\n\t\t\t\t\t})\n\t\t\t\t\t.then(Mono.fromCallable(() -> {\n\t\t\t\t\t\tBindingResult errors = binder.getBindingResult();\n\t\t\t\t\t\tif (adapter != null) {\n\t\t\t\t\t\t\treturn adapter.fromPublisher(errors.hasErrors() ?\n\t\t\t\t\t\t\t\t\tMono.error(new WebExchangeBindException(parameter, errors)) : valueMono);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errors.hasErrors() && !hasErrorsArgument(parameter)) {\n\t\t\t\t\t\t\t\tthrow new WebExchangeBindException(parameter, errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#asByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#indexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#lastIndexOf(predicate,fromIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onWebSocketBinary(byteBuffer,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback)",
    "source_code": "\tpublic void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.BINARY, buffer);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onWebSocketClose(statusCode,reason)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void onWebSocketClose(int statusCode, String reason)",
    "source_code": "\tpublic void onWebSocketClose(int statusCode, String reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(statusCode, reason));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onWebSocketFrame(frame,callback)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "frame",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void onWebSocketFrame(Frame frame, Callback callback)",
    "source_code": "\tpublic void onWebSocketFrame(Frame frame, Callback callback) {\n\t\tif (this.delegateSession != null) {\n\t\t\tif (OpCode.PONG == frame.getOpCode()) {\n\t\t\t\tByteBuffer byteBuffer = (frame.getPayload() != null ? frame.getPayload() : EMPTY_PAYLOAD);\n\t\t\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\t\t\tbuffer = new JettyDataBuffer(buffer, callback);\n\t\t\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.PONG, buffer);\n\t\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#read(destination,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#slice(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\treturn new JettyDataBuffer(delegateSlice, this.callback);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toByteBuffer(index,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toString(index,length,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#write(source,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(ReactorHttpExchangeAdapter client, Method method)",
    "source_code": "\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method,reactiveRegistry,blockTimeout)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method's return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method",
      "reactiveRegistry",
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(HttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout)",
    "source_code": "\t\tpublic static ResponseFunction create(\n\t\t\t\tHttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout) {\n\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = reactiveRegistry.getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::requestToVoid;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::requestToVoid;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::requestToHeaders;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::requestToBodilessEntity;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = reactiveRegistry.getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\tboolean blockForOptional = returnType.equals(Optional.class);\n\t\t\treturn new ResponseFunction(responseFunction, reactiveAdapter, blockForOptional, blockTimeout);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver)": {
    "change": "removed",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tHttpExchange annot1 = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange annot2 = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(annot2, \"Expected HttpRequest annotation\");\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(annot1, annot2);\n\t\t\tString url = initUrl(annot1, annot2, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(annot1, annot2);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(annot1, annot2);\n\n\t\t\treturn new HttpRequestValuesInitializer(httpMethod, url, contentType, acceptableMediaTypes);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver,requestValuesSupplier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver",
      "requestValuesSupplier"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange annot1 = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange annot2 = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(annot2, \"Expected HttpRequest annotation\");\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(annot1, annot2);\n\t\t\tString url = initUrl(annot1, annot2, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(annot1, annot2);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(annot1, annot2);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#invokeSuspendingFunction(invocation,httpServiceMethod)": {
    "change": "removed",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "httpServiceMethod"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(MethodInvocation invocation, HttpServiceMethod httpServiceMethod) {\n\t\t\tObject[] rawArguments = invocation.getArguments();\n\t\t\tObject[] arguments = resolveArguments(rawArguments);\n\t\t\tContinuation<Object> continuation = (Continuation<Object>) rawArguments[rawArguments.length - 1];\n\t\t\tMono<Object> wrapped = (Mono<Object>) httpServiceMethod.invoke(arguments);\n\t\t\treturn MonoKt.awaitSingleOrNull(wrapped, continuation);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\tAssert.notNull(bindType, \"BindType must not be null\");\n\t\t\tAssert.notNull(dataBinderCustomizer, \"DataBinderCustomizer must not be null\");\n\n\t\t\tServletRequestDataBinder dataBinder = new ServletRequestDataBinder(null);\n\t\t\tdataBinder.setTargetType(ResolvableType.forClass(bindType));\n\t\t\tdataBinderCustomizer.accept(dataBinder);\n\n\t\t\tHttpServletRequest servletRequest = servletRequest();\n\t\t\tdataBinder.construct(servletRequest);\n\t\t\tdataBinder.bind(servletRequest);\n\n\t\t\tBindingResult bindingResult = dataBinder.getBindingResult();\n\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\tthrow new BindException(bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT result = (T) bindingResult.getTarget();\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\"Binding result has neither target nor errors\");\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#of(value,commit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "commit"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<ServerRequest> commit)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<ServerRequest> commit) {\n\t\t\t\tif (commit == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, commit);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createRequestMappingInfo(httpExchange,customCondition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, or meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tHttpExchange httpExchange, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(toStringArray(httpExchange.value())))\n\t\t\t\t.methods(toMethodArray(httpExchange.method()))\n\t\t\t\t.consumes(toStringArray(httpExchange.contentType()))\n\t\t\t\t.produces(httpExchange.accept());\n\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHandlerMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHandlerMethodValidationException(\n\t\t\tHandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMethodValidationException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodValidationException(MethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodValidationException(\n\t\t\tMethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Validation failed\", null, null, request);\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleNoResourceFoundException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoResourceFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoResourceFoundException(NoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoResourceFoundException(\n\t\t\tNoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#shouldApplyTo(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\treturn (handler instanceof ResourceHttpRequestHandler ?\n\t\t\t\thasGlobalExceptionHandlers() : super.shouldApplyTo(request, handler));\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHandlerMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation for a controller method failed.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMethodValidationException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation failed on a component that is\n\t * not a web controller, e.g. on some underlying service.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleNoResourceFoundException(ex,request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no static resource was found.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link NoResourceFoundException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the resource handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#logException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (ex instanceof NoHandlerFoundException || ex instanceof NoResourceFoundException) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(buildLogMessage(ex, request));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.logException(ex, request);\n\t}"
  },
  "org.springframework.web.util.<unknown>#getDefaultMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#resolve(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(\n\t\t\tList<E> errors, MessageSource messageSource, Locale locale) {\n\n\t\tMap<E, String> map = new LinkedHashMap<>(errors.size());\n\t\terrors.forEach(error -> map.put(error, messageSource.getMessage(error, locale)));\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.util.<unknown>#resolveAndJoin(delimiter,prefix,suffix,errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter",
      "prefix",
      "suffix",
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "String",
    "signature": "public String resolveAndJoin(CharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin(\n\t\t\tCharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn errors.stream()\n\t\t\t\t.map(error -> messageSource.getMessage(error, locale))\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.collect(Collectors.joining(delimiter, prefix, suffix));\n\t}"
  },
  "org.springframework.web.util.<unknown>#resolveAndJoin(errors,messageSource,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin(\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn resolveAndJoin(\", and \", \"\", \"\", errors, messageSource, locale);\n\t}"
  }
}