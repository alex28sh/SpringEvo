{
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#argBinding(jp,jpMatch,returnValue,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Take the arguments at the method execution join point and output a set of arguments\n\t * to the advice method.\n\t * @param jp the current JoinPoint\n\t * @param jpMatch the join point match that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the empty array if there are no arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "Object[]",
    "signature": "protected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable ex) {\n\n\t\tcalculateArgumentBindings();\n\n\t\t// AMC start\n\t\tObject[] adviceInvocationArgs = new Object[this.parameterTypes.length];\n\t\tint numBound = 0;\n\n\t\tif (this.joinPointArgumentIndex != -1) {\n\t\t\tadviceInvocationArgs[this.joinPointArgumentIndex] = jp;\n\t\t\tnumBound++;\n\t\t}\n\t\telse if (this.joinPointStaticPartArgumentIndex != -1) {\n\t\t\tadviceInvocationArgs[this.joinPointStaticPartArgumentIndex] = jp.getStaticPart();\n\t\t\tnumBound++;\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.argumentBindings)) {\n\t\t\t// binding from pointcut match\n\t\t\tif (jpMatch != null) {\n\t\t\t\tPointcutParameter[] parameterBindings = jpMatch.getParameterBindings();\n\t\t\t\tfor (PointcutParameter parameter : parameterBindings) {\n\t\t\t\t\tString name = parameter.getName();\n\t\t\t\t\tInteger index = this.argumentBindings.get(name);\n\t\t\t\t\tadviceInvocationArgs[index] = parameter.getBinding();\n\t\t\t\t\tnumBound++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// binding from returning clause\n\t\t\tif (this.returningName != null) {\n\t\t\t\tInteger index = this.argumentBindings.get(this.returningName);\n\t\t\t\tadviceInvocationArgs[index] = returnValue;\n\t\t\t\tnumBound++;\n\t\t\t}\n\t\t\t// binding from thrown exception\n\t\t\tif (this.throwingName != null) {\n\t\t\t\tInteger index = this.argumentBindings.get(this.throwingName);\n\t\t\t\tadviceInvocationArgs[index] = ex;\n\t\t\t\tnumBound++;\n\t\t\t}\n\t\t}\n\n\t\tif (numBound != this.parameterTypes.length) {\n\t\t\tthrow new IllegalStateException(\"Required to bind \" + this.parameterTypes.length +\n\t\t\t\t\t\" arguments, but only bound \" + numBound + \" (JoinPointMatch \" +\n\t\t\t\t\t(jpMatch == null ? \"was NOT\" : \"WAS\") + \" bound in invocation)\");\n\t\t}\n\n\t\treturn adviceInvocationArgs;\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#couldMatchJoinPointsInType(someClass,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "someClass",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "boolean",
    "signature": "public boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context)",
    "source_code": "\t\tpublic boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context) {\n\t\t\treturn (contextMatch(someClass) == FuzzyBoolean.YES);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jp,jpMatch,returnValue,t)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "t"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t)",
    "source_code": "\tprotected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t) throws Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jpMatch,returnValue,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the advice method.\n\t * @param jpMatch the JoinPointMatch that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the invocation result\n\t * @throws Throwable in case of invocation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 612
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object invokeAdviceMethod(\n\t\t\t@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)\n\t\t\tthrows Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn !this.adviceMethod.equals(method);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\tobtainPointcutExpression();\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Bind Spring AOP proxy to AspectJ \"this\" and Spring AOP target to AspectJ target,\n\t\t// consistent with return of MethodInvocationProceedingJoinPoint\n\t\tProxyMethodInvocation pmi = null;\n\t\tObject targetObject = null;\n\t\tObject thisObject = null;\n\t\ttry {\n\t\t\tMethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();\n\t\t\ttargetObject = mi.getThis();\n\t\t\tif (!(mi instanceof ProxyMethodInvocation)) {\n\t\t\t\tthrow new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + mi);\n\t\t\t}\n\t\t\tpmi = (ProxyMethodInvocation) mi;\n\t\t\tthisObject = pmi.getProxy();\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\t// No current invocation...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not access current invocation - matching with limited context: \" + ex);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tJoinPointMatch joinPointMatch = shadowMatch.matchesJoinPoint(thisObject, targetObject, args);\n\n\t\t\t/*\n\t\t\t * Do a final check to see if any this(TYPE) kind of residue match. For\n\t\t\t * this purpose, we use the original method's (proxy method's) shadow to\n\t\t\t * ensure that 'this' is correctly checked against. Without this check,\n\t\t\t * we get incorrect match on this(TYPE) where TYPE matches the target\n\t\t\t * type but not 'this' (as would be the case of JDK dynamic proxies).\n\t\t\t * <p>See SPR-2979 for the original bug.\n\t\t\t */\n\t\t\tif (pmi != null && thisObject != null) {  // there is a current invocation\n\t\t\t\tRuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(getShadowMatch(method, method));\n\t\t\t\tif (!originalMethodResidueTest.testThisInstanceOfResidue(thisObject.getClass())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (joinPointMatch.matches()) {\n\t\t\t\t\tbindParameters(pmi, joinPointMatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn joinPointMatch.matches();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to evaluate join point for arguments \" + Arrays.asList(args) +\n\t\t\t\t\t\t\" - falling back to non-match\", ex);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass,hasIntroductions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tobtainPointcutExpression();\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Special handling for this, target, @this, @target, @annotation\n\t\t// in Spring - we can optimize since we know we have exactly this class,\n\t\t// and there will never be matching subclass at runtime.\n\t\tif (shadowMatch.alwaysMatches()) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (shadowMatch.neverMatches()) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// the maybe case\n\t\t\tif (hasIntroductions) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// A match test returned maybe - if there are any subtype sensitive variables\n\t\t\t// involved in the test (this, target, at_this, at_target, at_annotation) then\n\t\t\t// we say this is not a match as in Spring there will never be a different\n\t\t\t// runtime subtype.\n\t\t\tRuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);\n\t\t\treturn (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matchesJoinPoint(thisObject,targetObject,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "thisObject",
      "targetObject",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "JoinPointMatch",
    "signature": "public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args)",
    "source_code": "\t\tpublic JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {\n\t\t\ttry {\n\t\t\t\treturn this.primary.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t\tcatch (ReflectionWorldException ex) {\n\t\t\t\treturn this.other.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#getAdvice(candidateAdviceMethod,expressionPointcut,aspectInstanceFactory,declarationOrder,aspectName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdviceMethod",
      "expressionPointcut",
      "aspectInstanceFactory",
      "declarationOrder",
      "aspectName"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Advice",
    "signature": "public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n\t\t\tMetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName)",
    "source_code": "\tpublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n\t\t\tMetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n\t\tClass<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n\t\tvalidate(candidateAspectClass);\n\n\t\tAspectJAnnotation<?> aspectJAnnotation =\n\t\t\t\tAbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n\t\tif (aspectJAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If we get here, we know we have an AspectJ method.\n\t\t// Check that it's an AspectJ-annotated class\n\t\tif (!isAspect(candidateAspectClass)) {\n\t\t\tthrow new AopConfigException(\"Advice must be declared inside an aspect type: \" +\n\t\t\t\t\t\"Offending method '\" + candidateAdviceMethod + \"' in class [\" +\n\t\t\t\t\tcandidateAspectClass.getName() + \"]\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found AspectJ method: \" + candidateAdviceMethod);\n\t\t}\n\n\t\tAbstractAspectJAdvice springAdvice;\n\n\t\tswitch (aspectJAnnotation.getAnnotationType()) {\n\t\t\tcase AtPointcut -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\");\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcase AtAround -> springAdvice = new AspectJAroundAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtBefore -> springAdvice = new AspectJMethodBeforeAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtAfter -> springAdvice = new AspectJAfterAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtAfterReturning -> {\n\t\t\t\tspringAdvice = new AspectJAfterReturningAdvice(\n\t\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\t\tAfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();\n\t\t\t\tif (StringUtils.hasText(afterReturningAnnotation.returning())) {\n\t\t\t\t\tspringAdvice.setReturningName(afterReturningAnnotation.returning());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase AtAfterThrowing -> {\n\t\t\t\tspringAdvice = new AspectJAfterThrowingAdvice(\n\t\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\t\tAfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();\n\t\t\t\tif (StringUtils.hasText(afterThrowingAnnotation.throwing())) {\n\t\t\t\t\tspringAdvice.setThrowingName(afterThrowingAnnotation.throwing());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault -> throw new UnsupportedOperationException(\n\t\t\t\t\t\"Unsupported advice type on method: \" + candidateAdviceMethod);\n\t\t}\n\n\t\t// Now to configure the advice...\n\t\tspringAdvice.setAspectName(aspectName);\n\t\tspringAdvice.setDeclarationOrder(declarationOrder);\n\t\tString[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);\n\t\tif (argNames != null) {\n\t\t\tspringAdvice.setArgumentNamesFromStringArray(argNames);\n\t\t}\n\t\tspringAdvice.calculateArgumentBindings();\n\n\t\treturn springAdvice;\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#getAdvisor(candidateAdviceMethod,aspectInstanceFactory,declarationOrderInAspect,aspectName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdviceMethod",
      "aspectInstanceFactory",
      "declarationOrderInAspect",
      "aspectName"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Advisor",
    "signature": "public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n\t\t\tint declarationOrderInAspect, String aspectName)",
    "source_code": "\tpublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n\t\t\tint declarationOrderInAspect, String aspectName) {\n\n\t\tvalidate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\n\t\tAspectJExpressionPointcut expressionPointcut = getPointcut(\n\t\t\t\tcandidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\t\tif (expressionPointcut == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n\t\t\t\tthis, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\t// We're either instantiated and matching on declared pointcut,\n\t\t\t// or uninstantiated matching on either pointcut...\n\t\t\treturn (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass)) ||\n\t\t\t\t\tthis.preInstantiationPointcut.getMethodMatcher().matches(method, targetClass);\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#matches(method,targetClass,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\t\t// This can match only on declared pointcut.\n\t\t\treturn (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass));\n\t\t}"
  },
  "org.springframework.aop.aspectj.autoproxy.<unknown>#shouldSkip(beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "boolean",
    "signature": "protected boolean shouldSkip(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n\t\t// TODO: Consider optimization by caching the list of the aspect names\n\t\tList<Advisor> candidateAdvisors = findCandidateAdvisors();\n\t\tfor (Advisor advisor : candidateAdvisors) {\n\t\t\tif (advisor instanceof AspectJPointcutAdvisor pointcutAdvisor &&\n\t\t\t\t\tpointcutAdvisor.getAspectName().equals(beanName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.shouldSkip(beanClass, beanName);\n\t}"
  },
  "org.springframework.aop.config.<unknown>#decorate(node,definition,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tboolean proxyTargetClass = true;\n\t\tif (node instanceof Element ele) {\n\t\t\tif (ele.hasAttribute(PROXY_TARGET_CLASS)) {\n\t\t\t\tproxyTargetClass = Boolean.parseBoolean(ele.getAttribute(PROXY_TARGET_CLASS));\n\t\t\t}\n\t\t}\n\n\t\t// Register the original bean definition as it will be referenced by the scoped proxy\n\t\t// and is relevant for tooling (validation, navigation).\n\t\tBeanDefinitionHolder holder =\n\t\t\t\tScopedProxyUtils.createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);\n\t\tString targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());\n\t\tparserContext.getReaderContext().fireComponentRegistered(\n\t\t\t\tnew BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));\n\t\treturn holder;\n\t}"
  },
  "org.springframework.aop.config.<unknown>#parse(element,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tAopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n\t\textendBeanDefinition(element, parserContext);\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvice(pos,advice)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Cannot add introductions this way unless the advice implements IntroductionInfo.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advice"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "public void addAdvice(int pos, Advice advice)",
    "source_code": "\tpublic void addAdvice(int pos, Advice advice) throws AopConfigException {\n\t\tAssert.notNull(advice, \"Advice must not be null\");\n\t\tif (advice instanceof IntroductionInfo) {\n\t\t\t// We don't need an IntroductionAdvisor for this kind of introduction:\n\t\t\t// It's fully self-describing.\n\t\t\taddAdvisor(pos, new DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));\n\t\t}\n\t\telse if (advice instanceof DynamicIntroductionAdvice) {\n\t\t\t// We need an IntroductionAdvisor for this kind of introduction.\n\t\t\tthrow new AopConfigException(\"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor\");\n\t\t}\n\t\telse {\n\t\t\taddAdvisor(pos, new DefaultPointcutAdvisor(advice));\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvisor(pos,advisor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advisor"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void addAdvisor(int pos, Advisor advisor)",
    "source_code": "\tpublic void addAdvisor(int pos, Advisor advisor) throws AopConfigException {\n\t\tif (advisor instanceof IntroductionAdvisor) {\n\t\t\tvalidateIntroductionAdvisor((IntroductionAdvisor) advisor);\n\t\t}\n\t\taddAdvisorInternal(pos, advisor);\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#copyConfigurationFrom(other,targetSource,advisors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the AOP configuration from the given AdvisedSupport object,\n\t * but allow substitution of a fresh TargetSource and a given interceptor chain.\n\t * @param other the AdvisedSupport object to take proxy configuration from\n\t * @param targetSource the new TargetSource\n\t * @param advisors the Advisors for the chain\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "other",
      "targetSource",
      "advisors"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "void",
    "signature": "protected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors)",
    "source_code": "\tprotected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors) {\n\t\tcopyFrom(other);\n\t\tthis.targetSource = targetSource;\n\t\tthis.advisorChainFactory = other.advisorChainFactory;\n\t\tthis.interfaces = new ArrayList<>(other.interfaces);\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof IntroductionAdvisor) {\n\t\t\t\tvalidateIntroductionAdvisor((IntroductionAdvisor) advisor);\n\t\t\t}\n\t\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\t\tthis.advisors.add(advisor);\n\t\t}\n\t\tadviceChanged();\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#createProxyClassAndInstance(enhancer,callbacks)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "enhancer",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "Object",
    "signature": "protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)",
    "source_code": "\tprotected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {\n\t\tenhancer.setInterceptDuringConstruction(false);\n\t\tenhancer.setCallbacks(callbacks);\n\t\treturn (this.constructorArgs != null && this.constructorArgTypes != null ?\n\t\t\t\tenhancer.create(this.constructorArgTypes, this.constructorArgs) :\n\t\t\t\tenhancer.create());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#getInterceptorsAndDynamicInterceptionAdvice(config,method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "config",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "List<Object>",
    "signature": "public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\tAdvised config, Method method, @Nullable Class<?> targetClass) {\n\n\t\t// This is somewhat tricky... We have to process introductions first,\n\t\t// but we need to preserve order in the ultimate list.\n\t\tAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\n\t\tAdvisor[] advisors = config.getAdvisors();\n\t\tList<Object> interceptorList = new ArrayList<>(advisors.length);\n\t\tClass<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\n\t\tBoolean hasIntroductions = null;\n\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof PointcutAdvisor pointcutAdvisor) {\n\t\t\t\t// Add it conditionally.\n\t\t\t\tif (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\n\t\t\t\t\tMethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n\t\t\t\t\tboolean match;\n\t\t\t\t\tif (mm instanceof IntroductionAwareMethodMatcher) {\n\t\t\t\t\t\tif (hasIntroductions == null) {\n\t\t\t\t\t\t\thasIntroductions = hasMatchingIntroductions(advisors, actualClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = mm.matches(method, actualClass);\n\t\t\t\t\t}\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tMethodInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\t\t\tif (mm.isRuntime()) {\n\t\t\t\t\t\t\t// Creating a new object instance in the getInterceptors() method\n\t\t\t\t\t\t\t// isn't a problem as we normally cache created chains.\n\t\t\t\t\t\t\tfor (MethodInterceptor interceptor : interceptors) {\n\t\t\t\t\t\t\t\tinterceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (advisor instanceof IntroductionAdvisor ia) {\n\t\t\t\tif (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\n\t\t\t\t\tInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t}\n\t\t}\n\n\t\treturn interceptorList;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#getInterceptorsAndDynamicInterceptionAdvice(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects\n\t * for the given method, based on this configuration.\n\t * @param method the proxied method\n\t * @param targetClass the target class\n\t * @return a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "List<Object>",
    "signature": "public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass) {\n\t\tMethodCacheKey cacheKey = new MethodCacheKey(method);\n\t\tList<Object> cached = this.methodCache.get(cacheKey);\n\t\tif (cached == null) {\n\t\t\tcached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\tthis, method, targetClass);\n\t\t\tthis.methodCache.put(cacheKey, cached);\n\t\t}\n\t\treturn cached;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#intercept(proxy,method,args,methodProxy)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args",
      "methodProxy"
    ],
    "position": {
      "column": 1,
      "line": 680
    },
    "return": "Object",
    "signature": "public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)",
    "source_code": "\t\tpublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n\t\t\tObject oldProxy = null;\n\t\t\tboolean setProxyContext = false;\n\t\t\tObject target = null;\n\t\t\tTargetSource targetSource = this.advised.getTargetSource();\n\t\t\ttry {\n\t\t\t\tif (this.advised.exposeProxy) {\n\t\t\t\t\t// Make invocation available if necessary.\n\t\t\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\t\t\tsetProxyContext = true;\n\t\t\t\t}\n\t\t\t\t// Get as late as possible to minimize the time we \"own\" the target, in case it comes from a pool...\n\t\t\t\ttarget = targetSource.getTarget();\n\t\t\t\tClass<?> targetClass = (target != null ? target.getClass() : null);\n\t\t\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\t\t\t\tObject retVal;\n\t\t\t\t// Check whether we only have one InvokerInterceptor: that is,\n\t\t\t\t// no real advice, but just reflective invocation of the target.\n\t\t\t\tif (chain.isEmpty() && CglibMethodInvocation.isMethodProxyCompatible(method)) {\n\t\t\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly.\n\t\t\t\t\t// Note that the final invoker must be an InvokerInterceptor, so we know\n\t\t\t\t\t// it does nothing but a reflective operation on the target, and no hot\n\t\t\t\t\t// swapping or fancy proxying.\n\t\t\t\t\tObject[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n\t\t\t\t\tretVal = invokeMethod(target, method, argsToUse, methodProxy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We need to create a method invocation...\n\t\t\t\t\tretVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\n\t\t\t\t}\n\t\t\t\tretVal = processReturnType(proxy, target, method, retVal);\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t\t}\n\t\t\t\tif (setProxyContext) {\n\t\t\t\t\t// Restore old proxy.\n\t\t\t\t\tAopContext.setCurrentProxy(oldProxy);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.framework.<unknown>#isEligible(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean is eligible for advising with this\n\t * post-processor's {@link Advisor}.\n\t * <p>Delegates to {@link #isEligible(Class)} for target class checking.\n\t * Can be overridden e.g. to specifically exclude certain beans by name.\n\t * <p>Note: Only called for regular bean instances but not for existing\n\t * proxy instances which implement {@link Advised} and allow for adding\n\t * the local {@link Advisor} to the existing proxy's {@link Advisor} chain.\n\t * For the latter, {@link #isEligible(Class)} is being called directly,\n\t * with the actual target class behind the existing proxy (as determined\n\t * by {@link AopUtils#getTargetClass(Object)}).\n\t * @param bean the bean instance\n\t * @param beanName the name of the bean\n\t * @see #isEligible(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "protected boolean isEligible(Object bean, String beanName)",
    "source_code": "\tprotected boolean isEligible(Object bean, String beanName) {\n\t\treturn isEligible(bean.getClass());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (this.advisor == null || bean instanceof AopInfrastructureBean) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tif (bean instanceof Advised advised) {\n\t\t\tif (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {\n\t\t\t\t// Add our local Advisor to the existing proxy's Advisor chain...\n\t\t\t\tif (this.beforeExistingAdvisors) {\n\t\t\t\t\tadvised.addAdvisor(0, this.advisor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadvised.addAdvisor(this.advisor);\n\t\t\t\t}\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\n\t\tif (isEligible(bean, beanName)) {\n\t\t\tProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);\n\t\t\tif (!proxyFactory.isProxyTargetClass()) {\n\t\t\t\tevaluateProxyInterfaces(bean.getClass(), proxyFactory);\n\t\t\t}\n\t\t\tproxyFactory.addAdvisor(this.advisor);\n\t\t\tcustomizeProxyFactory(proxyFactory);\n\n\t\t\t// Use original ClassLoader if bean class not locally loaded in overriding class loader\n\t\t\tClassLoader classLoader = getProxyClassLoader();\n\t\t\tif (classLoader instanceof SmartClassLoader && classLoader != bean.getClass().getClassLoader()) {\n\t\t\t\tclassLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();\n\t\t\t}\n\t\t\treturn proxyFactory.getProxy(classLoader);\n\t\t}\n\n\t\t// No proxy needed.\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#prepareProxyFactory(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a {@link ProxyFactory} for the given bean.\n\t * <p>Subclasses may customize the handling of the target instance and in\n\t * particular the exposure of the target class. The default introspection\n\t * of interfaces for non-target-class proxies and the configured advisor\n\t * will be applied afterwards; {@link #customizeProxyFactory} allows for\n\t * late customizations of those parts right before proxy creation.\n\t * @param bean the bean instance to create a proxy for\n\t * @param beanName the corresponding bean name\n\t * @return the ProxyFactory, initialized with this processor's\n\t * {@link ProxyConfig} settings and the specified bean\n\t * @since 4.2.3\n\t * @see #customizeProxyFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "ProxyFactory",
    "signature": "protected ProxyFactory prepareProxyFactory(Object bean, String beanName)",
    "source_code": "\tprotected ProxyFactory prepareProxyFactory(Object bean, String beanName) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.copyFrom(this);\n\t\tproxyFactory.setTarget(bean);\n\t\treturn proxyFactory;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#replaceAdvisor(a,b)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "boolean",
    "signature": "public boolean replaceAdvisor(Advisor a, Advisor b)",
    "source_code": "\tpublic boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException {\n\t\tAssert.notNull(a, \"Advisor a must not be null\");\n\t\tAssert.notNull(b, \"Advisor b must not be null\");\n\t\tint index = indexOf(a);\n\t\tif (index == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tremoveAdvisor(index);\n\t\taddAdvisor(index, b);\n\t\treturn true;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#setConstructorArguments(constructorArgs,constructorArgTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set constructor arguments to use for creating the proxy.\n\t * @param constructorArgs the constructor argument values\n\t * @param constructorArgTypes the constructor argument types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructorArgs",
      "constructorArgTypes"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes)",
    "source_code": "\tpublic void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {\n\t\tif (constructorArgs == null || constructorArgTypes == null) {\n\t\t\tthrow new IllegalArgumentException(\"Both 'constructorArgs' and 'constructorArgTypes' need to be specified\");\n\t\t}\n\t\tif (constructorArgs.length != constructorArgTypes.length) {\n\t\t\tthrow new IllegalArgumentException(\"Number of 'constructorArgs' (\" + constructorArgs.length +\n\t\t\t\t\t\") must match number of 'constructorArgTypes' (\" + constructorArgTypes.length + \")\");\n\t\t}\n\t\tthis.constructorArgs = constructorArgs;\n\t\tthis.constructorArgTypes = constructorArgTypes;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#setUserAttribute(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "void",
    "signature": "public void setUserAttribute(String key, @Nullable Object value)",
    "source_code": "\tpublic void setUserAttribute(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\tif (this.userAttributes == null) {\n\t\t\t\tthis.userAttributes = new HashMap<>();\n\t\t\t}\n\t\t\tthis.userAttributes.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tif (this.userAttributes != null) {\n\t\t\t\tthis.userAttributes.remove(key);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#configure(defaultExecutor,exceptionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this aspect with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultExecutor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<Executor> defaultExecutor,\n\t\t\t@Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tpublic void configure(@Nullable Supplier<Executor> defaultExecutor,\n\t\t\t@Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tthis.defaultExecutor = new SingletonSupplier<>(defaultExecutor, () -> getDefaultExecutor(this.beanFactory));\n\t\tthis.exceptionHandler = new SingletonSupplier<>(exceptionHandler, SimpleAsyncUncaughtExceptionHandler::new);\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#doSubmit(task,executor,returnType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate for actually executing the given task with the chosen executor.\n\t * @param task the task to execute\n\t * @param executor the chosen executor\n\t * @param returnType the declared return type (potentially a {@link Future} variant)\n\t * @return the execution result (potentially a corresponding {@link Future} handle)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "executor",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "Object",
    "signature": "protected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType)",
    "source_code": "\tprotected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType) {\n\t\tif (CompletableFuture.class.isAssignableFrom(returnType)) {\n\t\t\treturn CompletableFuture.supplyAsync(() -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn task.call();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new CompletionException(ex);\n\t\t\t\t}\n\t\t\t}, executor);\n\t\t}\n\t\telse if (ListenableFuture.class.isAssignableFrom(returnType)) {\n\t\t\treturn ((AsyncListenableTaskExecutor) executor).submitListenable(task);\n\t\t}\n\t\telse if (Future.class.isAssignableFrom(returnType)) {\n\t\t\treturn executor.submit(task);\n\t\t}\n\t\telse if (void.class == returnType) {\n\t\t\texecutor.submit(task);\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Invalid return type for async method (only Future and void supported): \" + returnType);\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#findQualifiedExecutor(beanFactory,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a target executor for the given qualifier.\n\t * @param qualifier the qualifier to resolve\n\t * @return the target executor, or {@code null} if none available\n\t * @since 4.2.6\n\t * @see #getExecutorQualifier(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "Executor",
    "signature": "protected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier)",
    "source_code": "\tprotected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier) {\n\t\tif (beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\"BeanFactory must be set on \" + getClass().getSimpleName() +\n\t\t\t\t\t\" to access qualified executor '\" + qualifier + \"'\");\n\t\t}\n\t\tif (beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tEmbeddedValueResolver embeddedValueResolver = new EmbeddedValueResolver(configurableBeanFactory);\n\t\t\tqualifier = embeddedValueResolver.resolveStringValue(qualifier);\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, Executor.class, qualifier);\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#handleError(ex,method,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handles a fatal error thrown while asynchronously invoking the specified\n\t * {@link Method}.\n\t * <p>If the return type of the method is a {@link Future} object, the original\n\t * exception can be propagated by just throwing it at the higher level. However,\n\t * for all other cases, the exception will not be transmitted back to the client.\n\t * In that later case, the current {@link AsyncUncaughtExceptionHandler} will be\n\t * used to manage such exception.\n\t * @param ex the exception to handle\n\t * @param method the method that was invoked\n\t * @param params the parameters used to invoke the method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "method",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void handleError(Throwable ex, Method method, Object... params)",
    "source_code": "\tprotected void handleError(Throwable ex, Method method, Object... params) throws Exception {\n\t\tif (Future.class.isAssignableFrom(method.getReturnType())) {\n\t\t\tReflectionUtils.rethrowException(ex);\n\t\t}\n\t\telse {\n\t\t\t// Could not transmit the exception to the caller with default executor\n\t\t\ttry {\n\t\t\t\tthis.exceptionHandler.obtain().handleUncaughtException(ex, method, params);\n\t\t\t}\n\t\t\tcatch (Throwable ex2) {\n\t\t\t\tlogger.warn(\"Exception handler for async method '\" + method.toGenericString() +\n\t\t\t\t\t\t\"' threw unexpected exception itself\", ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.scope.<unknown>#createScopedProxy(definition,registry,proxyTargetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a scoped proxy for the supplied target bean, registering the target\n\t * bean with an internal name and setting 'targetBeanName' on the scoped proxy.\n\t * @param definition the original bean definition\n\t * @param registry the bean definition registry\n\t * @param proxyTargetClass whether to create a target class proxy\n\t * @return the scoped proxy definition\n\t * @see #getTargetBeanName(String)\n\t * @see #getOriginalBeanName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition",
      "registry",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition,\n\t\t\tBeanDefinitionRegistry registry, boolean proxyTargetClass)",
    "source_code": "\tpublic static BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition,\n\t\t\tBeanDefinitionRegistry registry, boolean proxyTargetClass) {\n\n\t\tString originalBeanName = definition.getBeanName();\n\t\tBeanDefinition targetDefinition = definition.getBeanDefinition();\n\t\tString targetBeanName = getTargetBeanName(originalBeanName);\n\n\t\t// Create a scoped proxy definition for the original bean name,\n\t\t// \"hiding\" the target bean in an internal target definition.\n\t\tRootBeanDefinition proxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\tproxyDefinition.setDecoratedDefinition(new BeanDefinitionHolder(targetDefinition, targetBeanName));\n\t\tproxyDefinition.setOriginatingBeanDefinition(targetDefinition);\n\t\tproxyDefinition.setSource(definition.getSource());\n\t\tproxyDefinition.setRole(targetDefinition.getRole());\n\n\t\tproxyDefinition.getPropertyValues().add(\"targetBeanName\", targetBeanName);\n\t\tif (proxyTargetClass) {\n\t\t\ttargetDefinition.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedProxyFactoryBean's \"proxyTargetClass\" default is TRUE, so we don't need to set it explicitly here.\n\t\t}\n\t\telse {\n\t\t\tproxyDefinition.getPropertyValues().add(\"proxyTargetClass\", Boolean.FALSE);\n\t\t}\n\n\t\t// Copy autowire settings from original bean definition.\n\t\tproxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());\n\t\tproxyDefinition.setPrimary(targetDefinition.isPrimary());\n\t\tif (targetDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\tproxyDefinition.copyQualifiersFrom(abd);\n\t\t}\n\n\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\ttargetDefinition.setAutowireCandidate(false);\n\t\ttargetDefinition.setPrimary(false);\n\n\t\t// Register the target bean as separate bean in the factory.\n\t\tregistry.registerBeanDefinition(targetBeanName, targetDefinition);\n\n\t\t// Return the scoped proxy definition as primary bean definition\n\t\t// (potentially an inner bean).\n\t\treturn new BeanDefinitionHolder(proxyDefinition, originalBeanName, definition.getAliases());\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(advisor,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given advisor apply at all on the given class?\n\t * This is an important test as it can be used to optimize\n\t * out a advisor for a class.\n\t * @param advisor the advisor to check\n\t * @param targetClass class we're testing\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advisor",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "boolean",
    "signature": "public boolean canApply(Advisor advisor, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Advisor advisor, Class<?> targetClass) {\n\t\treturn canApply(advisor, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(advisor,targetClass,hasIntroductions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given advisor apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize out a advisor for a class.\n\t * This version also takes into account introductions (for IntroductionAwareMethodMatchers).\n\t * @param advisor the advisor to check\n\t * @param targetClass class we're testing\n\t * @param hasIntroductions whether or not the advisor chain for this bean includes\n\t * any introductions\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advisor",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n\t\tif (advisor instanceof IntroductionAdvisor) {\n\t\t\treturn ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n\t\t}\n\t\telse if (advisor instanceof PointcutAdvisor pca) {\n\t\t\treturn canApply(pca.getPointcut(), targetClass, hasIntroductions);\n\t\t}\n\t\telse {\n\t\t\t// It doesn't have a pointcut so we assume it applies.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass) {\n\t\treturn canApply(pc, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass,hasIntroductions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @param hasIntroductions whether or not the advisor chain\n\t * for this bean includes any introductions\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n\t\tAssert.notNull(pc, \"Pointcut must not be null\");\n\t\tif (!pc.getClassFilter().matches(targetClass)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMethodMatcher methodMatcher = pc.getMethodMatcher();\n\t\tif (methodMatcher == MethodMatcher.TRUE) {\n\t\t\t// No need to iterate the methods if we're matching any method anyway...\n\t\t\treturn true;\n\t\t}\n\n\t\tIntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n\t\tif (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n\t\t\tintroductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n\t\t}\n\n\t\tSet<Class<?>> classes = new LinkedHashSet<>();\n\t\tif (!Proxy.isProxyClass(targetClass)) {\n\t\t\tclasses.add(ClassUtils.getUserClass(targetClass));\n\t\t}\n\t\tclasses.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tMethod[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (introductionAwareMethodMatcher != null ?\n\t\t\t\t\t\tintroductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :\n\t\t\t\t\t\tmethodMatcher.matches(method, targetClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#findAdvisorsThatCanApply(candidateAdvisors,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the sublist of the {@code candidateAdvisors} list\n\t * that is applicable to the given class.\n\t * @param candidateAdvisors the Advisors to evaluate\n\t * @param clazz the target class\n\t * @return sublist of Advisors that can apply to an object of the given class\n\t * (may be the incoming List as-is)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdvisors",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "List<Advisor>",
    "signature": "public List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz)",
    "source_code": "\tpublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n\t\tif (candidateAdvisors.isEmpty()) {\n\t\t\treturn candidateAdvisors;\n\t\t}\n\t\tList<Advisor> eligibleAdvisors = new ArrayList<>();\n\t\tfor (Advisor candidate : candidateAdvisors) {\n\t\t\tif (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n\t\t\t\teligibleAdvisors.add(candidate);\n\t\t\t}\n\t\t}\n\t\tboolean hasIntroductions = !eligibleAdvisors.isEmpty();\n\t\tfor (Advisor candidate : candidateAdvisors) {\n\t\t\tif (candidate instanceof IntroductionAdvisor) {\n\t\t\t\t// already processed\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (canApply(candidate, clazz, hasIntroductions)) {\n\t\t\t\teligibleAdvisors.add(candidate);\n\t\t\t}\n\t\t}\n\t\treturn eligibleAdvisors;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#getMostSpecificMethod(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current AOP invocation, find the corresponding target method if there\n\t * is one. E.g. the method may be {@code IFoo.bar()} and the target class\n\t * may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},\n\t * this method resolves bridge methods in order to retrieve attributes from\n\t * the <i>original</i> method definition.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation.\n\t * May be {@code null} or may not even implement the method.\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} doesn't implement it or is {@code null}\n\t * @see org.springframework.util.ClassUtils#getMostSpecificMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> specificTargetClass = (targetClass != null ? ClassUtils.getUserClass(targetClass) : null);\n\t\tMethod resolvedMethod = ClassUtils.getMostSpecificMethod(method, specificTargetClass);\n\t\t// If we are dealing with method with generic parameters, find the original method.\n\t\treturn BridgeMethodResolver.findBridgedMethod(resolvedMethod);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#intersection(mm1,mm2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>both</i> of the given MethodMatchers match.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that both\n\t * of the given MethodMatchers match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher intersection(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher intersection(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew IntersectionIntroductionAwareMethodMatcher(mm1, mm2) : new IntersectionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#invokeJoinpointUsingReflection(target,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given target via reflection, as part of an AOP method invocation.\n\t * @param target the target object\n\t * @param method the method to invoke\n\t * @param args the arguments for the method\n\t * @return the invocation result, if any\n\t * @throws Throwable if thrown by the target method\n\t * @throws org.springframework.aop.AopInvocationException in case of a reflection error\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "public Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)",
    "source_code": "\tpublic static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\n\t\t// Use reflection to invoke the method.\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Invoked method threw a checked exception.\n\t\t\t// We must rethrow it. The client won't see the interceptor.\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new AopInvocationException(\"AOP configuration seems to be invalid: tried calling method [\" +\n\t\t\t\t\tmethod + \"] on target [\" + target + \"]\", ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new AopInvocationException(\"Could not access method [\" + method + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn (this.mm1.matches(method, targetClass) && this.mm2.matches(method, targetClass));\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\t\t// Because a dynamic intersection may be composed of a static and dynamic part,\n\t\t\t// we must avoid calling the 3-arg matches method on a dynamic matcher, as\n\t\t\t// it will probably be an unsupported operation.\n\t\t\tboolean aMatches = (this.mm1.isRuntime() ?\n\t\t\t\t\tthis.mm1.matches(method, targetClass, args) : this.mm1.matches(method, targetClass));\n\t\t\tboolean bMatches = (this.mm2.isRuntime() ?\n\t\t\t\t\tthis.mm2.matches(method, targetClass, args) : this.mm2.matches(method, targetClass));\n\t\t\treturn aMatches && bMatches;\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass,hasIntroductions)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\t\treturn (MethodMatchers.matches(this.mm1, method, targetClass, hasIntroductions) &&\n\t\t\t\t\tMethodMatchers.matches(this.mm2, method, targetClass, hasIntroductions));\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(mm,method,targetClass,hasIntroductions)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given MethodMatcher to the given Method, supporting an\n\t * {@link org.springframework.aop.IntroductionAwareMethodMatcher}\n\t * (if applicable).\n\t * @param mm the MethodMatcher to apply (may be an IntroductionAwareMethodMatcher)\n\t * @param method the candidate method\n\t * @param targetClass the target class\n\t * @param hasIntroductions {@code true} if the object on whose behalf we are\n\t * asking is the subject on one or more introductions; {@code false} otherwise\n\t * @return whether or not this method matches statically\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm",
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "boolean",
    "signature": "public boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tAssert.notNull(mm, \"MethodMatcher must not be null\");\n\t\treturn (mm instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\t((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions) :\n\t\t\t\tmm.matches(method, targetClass));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(pattern,patternIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the pattern at the given index match the given String?\n\t * @param pattern the {@code String} pattern to match\n\t * @param patternIndex index of pattern (starting from 0)\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pattern",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "protected boolean matches(String pattern, int patternIndex)",
    "source_code": "\tprotected abstract boolean matches(String pattern, int patternIndex);"
  },
  "org.springframework.aop.support.<unknown>#matchesExclusion(pattern,patternIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Does the exclusion pattern at the given index match the given String?\n\t * @param pattern the {@code String} pattern to match\n\t * @param patternIndex index of pattern (starting from 0)\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pattern",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "boolean",
    "signature": "protected boolean matchesExclusion(String pattern, int patternIndex)",
    "source_code": "\tprotected abstract boolean matchesExclusion(String pattern, int patternIndex);"
  },
  "org.springframework.aop.support.<unknown>#selectInvocableMethod(method,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Select an invocable method on the target type: either the given method itself\n\t * if actually exposed on the target type, or otherwise a corresponding method\n\t * on one of the target type's interfaces or on the target type itself.\n\t * @param method the method to check\n\t * @param targetType the target type to search methods on (typically an AOP proxy)\n\t * @return a corresponding invocable method on the target type\n\t * @throws IllegalStateException if the given method is not invocable on the given\n\t * target type (typically due to a proxy mismatch)\n\t * @since 4.3\n\t * @see MethodIntrospector#selectInvocableMethod(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Method",
    "signature": "public Method selectInvocableMethod(Method method, @Nullable Class<?> targetType)",
    "source_code": "\tpublic static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn method;\n\t\t}\n\t\tMethod methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType);\n\t\tif (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&\n\t\t\t\tSpringProxy.class.isAssignableFrom(targetType)) {\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"Need to invoke method '%s' found on proxy for target class '%s' but cannot \" +\n\t\t\t\t\t\"be delegated to target bean. Switch its visibility to package or protected.\",\n\t\t\t\t\tmethod.getName(), method.getDeclaringClass().getSimpleName()));\n\t\t}\n\t\treturn methodToUse;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(mm1,mm2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>either</i> (or both) of the given MethodMatchers matches.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that either\n\t * of the given MethodMatchers matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew UnionIntroductionAwareMethodMatcher(mm1, mm2) : new UnionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.aop.support.annotation.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tif (matchesMethod(method)) {\n\t\t\treturn true;\n\t\t}\n\t\t// Proxy classes never have annotations on their redeclared methods.\n\t\tif (Proxy.isProxyClass(targetClass)) {\n\t\t\treturn false;\n\t\t}\n\t\t// The method may be on an interface, so let's check on the target class as well.\n\t\tMethod specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\t\treturn (specificMethod != method && matchesMethod(specificMethod));\n\t}"
  },
  "org.springframework.aop.target.<unknown>#forClass(targetClass,isStatic)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an EmptyTargetSource for the given target Class.\n\t * @param targetClass the target Class (may be {@code null})\n\t * @param isStatic whether the TargetSource should be marked as static\n\t * @see #getTargetClass()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "isStatic"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmptyTargetSource",
    "signature": "public EmptyTargetSource forClass(@Nullable Class<?> targetClass, boolean isStatic)",
    "source_code": "\tpublic static EmptyTargetSource forClass(@Nullable Class<?> targetClass, boolean isStatic) {\n\t\treturn (targetClass == null && isStatic ? INSTANCE : new EmptyTargetSource(targetClass, isStatic));\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#addFile(kind,path,content)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void addFile(Kind kind, String path, InputStreamSource content)",
    "source_code": "\tpublic void addFile(Kind kind, String path, InputStreamSource content) {\n\t\tAssert.notNull(kind, \"'kind' must not be null\");\n\t\tAssert.hasLength(path, \"'path' must not be empty\");\n\t\tAssert.notNull(content, \"'content' must not be null\");\n\t\tPath root = this.roots.apply(kind).toAbsolutePath().normalize();\n\t\tPath relativePath = root.resolve(path).toAbsolutePath().normalize();\n\t\tAssert.isTrue(relativePath.startsWith(root), () -> \"'path' must be relative\");\n\t\ttry {\n\t\t\ttry (InputStream inputStream = content.getInputStream()) {\n\t\t\t\tFiles.createDirectories(relativePath.getParent());\n\t\t\t\tFiles.copy(inputStream, relativePath);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#of(declaringClass,methodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new method reference that refers to the given instance method.\n\t * @param declaringClass the declaring class\n\t * @param methodName the method name\n\t * @return a new {@link MethodReference} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declaringClass",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "MethodReference",
    "signature": "public MethodReference of(ClassName declaringClass, String methodName)",
    "source_code": "\tpublic static MethodReference of(ClassName declaringClass, String methodName) {\n\t\tAssert.notNull(declaringClass, \"'declaringClass' must not be null\");\n\t\tAssert.hasLength(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodReference(Kind.INSTANCE, declaringClass, methodName);\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#ofStatic(declaringClass,methodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new method reference that refers to the given static method.\n\t * @param declaringClass the declaring class\n\t * @param methodName the method name\n\t * @return a new {@link MethodReference} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declaringClass",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "MethodReference",
    "signature": "public MethodReference ofStatic(ClassName declaringClass, String methodName)",
    "source_code": "\tpublic static MethodReference ofStatic(ClassName declaringClass, String methodName) {\n\t\tAssert.notNull(declaringClass, \"'declaringClass' must not be null\");\n\t\tAssert.hasLength(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodReference(Kind.STATIC, declaringClass, methodName);\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#toInvokeCodeBlock(instanceVariable,arguments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return this method reference as an invocation {@link CodeBlock}.\n\t * @param instanceVariable the instance variable or {@code null}\n\t * @param arguments the method arguments\n\t * @return a code back to invoke the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "instanceVariable",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock toInvokeCodeBlock(@Nullable String instanceVariable,\n\t\t\tCodeBlock... arguments)",
    "source_code": "\tpublic CodeBlock toInvokeCodeBlock(@Nullable String instanceVariable,\n\t\t\tCodeBlock... arguments) {\n\n\t\treturn switch (this.kind) {\n\t\tcase INSTANCE -> toInvokeCodeBlockForInstance(instanceVariable, arguments);\n\t\tcase STATIC -> toInvokeCodeBlockForStatic(instanceVariable, arguments);\n\t\t};\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(chars,offset,length)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "chars",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "void",
    "signature": "public void write(char[] chars, int offset, int length)",
    "source_code": "\t\tpublic void write(char[] chars, int offset, int length) {\n\t\t\ttry {\n\t\t\t\tif (this.prependIndent) {\n\t\t\t\t\tthis.out.write(this.currentIndent.toCharArray(), 0, this.currentIndent.length());\n\t\t\t\t\tthis.prependIndent = false;\n\t\t\t\t}\n\t\t\t\tthis.out.write(chars, offset, length);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(writer,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void write(BasicJsonWriter writer, ReflectionHints hints)",
    "source_code": "\tpublic void write(BasicJsonWriter writer, ReflectionHints hints) {\n\t\twriter.writeArray(hints.typeHints().map(this::toAttributes).toList());\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#writeObject(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write an object with the specified attributes. Each attribute is\n\t * written according to its value type:\n\t * <ul>\n\t * <li>Map: write the value as a nested object</li>\n\t * <li>List: write the value as a nested array</li>\n\t * <li>Otherwise, write a single value</li>\n\t * </ul>\n\t * @param attributes the attributes of the object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void writeObject(Map<String, Object> attributes)",
    "source_code": "\tpublic void writeObject(Map<String, Object> attributes) {\n\t\twriteObject(attributes, true);\n\t}"
  },
  "org.springframework.aot.test.generator.compile.<unknown>#interceptAfterAllMethod(invocation,invocationContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "invocationContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "void",
    "signature": "public void interceptAfterAllMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext)",
    "source_code": "\tpublic void interceptAfterAllMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext) throws Throwable {\n\n\t\tintercept(invocation, extensionContext);\n\t}"
  },
  "org.springframework.aot.test.generator.compile.<unknown>#interceptAfterEachMethod(invocation,invocationContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "invocationContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void interceptAfterEachMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext)",
    "source_code": "\tpublic void interceptAfterEachMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext) throws Throwable {\n\n\t\tintercept(invocation, extensionContext);\n\t}"
  },
  "org.springframework.aot.test.generator.compile.<unknown>#interceptBeforeAllMethod(invocation,invocationContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "invocationContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void interceptBeforeAllMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext)",
    "source_code": "\tpublic void interceptBeforeAllMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext) throws Throwable {\n\n\t\tintercept(invocation, extensionContext);\n\t}"
  },
  "org.springframework.aot.test.generator.compile.<unknown>#interceptBeforeEachMethod(invocation,invocationContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "invocationContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void interceptBeforeEachMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext)",
    "source_code": "\tpublic void interceptBeforeEachMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext) throws Throwable {\n\n\t\tintercept(invocation, extensionContext);\n\t}"
  },
  "org.springframework.aot.test.generator.compile.<unknown>#interceptTestMethod(invocation,invocationContext,extensionContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invocation",
      "invocationContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void interceptTestMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext)",
    "source_code": "\tpublic void interceptTestMethod(Invocation<Void> invocation,\n\t\t\tReflectiveInvocationContext<Method> invocationContext,\n\t\t\tExtensionContext extensionContext) throws Throwable {\n\n\t\tintercept(invocation, extensionContext,\n\t\t\t\t() -> runTestWithModifiedClassPath(invocationContext, extensionContext));\n\t}"
  },
  "org.springframework.beans.<unknown>#add(propertyName,propertyValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a PropertyValue object, replacing any existing one for the\n\t * corresponding property or getting merged with it (if applicable).\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue)",
    "source_code": "\tpublic MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValue(propertyName,propertyValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overloaded version of {@code addPropertyValue} that takes\n\t * a property name and a property value.\n\t * <p>Note: As of Spring 3.0, we recommend using the more concise\n\t * and chaining-capable variant {@link #add}.\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @see #addPropertyValue(PropertyValue)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void addPropertyValue(String propertyName, Object propertyValue)",
    "source_code": "\tpublic void addPropertyValue(String propertyName, Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValues(Map<?,other)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all property values from the given Map.\n\t * @param other a Map with property values keyed by property name,\n\t * which must be a String\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "other"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other)",
    "source_code": "\tpublic MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other) {\n\t\tif (other != null) {\n\t\t\tother.forEach((attrName, attrValue) -> addPropertyValue(\n\t\t\t\t\tnew PropertyValue(attrName.toString(), attrValue)));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.<unknown>#compare(desc1,desc2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "int",
    "signature": "public int compare(PropertyDescriptor desc1, PropertyDescriptor desc2)",
    "source_code": "\t\tpublic int compare(PropertyDescriptor desc1, PropertyDescriptor desc2) {\n\t\t\tString left = desc1.getName();\n\t\t\tString right = desc2.getName();\n\t\t\tbyte[] leftBytes = left.getBytes();\n\t\t\tbyte[] rightBytes = right.getBytes();\n\t\t\tfor (int i = 0; i < left.length(); i++) {\n\t\t\t\tif (right.length() == i) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tint result = leftBytes[i] - rightBytes[i];\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn left.length() - right.length();\n\t\t}"
  },
  "org.springframework.beans.<unknown>#convertForProperty(propertyName,oldValue,newValue,td)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "td"
    ],
    "position": {
      "column": 1,
      "line": 604
    },
    "return": "Object",
    "signature": "protected Object convertForProperty(String propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)",
    "source_code": "\tprotected Object convertForProperty(\n\t\t\tString propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn convertIfNecessary(propertyName, oldValue, newValue, td.getType(), td);\n\t}"
  },
  "org.springframework.beans.<unknown>#getFinalPath(pa,nestedPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the last component of the path. Also works if not nested.\n\t * @param pa property accessor to work on\n\t * @param nestedPath property path we know is nested\n\t * @return last component of the path (the property on the target bean)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pa",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "String",
    "signature": "protected String getFinalPath(AbstractNestablePropertyAccessor pa, String nestedPath)",
    "source_code": "\tprotected String getFinalPath(AbstractNestablePropertyAccessor pa, String nestedPath) {\n\t\tif (pa == this) {\n\t\t\treturn nestedPath;\n\t\t}\n\t\treturn nestedPath.substring(PropertyAccessorUtils.getLastNestedPropertySeparatorIndex(nestedPath) + 1);\n\t}"
  },
  "org.springframework.beans.<unknown>#newNestedPropertyAccessor(object,nestedPath)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new nested property accessor instance.\n\t * Can be overridden in subclasses to create a PropertyAccessor subclass.\n\t * @param object the object wrapped by this PropertyAccessor\n\t * @param nestedPath the nested path of the object\n\t * @return the nested PropertyAccessor instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 745
    },
    "return": "AbstractNestablePropertyAccessor",
    "signature": "protected AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath)",
    "source_code": "\tprotected abstract AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath);"
  },
  "org.springframework.beans.<unknown>#setPropertyValue(propertyName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "public void setPropertyValue(String propertyName, @Nullable Object value)",
    "source_code": "\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n\t\tAbstractNestablePropertyAccessor nestedPa;\n\t\ttry {\n\t\t\tnestedPa = getPropertyAccessorForPropertyPath(propertyName);\n\t\t}\n\t\tcatch (NotReadablePropertyException ex) {\n\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\"Nested property in path '\" + propertyName + \"' does not exist\", ex);\n\t\t}\n\t\tPropertyTokenHolder tokens = getPropertyNameTokens(getFinalPath(nestedPa, propertyName));\n\t\tnestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValue(tokens,pv)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tokens",
      "pv"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv)",
    "source_code": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tif (tokens.keys != null) {\n\t\t\tprocessKeyedProperty(tokens, pv);\n\t\t}\n\t\telse {\n\t\t\tprocessLocalProperty(tokens, pv);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValueAt(pv,i)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Modify a PropertyValue object held in this object.\n\t * Indexed from 0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pv",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "public void setPropertyValueAt(PropertyValue pv, int i)",
    "source_code": "\tpublic void setPropertyValueAt(PropertyValue pv, int i) {\n\t\tthis.propertyValueList.set(i, pv);\n\t}"
  },
  "org.springframework.beans.<unknown>#setWrappedInstance(object,nestedPath,rootObject)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Switch the target object, replacing the cached introspection results only\n\t * if the class of the new object is different to that of the replaced object.\n\t * @param object the new target object\n\t * @param nestedPath the nested path of the object\n\t * @param rootObject the root object at the top of the path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "nestedPath",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject)",
    "source_code": "\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tthis.wrappedObject = ObjectUtils.unwrapOptional(object);\n\t\tAssert.notNull(this.wrappedObject, \"Target object must not be null\");\n\t\tthis.nestedPath = (nestedPath != null ? nestedPath : \"\");\n\t\tthis.rootObject = (!this.nestedPath.isEmpty() ? rootObject : this.wrappedObject);\n\t\tthis.nestedPropertyAccessors = null;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForAnnotationIncludingAncestors(lbf,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names whose {@code Class} has the supplied {@link Annotation}\n\t * type, including those defined in ancestor factories, without creating any bean\n\t * instances yet. Will return unique names in case of overridden bean definitions.\n\t * @param lbf the bean factory\n\t * @param annotationType the type of annotation to look for\n\t * @return the array of matching bean names, or an empty array if none\n\t * @since 5.0\n\t * @see ListableBeanFactory#getBeanNamesForAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForAnnotationIncludingAncestors(ListableBeanFactory lbf, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static String[] beanNamesForAnnotationIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<? extends Annotation> annotationType) {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForAnnotation(annotationType);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForAnnotationIncludingAncestors(pbf, annotationType);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForTypeIncludingAncestors(lbf,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names for the given type, including those defined in ancestor\n\t * factories. Will return unique names in case of overridden bean definitions.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanNamesForTypeIncludingAncestors} automatically\n\t * includes prototypes and FactoryBeans.\n\t * @param lbf the bean factory\n\t * @param type the type that beans must match (as a {@code Class})\n\t * @return the array of matching bean names, or an empty array if none\n\t * @see ListableBeanFactory#getBeanNamesForType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type)",
    "source_code": "\tpublic static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForType(type);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForTypeIncludingAncestors(pbf, type);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names for the given type, including those defined in ancestor\n\t * factories. Will return unique names in case of overridden bean definitions.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @param type the type that beans must match\n\t * @return the array of matching bean names, or an empty array if none\n\t * @see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static String[] beanNamesForTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForTypeIncludingAncestors(\n\t\t\t\t\t\tpbf, type, includeNonSingletons, allowEagerInit);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanOfType} automatically includes\n\t * prototypes and FactoryBeans.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfType(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfTypeIncludingAncestors(lbf,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, also picking up beans\n\t * defined in ancestor bean factories if the current bean factory is a\n\t * HierarchicalBeanFactory. Useful convenience method when we expect a\n\t * single bean and don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanOfTypeIncludingAncestors} automatically includes\n\t * prototypes and FactoryBeans.\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "T",
    "signature": "public T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, also picking up beans\n\t * defined in ancestor bean factories if the current bean factory is a\n\t * HierarchicalBeanFactory. Useful convenience method when we expect a\n\t * single bean and don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "T",
    "signature": "public T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type, includeNonSingletons, allowEagerInit);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode) {\n\n\t\t\tClassName className = generationContext.getClassNameGenerator()\n\t\t\t\t\t.generateClassName(this.target, \"Autowiring\");\n\t\t\tTypeSpec.Builder classBuilder = TypeSpec.classBuilder(className);\n\t\t\tclassBuilder.addJavadoc(\"Autowiring for {@link $T}.\", this.target);\n\t\t\tclassBuilder.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\tclassBuilder.addMethod(generateMethod(generationContext.getRuntimeHints()));\n\t\t\tJavaFile javaFile = JavaFile\n\t\t\t\t\t.builder(className.packageName(), classBuilder.build()).build();\n\t\t\tgenerationContext.getGeneratedFiles().addSourceFile(javaFile);\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(\n\t\t\t\t\tMethodReference.ofStatic(className, APPLY_METHOD));\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#forElements(elements,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@code InjectionMetadata} instance, possibly for empty elements.\n\t * @param elements the elements to inject (possibly empty)\n\t * @param clazz the target class\n\t * @return a new {@link #InjectionMetadata(Class, Collection)} instance\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "InjectionMetadata",
    "signature": "public InjectionMetadata forElements(Collection<InjectedElement> elements, Class<?> clazz)",
    "source_code": "\tpublic static InjectionMetadata forElements(Collection<InjectedElement> elements, Class<?> clazz) {\n\t\treturn (elements.isEmpty() ? new InjectionMetadata(clazz, Collections.emptyList()) :\n\t\t\t\tnew InjectionMetadata(clazz, elements));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Either this or {@link #inject} needs to be overridden.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(bean,beanName,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 761
    },
    "return": "void",
    "signature": "protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\t\tprotected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\t\tif (checkPropertySkipping(pvs)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMethod method = (Method) this.member;\n\t\t\tObject[] arguments;\n\t\t\tif (this.cached) {\n\t\t\t\ttry {\n\t\t\t\t\targuments = resolveCachedArguments(beanName);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t// Unexpected removal of target bean for cached argument -> re-resolve\n\t\t\t\t\targuments = resolveMethodArguments(method, bean, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\targuments = resolveMethodArguments(method, bean, beanName);\n\t\t\t}\n\t\t\tif (arguments != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(bean, arguments);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,beanName,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\tpublic void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\tCollection<InjectedElement> checkedElements = this.checkedElements;\n\t\tCollection<InjectedElement> elementsToIterate =\n\t\t\t\t(checkedElements != null ? checkedElements : this.injectedElements);\n\t\tif (!elementsToIterate.isEmpty()) {\n\t\t\tfor (InjectedElement element : elementsToIterate) {\n\t\t\t\telement.inject(target, beanName, pvs);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,requestingBeanName,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Either this or {@link #getResourceToInject} needs to be overridden.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)",
    "source_code": "\t\tprotected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)\n\t\t\t\tthrows Throwable {\n\n\t\t\tif (this.isField) {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tfield.set(target, getResourceToInject(target, requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (checkPropertySkipping(pvs)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = (Method) this.member;\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(target, getResourceToInject(target, requestingBeanName));\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#invokeDestroyMethods(target,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "void",
    "signature": "public void invokeDestroyMethods(Object target, String beanName)",
    "source_code": "\t\tpublic void invokeDestroyMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleElement> checkedDestroyMethods = this.checkedDestroyMethods;\n\t\t\tCollection<LifecycleElement> destroyMethodsToUse =\n\t\t\t\t\t(checkedDestroyMethods != null ? checkedDestroyMethods : this.destroyMethods);\n\t\t\tif (!destroyMethodsToUse.isEmpty()) {\n\t\t\t\tfor (LifecycleElement element : destroyMethodsToUse) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking destroy method on bean '\" + beanName + \"': \" + element.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\telement.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#invokeInitMethods(target,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "void",
    "signature": "public void invokeInitMethods(Object target, String beanName)",
    "source_code": "\t\tpublic void invokeInitMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleElement> checkedInitMethods = this.checkedInitMethods;\n\t\t\tCollection<LifecycleElement> initMethodsToIterate =\n\t\t\t\t\t(checkedInitMethods != null ? checkedInitMethods : this.initMethods);\n\t\t\tif (!initMethodsToIterate.isEmpty()) {\n\t\t\t\tfor (LifecycleElement element : initMethodsToIterate) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking init method on bean '\" + beanName + \"': \" + element.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\telement.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isQualifierMatch(qualifier,beanName,beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the named bean declares a qualifier of the given name.\n\t * @param qualifier the qualifier to match\n\t * @param beanName the name of the candidate bean\n\t * @param beanFactory the factory from which to retrieve the named bean\n\t * @return {@code true} if either the bean definition (in the XML case)\n\t * or the bean's factory method (in the {@code @Bean} case) defines a matching\n\t * qualifier value (through {@code <qualifier>} or {@code @Qualifier})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifier",
      "beanName",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "boolean",
    "signature": "public boolean isQualifierMatch(Predicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic static boolean isQualifierMatch(\n\t\t\tPredicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory) {\n\n\t\t// Try quick bean name or alias match first...\n\t\tif (qualifier.test(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (beanFactory != null) {\n\t\t\tfor (String alias : beanFactory.getAliases(beanName)) {\n\t\t\t\tif (qualifier.test(alias)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tClass<?> beanType = beanFactory.getType(beanName);\n\t\t\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\t\tBeanDefinition bd = cbf.getMergedBeanDefinition(beanName);\n\t\t\t\t\t// Explicit qualifier metadata on bean definition? (typically in XML definition)\n\t\t\t\t\tif (bd instanceof AbstractBeanDefinition abd) {\n\t\t\t\t\t\tAutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName());\n\t\t\t\t\t\tif (candidate != null) {\n\t\t\t\t\t\t\tObject value = candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY);\n\t\t\t\t\t\t\tif (value != null && qualifier.test(value.toString())) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Corresponding qualifier on factory method? (typically in configuration class)\n\t\t\t\t\tif (bd instanceof RootBeanDefinition rbd) {\n\t\t\t\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\t\t\t\tif (factoryMethod != null) {\n\t\t\t\t\t\t\tQualifier targetAnnotation = AnnotationUtils.getAnnotation(factoryMethod, Qualifier.class);\n\t\t\t\t\t\t\tif (targetAnnotation != null) {\n\t\t\t\t\t\t\t\treturn qualifier.test(targetAnnotation.value());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Corresponding qualifier on bean implementation class? (for custom user types)\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\tQualifier targetAnnotation = AnnotationUtils.getAnnotation(beanType, Qualifier.class);\n\t\t\t\t\tif (targetAnnotation != null) {\n\t\t\t\t\t\treturn qualifier.test(targetAnnotation.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore - can't compare qualifiers for a manually registered singleton object\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#needsRefresh(metadata,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given injection metadata needs to be refreshed.\n\t * @param metadata the existing metadata instance\n\t * @param clazz the current target class\n\t * @return {@code true} indicating a refresh, {@code false} otherwise\n\t * @see #needsRefresh(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz)",
    "source_code": "\tpublic static boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz) {\n\t\treturn (metadata == null || metadata.needsRefresh(clazz));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\t\ttry {\n\t\t\tmetadata.invokeDestroyMethods(bean, beanName);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tString msg = \"Destroy method on bean with name '\" + beanName + \"' threw an exception\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, ex.getTargetException());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + ex.getTargetException());\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.warn(\"Failed to invoke destroy method on bean with name '\" + beanName + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\t\ttry {\n\t\t\tmetadata.invokeInitMethods(bean, beanName);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Invocation of init method failed\", ex.getTargetException());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Failed to invoke init method\", ex);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanDefinition, beanType);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#qualifiedBeanOfType(beanFactory,beanType,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a\n\t * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given\n\t * qualifier, or having a bean name matching the given qualifier.\n\t * @param beanFactory the factory to get the target bean from (also searching ancestors)\n\t * @param beanType the type of bean to retrieve\n\t * @param qualifier the qualifier for selecting between multiple bean matches\n\t * @return the matching bean of type {@code T} (never {@code null})\n\t * @throws NoUniqueBeanDefinitionException if multiple matching beans of type {@code T} found\n\t * @throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found\n\t * @throws BeansException if the bean could not be created\n\t * @see BeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanType",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "T",
    "signature": "public T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)",
    "source_code": "\tpublic static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(beanFactory, \"BeanFactory must not be null\");\n\n\t\tif (beanFactory instanceof ListableBeanFactory lbf) {\n\t\t\t// Full qualifier matching supported.\n\t\t\treturn qualifiedBeanOfType(lbf, beanType, qualifier);\n\t\t}\n\t\telse if (beanFactory.containsBean(qualifier)) {\n\t\t\t// Fallback: target bean at least found by bean name.\n\t\t\treturn beanFactory.getBean(qualifier, beanType);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchBeanDefinitionException(qualifier, \"No matching \" + beanType.getSimpleName() +\n\t\t\t\t\t\" bean found for bean name '\" + qualifier +\n\t\t\t\t\t\"'! (Note: Qualifier matching not supported because given \" +\n\t\t\t\t\t\"BeanFactory does not implement ConfigurableListableBeanFactory.)\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#qualifiedBeansOfType(beanFactory,beanType,qualifier)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve all beans of type {@code T} from the given {@code BeanFactory} declaring a\n\t * qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given\n\t * qualifier, or having a bean name matching the given qualifier.\n\t * @param beanFactory the factory to get the target beans from (also searching ancestors)\n\t * @param beanType the type of beans to retrieve\n\t * @param qualifier the qualifier for selecting among all type matches\n\t * @return the matching beans of type {@code T}\n\t * @throws BeansException if any of the matching beans could not be created\n\t * @since 5.1.1\n\t * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanType",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "T>",
    "signature": "public T> qualifiedBeansOfType(ListableBeanFactory beanFactory, Class<T> beanType, String qualifier)",
    "source_code": "\tpublic static <T> Map<String, T> qualifiedBeansOfType(\n\t\t\tListableBeanFactory beanFactory, Class<T> beanType, String qualifier) throws BeansException {\n\n\t\tString[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanType);\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tfor (String beanName : candidateBeans) {\n\t\t\tif (isQualifierMatch(qualifier::equals, beanName, beanFactory)) {\n\t\t\t\tresult.put(beanName, beanFactory.getBean(beanName, beanType));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forFactoryMethod(declaringClass,methodName,parameterTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link AutowiredInstantiationArgumentsResolver} that\n\t * resolves arguments for the specified factory method.\n\t * @param declaringClass the class that declares the factory method\n\t * @param methodName the factory method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link AutowiredInstantiationArgumentsResolver} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declaringClass",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "AutowiredInstantiationArgumentsResolver",
    "signature": "public AutowiredInstantiationArgumentsResolver forFactoryMethod(Class<?> declaringClass, String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static AutowiredInstantiationArgumentsResolver forFactoryMethod(\n\t\t\tClass<?> declaringClass, String methodName, Class<?>... parameterTypes) {\n\n\t\tAssert.notNull(declaringClass, \"DeclaringClass must not be null\");\n\t\tAssert.hasText(methodName, \"MethodName must not be empty\");\n\t\tAssert.notNull(parameterTypes, \"ParameterTypes must not be null\");\n\t\tAssert.noNullElements(parameterTypes,\n\t\t\t\t\"ParameterTypes must not contain null elements\");\n\t\treturn new AutowiredInstantiationArgumentsResolver(\n\t\t\t\tnew FactoryMethodLookup(declaringClass, methodName, parameterTypes),\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex) {\n\t\treturn generateCode(parameterTypes, startIndex, \"args\");\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex,variableName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex",
      "variableName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex,\n\t\t\tString variableName)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex,\n\t\t\tString variableName) {\n\n\t\tAssert.notNull(parameterTypes, \"ParameterTypes must not be null\");\n\t\tAssert.notNull(variableName, \"VariableName must not be null\");\n\t\tboolean ambiguous = isAmbiguous();\n\t\tCodeBlock.Builder builder = CodeBlock.builder();\n\t\tfor (int i = startIndex; i < parameterTypes.length; i++) {\n\t\t\tbuilder.add((i != startIndex) ? \", \" : \"\");\n\t\t\tif (!ambiguous) {\n\t\t\t\tbuilder.add(\"$L.get($L)\", variableName, i - startIndex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.add(\"$L.get($L, $T.class)\", variableName, i - startIndex,\n\t\t\t\t\t\tparameterTypes[i]);\n\t\t\t}\n\t\t}\n\t\treturn builder.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Object value, ResolvableType type)",
    "source_code": "\t\tpublic CodeBlock generateCode(Object value, ResolvableType type) {\n\t\t\tif (value instanceof BeanReference beanReference) {\n\t\t\t\treturn CodeBlock.of(\"new $T($S)\", RuntimeBeanReference.class,\n\t\t\t\t\t\tbeanReference.getBeanName());\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionCode(elementType,collection)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ResolvableType elementType, T collection)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ResolvableType elementType, T collection) {\n\t\t\treturn generateCollectionOf(collection, this.collectionType, elementType);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionCode(elementType,set)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "set"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ResolvableType elementType, Set<?> set)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ResolvableType elementType, Set<?> set) {\n\t\t\tif (set instanceof LinkedHashSet) {\n\t\t\t\treturn CodeBlock.of(\"new $T($L)\", LinkedHashSet.class,\n\t\t\t\t\t\tgenerateCollectionOf(set, List.class, elementType));\n\t\t\t}\n\t\t\tset = orderForCodeConsistency(set);\n\t\t\treturn super.generateCollectionCode(elementType, set);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCollectionOf(collection,collectionType,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collection",
      "collectionType",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionOf(Collection<?> collection,\n\t\t\t\tClass<?> collectionType, ResolvableType elementType)",
    "source_code": "\t\tprotected final CodeBlock generateCollectionOf(Collection<?> collection,\n\t\t\t\tClass<?> collectionType, ResolvableType elementType) {\n\t\t\tBuilder builder = CodeBlock.builder();\n\t\t\tbuilder.add(\"$T.of(\", collectionType);\n\t\t\tIterator<?> iterator = collection.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject element = iterator.next();\n\t\t\t\tbuilder.add(\"$L\", BeanDefinitionPropertyValueCodeGenerator.this\n\t\t\t\t\t\t.generateCode(element, elementType));\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tbuilder.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.add(\")\");\n\t\t\treturn builder.build();\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,constructorOrFactoryMethod,allowDirectSupplierShortcut)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "constructorOrFactoryMethod",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode,\n\t\t\tExecutable constructorOrFactoryMethod, boolean allowDirectSupplierShortcut) {\n\n\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\tbeanRegistrationCode.getClassName(),\n\t\t\t\tbeanRegistrationCode.getMethodGenerator(), allowDirectSupplierShortcut)\n\t\t\t\t\t\t.generateCode(this.registeredBean, constructorOrFactoryMethod);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateNewBeanDefinitionCode(generationContext,beanType,beanRegistrationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanType",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\tpublic CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode) {\n\n\t\tCodeBlock.Builder builder = CodeBlock.builder();\n\t\tbuilder.addStatement(generateBeanTypeCode(beanType));\n\t\tbuilder.addStatement(\"$T $L = new $T($L)\", RootBeanDefinition.class,\n\t\t\t\tBEAN_DEFINITION_VARIABLE, RootBeanDefinition.class, BEAN_TYPE_VARIABLE);\n\t\treturn builder.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateReturnCode(generationContext,beanRegistrationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateReturnCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode)",
    "source_code": "\tpublic CodeBlock generateReturnCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode) {\n\n\t\tCodeBlock.Builder builder = CodeBlock.builder();\n\t\tbuilder.addStatement(\"return $L\", BEAN_DEFINITION_VARIABLE);\n\t\treturn builder.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition,\n\t\t\tPredicate<String> attributeFilter)",
    "source_code": "\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(\n\t\t\tGenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, RootBeanDefinition beanDefinition,\n\t\t\tPredicate<String> attributeFilter) {\n\n\t\treturn new BeanDefinitionPropertiesCodeGenerator(\n\t\t\t\tgenerationContext.getRuntimeHints(), attributeFilter,\n\t\t\t\tbeanRegistrationCode.getMethodGenerator(),\n\t\t\t\t(name, value) -> generateValueCode(generationContext, name, value))\n\t\t\t\t\t\t.generateCode(beanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateSetBeanInstanceSupplierCode(generationContext,beanRegistrationCode,instanceSupplierCode,postProcessors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "instanceSupplierCode",
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanInstanceSupplierCode(GenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, CodeBlock instanceSupplierCode,\n\t\t\tList<MethodReference> postProcessors)",
    "source_code": "\tpublic CodeBlock generateSetBeanInstanceSupplierCode(\n\t\t\tGenerationContext generationContext,\n\t\t\tBeanRegistrationCode beanRegistrationCode, CodeBlock instanceSupplierCode,\n\t\t\tList<MethodReference> postProcessors) {\n\n\t\tCodeBlock.Builder builder = CodeBlock.builder();\n\t\tif (postProcessors.isEmpty()) {\n\t\t\tbuilder.addStatement(\"$L.setInstanceSupplier($L)\", BEAN_DEFINITION_VARIABLE,\n\t\t\t\t\tinstanceSupplierCode);\n\t\t\treturn builder.build();\n\t\t}\n\t\tbuilder.addStatement(\"$T $L = $L\",\n\t\t\t\tParameterizedTypeName.get(InstanceSupplier.class,\n\t\t\t\t\t\tthis.registeredBean.getBeanClass()),\n\t\t\t\tINSTANCE_SUPPLIER_VARIABLE, instanceSupplierCode);\n\t\tfor (MethodReference postProcessor : postProcessors) {\n\t\t\tbuilder.addStatement(\"$L = $L.andThen($L)\", INSTANCE_SUPPLIER_VARIABLE,\n\t\t\t\t\tINSTANCE_SUPPLIER_VARIABLE, postProcessor.toCodeBlock());\n\t\t}\n\t\tbuilder.addStatement(\"$L.setInstanceSupplier($L)\", BEAN_DEFINITION_VARIABLE,\n\t\t\t\tINSTANCE_SUPPLIER_VARIABLE);\n\t\treturn builder.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateValueCode(generationContext,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generationContext",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateValueCode(GenerationContext generationContext,\n\t\t\tString name, Object value)",
    "source_code": "\tprotected CodeBlock generateValueCode(GenerationContext generationContext,\n\t\t\tString name, Object value) {\n\n\t\tRegisteredBean innerRegisteredBean = getInnerRegisteredBean(value);\n\t\tif (innerRegisteredBean != null) {\n\t\t\tBeanDefinitionMethodGenerator methodGenerator = this.beanDefinitionMethodGeneratorFactory\n\t\t\t\t\t.getBeanDefinitionMethodGenerator(innerRegisteredBean, name);\n\t\t\tAssert.state(methodGenerator != null, \"Unexpected filtering of inner-bean\");\n\t\t\tMethodReference generatedMethod = methodGenerator\n\t\t\t\t\t.generateBeanDefinitionMethod(generationContext,\n\t\t\t\t\t\t\tthis.beanRegistrationsCode);\n\t\t\treturn generatedMethod.toInvokeCodeBlock();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#getAccessVisibility(registeredBean,member)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "registeredBean",
      "member"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "AccessVisibility",
    "signature": "protected AccessVisibility getAccessVisibility(RegisteredBean registeredBean,\n\t\t\tMember member)",
    "source_code": "\tprotected AccessVisibility getAccessVisibility(RegisteredBean registeredBean,\n\t\t\tMember member) {\n\n\t\tAccessVisibility beanTypeAccessVisibility = AccessVisibility\n\t\t\t\t.forResolvableType(registeredBean.getBeanType());\n\t\tAccessVisibility memberAccessVisibility = AccessVisibility.forMember(member);\n\t\treturn AccessVisibility.lowest(beanTypeAccessVisibility, memberAccessVisibility);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolve(registeredBean,ThrowingFunction<AutowiredArguments,generator)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve arguments for the specified registered bean and provide them to\n\t * the given generator in order to return a result.\n\t * @param registeredBean the registered bean\n\t * @param generator the generator to execute with the resolved constructor\n\t * or factory method arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "ThrowingFunction<AutowiredArguments",
      "generator"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "T",
    "signature": "public T resolve(RegisteredBean registeredBean,\n\t\t\tThrowingFunction<AutowiredArguments, T> generator)",
    "source_code": "\tpublic <T> T resolve(RegisteredBean registeredBean,\n\t\t\tThrowingFunction<AutowiredArguments, T> generator) {\n\n\t\tAssert.notNull(registeredBean, \"RegisteredBean must not be null\");\n\t\tAssert.notNull(generator, \"Action must not be null\");\n\t\tAutowiredArguments resolved = resolveArguments(registeredBean,\n\t\t\t\tthis.lookup.get(registeredBean));\n\t\treturn generator.apply(resolved);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#resolveAndInstantiate(registeredBean,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve arguments for the specified registered bean and instantiate a new\n\t * instance using reflection.\n\t * @param registeredBean the registered bean\n\t * @param requiredType the required result type\n\t * @return an instance of the bean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "T",
    "signature": "public T resolveAndInstantiate(RegisteredBean registeredBean,\n\t\t\tClass<T> requiredType)",
    "source_code": "\tpublic <T> T resolveAndInstantiate(RegisteredBean registeredBean,\n\t\t\tClass<T> requiredType) {\n\n\t\tAssert.notNull(registeredBean, \"RegisteredBean must not be null\");\n\t\tAssert.notNull(registeredBean, \"RequiredType must not be null\");\n\t\tExecutable executable = this.lookup.get(registeredBean);\n\t\tAutowiredArguments arguments = resolveArguments(registeredBean, executable);\n\t\tObject instance = instantiate(registeredBean.getBeanFactory(), executable,\n\t\t\t\targuments.toArray());\n\t\tAssert.isInstanceOf(requiredType, instance);\n\t\treturn (T) instance;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addGenericArgumentValue(value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a generic argument value to be matched by type.\n\t * <p>Note: A single generic argument value will just be used once,\n\t * rather than matched multiple times.\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addGenericArgumentValue(Object value, String type)",
    "source_code": "\tpublic void addGenericArgumentValue(Object value, String type) {\n\t\tthis.genericArgumentValues.add(new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param newValue the argument value in the form of a ValueHolder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, ValueHolder newValue)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, ValueHolder newValue) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tAssert.notNull(newValue, \"ValueHolder must not be null\");\n\t\taddOrMergeIndexedArgumentValue(index, newValue);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param value the argument value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, @Nullable Object value)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, @Nullable Object value) {\n\t\taddIndexedArgumentValue(index, new ValueHolder(value));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, @Nullable Object value, String type)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, @Nullable Object value, String type) {\n\t\taddIndexedArgumentValue(index, new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addScope(scopeName,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given scope to this configurer's map of scopes.\n\t * @param scopeName the name of the scope\n\t * @param scope the scope implementation\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void addScope(String scopeName, Scope scope) {\n\t\tif (this.scopes == null) {\n\t\t\tthis.scopes = new LinkedHashMap<>(1);\n\t\t}\n\t\tthis.scopes.put(scopeName, scope);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType) {\n\t\treturn getArgumentValue(index, requiredType, null, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @param requiredName the parameter name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName) {\n\t\treturn getArgumentValue(index, requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName,usedValueHolders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match (can be {@code null}\n\t * to find an untyped argument value)\n\t * @param requiredName the parameter name to match (can be {@code null}\n\t * to find an unnamed argument value, or empty String to match any name)\n\t * @param usedValueHolders a Set of ValueHolder objects that have already\n\t * been used in the current resolution process and should therefore not\n\t * be returned again (allowing to return the next generic argument match\n\t * in case of multiple generic argument values of the same type)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName",
      "usedValueHolders"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType,\n\t\t\t@Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType,\n\t\t\t@Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders) {\n\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tValueHolder valueHolder = getIndexedArgumentValue(index, requiredType, requiredName);\n\t\tif (valueHolder == null) {\n\t\t\tvalueHolder = getGenericArgumentValue(requiredType, requiredName, usedValueHolders);\n\t\t}\n\t\treturn valueHolder;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getGenericArgumentValue(requiredType,requiredName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for a generic argument value that matches the given type.\n\t * @param requiredType the type to match\n\t * @param requiredName the name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName) {\n\t\treturn getGenericArgumentValue(requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getGenericArgumentValue(requiredType,requiredName,usedValueHolders)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look for the next generic argument value that matches the given type,\n\t * ignoring argument values that have already been used in the current\n\t * resolution process.\n\t * @param requiredType the type to match (can be {@code null} to find\n\t * an arbitrary next generic argument value)\n\t * @param requiredName the name to match (can be {@code null} to not\n\t * match argument values by name, or empty String to match any name)\n\t * @param usedValueHolders a Set of ValueHolder objects that have already been used\n\t * in the current resolution process and should therefore not be returned again\n\t * @return the ValueHolder for the argument, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "requiredName",
      "usedValueHolders"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName,\n\t\t\t@Nullable Set<ValueHolder> usedValueHolders)",
    "source_code": "\tpublic ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName,\n\t\t\t@Nullable Set<ValueHolder> usedValueHolders) {\n\n\t\tfor (ValueHolder valueHolder : this.genericArgumentValues) {\n\t\t\tif (usedValueHolders != null && usedValueHolders.contains(valueHolder)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (valueHolder.getName() != null && (requiredName == null ||\n\t\t\t\t\t(!requiredName.isEmpty() && !requiredName.equals(valueHolder.getName())))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (valueHolder.getType() != null && (requiredType == null ||\n\t\t\t\t\t!ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (requiredType != null && valueHolder.getType() == null && valueHolder.getName() == null &&\n\t\t\t\t\t!ClassUtils.isAssignableValue(requiredType, valueHolder.getValue())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn valueHolder;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getIndexedArgumentValue(index,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the type to match (can be {@code null} to match\n\t * untyped values only)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType)",
    "source_code": "\tpublic ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType) {\n\t\treturn getIndexedArgumentValue(index, requiredType, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getIndexedArgumentValue(index,requiredType,requiredName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the type to match (can be {@code null} to match\n\t * untyped values only)\n\t * @param requiredName the type to match (can be {@code null} to match\n\t * unnamed values only, or empty String to match any name)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName)",
    "source_code": "\tpublic ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tValueHolder valueHolder = this.indexedArgumentValues.get(index);\n\t\tif (valueHolder != null &&\n\t\t\t\t(valueHolder.getType() == null || (requiredType != null &&\n\t\t\t\t\t\tClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) &&\n\t\t\t\t(valueHolder.getName() == null || (requiredName != null &&\n\t\t\t\t\t\t(requiredName.isEmpty() || requiredName.equals(valueHolder.getName()))))) {\n\t\t\treturn valueHolder;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#setScopes(Map<String,scopes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the custom scopes that are to be registered.\n\t * <p>The keys indicate the scope names (of type String); each value\n\t * is expected to be the corresponding custom {@link Scope} instance\n\t * or class name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "scopes"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setScopes(Map<String, Object> scopes)",
    "source_code": "\tpublic void setScopes(Map<String, Object> scopes) {\n\t\tthis.scopes = scopes;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#visitIndexedArgumentValues(Map<Integer,ias)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<Integer",
      "ias"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "protected void visitIndexedArgumentValues(Map<Integer, ConstructorArgumentValues.ValueHolder> ias)",
    "source_code": "\tprotected void visitIndexedArgumentValues(Map<Integer, ConstructorArgumentValues.ValueHolder> ias) {\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : ias.values()) {\n\t\t\tObject newVal = resolveValue(valueHolder.getValue());\n\t\t\tif (!ObjectUtils.nullSafeEquals(newVal, valueHolder.getValue())) {\n\t\t\t\tvalueHolder.setValue(newVal);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#visitMap(Map<?,mapVal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "mapVal"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "protected void visitMap(Map<?, ?> mapVal)",
    "source_code": "\tprotected void visitMap(Map<?, ?> mapVal) {\n\t\tMap newContent = new LinkedHashMap();\n\t\tboolean entriesModified = false;\n\t\tfor (Map.Entry entry : mapVal.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tint keyHash = (key != null ? key.hashCode() : 0);\n\t\t\tObject newKey = resolveValue(key);\n\t\t\tint newKeyHash = (newKey != null ? newKey.hashCode() : 0);\n\t\t\tObject val = entry.getValue();\n\t\t\tObject newVal = resolveValue(val);\n\t\t\tnewContent.put(newKey, newVal);\n\t\t\tentriesModified = entriesModified || (newVal != val || newKey != key || newKeyHash != keyHash);\n\t\t}\n\t\tif (entriesModified) {\n\t\t\tmapVal.clear();\n\t\t\tmapVal.putAll(newContent);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#addProperty(propertyName,propertyValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "GroovyBeanDefinitionWrapper",
    "signature": "public GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue)",
    "source_code": "\tpublic GroovyBeanDefinitionWrapper addProperty(String propertyName, Object propertyValue) {\n\t\tif (propertyValue instanceof GroovyBeanDefinitionWrapper) {\n\t\t\tpropertyValue = ((GroovyBeanDefinitionWrapper) propertyValue).getBeanDefinition();\n\t\t}\n\t\tgetBeanDefinition().getPropertyValues().add(propertyName, propertyValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#applyPropertyToBeanDefinition(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 614
    },
    "return": "void",
    "signature": "protected void applyPropertyToBeanDefinition(String name, Object value)",
    "source_code": "\tprotected void applyPropertyToBeanDefinition(String name, Object value) {\n\t\tif (value instanceof GString) {\n\t\t\tvalue = value.toString();\n\t\t}\n\t\tif (addDeferredProperty(name, value)) {\n\t\t\treturn;\n\t\t}\n\t\telse if (value instanceof Closure) {\n\t\t\tGroovyBeanDefinitionWrapper current = this.currentBeanDefinition;\n\t\t\ttry {\n\t\t\t\tClosure<?> callable = (Closure<?>) value;\n\t\t\t\tClass<?> parameterType = callable.getParameterTypes()[0];\n\t\t\t\tif (Object.class == parameterType) {\n\t\t\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(\"\");\n\t\t\t\t\tcallable.call(this.currentBeanDefinition);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, parameterType);\n\t\t\t\t\tcallable.call((Object) null);\n\t\t\t\t}\n\n\t\t\t\tvalue = this.currentBeanDefinition.getBeanDefinition();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.currentBeanDefinition = current;\n\t\t\t}\n\t\t}\n\t\tthis.currentBeanDefinition.addProperty(name, value);\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#bean(type,Object...args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define an inner bean definition.\n\t * @param type the bean type\n\t * @param args the constructors arguments and closure configurer\n\t * @return the bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Object...args"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition bean(Class<?> type, Object...args)",
    "source_code": "\tpublic AbstractBeanDefinition bean(Class<?> type, Object...args) {\n\t\tGroovyBeanDefinitionWrapper current = this.currentBeanDefinition;\n\t\ttry {\n\t\t\tClosure<?> callable = null;\n\t\t\tCollection<Object> constructorArgs = null;\n\t\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\t\tint index = args.length;\n\t\t\t\tObject lastArg = args[index - 1];\n\t\t\t\tif (lastArg instanceof Closure<?>) {\n\t\t\t\t\tcallable = (Closure<?>) lastArg;\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\tconstructorArgs = resolveConstructorArguments(args, 0, index);\n\t\t\t}\n\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, type, constructorArgs);\n\t\t\tif (callable != null) {\n\t\t\t\tcallable.call(this.currentBeanDefinition);\n\t\t\t}\n\t\t\treturn this.currentBeanDefinition.getBeanDefinition();\n\t\t}\n\t\tfinally {\n\t\t\tthis.currentBeanDefinition = current;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,arg)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This method overrides method invocation to create beans for each method name that\n\t * takes a class argument.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "arg"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object arg)",
    "source_code": "\tpublic Object invokeMethod(String name, Object arg) {\n\t\tObject[] args = (Object[])arg;\n\t\tif (\"beans\".equals(name) && args.length == 1 && args[0] instanceof Closure) {\n\t\t\treturn beans((Closure<?>) args[0]);\n\t\t}\n\t\telse if (\"ref\".equals(name)) {\n\t\t\tString refName;\n\t\t\tif (args[0] == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Argument to ref() is not a valid bean or was not found\");\n\t\t\t}\n\t\t\tif (args[0] instanceof RuntimeBeanReference) {\n\t\t\t\trefName = ((RuntimeBeanReference) args[0]).getBeanName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\trefName = args[0].toString();\n\t\t\t}\n\t\t\tboolean parentRef = false;\n\t\t\tif (args.length > 1 && args[1] instanceof Boolean) {\n\t\t\t\tparentRef = (Boolean) args[1];\n\t\t\t}\n\t\t\treturn new RuntimeBeanReference(refName, parentRef);\n\t\t}\n\t\telse if (this.namespaces.containsKey(name) && args.length > 0 && args[0] instanceof Closure) {\n\t\t\tGroovyDynamicElementReader reader = createDynamicElementReader(name);\n\t\t\treader.invokeMethod(\"doCall\", args);\n\t\t}\n\t\telse if (args.length > 0 && args[0] instanceof Closure) {\n\t\t\t// abstract bean definition\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\telse if (args.length > 0 &&\n\t\t\t\t(args[0] instanceof Class || args[0] instanceof RuntimeBeanReference || args[0] instanceof Map)) {\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\telse if (args.length > 1 && args[args.length -1] instanceof Closure) {\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\tMetaClass mc = DefaultGroovyMethods.getMetaClass(getRegistry());\n\t\tif (!mc.respondsTo(getRegistry(), name, args).isEmpty()){\n\t\t\treturn mc.invokeMethod(getRegistry(), name, args);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 835
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\t\t\tpublic Object invokeMethod(String name, Object args) {\n\t\t\t\treturn InvokerHelper.invokeMethod(this.propertyValue, name, args);\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,obj)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object obj)",
    "source_code": "\tpublic Object invokeMethod(String name, Object obj) {\n\t\tObject[] args = (Object[]) obj;\n\t\tif (name.equals(\"doCall\")) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tClosure<Object> callable = (Closure<Object>) args[0];\n\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\tcallable.setDelegate(this);\n\t\t\tObject result = callable.call();\n\n\t\t\tif (this.callAfterInvocation) {\n\t\t\t\tafterInvocation();\n\t\t\t\tthis.callAfterInvocation = false;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tStreamingMarkupBuilder builder = new StreamingMarkupBuilder();\n\t\t\tString myNamespace = this.rootNamespace;\n\t\t\tMap<String, String> myNamespaces = this.xmlNamespaces;\n\n\t\t\tClosure<Object> callable = new Closure<>(this) {\n\t\t\t\t@Override\n\t\t\t\tpublic Object call(Object... arguments) {\n\t\t\t\t\t((GroovyObject) getProperty(\"mkp\")).invokeMethod(\"declareNamespace\", new Object[] {myNamespaces});\n\t\t\t\t\tint len = args.length;\n\t\t\t\t\tif (len > 0 && args[len-1] instanceof Closure<?> callable) {\n\t\t\t\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\t\t\t\tcallable.setDelegate(builder);\n\t\t\t\t\t}\n\t\t\t\t\treturn ((GroovyObject) ((GroovyObject) getDelegate()).getProperty(myNamespace)).invokeMethod(name, args);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\tcallable.setDelegate(builder);\n\t\t\tWritable writable = (Writable) builder.bind(callable);\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\ttry {\n\t\t\t\twritable.writeTo(sw);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\n\t\t\tElement element = this.delegate.getReaderContext().readDocumentFromString(sw.toString()).getDocumentElement();\n\t\t\tthis.delegate.initDefaults(element);\n\t\t\tif (this.decorating) {\n\t\t\t\tBeanDefinitionHolder holder = this.beanDefinition.getBeanDefinitionHolder();\n\t\t\t\tholder = this.delegate.decorateIfRequired(element, holder, null);\n\t\t\t\tthis.beanDefinition.setBeanDefinitionHolder(holder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBeanDefinition beanDefinition = this.delegate.parseCustomElement(element);\n\t\t\t\tif (beanDefinition != null) {\n\t\t\t\t\tthis.beanDefinition.setBeanDefinition((AbstractBeanDefinition) beanDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.callAfterInvocation) {\n\t\t\t\tafterInvocation();\n\t\t\t\tthis.callAfterInvocation = false;\n\t\t\t}\n\t\t\treturn element;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#resolveConstructorArguments(args,start,end)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "start",
      "end"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "List<Object>",
    "signature": "protected List<Object> resolveConstructorArguments(Object[] args, int start, int end)",
    "source_code": "\tprotected List<Object> resolveConstructorArguments(Object[] args, int start, int end) {\n\t\tObject[] constructorArgs = Arrays.copyOfRange(args, start, end);\n\t\tfor (int i = 0; i < constructorArgs.length; i++) {\n\t\t\tif (constructorArgs[i] instanceof GString) {\n\t\t\t\tconstructorArgs[i] = constructorArgs[i].toString();\n\t\t\t}\n\t\t\telse if (constructorArgs[i] instanceof List) {\n\t\t\t\tconstructorArgs[i] = manageListIfNecessary((List<?>) constructorArgs[i]);\n\t\t\t}\n\t\t\telse if (constructorArgs[i] instanceof Map){\n\t\t\t\tconstructorArgs[i] = manageMapIfNecessary((Map<?, ?>) constructorArgs[i]);\n\t\t\t}\n\t\t}\n\t\treturn Arrays.asList(constructorArgs);\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setProperty(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "void",
    "signature": "public void setProperty(String name, Object value)",
    "source_code": "\t\t\tpublic void setProperty(String name, Object value) {\n\t\t\t\tInvokerHelper.setProperty(this.propertyValue, name, value);\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setProperty(property,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 790
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\t\tpublic void setProperty(String property, Object newValue) {\n\t\t\tif (!addDeferredProperty(property, newValue)) {\n\t\t\t\tthis.beanDefinition.getBeanDefinition().getPropertyValues().add(property, newValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setVariable(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void setVariable(String name, Object value)",
    "source_code": "\t\t\tpublic void setVariable(String name, Object value) {\n\t\t\t\tif (currentBeanDefinition != null) {\n\t\t\t\t\tapplyPropertyToBeanDefinition(name, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsuper.setVariable(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#xmlns(Map<String,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Define a Spring XML namespace definition to use.\n\t * @param definition the namespace definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "public void xmlns(Map<String, String> definition)",
    "source_code": "\tpublic void xmlns(Map<String, String> definition) {\n\t\tif (!definition.isEmpty()) {\n\t\t\tfor (Map.Entry<String,String> entry : definition.entrySet()) {\n\t\t\t\tString namespace = entry.getKey();\n\t\t\t\tString uri = entry.getValue();\n\t\t\t\tif (uri == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Namespace definition must supply a non-null URI\");\n\t\t\t\t}\n\t\t\t\tNamespaceHandler namespaceHandler =\n\t\t\t\t\t\tthis.groovyDslXmlBeanDefinitionReader.getNamespaceHandlerResolver().resolve(uri);\n\t\t\t\tif (namespaceHandler == null) {\n\t\t\t\t\tthrow new BeanDefinitionParsingException(new Problem(\"No namespace handler found for URI: \" + uri,\n\t\t\t\t\t\t\tnew Location(new DescriptiveResource((\"Groovy\")))));\n\t\t\t\t}\n\t\t\t\tthis.namespaces.put(namespace, uri);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#add(index,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 1952
    },
    "return": "void",
    "signature": "public void add(int index, BeanPostProcessor element)",
    "source_code": "\t\tpublic void add(int index, BeanPostProcessor element) {\n\t\t\tsuper.add(index, element);\n\t\t\tbeanPostProcessorCache = null;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addAll(index,c)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 2001
    },
    "return": "boolean",
    "signature": "public boolean addAll(int index, Collection<? extends BeanPostProcessor> c)",
    "source_code": "\t\tpublic boolean addAll(int index, Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(index, c);\n\t\t\tif (success) {\n\t\t\t\tbeanPostProcessorCache = null;\n\t\t\t}\n\t\t\treturn success;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessAfterInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsBeforeInstantiation(beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply InstantiationAwareBeanPostProcessors to the specified bean definition\n\t * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.\n\t * <p>Any returned object will be used as the bean instead of actually instantiating\n\t * the target bean. A {@code null} return value from the post-processor will\n\t * result in the target bean being instantiated.\n\t * @param beanClass the class of the bean to be instantiated\n\t * @param beanName the name of the bean\n\t * @return the bean object to use instead of a default instance of the target bean, or {@code null}\n\t * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1124
    },
    "return": "Object",
    "signature": "protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\tObject result = bp.postProcessBeforeInstantiation(beanClass, beanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tapplyPropertyValues(beanName, bd, bw, bd.getPropertyValues());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyMergedBeanDefinitionPostProcessors(mbd,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,\n\t * invoking their {@code postProcessMergedBeanDefinition} methods.\n\t * @param mbd the merged bean definition for the bean\n\t * @param beanType the actual type of the managed bean instance\n\t * @param beanName the name of the bean\n\t * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1080
    },
    "return": "void",
    "signature": "protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName)",
    "source_code": "\tprotected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyPropertyValues(beanName,mbd,bw,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given property values, resolving any runtime references\n\t * to other beans in this bean factory. Must use deep copy, so we\n\t * don't permanently modify this property.\n\t * @param beanName the bean name passed for better exception information\n\t * @param mbd the merged bean definition\n\t * @param bw the BeanWrapper wrapping the target object\n\t * @param pvs the new property values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1616
    },
    "return": "void",
    "signature": "protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)",
    "source_code": "\tprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n\t\tif (pvs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMutablePropertyValues mpvs = null;\n\t\tList<PropertyValue> original;\n\n\t\tif (pvs instanceof MutablePropertyValues) {\n\t\t\tmpvs = (MutablePropertyValues) pvs;\n\t\t\tif (mpvs.isConverted()) {\n\t\t\t\t// Shortcut: use the pre-converted values as-is.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValues(mpvs);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginal = mpvs.getPropertyValueList();\n\t\t}\n\t\telse {\n\t\t\toriginal = Arrays.asList(pvs.getPropertyValues());\n\t\t}\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\t\tBeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n\t\t// Create a deep copy, resolving any references for values.\n\t\tList<PropertyValue> deepCopy = new ArrayList<>(original.size());\n\t\tboolean resolveNecessary = false;\n\t\tfor (PropertyValue pv : original) {\n\t\t\tif (pv.isConverted()) {\n\t\t\t\tdeepCopy.add(pv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString propertyName = pv.getName();\n\t\t\t\tObject originalValue = pv.getValue();\n\t\t\t\tif (originalValue == AutowiredPropertyMarker.INSTANCE) {\n\t\t\t\t\tMethod writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();\n\t\t\t\t\tif (writeMethod == null) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Autowire marker for property without write method: \" + pv);\n\t\t\t\t\t}\n\t\t\t\t\toriginalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);\n\t\t\t\t}\n\t\t\t\tObject resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n\t\t\t\tObject convertedValue = resolvedValue;\n\t\t\t\tboolean convertible = bw.isWritableProperty(propertyName) &&\n\t\t\t\t\t\t!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n\t\t\t\tif (convertible) {\n\t\t\t\t\tconvertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n\t\t\t\t}\n\t\t\t\t// Possibly store converted value in merged bean definition,\n\t\t\t\t// in order to avoid re-conversion for every created bean instance.\n\t\t\t\tif (resolvedValue == originalValue) {\n\t\t\t\t\tif (convertible) {\n\t\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse if (convertible && originalValue instanceof TypedStringValue &&\n\t\t\t\t\t\t!((TypedStringValue) originalValue).isDynamic() &&\n\t\t\t\t\t\t!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveNecessary = true;\n\t\t\t\t\tdeepCopy.add(new PropertyValue(pv, convertedValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mpvs != null && !resolveNecessary) {\n\t\t\tmpvs.setConverted();\n\t\t}\n\n\t\t// Set our (possibly massaged) deep copy.\n\t\ttry {\n\t\t\tbw.setPropertyValues(new MutablePropertyValues(deepCopy));\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tif (bd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR) {\n\t\t\treturn autowireConstructor(beanClass.getName(), bd, null, null).getWrappedInstance();\n\t\t}\n\t\telse {\n\t\t\tObject bean = getInstantiationStrategy().instantiate(bd, null, this);\n\t\t\tpopulateBean(beanClass.getName(), bd, new BeanWrapperImpl(bean));\n\t\t\treturn bean;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException {\n\n\t\tif (autowireMode == AUTOWIRE_CONSTRUCTOR) {\n\t\t\tthrow new IllegalArgumentException(\"AUTOWIRE_CONSTRUCTOR not supported for existing bean instance\");\n\t\t}\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd =\n\t\t\t\tnew RootBeanDefinition(ClassUtils.getUserClass(existingBean), autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireByName(beanName,mbd,bw,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Fill in any missing property values with references to\n\t * other beans in this factory if autowire is set to \"byName\".\n\t * @param beanName the name of the bean we're wiring up.\n\t * Useful for debugging messages; not used functionally.\n\t * @param mbd bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1428
    },
    "return": "void",
    "signature": "protected void autowireByName(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)",
    "source_code": "\tprotected void autowireByName(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\tif (containsBean(propertyName)) {\n\t\t\t\tObject bean = getBean(propertyName);\n\t\t\t\tpvs.add(propertyName, bean);\n\t\t\t\tregisterDependentBean(propertyName, beanName);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireByType(beanName,mbd,bw,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract method defining \"autowire by type\" (bean properties by type) behavior.\n\t * <p>This is like PicoContainer default, in which there must be exactly one bean\n\t * of the property type in the bean factory. This makes bean factories simple to\n\t * configure for small namespaces, but doesn't work as well as standard Spring\n\t * behavior for bigger applications.\n\t * @param beanName the name of the bean to autowire by type\n\t * @param mbd the merged bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1462
    },
    "return": "void",
    "signature": "protected void autowireByType(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)",
    "source_code": "\tprotected void autowireByType(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\ttry {\n\t\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\t\t// Don't try autowiring by type for type Object: never makes sense,\n\t\t\t\t// even if it technically is a unsatisfied, non-simple property.\n\t\t\t\tif (Object.class != pd.getPropertyType()) {\n\t\t\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t\t// Do not allow eager init for type matching in case of a prioritized post-processor.\n\t\t\t\t\tboolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);\n\t\t\t\t\tDependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n\t\t\t\t\tObject autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n\t\t\t\t\tif (autowiredArgument != null) {\n\t\t\t\t\t\tpvs.add(propertyName, autowiredArgument);\n\t\t\t\t\t}\n\t\t\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\t\t\tregisterDependentBean(autowiredBeanName, beanName);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" +\n\t\t\t\t\t\t\t\t\tpropertyName + \"' to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tautowiredBeanNames.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireConstructor(beanName,mbd,ctors,explicitArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "ctors",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1341
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkDependencies(beanName,mbd,pds,pvs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a dependency check that all properties exposed have been set,\n\t * if desired. Dependency checks can be objects (collaborating beans),\n\t * simple (primitives and String), or all (both).\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param pds the relevant property descriptors for the target bean\n\t * @param pvs the property values to be applied to the bean\n\t * @see #isExcludedFromDependencyCheck(java.beans.PropertyDescriptor)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "pds",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1588
    },
    "return": "void",
    "signature": "protected void checkDependencies(String beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)",
    "source_code": "\tprotected void checkDependencies(\n\t\t\tString beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)\n\t\t\tthrows UnsatisfiedDependencyException {\n\n\t\tint dependencyCheck = mbd.getDependencyCheck();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && (pvs == null || !pvs.contains(pd.getName()))) {\n\t\t\t\tboolean isSimple = BeanUtils.isSimpleProperty(pd.getPropertyType());\n\t\t\t\tboolean unsatisfied = (dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_ALL) ||\n\t\t\t\t\t\t(isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLE) ||\n\t\t\t\t\t\t(!isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\tif (unsatisfied) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, pd.getName(),\n\t\t\t\t\t\t\t\"Set this property value or disable dependency checking for this bean.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkForAliasCircle(name,alias)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Also checks for an alias overriding a bean definition of the same name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 1120
    },
    "return": "void",
    "signature": "protected void checkForAliasCircle(String name, String alias)",
    "source_code": "\tprotected void checkForAliasCircle(String name, String alias) {\n\t\tsuper.checkForAliasCircle(name, alias);\n\t\tif (!isAllowBeanDefinitionOverriding() && containsBeanDefinition(alias)) {\n\t\t\tthrow new IllegalStateException(\"Cannot register alias '\" + alias +\n\t\t\t\t\t\"' for name '\" + name + \"': Alias would override bean definition '\" + alias + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkGenericTypeMatch(bdHolder,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given dependency type with its generic type information against the given\n\t * candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "boolean",
    "signature": "protected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tprotected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tResolvableType dependencyType = descriptor.getResolvableType();\n\t\tif (dependencyType.getType() instanceof Class) {\n\t\t\t// No generic type -> we know it's a Class type-match, so no need to check again.\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvableType targetType = null;\n\t\tboolean cacheType = false;\n\t\tRootBeanDefinition rbd = null;\n\t\tif (bdHolder.getBeanDefinition() instanceof RootBeanDefinition) {\n\t\t\trbd = (RootBeanDefinition) bdHolder.getBeanDefinition();\n\t\t}\n\t\tif (rbd != null) {\n\t\t\ttargetType = rbd.targetType;\n\t\t\tif (targetType == null) {\n\t\t\t\tcacheType = true;\n\t\t\t\t// First, check factory method return type, if applicable\n\t\t\t\ttargetType = getReturnTypeForFactoryMethod(rbd, descriptor);\n\t\t\t\tif (targetType == null) {\n\t\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(rbd);\n\t\t\t\t\tif (dbd != null) {\n\t\t\t\t\t\ttargetType = dbd.targetType;\n\t\t\t\t\t\tif (targetType == null) {\n\t\t\t\t\t\t\ttargetType = getReturnTypeForFactoryMethod(dbd, descriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\t// Regular case: straight bean instance, with BeanFactory available.\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tClass<?> beanType = this.beanFactory.getType(bdHolder.getBeanName());\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanType));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Fallback: no BeanFactory set, or no type resolvable through it\n\t\t\t// -> best-effort match against the target class if applicable.\n\t\t\tif (targetType == null && rbd != null && rbd.hasBeanClass() && rbd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = rbd.getBeanClass();\n\t\t\t\tif (!FactoryBean.class.isAssignableFrom(beanClass)) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (cacheType) {\n\t\t\trbd.targetType = targetType;\n\t\t}\n\t\tif (descriptor.fallbackMatchAllowed() &&\n\t\t\t\t(targetType.hasUnresolvableGenerics() || targetType.resolve() == Properties.class)) {\n\t\t\t// Fallback matches allow unresolvable generics, e.g. plain HashMap to Map<String,String>;\n\t\t\t// and pragmatically also java.util.Properties to any Map (since despite formally being a\n\t\t\t// Map<Object,Object>, java.util.Properties is usually perceived as a Map<String,String>).\n\t\t\treturn true;\n\t\t}\n\t\t// Full check for complex generic type match...\n\t\treturn dependencyType.isAssignableFrom(targetType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkMergedBeanDefinition(mbd,beanName,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given merged bean definition,\n\t * potentially throwing validation exceptions.\n\t * @param mbd the merged bean definition to check\n\t * @param beanName the name of the bean\n\t * @param args the arguments for bean creation, if any\n\t * @throws BeanDefinitionStoreException in case of validation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1431
    },
    "return": "void",
    "signature": "protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)",
    "source_code": "\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tif (mbd.isAbstract()) {\n\t\t\tthrow new BeanIsAbstractException(beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#configureBean(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\tpublic Object configureBean(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition mbd = getMergedBeanDefinition(beanName);\n\t\tRootBeanDefinition bd = null;\n\t\tif (mbd instanceof RootBeanDefinition rbd) {\n\t\t\tbd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition());\n\t\t}\n\t\tif (bd == null) {\n\t\t\tbd = new RootBeanDefinition(mbd);\n\t\t}\n\t\tif (!bd.isPrototype()) {\n\t\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\t\tbd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader());\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(beanName, bd, bw);\n\t\treturn initializeBean(beanName, existingBean, bd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\treturn createBean(beanClass.getName(), bd, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBean(beanName,mbd,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Central method of this class: creates a bean instance,\n\t * populates the bean instance, applies post-processors, etc.\n\t * @see #doCreateBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "Object",
    "signature": "protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n\t\t}\n\t\tRootBeanDefinition mbdToUse = mbd;\n\n\t\t// Make sure bean class is actually resolved at this point, and\n\t\t// clone the bean definition in case of a dynamically resolved Class\n\t\t// which cannot be stored in the shared merged bean definition.\n\t\tClass<?> resolvedClass = resolveBeanClass(mbd, beanName);\n\t\tif (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n\t\t\tmbdToUse = new RootBeanDefinition(mbd);\n\t\t\tmbdToUse.setBeanClass(resolvedClass);\n\t\t}\n\n\t\t// Prepare method overrides.\n\t\ttry {\n\t\t\tmbdToUse.prepareMethodOverrides();\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n\t\t\t\t\tbeanName, \"Validation of method overrides failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\n\t\t\tif (bean != null) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n\t\t\t\t\t\"BeanPostProcessor before instantiation of bean failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\t\tcatch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n\t\t\t// A previously detected exception with proper bean creation context already,\n\t\t\t// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBeanInstance(beanName,mbd,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n\t * factory method, constructor autowiring, or simple instantiation.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a BeanWrapper for the new instance\n\t * @see #obtainFromSupplier\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t * @see #instantiateBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1146
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n\t\t// Make sure bean class is actually resolved at this point.\n\t\tClass<?> beanClass = resolveBeanClass(mbd, beanName);\n\n\t\tif (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n\t\t}\n\n\t\tSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\n\t\tif (instanceSupplier != null) {\n\t\t\treturn obtainFromSupplier(instanceSupplier, beanName);\n\t\t}\n\n\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t\t}\n\n\t\t// Shortcut when re-creating the same bean...\n\t\tboolean resolved = false;\n\t\tboolean autowireNecessary = false;\n\t\tif (args == null) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (resolved) {\n\t\t\tif (autowireNecessary) {\n\t\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn instantiateBean(beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\t// Candidate constructors for autowiring?\n\t\tConstructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\t\tif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n\t\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t\t}\n\n\t\t// Preferred constructors for default construction?\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n\n\t\t// No special handling: simply use no-arg constructor.\n\t\treturn instantiateBean(beanName, mbd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createDependencyProvider(descriptor,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 2111
    },
    "return": "Object",
    "signature": "public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\treturn new Jsr330Provider(descriptor, beanName);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#destroyBean(beanName,bean,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the given bean instance (usually a prototype instance\n\t * obtained from this factory) according to the given bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bean the bean instance to destroy\n\t * @param mbd the merged bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1182
    },
    "return": "void",
    "signature": "protected void destroyBean(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void destroyBean(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tnew DisposableBeanAdapter(\n\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware).destroy();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#destroyBean(beanName,beanInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 1171
    },
    "return": "void",
    "signature": "public void destroyBean(String beanName, Object beanInstance)",
    "source_code": "\tpublic void destroyBean(String beanName, Object beanInstance) {\n\t\tdestroyBean(beanName, beanInstance, getMergedLocalBeanDefinition(beanName));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determineAutowireCandidate(Map<String,candidates,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the autowire candidate in the given set of beans.\n\t * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).\n\t * @param candidates a Map of candidate names and candidate instances\n\t * that match the required type, as returned by {@link #findAutowireCandidates}\n\t * @param descriptor the target dependency to match against\n\t * @return the name of the autowire candidate, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 1612
    },
    "return": "String",
    "signature": "protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor)",
    "source_code": "\tprotected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {\n\t\tClass<?> requiredType = descriptor.getDependencyType();\n\t\tString primaryCandidate = determinePrimaryCandidate(candidates, requiredType);\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\t\tString priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);\n\t\tif (priorityCandidate != null) {\n\t\t\treturn priorityCandidate;\n\t\t}\n\t\t// Fallback\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif ((beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) ||\n\t\t\t\t\tmatchesBeanName(candidateName, descriptor.getDependencyName())) {\n\t\t\t\treturn candidateName;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determineHighestPriorityCandidate(Map<String,candidates,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the candidate with the highest priority in the given set of beans.\n\t * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related\n\t * {@link org.springframework.core.Ordered} interface, the lowest value has\n\t * the highest priority.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the candidate with the highest priority,\n\t * or {@code null} if none found\n\t * @see #getPriority(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1681
    },
    "return": "String",
    "signature": "protected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType)",
    "source_code": "\tprotected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString highestPriorityBeanName = null;\n\t\tInteger highestPriority = null;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null) {\n\t\t\t\tInteger candidatePriority = getPriority(beanInstance);\n\t\t\t\tif (candidatePriority != null) {\n\t\t\t\t\tif (highestPriorityBeanName != null) {\n\t\t\t\t\t\tif (candidatePriority.equals(highestPriority)) {\n\t\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\t\"Multiple beans found with the same priority ('\" + highestPriority +\n\t\t\t\t\t\t\t\t\t\"') among candidates: \" + candidates.keySet());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (candidatePriority < highestPriority) {\n\t\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn highestPriorityBeanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determinePrimaryCandidate(Map<String,candidates,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the primary candidate in the given set of beans.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see #isPrimary(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1643
    },
    "return": "String",
    "signature": "protected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType)",
    "source_code": "\tprotected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString primaryBeanName = null;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n\t\t\t\t\tif (candidateLocal && primaryLocal) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidates.keySet());\n\t\t\t\t\t}\n\t\t\t\t\telse if (candidateLocal) {\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doCreateBean(beanName,mbd,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually create the specified bean. Pre-creation processing has already happened\n\t * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n\t * <p>Differentiates between default bean instantiation, use of a\n\t * factory method, and autowiring a constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t * @see #instantiateBean\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "Object",
    "signature": "protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\tObject bean = instanceWrapper.getWrappedInstance();\n\t\tClass<?> beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.postProcessed = true;\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n\t\t\t\tthrow (BeanCreationException) ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doGetBean(name,requiredType,args,typeCheckOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @param typeCheckOnly whether the instance is obtained for a type check,\n\t * not for actual use\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "requiredType",
      "args",
      "typeCheckOnly"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "T",
    "signature": "protected T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)",
    "source_code": "\tprotected <T> T doGetBean(\n\t\t\tString name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)\n\t\t\tthrows BeansException {\n\n\t\tString beanName = transformedBeanName(name);\n\t\tObject beanInstance;\n\n\t\t// Eagerly check singleton cache for manually registered singletons.\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\tif (sharedInstance != null && args == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\tlogger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n\t\t\t\t\t\t\t\"' that is not fully initialized yet - a consequence of a circular reference\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t\t}\n\n\t\telse {\n\t\t\t// Fail if we're already creating this bean instance:\n\t\t\t// We're assumably within a circular reference.\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// Check if bean definition exists in this factory.\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// Not found -> check parent.\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory abf) {\n\t\t\t\t\treturn abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t}\n\t\t\t\telse if (args != null) {\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t}\n\t\t\t\telse if (requiredType != null) {\n\t\t\t\t\t// No args -> delegate to standard getBean method.\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\tStartupStep beanCreation = this.applicationStartup.start(\"spring.beans.instantiate\")\n\t\t\t\t\t.tag(\"beanName\", name);\n\t\t\ttry {\n\t\t\t\tif (requiredType != null) {\n\t\t\t\t\tbeanCreation.tag(\"beanType\", requiredType::toString);\n\t\t\t\t}\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create bean instance.\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t// It's a prototype -> create a new instance.\n\t\t\t\t\tObject prototypeInstance = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\tif (!StringUtils.hasLength(scopeName)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No scope name defined for bean '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbeanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t\tthrow new ScopeNotActiveException(beanName, scopeName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tbeanCreation.tag(\"exception\", ex.getClass().toString());\n\t\t\t\tbeanCreation.tag(\"message\", String.valueOf(ex.getMessage()));\n\t\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tbeanCreation.end();\n\t\t\t}\n\t\t}\n\n\t\treturn adaptBeanInstance(name, beanInstance, requiredType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doResolveDependency(descriptor,beanName,autowiredBeanNames,typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 1299
    },
    "return": "Object",
    "signature": "public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\tObject shortcut = descriptor.resolveShortcut(this);\n\t\t\tif (shortcut != null) {\n\t\t\t\treturn shortcut;\n\t\t\t}\n\n\t\t\tClass<?> type = descriptor.getDependencyType();\n\t\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof String) {\n\t\t\t\t\tString strVal = resolveEmbeddedValue((String) value);\n\t\t\t\t\tBeanDefinition bd = (beanName != null && containsBean(beanName) ?\n\t\t\t\t\t\t\tgetMergedBeanDefinition(beanName) : null);\n\t\t\t\t\tvalue = evaluateBeanDefinitionString(strVal, bd);\n\t\t\t\t}\n\t\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\t\ttry {\n\t\t\t\t\treturn converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t\t// A custom TypeConverter which does not support TypeDescriptor resolution...\n\t\t\t\t\treturn (descriptor.getField() != null ?\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getField()) :\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tif (multipleBeans != null) {\n\t\t\t\treturn multipleBeans;\n\t\t\t}\n\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString autowiredBeanName;\n\t\t\tObject instanceCandidate;\n\n\t\t\tif (matchingBeans.size() > 1) {\n\t\t\t\tautowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n\t\t\t\tif (autowiredBeanName == null) {\n\t\t\t\t\tif (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n\t\t\t\t\t\treturn descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// In case of an optional Collection/Map, silently ignore a non-unique case:\n\t\t\t\t\t\t// possibly it was meant to be an empty collection of multiple regular beans\n\t\t\t\t\t\t// (before 4.3 in particular when we didn't even look for collection beans).\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinstanceCandidate = matchingBeans.get(autowiredBeanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have exactly one match.\n\t\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n\t\t\t\tautowiredBeanName = entry.getKey();\n\t\t\t\tinstanceCandidate = entry.getValue();\n\t\t\t}\n\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.add(autowiredBeanName);\n\t\t\t}\n\t\t\tif (instanceCandidate instanceof Class) {\n\t\t\t\tinstanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);\n\t\t\t}\n\t\t\tObject result = instanceCandidate;\n\t\t\tif (result instanceof NullBean) {\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t\tif (!ClassUtils.isAssignableValue(type, result)) {\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluateBeanDefinitionString(value,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the given String as contained in a bean definition,\n\t * potentially resolving it as an expression.\n\t * @param value the value to check\n\t * @param beanDefinition the bean definition that the value comes from\n\t * @return the resolved value\n\t * @see #setBeanExpressionResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 1565
    },
    "return": "Object",
    "signature": "protected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition)",
    "source_code": "\tprotected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition) {\n\t\tif (this.beanExpressionResolver == null) {\n\t\t\treturn value;\n\t\t}\n\n\t\tScope scope = null;\n\t\tif (beanDefinition != null) {\n\t\t\tString scopeName = beanDefinition.getScope();\n\t\t\tif (scopeName != null) {\n\t\t\t\tscope = getRegisteredScope(scopeName);\n\t\t\t}\n\t\t}\n\t\treturn this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#filterPropertyDescriptorsForDependencyCheck(bw,cache)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @param cache whether to cache filtered PropertyDescriptors for the given bean Class\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t * @see #filterPropertyDescriptorsForDependencyCheck(org.springframework.beans.BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 1534
    },
    "return": "PropertyDescriptor[]",
    "signature": "protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache)",
    "source_code": "\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache) {\n\t\tPropertyDescriptor[] filtered = this.filteredPropertyDescriptorsCache.get(bw.getWrappedClass());\n\t\tif (filtered == null) {\n\t\t\tfiltered = filterPropertyDescriptorsForDependencyCheck(bw);\n\t\t\tif (cache) {\n\t\t\t\tPropertyDescriptor[] existing =\n\t\t\t\t\t\tthis.filteredPropertyDescriptorsCache.putIfAbsent(bw.getWrappedClass(), filtered);\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tfiltered = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findAnnotationOnBean(beanName, annotationType, true);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findMergedAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAutowireCandidates(beanName,requiredType,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find bean instances that match the required type.\n\t * Called during autowiring for the specified bean.\n\t * @param beanName the name of the bean that is about to be wired\n\t * @param requiredType the actual type of bean to look for\n\t * (may be an array component type or collection element type)\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @return a Map of candidate names and candidate instances that match\n\t * the required type (never {@code null})\n\t * @throws BeansException in case of errors\n\t * @see #autowireByType\n\t * @see #autowireConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "requiredType",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 1533
    },
    "return": "Object>",
    "signature": "protected Object> findAutowireCandidates(@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor)",
    "source_code": "\tprotected Map<String, Object> findAutowireCandidates(\n\t\t\t@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {\n\n\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tthis, requiredType, true, descriptor.isEager());\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\tfor (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {\n\t\t\tClass<?> autowiringType = classObjectEntry.getKey();\n\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n\t\t\t\tObject autowiringValue = classObjectEntry.getValue();\n\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (String candidate : candidateNames) {\n\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n\t\tif (result.isEmpty()) {\n\t\t\tboolean multiple = indicatesMultipleBeans(requiredType);\n\t\t\t// Consider fallback matches if the first pass failed to find anything...\n\t\t\tDependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();\n\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&\n\t\t\t\t\t\t(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {\n\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isEmpty() && !multiple) {\n\t\t\t\t// Consider self references as a final pass...\n\t\t\t\t// but in the case of a dependency collection, not the very same bean itself.\n\t\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t\tif (isSelfReference(beanName, candidate) &&\n\t\t\t\t\t\t\t(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&\n\t\t\t\t\t\t\tisAutowireCandidate(candidate, fallbackDescriptor)) {\n\t\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn doGetBean(name, null, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn doGetBean(name, requiredType, null, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "T",
    "signature": "public T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n\t\t\tthrows BeansException {\n\n\t\treturn doGetBean(name, requiredType, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tObject resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);\n\t\tif (resolved == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t\treturn (T) resolved;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tif (!isConfigurationFrozen() || type == null || !allowEagerInit) {\n\t\t\treturn doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);\n\t\t}\n\t\tMap<Class<?>, String[]> cache =\n\t\t\t\t(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);\n\t\tString[] resolvedBeanNames = cache.get(type);\n\t\tif (resolvedBeanNames != null) {\n\t\t\treturn resolvedBeanNames;\n\t\t}\n\t\tresolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);\n\t\tif (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {\n\t\t\tcache.put(type, resolvedBeanNames);\n\t\t}\n\t\treturn resolvedBeanNames;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new BeanObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, null, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, args, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, false);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfAvailable();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, true);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfUnique();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForTypedStream(requiredType, allowEagerInit))\n\t\t\t\t\t\t.map(name -> (T) getBean(name))\n\t\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\tString[] beanNames = getBeanNamesForTypedStream(requiredType, allowEagerInit);\n\t\t\t\tif (beanNames.length == 0) {\n\t\t\t\t\treturn Stream.empty();\n\t\t\t\t}\n\t\t\t\tMap<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\t\tfor (String beanName : beanNames) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, (T) beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStream<T> stream = matchingBeans.values().stream();\n\t\t\t\treturn stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(\n\t\t\t@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {\n\n\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tMap<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\ttry {\n\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\tresult.put(beanName, (T) beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\tString exBeanName = bce.getBeanName();\n\t\t\t\t\tif (exBeanName != null && isCurrentlyInCreation(exBeanName)) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring match to currently created bean '\" + exBeanName + \"': \" +\n\t\t\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getEarlyBeanReference(beanName,mbd,bean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a reference for early access to the specified bean,\n\t * typically for the purpose of resolving a circular reference.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param bean the raw bean instance\n\t * @return the object to expose as bean reference\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 947
    },
    "return": "Object",
    "signature": "protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean)",
    "source_code": "\tprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\texposedObject = bp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getMergedBeanDefinition(beanName,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a RootBeanDefinition for the given top-level bean, by merging with\n\t * the parent if the given bean's definition is a child bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bd the original bean definition (Root/ChildBeanDefinition)\n\t * @return a (potentially merged) RootBeanDefinition for the given bean\n\t * @throws BeanDefinitionStoreException in case of an invalid bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1313
    },
    "return": "RootBeanDefinition",
    "signature": "protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)",
    "source_code": "\tprotected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\treturn getMergedBeanDefinition(beanName, bd, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getMergedBeanDefinition(beanName,bd,containingBd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a RootBeanDefinition for the given bean, by merging with the\n\t * parent if the given bean's definition is a child bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bd the original bean definition (Root/ChildBeanDefinition)\n\t * @param containingBd the containing bean definition in case of inner bean,\n\t * or {@code null} in case of a top-level bean\n\t * @return a (potentially merged) RootBeanDefinition for the given bean\n\t * @throws BeanDefinitionStoreException in case of an invalid bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bd",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1329
    },
    "return": "RootBeanDefinition",
    "signature": "protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)",
    "source_code": "\tprotected RootBeanDefinition getMergedBeanDefinition(\n\t\t\tString beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tsynchronized (this.mergedBeanDefinitions) {\n\t\t\tRootBeanDefinition mbd = null;\n\t\t\tRootBeanDefinition previous = null;\n\n\t\t\t// Check with full lock now in order to enforce the same merged instance.\n\t\t\tif (containingBd == null) {\n\t\t\t\tmbd = this.mergedBeanDefinitions.get(beanName);\n\t\t\t}\n\n\t\t\tif (mbd == null || mbd.stale) {\n\t\t\t\tprevious = mbd;\n\t\t\t\tif (bd.getParentName() == null) {\n\t\t\t\t\t// Use copy of given root bean definition.\n\t\t\t\t\tif (bd instanceof RootBeanDefinition rootBeanDef) {\n\t\t\t\t\t\tmbd = rootBeanDef.cloneBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmbd = new RootBeanDefinition(bd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Child bean definition: needs to be merged with parent.\n\t\t\t\t\tBeanDefinition pbd;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString parentBeanName = transformedBeanName(bd.getParentName());\n\t\t\t\t\t\tif (!beanName.equals(parentBeanName)) {\n\t\t\t\t\t\t\tpbd = getMergedBeanDefinition(parentBeanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (getParentBeanFactory() instanceof ConfigurableBeanFactory parent) {\n\t\t\t\t\t\t\t\tpbd = parent.getMergedBeanDefinition(parentBeanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(parentBeanName,\n\t\t\t\t\t\t\t\t\t\t\"Parent name '\" + parentBeanName + \"' is equal to bean name '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\t\t\"': cannot be resolved without a ConfigurableBeanFactory parent\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Could not resolve parent bean definition '\" + bd.getParentName() + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\t// Deep copy with overridden values.\n\t\t\t\t\tmbd = new RootBeanDefinition(pbd);\n\t\t\t\t\tmbd.overrideFrom(bd);\n\t\t\t\t}\n\n\t\t\t\t// Set default singleton scope, if not configured before.\n\t\t\t\tif (!StringUtils.hasLength(mbd.getScope())) {\n\t\t\t\t\tmbd.setScope(SCOPE_SINGLETON);\n\t\t\t\t}\n\n\t\t\t\t// A bean contained in a non-singleton bean cannot be a singleton itself.\n\t\t\t\t// Let's correct this on the fly here, since this might be the result of\n\t\t\t\t// parent-child merging for the outer bean, in which case the original inner bean\n\t\t\t\t// definition will not have inherited the merged outer bean's singleton status.\n\t\t\t\tif (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {\n\t\t\t\t\tmbd.setScope(containingBd.getScope());\n\t\t\t\t}\n\n\t\t\t\t// Cache the merged bean definition for the time being\n\t\t\t\t// (it might still get re-merged later on in order to pick up metadata changes)\n\t\t\t\tif (containingBd == null && isCacheBeanMetadata()) {\n\t\t\t\t\tthis.mergedBeanDefinitions.put(beanName, mbd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (previous != null) {\n\t\t\t\tcopyRelevantMergedBeanDefinitionCaches(previous, mbd);\n\t\t\t}\n\t\t\treturn mbd;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectForBeanInstance(beanInstance,name,beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden in order to implicitly register the currently created bean as\n\t * dependent on further beans getting programmatically retrieved during a\n\t * {@link Supplier} callback.\n\t * @since 5.0\n\t * @see #obtainFromSupplier\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanInstance",
      "name",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1256
    },
    "return": "Object",
    "signature": "protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object getObjectForBeanInstance(\n\t\t\tObject beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {\n\n\t\tString currentlyCreatedBean = this.currentlyCreatedBean.get();\n\t\tif (currentlyCreatedBean != null) {\n\t\t\tregisterDependentBean(beanName, currentlyCreatedBean);\n\t\t}\n\n\t\treturn super.getObjectForBeanInstance(beanInstance, name, beanName, mbd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getReturnTypeForFactoryMethod(rbd,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rbd",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor)",
    "source_code": "\tprotected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor) {\n\t\t// Should typically be set for any kind of factory method, since the BeanFactory\n\t\t// pre-resolves them before reaching out to the AutowireCandidateResolver...\n\t\tResolvableType returnType = rbd.factoryMethodReturnType;\n\t\tif (returnType == null) {\n\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\treturnType = ResolvableType.forMethodReturnType(factoryMethod);\n\t\t\t}\n\t\t}\n\t\tif (returnType != null) {\n\t\t\tClass<?> resolvedClass = returnType.resolve();\n\t\t\tif (resolvedClass != null && descriptor.getDependencyType().isAssignableFrom(resolvedClass)) {\n\t\t\t\t// Only use factory method metadata if the return type is actually expressive enough\n\t\t\t\t// for our dependency. Otherwise, the returned instance type may have matched instead\n\t\t\t\t// in case of a singleton instance having been registered with the container already.\n\t\t\t\treturn returnType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getTypeForFactoryBean(beanName,mbd,allowInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation attempts to query the FactoryBean's generic parameter metadata\n\t * if present to determine the object type. If not present, i.e. the FactoryBean is\n\t * declared as a raw type, checks the FactoryBean's {@code getObjectType} method\n\t * on a plain instance of the FactoryBean, without bean properties applied yet.\n\t * If this doesn't return a type yet, and {@code allowInit} is {@code true} a\n\t * full creation of the FactoryBean is used as fallback (through delegation to the\n\t * superclass's implementation).\n\t * <p>The shortcut check for a FactoryBean is only applied in case of a singleton\n\t * FactoryBean. If the FactoryBean instance itself is not kept as singleton,\n\t * it will be fully created to check the type of its exposed object.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "allowInit"
    ],
    "position": {
      "column": 1,
      "line": 832
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit)",
    "source_code": "\tprotected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit) {\n\t\t// Check if the bean definition itself has defined the type with an attribute\n\t\tResolvableType result = getTypeForFactoryBeanFromAttributes(mbd);\n\t\tif (result != ResolvableType.NONE) {\n\t\t\treturn result;\n\t\t}\n\n\t\tResolvableType beanType =\n\t\t\t\t(mbd.hasBeanClass() ? ResolvableType.forClass(mbd.getBeanClass()) : ResolvableType.NONE);\n\n\t\t// For instance supplied beans try the target type and bean class\n\t\tif (mbd.getInstanceSupplier() != null) {\n\t\t\tresult = getFactoryBeanGeneric(mbd.targetType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = getFactoryBeanGeneric(beanType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// Consider factory methods\n\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\tString factoryMethodName = mbd.getFactoryMethodName();\n\n\t\t// Scan the factory bean methods\n\t\tif (factoryBeanName != null) {\n\t\t\tif (factoryMethodName != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from its factory method\n\t\t\t\t// declaration without instantiating the containing bean at all.\n\t\t\t\tBeanDefinition factoryBeanDefinition = getBeanDefinition(factoryBeanName);\n\t\t\t\tClass<?> factoryBeanClass;\n\t\t\t\tif (factoryBeanDefinition instanceof AbstractBeanDefinition &&\n\t\t\t\t\t\t((AbstractBeanDefinition) factoryBeanDefinition).hasBeanClass()) {\n\t\t\t\t\tfactoryBeanClass = ((AbstractBeanDefinition) factoryBeanDefinition).getBeanClass();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tRootBeanDefinition fbmbd = getMergedBeanDefinition(factoryBeanName, factoryBeanDefinition);\n\t\t\t\t\tfactoryBeanClass = determineTargetType(factoryBeanName, fbmbd);\n\t\t\t\t}\n\t\t\t\tif (factoryBeanClass != null) {\n\t\t\t\t\tresult = getTypeForFactoryBeanFromMethod(factoryBeanClass, factoryMethodName);\n\t\t\t\t\tif (result.resolve() != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If not resolvable above and the referenced factory bean doesn't exist yet,\n\t\t\t// exit here - we don't want to force the creation of another bean just to\n\t\t\t// obtain a FactoryBean's object type...\n\t\t\tif (!isBeanEligibleForMetadataCaching(factoryBeanName)) {\n\t\t\t\treturn ResolvableType.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// If we're allowed, we can create the factory bean and call getObjectType() early\n\t\tif (allowInit) {\n\t\t\tFactoryBean<?> factoryBean = (mbd.isSingleton() ?\n\t\t\t\t\tgetSingletonFactoryBeanForTypeCheck(beanName, mbd) :\n\t\t\t\t\tgetNonSingletonFactoryBeanForTypeCheck(beanName, mbd));\n\t\t\tif (factoryBean != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from this early stage of the instance.\n\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\tif (type != null) {\n\t\t\t\t\treturn ResolvableType.forClass(type);\n\t\t\t\t}\n\t\t\t\t// No type found for shortcut FactoryBean instance:\n\t\t\t\t// fall back to full creation of the FactoryBean instance.\n\t\t\t\treturn super.getTypeForFactoryBean(beanName, mbd, true);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryBeanName == null && mbd.hasBeanClass() && factoryMethodName != null) {\n\t\t\t// No early bean instantiation possible: determine FactoryBean's type from\n\t\t\t// static factory method signature or from class inheritance hierarchy...\n\t\t\treturn getTypeForFactoryBeanFromMethod(mbd.getBeanClass(), factoryMethodName);\n\t\t}\n\t\tresult = getFactoryBeanGeneric(beanType);\n\t\tif (result.resolve() != null) {\n\t\t\treturn result;\n\t\t}\n\t\treturn ResolvableType.NONE;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#initializeBean(beanName,bean,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given bean instance, applying factory callbacks\n\t * as well as init methods and bean post processors.\n\t * <p>Called from {@link #createBean} for traditionally defined beans,\n\t * and from {@link #initializeBean} for existing bean instances.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @return the initialized bean instance (potentially wrapped)\n\t * @see BeanNameAware\n\t * @see BeanClassLoaderAware\n\t * @see BeanFactoryAware\n\t * @see #applyBeanPostProcessorsBeforeInitialization\n\t * @see #invokeInitMethods\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1742
    },
    "return": "Object",
    "signature": "protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tinvokeAwareMethods(beanName, bean);\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null),\n\t\t\t\t\tbeanName, \"Invocation of init method failed\", ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#initializeBean(existingBean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\tpublic Object initializeBean(Object existingBean, String beanName) {\n\t\treturn initializeBean(beanName, existingBean, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateBean(beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the given bean using its default constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1297
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {\n\t\ttry {\n\t\t\tObject beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);\n\t\t\tBeanWrapper bw = new BeanWrapperImpl(beanInstance);\n\t\t\tinitBeanWrapper(bw);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateUsingFactoryMethod(beanName,mbd,explicitArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * mbd parameter specifies a class, rather than a factoryBean, or an instance variable\n\t * on a factory object itself configured using Dependency Injection.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t * @see #getBean(String, Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1321
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"toString\":\n\t\t\t\t\treturn this.objectFactory.toString();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.objectFactory.getObject(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invokeCustomInitMethod(beanName,bean,mbd,initMethodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified custom init method on the given bean.\n\t * Called by invokeInitMethods.\n\t * <p>Can be overridden in subclasses for custom resolution of init\n\t * methods with arguments.\n\t * @see #invokeInitMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd",
      "initMethodName"
    ],
    "position": {
      "column": 1,
      "line": 1826
    },
    "return": "void",
    "signature": "protected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)",
    "source_code": "\tprotected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)\n\t\t\tthrows Throwable {\n\n\t\tMethod initMethod = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\tBeanUtils.findMethod(bean.getClass(), initMethodName) :\n\t\t\t\tClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));\n\n\t\tif (initMethod == null) {\n\t\t\tif (mbd.isEnforceInitMethod()) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\"Could not find an init method named '\" +\n\t\t\t\t\t\tinitMethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No default init method named '\" + initMethodName +\n\t\t\t\t\t\t\t\"' found on bean with name '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t\t// Ignore non-existent default lifecycle methods.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking init method  '\" + initMethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t}\n\t\tMethod methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod, bean.getClass());\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(methodToInvoke);\n\t\t\tmethodToInvoke.invoke(bean);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invokeInitMethods(beanName,bean,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Give a bean a chance to react now all its properties are set,\n\t * and a chance to know about its owning bean factory (this object).\n\t * This means checking whether the bean implements InitializingBean or defines\n\t * a custom init method, and invoking the necessary callback(s) if it does.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the merged bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @throws Throwable if thrown by init methods or by the invocation process\n\t * @see #invokeCustomInitMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1794
    },
    "return": "void",
    "signature": "protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)\n\t\t\tthrows Throwable {\n\n\t\tboolean isInitializingBean = (bean instanceof InitializingBean);\n\t\tif (isInitializingBean && (mbd == null || !mbd.hasAnyExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t}\n\n\t\tif (mbd != null && bean.getClass() != NullBean.class) {\n\t\t\tString[] initMethodNames = mbd.getInitMethodNames();\n\t\t\tif (initMethodNames != null) {\n\t\t\t\tfor (String initMethodName : initMethodNames) {\n\t\t\t\t\tif (StringUtils.hasLength(initMethodName) &&\n\t\t\t\t\t\t\t!(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) &&\n\t\t\t\t\t\t\t!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {\n\t\t\t\t\t\tinvokeCustomInitMethod(beanName, bean, mbd, initMethodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tif (!super.isAutowireCandidate(bdHolder, descriptor)) {\n\t\t\t// If explicitly false, do not proceed with any other checks...\n\t\t\treturn false;\n\t\t}\n\t\treturn checkGenericTypeMatch(bdHolder, descriptor);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 789
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(\n\t\t\tString beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(bdName)) {\n\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);\n\t\t}\n\t\telse if (containsSingleton(beanName)) {\n\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);\n\t\t}\n\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlfb) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn dlfb.isAutowireCandidate(beanName, descriptor, resolver);\n\t\t}\n\t\telse if (parent instanceof ConfigurableListableBeanFactory clfb) {\n\t\t\t// If no DefaultListableBeanFactory, can't pass the resolver along.\n\t\t\treturn clfb.isAutowireCandidate(beanName, descriptor);\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,mbd,descriptor,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param mbd the merged bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver) {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tresolveBeanClass(mbd, bdName);\n\t\tif (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {\n\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n\t\t}\n\t\tBeanDefinitionHolder holder = (beanName.equals(bdName) ?\n\t\t\t\tthis.mergedBeanDefinitionHolders.computeIfAbsent(beanName,\n\t\t\t\t\t\tkey -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :\n\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));\n\t\treturn resolver.isAutowireCandidate(holder, descriptor);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isFactoryBean(beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean is defined as a {@link FactoryBean}.\n\t * @param beanName the name of the bean\n\t * @param mbd the corresponding bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1613
    },
    "return": "boolean",
    "signature": "protected boolean isFactoryBean(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected boolean isFactoryBean(String beanName, RootBeanDefinition mbd) {\n\t\tBoolean result = mbd.isFactoryBean;\n\t\tif (result == null) {\n\t\t\tClass<?> beanType = predictBeanType(beanName, mbd, FactoryBean.class);\n\t\t\tresult = (beanType != null && FactoryBean.class.isAssignableFrom(beanType));\n\t\t\tmbd.isFactoryBean = result;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isPrimary(beanName,beanInstance)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a primary bean.\n\t * @param beanName the name of the bean\n\t * @param beanInstance the corresponding bean instance (can be null)\n\t * @return whether the given bean qualifies as primary\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 1718
    },
    "return": "boolean",
    "signature": "protected boolean isPrimary(String beanName, Object beanInstance)",
    "source_code": "\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isPrimary();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isPrimary(transformedBeanName, beanInstance));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isSetterDefinedInInterface(pd,interfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the setter method of the given bean property is defined\n\t * in any of the given interfaces.\n\t * @param pd the PropertyDescriptor of the bean property\n\t * @param interfaces the Set of interfaces (Class objects)\n\t * @return whether the setter method is defined by an interface\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pd",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces)",
    "source_code": "\tpublic static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {\n\t\tMethod setter = pd.getWriteMethod();\n\t\tif (setter != null) {\n\t\t\tClass<?> targetClass = setter.getDeclaringClass();\n\t\t\tfor (Class<?> ifc : interfaces) {\n\t\t\t\tif (ifc.isAssignableFrom(targetClass) && ClassUtils.hasMethod(ifc, setter)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isTypeMatch(name,typeToMatch,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Internal extended variant of {@link #isTypeMatch(String, ResolvableType)}\n\t * to check whether the bean with the given name matches the specified type. Allow\n\t * additional constraints to be applied to ensure that beans are not created early.\n\t * @param name the name of the bean to query\n\t * @param typeToMatch the type to match against (as a\n\t * {@code ResolvableType})\n\t * @return {@code true} if the bean type matches, {@code false} if it\n\t * doesn't match or cannot be determined yet\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 5.2\n\t * @see #getBean\n\t * @see #getType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "typeToMatch",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "boolean",
    "signature": "protected boolean isTypeMatch(String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)",
    "source_code": "\tprotected boolean isTypeMatch(String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString beanName = transformedBeanName(name);\n\t\tboolean isFactoryDereference = BeanFactoryUtils.isFactoryDereference(name);\n\n\t\t// Check manually registered singletons.\n\t\tObject beanInstance = getSingleton(beanName, false);\n\t\tif (beanInstance != null && beanInstance.getClass() != NullBean.class) {\n\t\t\tif (beanInstance instanceof FactoryBean<?> factoryBean) {\n\t\t\t\tif (!isFactoryDereference) {\n\t\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\t\treturn (type != null && typeToMatch.isAssignableFrom(type));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn typeToMatch.isInstance(beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!isFactoryDereference) {\n\t\t\t\tif (typeToMatch.isInstance(beanInstance)) {\n\t\t\t\t\t// Direct match for exposed instance?\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (typeToMatch.hasGenerics() && containsBeanDefinition(beanName)) {\n\t\t\t\t\t// Generics potentially only match on the target class, not on the proxy...\n\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t\tClass<?> targetType = mbd.getTargetType();\n\t\t\t\t\tif (targetType != null && targetType != ClassUtils.getUserClass(beanInstance)) {\n\t\t\t\t\t\t// Check raw class match as well, making sure it's exposed on the proxy.\n\t\t\t\t\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\t\t\t\t\tif (classToMatch != null && !classToMatch.isInstance(beanInstance)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeToMatch.isAssignableFrom(targetType)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tResolvableType resolvableType = mbd.targetType;\n\t\t\t\t\tif (resolvableType == null) {\n\t\t\t\t\t\tresolvableType = mbd.factoryMethodReturnType;\n\t\t\t\t\t}\n\t\t\t\t\treturn (resolvableType != null && typeToMatch.isAssignableFrom(resolvableType));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse if (containsSingleton(beanName) && !containsBeanDefinition(beanName)) {\n\t\t\t// null instance registered\n\t\t\treturn false;\n\t\t}\n\n\t\t// No singleton instance found -> check bean definition.\n\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);\n\t\t}\n\n\t\t// Retrieve corresponding bean definition.\n\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\tBeanDefinitionHolder dbd = mbd.getDecoratedDefinition();\n\n\t\t// Setup the types that we want to match against\n\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\tif (classToMatch == null) {\n\t\t\tclassToMatch = FactoryBean.class;\n\t\t}\n\t\tClass<?>[] typesToMatch = (FactoryBean.class == classToMatch ?\n\t\t\t\tnew Class<?>[] {classToMatch} : new Class<?>[] {FactoryBean.class, classToMatch});\n\n\n\t\t// Attempt to predict the bean type\n\t\tClass<?> predictedType = null;\n\n\t\t// We're looking for a regular reference, but we're a factory bean that has\n\t\t// a decorated bean definition. The target bean should be the same type\n\t\t// as FactoryBean would ultimately return.\n\t\tif (!isFactoryDereference && dbd != null && isFactoryBean(beanName, mbd)) {\n\t\t\t// We should only attempt if the user explicitly set lazy-init to true\n\t\t\t// and we know the merged bean definition is for a factory bean.\n\t\t\tif (!mbd.isLazyInit() || allowFactoryBeanInit) {\n\t\t\t\tRootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);\n\t\t\t\tClass<?> targetType = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);\n\t\t\t\tif (targetType != null && !FactoryBean.class.isAssignableFrom(targetType)) {\n\t\t\t\t\tpredictedType = targetType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we couldn't use the target type, try regular prediction.\n\t\tif (predictedType == null) {\n\t\t\tpredictedType = predictBeanType(beanName, mbd, typesToMatch);\n\t\t\tif (predictedType == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Attempt to get the actual ResolvableType for the bean.\n\t\tResolvableType beanType = null;\n\n\t\t// If it's a FactoryBean, we want to look at what it creates, not the factory class.\n\t\tif (FactoryBean.class.isAssignableFrom(predictedType)) {\n\t\t\tif (beanInstance == null && !isFactoryDereference) {\n\t\t\t\tbeanType = getTypeForFactoryBean(beanName, mbd, allowFactoryBeanInit);\n\t\t\t\tpredictedType = beanType.resolve();\n\t\t\t\tif (predictedType == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (isFactoryDereference) {\n\t\t\t// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean\n\t\t\t// type, but we nevertheless are being asked to dereference a FactoryBean...\n\t\t\t// Let's check the original bean class and proceed with it if it is a FactoryBean.\n\t\t\tpredictedType = predictBeanType(beanName, mbd, FactoryBean.class);\n\t\t\tif (predictedType == null || !FactoryBean.class.isAssignableFrom(predictedType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// We don't have an exact type but if bean definition target type or the factory\n\t\t// method return type matches the predicted type then we can use that.\n\t\tif (beanType == null) {\n\t\t\tResolvableType definedType = mbd.targetType;\n\t\t\tif (definedType == null) {\n\t\t\t\tdefinedType = mbd.factoryMethodReturnType;\n\t\t\t}\n\t\t\tif (definedType != null && definedType.resolve() == predictedType) {\n\t\t\t\tbeanType = definedType;\n\t\t\t}\n\t\t}\n\n\t\t// If we have a bean type use it so that generics are considered\n\t\tif (beanType != null) {\n\t\t\treturn typeToMatch.isAssignableFrom(beanType);\n\t\t}\n\n\t\t// If we don't have a bean type, fallback to the predicted type\n\t\treturn typeToMatch.isAssignableFrom(predictedType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(encodedResource,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified properties file.\n\t * @param encodedResource the resource descriptor for the properties file,\n\t * allowing to specify an encoding to use for parsing the file\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encodedResource",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix)",
    "source_code": "\tpublic int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading properties bean definitions from \" + encodedResource);\n\t\t}\n\n\t\tProperties props = new Properties();\n\t\ttry {\n\t\t\ttry (InputStream is = encodedResource.getResource().getInputStream()) {\n\t\t\t\tif (encodedResource.getEncoding() != null) {\n\t\t\t\t\tgetPropertiesPersister().load(props, new InputStreamReader(is, encodedResource.getEncoding()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgetPropertiesPersister().load(props, is);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint count = registerBeanDefinitions(props, prefix, encodedResource.getResource().getDescription());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loaded \" + count + \" bean definitions from \" + encodedResource);\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"Could not parse properties from \" + encodedResource.getResource(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(resource,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified properties file.\n\t * @param resource the resource descriptor for the properties file\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(Resource resource, @Nullable String prefix)",
    "source_code": "\tpublic int loadBeanDefinitions(Resource resource, @Nullable String prefix) throws BeanDefinitionStoreException {\n\t\treturn loadBeanDefinitions(new EncodedResource(resource), prefix);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#matchesBeanName(beanName,candidateName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given candidate name matches the bean name or the aliases\n\t * stored in this bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "candidateName"
    ],
    "position": {
      "column": 1,
      "line": 1752
    },
    "return": "boolean",
    "signature": "protected boolean matchesBeanName(String beanName, @Nullable String candidateName)",
    "source_code": "\tprotected boolean matchesBeanName(String beanName, @Nullable String candidateName) {\n\t\treturn (candidateName != null &&\n\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#obtainFromSupplier(supplier,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @return a BeanWrapper for the new instance\n\t * @since 5.0\n\t * @see #getObjectForBeanInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName)",
    "source_code": "\tprotected BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName) {\n\t\tObject instance = obtainInstanceFromSupplier(supplier, beanName);\n\t\tif (instance == null) {\n\t\t\tinstance = new NullBean();\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(instance);\n\t\tinitBeanWrapper(bw);\n\t\treturn bw;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#populateBean(beanName,mbd,bw)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param bw the BeanWrapper with bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1355
    },
    "return": "void",
    "signature": "protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)",
    "source_code": "\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\n\t\tboolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n\t\tif (hasInstAwareBpps) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#postProcessObjectFromFactoryBean(object,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Applies the {@code postProcessAfterInitialization} callback of all\n\t * registered BeanPostProcessors, giving them a chance to post-process the\n\t * object obtained from FactoryBeans (for example, to auto-proxy them).\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1870
    },
    "return": "Object",
    "signature": "protected Object postProcessObjectFromFactoryBean(Object object, String beanName)",
    "source_code": "\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n\t\treturn applyBeanPostProcessorsAfterInitialization(object, beanName);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,Map<?,map,prefix,resourceDescription)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get all property values, given a prefix (which will be stripped)\n\t * and add the bean they define to the factory with the given name.\n\t * @param beanName name of the bean to define\n\t * @param map a Map containing string pairs\n\t * @param prefix prefix of each entry, which will be stripped\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @throws BeansException if the bean definition could not be parsed or registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(String beanName, Map<?, ?> map, String prefix, String resourceDescription)",
    "source_code": "\tprotected void registerBeanDefinition(String beanName, Map<?, ?> map, String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tString className = null;\n\t\tString parent = null;\n\t\tString scope = BeanDefinition.SCOPE_SINGLETON;\n\t\tboolean isAbstract = false;\n\t\tboolean lazyInit = false;\n\n\t\tConstructorArgumentValues cas = new ConstructorArgumentValues();\n\t\tMutablePropertyValues pvs = new MutablePropertyValues();\n\n\t\tString prefixWithSep = prefix + SEPARATOR;\n\t\tint beginIndex = prefixWithSep.length();\n\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tString key = ((String) entry.getKey()).strip();\n\t\t\tif (key.startsWith(prefixWithSep)) {\n\t\t\t\tString property = key.substring(beginIndex);\n\t\t\t\tif (CLASS_KEY.equals(property)) {\n\t\t\t\t\tclassName = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (PARENT_KEY.equals(property)) {\n\t\t\t\t\tparent = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (ABSTRACT_KEY.equals(property)) {\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tisAbstract = TRUE_VALUE.equals(val);\n\t\t\t\t}\n\t\t\t\telse if (SCOPE_KEY.equals(property)) {\n\t\t\t\t\t// Spring 2.0 style\n\t\t\t\t\tscope = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (SINGLETON_KEY.equals(property)) {\n\t\t\t\t\t// Spring 1.2 style\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tscope = (!StringUtils.hasLength(val) || TRUE_VALUE.equals(val) ?\n\t\t\t\t\t\t\tBeanDefinition.SCOPE_SINGLETON : BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\t\t\t\telse if (LAZY_INIT_KEY.equals(property)) {\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tlazyInit = TRUE_VALUE.equals(val);\n\t\t\t\t}\n\t\t\t\telse if (property.startsWith(CONSTRUCTOR_ARG_PREFIX)) {\n\t\t\t\t\tif (property.endsWith(REF_SUFFIX)) {\n\t\t\t\t\t\tint index = Integer.parseInt(property, 1, property.length() - REF_SUFFIX.length(), 10);\n\t\t\t\t\t\tcas.addIndexedArgumentValue(index, new RuntimeBeanReference(entry.getValue().toString()));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint index = Integer.parseInt(property, 1, property.length(), 10);\n\t\t\t\t\t\tcas.addIndexedArgumentValue(index, readValue(entry));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (property.endsWith(REF_SUFFIX)) {\n\t\t\t\t\t// This isn't a real property, but a reference to another prototype\n\t\t\t\t\t// Extract property name: property is of form dog(ref)\n\t\t\t\t\tproperty = property.substring(0, property.length() - REF_SUFFIX.length());\n\t\t\t\t\tString ref = ((String) entry.getValue()).strip();\n\n\t\t\t\t\t// It doesn't matter if the referenced bean hasn't yet been registered:\n\t\t\t\t\t// this will ensure that the reference is resolved at runtime.\n\t\t\t\t\tObject val = new RuntimeBeanReference(ref);\n\t\t\t\t\tpvs.add(property, val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// It's a normal bean property.\n\t\t\t\t\tpvs.add(property, readValue(entry));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Registering bean definition for bean name '\" + beanName + \"' with \" + pvs);\n\t\t}\n\n\t\t// Just use default parent if we're not dealing with the parent itself,\n\t\t// and if there's no class name specified. The latter has to happen for\n\t\t// backwards compatibility reasons.\n\t\tif (parent == null && className == null && !beanName.equals(this.defaultParentBean)) {\n\t\t\tparent = this.defaultParentBean;\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\t\tparent, className, getBeanClassLoader());\n\t\t\tbd.setScope(scope);\n\t\t\tbd.setAbstract(isAbstract);\n\t\t\tbd.setLazyInit(lazyInit);\n\t\t\tbd.setConstructorArgumentValues(cas);\n\t\t\tbd.setPropertyValues(pvs);\n\t\t\tgetRegistry().registerBeanDefinition(beanName, bd);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new CannotLoadBeanClassException(resourceDescription, beanName, className, ex);\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\tthrow new CannotLoadBeanClassException(resourceDescription, beanName, className, err);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 951
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\tif (beanDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\ttry {\n\t\t\t\tabd.validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n\t\tif (existingDefinition != null) {\n\t\t\tif (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\telse if (existingDefinition.getRole() < beanDefinition.getRole()) {\n\t\t\t\t// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Overriding user-defined bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a framework-generated bean definition: replacing [\" +\n\t\t\t\t\t\t\texistingDefinition + \"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!beanDefinition.equals(existingDefinition)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tif (isAlias(beanName)) {\n\t\t\t\tif (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\t\tString aliasedName = canonicalName(beanName);\n\t\t\t\t\tif (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(\n\t\t\t\t\t\t\t\tbeanName, beanDefinition, getBeanDefinition(aliasedName));\n\t\t\t\t\t}\n\t\t\t\t\telse {  // alias pointing to non-existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Cannot register bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\t\"' since there is already an alias for bean '\" + aliasedName + \"' bound.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tremoveAlias(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\n\t\tif (existingDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\telse if (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map, using all property keys (i.e. not\n\t * filtering by prefix).\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(java.util.Map, String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map) throws BeansException {\n\t\treturn registerBeanDefinitions(map, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix) throws BeansException {\n\t\treturn registerBeanDefinitions(map, prefix, \"Map \" + map);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix,resourceDescription)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(Map, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\tint beanCount = 0;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tif (!(key instanceof String keyString)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Illegal key [\" + key + \"]: only Strings allowed\");\n\t\t\t}\n\t\t\tif (keyString.startsWith(prefix)) {\n\t\t\t\t// Key is of form: prefix<name>.property\n\t\t\t\tString nameAndProperty = keyString.substring(prefix.length());\n\t\t\t\t// Find dot before property name, ignoring dots in property keys.\n\t\t\t\tint sepIdx ;\n\t\t\t\tint propKeyIdx = nameAndProperty.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX);\n\t\t\t\tif (propKeyIdx != -1) {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR, propKeyIdx);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR);\n\t\t\t\t}\n\t\t\t\tif (sepIdx != -1) {\n\t\t\t\t\tString beanName = nameAndProperty.substring(0, sepIdx);\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Found bean name '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!getRegistry().containsBeanDefinition(beanName)) {\n\t\t\t\t\t\t// If we haven't already registered it...\n\t\t\t\t\t\tregisterBeanDefinition(beanName, map, prefix + beanName, resourceDescription);\n\t\t\t\t\t\t++beanCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Ignore it: It wasn't a valid bean name and property,\n\t\t\t\t\t// although it did start with the required prefix.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Invalid bean name and property [\" + nameAndProperty + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn beanCount;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(rb,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a ResourceBundle.\n\t * <p>Similar syntax as for a Map. This method is useful to enable\n\t * standard Java internationalization support.\n\t * @param rb the ResourceBundle to load from\n\t * @param prefix a filter within the keys in the map: e.g. 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rb",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(ResourceBundle rb, @Nullable String prefix)",
    "source_code": "\tpublic int registerBeanDefinitions(ResourceBundle rb, @Nullable String prefix) throws BeanDefinitionStoreException {\n\t\t// Simply create a map and call overloaded method.\n\t\tMap<String, Object> map = new HashMap<>();\n\t\tEnumeration<String> keys = rb.getKeys();\n\t\twhile (keys.hasMoreElements()) {\n\t\t\tString key = keys.nextElement();\n\t\t\tmap.put(key, rb.getObject(key));\n\t\t}\n\t\treturn registerBeanDefinitions(map, prefix);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerCustomEditor(requiredType,propertyEditorClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditorClass"
    ],
    "position": {
      "column": 1,
      "line": 852
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tAssert.notNull(propertyEditorClass, \"PropertyEditor class must not be null\");\n\t\tthis.customEditors.put(requiredType, propertyEditorClass);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerDisposableBeanIfNecessary(beanName,bean,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given bean to the list of disposable beans in this factory,\n\t * registering its DisposableBean interface and/or the given destroy method\n\t * to be called on factory shutdown (if applicable). Only applies to singletons.\n\t * @param beanName the name of the bean\n\t * @param bean the bean instance\n\t * @param mbd the bean definition for the bean\n\t * @see RootBeanDefinition#isSingleton\n\t * @see RootBeanDefinition#getDependsOn\n\t * @see #registerDisposableBean\n\t * @see #registerDependentBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1850
    },
    "return": "void",
    "signature": "protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tif (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {\n\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t// Register a DisposableBean implementation that performs all destruction\n\t\t\t\t// work for the given bean: DestructionAwareBeanPostProcessors,\n\t\t\t\t// DisposableBean interface, custom destroy method.\n\t\t\t\tregisterDisposableBean(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A bean with a custom scope...\n\t\t\t\tScope scope = this.scopes.get(mbd.getScope());\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + mbd.getScope() + \"'\");\n\t\t\t\t}\n\t\t\t\tscope.registerDestructionCallback(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerResolvableDependency(dependencyType,autowiredValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dependencyType",
      "autowiredValue"
    ],
    "position": {
      "column": 1,
      "line": 777
    },
    "return": "void",
    "signature": "public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue)",
    "source_code": "\tpublic void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {\n\t\tAssert.notNull(dependencyType, \"Dependency type must not be null\");\n\t\tif (autowiredValue != null) {\n\t\t\tif (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {\n\t\t\t\tthrow new IllegalArgumentException(\"Value [\" + autowiredValue +\n\t\t\t\t\t\t\"] does not implement specified dependency type [\" + dependencyType.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerScope(scopeName,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "void",
    "signature": "public void registerScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void registerScope(String scopeName, Scope scope) {\n\t\tAssert.notNull(scopeName, \"Scope identifier must not be null\");\n\t\tAssert.notNull(scope, \"Scope must not be null\");\n\t\tif (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot replace existing scopes 'singleton' and 'prototype'\");\n\t\t}\n\t\tScope previous = this.scopes.put(scopeName, scope);\n\t\tif (previous != null && previous != scope) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Replacing scope '\" + scopeName + \"' from [\" + previous + \"] to [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering scope '\" + scopeName + \"' with implementation [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerSingleton(beanName,singletonObject)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "singletonObject"
    ],
    "position": {
      "column": 1,
      "line": 1129
    },
    "return": "void",
    "signature": "public void registerSingleton(String beanName, Object singletonObject)",
    "source_code": "\tpublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {\n\t\tsuper.registerSingleton(beanName, singletonObject);\n\t\tupdateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));\n\t\tclearByTypeCache();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#requiresDestruction(bean,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean requires destruction on shutdown.\n\t * <p>The default implementation checks the DisposableBean interface as well as\n\t * a specified destroy method and registered DestructionAwareBeanPostProcessors.\n\t * @param bean the bean instance to check\n\t * @param mbd the corresponding bean definition\n\t * @see org.springframework.beans.factory.DisposableBean\n\t * @see AbstractBeanDefinition#getDestroyMethodName()\n\t * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1832
    },
    "return": "boolean",
    "signature": "protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) {\n\t\treturn (bean.getClass() != NullBean.class && (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) ||\n\t\t\t\t(hasDestructionAwareBeanPostProcessors() && DisposableBeanAdapter.hasApplicableProcessors(\n\t\t\t\t\t\tbean, getBeanPostProcessorCache().destructionAware))));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveAutowiringValue(autowiringValue,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given autowiring value against the given required type,\n\t * e.g. an {@link ObjectFactory} value to its actual object result.\n\t * @param autowiringValue the value to resolve\n\t * @param requiredType the type to assign the result to\n\t * @return the resolved value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autowiringValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "public Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType)",
    "source_code": "\tpublic static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {\n\t\tif (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {\n\t\t\tObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue;\n\t\t\tif (autowiringValue instanceof Serializable && requiredType.isInterface()) {\n\t\t\t\tautowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),\n\t\t\t\t\t\tnew Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn factory.getObject();\n\t\t\t}\n\t\t}\n\t\treturn autowiringValue;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeanByName(name,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) {\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\treturn getBean(name, descriptor.getDependencyType());\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeforeInstantiation(beanName,mbd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply before-instantiation post-processors, resolving whether there is a\n\t * before-instantiation shortcut for the specified bean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the shortcut-determined bean instance, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1094
    },
    "return": "Object",
    "signature": "protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n\t\tObject bean = null;\n\t\tif (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n\t\t\t// Make sure bean class is actually resolved at this point.\n\t\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\t\tClass<?> targetType = determineTargetType(beanName, mbd);\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tbean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\tif (bean != null) {\n\t\t\t\t\t\tbean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmbd.beforeInstantiationResolved = (bean != null);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveCandidate(beanName,requiredType,beanFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 1985
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\t\t\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\t\t\treturn beanFactory.getBean(beanName, args);\n\t\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException {\n\t\treturn resolveDependency(descriptor, requestingBeanName, null, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 1274
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\t\tif (Optional.class == descriptor.getDependencyType()) {\n\t\t\treturn createOptionalDependency(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (ObjectFactory.class == descriptor.getDependencyType() ||\n\t\t\t\tObjectProvider.class == descriptor.getDependencyType()) {\n\t\t\treturn new DependencyObjectProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n\t\t\treturn new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse {\n\t\t\tObject result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n\t\t\t\t\tdescriptor, requestingBeanName);\n\t\t\tif (result == null) {\n\t\t\t\tresult = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveInnerBean(innerBeanName,innerBd,BiFunction<String,RootBeanDefinition,resolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve an inner bean definition and invoke the specified {@code resolver}\n\t * on its merged bean definition.\n\t * @param innerBeanName the inner bean name (or {@code null} to assign one)\n\t * @param innerBd the inner raw bean definition\n\t * @param resolver the function to invoke to resolve\n\t * @param <T> the type of the resolution\n\t * @return a resolved inner bean, as a result of applying the {@code resolver}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "innerBeanName",
      "innerBd",
      "BiFunction<String",
      "RootBeanDefinition",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "T",
    "signature": "public T resolveInnerBean(@Nullable String innerBeanName, BeanDefinition innerBd,\n\t\t\tBiFunction<String, RootBeanDefinition, T> resolver)",
    "source_code": "\tpublic <T> T resolveInnerBean(@Nullable String innerBeanName, BeanDefinition innerBd,\n\t\t\tBiFunction<String, RootBeanDefinition, T> resolver) {\n\t\tString nameToUse = (innerBeanName != null ? innerBeanName : \"(inner bean)\"\n\t\t\t\t+ BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(innerBd));\n\t\treturn resolver.apply(nameToUse, this.beanFactory.getMergedBeanDefinition(\n\t\t\t\tnameToUse, innerBd, this.beanDefinition));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveNotUnique(type,Map<String,matchingBeans)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 2044
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\t\t\t\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {\n\t\t\t\t\treturn null;\n\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveValueIfNecessary(argName,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Given a PropertyValue, return a value, resolving any references to other\n\t * beans in the factory if necessary. The value could be:\n\t * <li>A BeanDefinition, which leads to the creation of a corresponding\n\t * new bean instance. Singleton flags and names of such \"inner beans\"\n\t * are always ignored: Inner beans are anonymous prototypes.\n\t * <li>A RuntimeBeanReference, which must be resolved.\n\t * <li>A ManagedList. This is a special collection that may contain\n\t * RuntimeBeanReferences or Collections that will need to be resolved.\n\t * <li>A ManagedSet. May also contain RuntimeBeanReferences or\n\t * Collections that will need to be resolved.\n\t * <li>A ManagedMap. In this case the value may be a RuntimeBeanReference\n\t * or Collection that will need to be resolved.\n\t * <li>An ordinary object or {@code null}, in which case it's left alone.\n\t * @param argName the name of the argument that the value is defined for\n\t * @param value the value object to resolve\n\t * @return the resolved object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object",
    "signature": "public Object resolveValueIfNecessary(Object argName, @Nullable Object value)",
    "source_code": "\tpublic Object resolveValueIfNecessary(Object argName, @Nullable Object value) {\n\t\t// We must check each value to see whether it requires a runtime reference\n\t\t// to another bean to be resolved.\n\t\tif (value instanceof RuntimeBeanReference ref) {\n\t\t\treturn resolveReference(argName, ref);\n\t\t}\n\t\telse if (value instanceof RuntimeBeanNameReference ref) {\n\t\t\tString refName = ref.getBeanName();\n\t\t\trefName = String.valueOf(doEvaluate(refName));\n\t\t\tif (!this.beanFactory.containsBean(refName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Invalid bean name '\" + refName + \"' in bean reference for \" + argName);\n\t\t\t}\n\t\t\treturn refName;\n\t\t}\n\t\telse if (value instanceof BeanDefinitionHolder bdHolder) {\n\t\t\t// Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.\n\t\t\treturn resolveInnerBean(bdHolder.getBeanName(), bdHolder.getBeanDefinition(),\n\t\t\t\t\t(name, mbd) -> resolveInnerBeanValue(argName, name, mbd));\n\t\t}\n\t\telse if (value instanceof BeanDefinition bd) {\n\t\t\treturn resolveInnerBean(null, bd,\n\t\t\t\t\t(name, mbd) -> resolveInnerBeanValue(argName, name, mbd));\n\t\t}\n\t\telse if (value instanceof DependencyDescriptor dependencyDescriptor) {\n\t\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\t\t\tObject result = this.beanFactory.resolveDependency(\n\t\t\t\t\tdependencyDescriptor, this.beanName, autowiredBeanNames, this.typeConverter);\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (this.beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, this.beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse if (value instanceof ManagedArray managedArray) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\tClass<?> elementType = managedArray.resolvedElementType;\n\t\t\tif (elementType == null) {\n\t\t\t\tString elementTypeName = managedArray.getElementTypeName();\n\t\t\t\tif (StringUtils.hasText(elementTypeName)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\telementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader());\n\t\t\t\t\t\tmanagedArray.resolvedElementType = elementType;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t// Improve the message by showing the context.\n\t\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\t\t\"Error resolving array type for \" + argName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telementType = Object.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resolveManagedArray(argName, (List<?>) value, elementType);\n\t\t}\n\t\telse if (value instanceof ManagedList<?> managedList) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedList(argName, managedList);\n\t\t}\n\t\telse if (value instanceof ManagedSet<?> managedSet) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedSet(argName, managedSet);\n\t\t}\n\t\telse if (value instanceof ManagedMap<?, ?> managedMap) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedMap(argName, managedMap);\n\t\t}\n\t\telse if (value instanceof ManagedProperties original) {\n\t\t\t// Properties original = managedProperties;\n\t\t\tProperties copy = new Properties();\n\t\t\toriginal.forEach((propKey, propValue) -> {\n\t\t\t\tif (propKey instanceof TypedStringValue typedStringValue) {\n\t\t\t\t\tpropKey = evaluate(typedStringValue);\n\t\t\t\t}\n\t\t\t\tif (propValue instanceof TypedStringValue typedStringValue) {\n\t\t\t\t\tpropValue = evaluate(typedStringValue);\n\t\t\t\t}\n\t\t\t\tif (propKey == null || propValue == null) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\t\"Error converting Properties key/value pair for \" + argName + \": resolved to null\");\n\t\t\t\t}\n\t\t\t\tcopy.put(propKey, propValue);\n\t\t\t});\n\t\t\treturn copy;\n\t\t}\n\t\telse if (value instanceof TypedStringValue typedStringValue) {\n\t\t\t// Convert value to target type here.\n\t\t\tObject valueObject = evaluate(typedStringValue);\n\t\t\ttry {\n\t\t\t\tClass<?> resolvedTargetType = resolveTargetType(typedStringValue);\n\t\t\t\tif (resolvedTargetType != null) {\n\t\t\t\t\treturn this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn valueObject;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Improve the message by showing the context.\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\"Error converting typed String value for \" + argName, ex);\n\t\t\t}\n\t\t}\n\t\telse if (value instanceof NullBean) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn evaluate(value);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#set(index,element)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 1938
    },
    "return": "BeanPostProcessor",
    "signature": "public BeanPostProcessor set(int index, BeanPostProcessor element)",
    "source_code": "\t\tpublic BeanPostProcessor set(int index, BeanPostProcessor element) {\n\t\t\tBeanPostProcessor result = super.set(index, element);\n\t\t\tbeanPostProcessorCache = null;\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#unsatisfiedNonSimpleProperties(mbd,bw)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an array of non-simple bean properties that are unsatisfied.\n\t * These are probably unsatisfied references to other beans in the\n\t * factory. Does not include simple properties like primitives or Strings.\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return an array of bean property names\n\t * @see org.springframework.beans.BeanUtils#isSimpleProperty\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1512
    },
    "return": "String[]",
    "signature": "protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw)",
    "source_code": "\tprotected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {\n\t\tSet<String> result = new TreeSet<>();\n\t\tPropertyValues pvs = mbd.getPropertyValues();\n\t\tPropertyDescriptor[] pds = bw.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&\n\t\t\t\t\t!BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n\t\t\t\tresult.add(pd.getName());\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#buildTypedStringValue(value,targetTypeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "targetTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1096
    },
    "return": "TypedStringValue",
    "signature": "protected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)",
    "source_code": "\tprotected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\tClassLoader classLoader = this.readerContext.getBeanClassLoader();\n\t\tTypedStringValue typedValue;\n\t\tif (!StringUtils.hasText(targetTypeName)) {\n\t\t\ttypedValue = new TypedStringValue(value);\n\t\t}\n\t\telse if (classLoader != null) {\n\t\t\tClass<?> targetType = ClassUtils.forName(targetTypeName, classLoader);\n\t\t\ttypedValue = new TypedStringValue(value, targetType);\n\t\t}\n\t\telse {\n\t\t\ttypedValue = new TypedStringValue(value, targetTypeName);\n\t\t}\n\t\treturn typedValue;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#buildTypedStringValueForMap(value,defaultTypeName,entryEle)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "defaultTypeName",
      "entryEle"
    ],
    "position": {
      "column": 1,
      "line": 1291
    },
    "return": "Object",
    "signature": "protected Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle)",
    "source_code": "\tprotected final Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle) {\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, defaultTypeName);\n\t\t\ttypedValue.setSource(extractSource(entryEle));\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + defaultTypeName + \"] not found for Map key/value type\", entryEle, ex);\n\t\t\treturn value;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#checkNameUniqueness(beanName,aliases,beanElement)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate that the specified bean name and aliases have not been used already\n\t * within the current level of beans element nesting.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "aliases",
      "beanElement"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "protected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement)",
    "source_code": "\tprotected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {\n\t\tString foundName = null;\n\n\t\tif (StringUtils.hasText(beanName) && this.usedNames.contains(beanName)) {\n\t\t\tfoundName = beanName;\n\t\t}\n\t\tif (foundName == null) {\n\t\t\tfoundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);\n\t\t}\n\t\tif (foundName != null) {\n\t\t\terror(\"Bean name '\" + foundName + \"' is already used in this <beans> element\", beanElement);\n\t\t}\n\n\t\tthis.usedNames.add(beanName);\n\t\tthis.usedNames.addAll(aliases);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#createBeanDefinition(className,parentName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean definition for the given class name and parent name.\n\t * @param className the name of the bean class\n\t * @param parentName the name of the bean's parent bean\n\t * @return the newly created bean definition\n\t * @throws ClassNotFoundException if bean class resolution was attempted but failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "parentName"
    ],
    "position": {
      "column": 1,
      "line": 639
    },
    "return": "AbstractBeanDefinition",
    "signature": "protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)",
    "source_code": "\tprotected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\treturn BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\tparentName, className, this.readerContext.getBeanClassLoader());\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#createDelegate(readerContext,root,parentDelegate)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "root",
      "parentDelegate"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "BeanDefinitionParserDelegate",
    "signature": "protected BeanDefinitionParserDelegate createDelegate(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate)",
    "source_code": "\tprotected BeanDefinitionParserDelegate createDelegate(\n\t\t\tXmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {\n\n\t\tBeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);\n\t\tdelegate.initDefaults(root, parentDelegate);\n\t\treturn delegate;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorate(node,definition,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tif (node instanceof Attr attr) {\n\t\t\tString propertyName = parserContext.getDelegate().getLocalName(attr);\n\t\t\tString propertyValue = attr.getValue();\n\t\t\tMutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();\n\t\t\tif (pvs.contains(propertyName)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Property '\" + propertyName + \"' is already defined using \" +\n\t\t\t\t\t\t\"both <property> and inline syntax. Only one approach may be used per property.\", attr);\n\t\t\t}\n\t\t\tif (propertyName.endsWith(REF_SUFFIX)) {\n\t\t\t\tpropertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);\n\t\t\t}\n\t\t}\n\t\treturn definition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateBeanDefinitionIfRequired(ele,originalDef)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "originalDef"
    ],
    "position": {
      "column": 1,
      "line": 1399
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef)",
    "source_code": "\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {\n\t\treturn decorateBeanDefinitionIfRequired(ele, originalDef, null);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateBeanDefinitionIfRequired(ele,originalDef,containingBd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "originalDef",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1410
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n\t\t\tElement ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tBeanDefinitionHolder finalDefinition = originalDef;\n\n\t\t// Decorate based on custom attributes first.\n\t\tNamedNodeMap attributes = ele.getAttributes();\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tNode node = attributes.item(i);\n\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t}\n\n\t\t// Decorate based on custom nested elements.\n\t\tNodeList children = ele.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode node = children.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t\t}\n\t\t}\n\t\treturn finalDefinition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateIfRequired(node,originalDef,containingBd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler,\n\t * if applicable.\n\t * @param node the current child node\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "originalDef",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1441
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateIfRequired(Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinitionHolder decorateIfRequired(\n\t\t\tNode node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tString namespaceUri = getNamespaceURI(node);\n\t\tif (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {\n\t\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\t\tif (handler != null) {\n\t\t\t\tBeanDefinitionHolder decorated =\n\t\t\t\t\t\thandler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));\n\t\t\t\tif (decorated != null) {\n\t\t\t\t\treturn decorated;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (namespaceUri.startsWith(\"http://www.springframework.org/schema/\")) {\n\t\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A custom namespace, not to be handled by Spring - maybe \"xml:...\".\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No Spring NamespaceHandler found for XML schema namespace [\" + namespaceUri + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn originalDef;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#error(message,source)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Report an error with the given message for the given source element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "protected void error(String message, Element source)",
    "source_code": "\tprotected void error(String message, Element source) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot());\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#error(message,source,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Report an error with the given message for the given source element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "source",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "protected void error(String message, Element source, Throwable cause)",
    "source_code": "\tprotected void error(String message, Element source, Throwable cause) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot(), cause);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#initDefaults(root,parent)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the default lazy-init, autowire, dependency check settings,\n\t * init-method, destroy-method and merge settings. Support nested 'beans'\n\t * element use cases by falling back to the given parent in case the\n\t * defaults are not explicitly set locally.\n\t * @see #populateDefaults(DocumentDefaultsDefinition, DocumentDefaultsDefinition, org.w3c.dom.Element)\n\t * @see #getDefaults()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "root",
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent)",
    "source_code": "\tpublic void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) {\n\t\tpopulateDefaults(this.defaults, (parent != null ? parent.defaults : null), root);\n\t\tthis.readerContext.fireDefaultsRegistered(this.defaults);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#nodeNameEquals(node,desiredName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the name of the supplied node is equal to the supplied name.\n\t * <p>The default implementation checks the supplied desired name against both\n\t * {@link Node#getNodeName()} and {@link Node#getLocalName()}.\n\t * <p>Subclasses may override the default implementation to provide a different\n\t * mechanism for comparing node names.\n\t * @param node the node to compare\n\t * @param desiredName the name to check for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "desiredName"
    ],
    "position": {
      "column": 1,
      "line": 1517
    },
    "return": "boolean",
    "signature": "public boolean nodeNameEquals(Node node, String desiredName)",
    "source_code": "\tpublic boolean nodeNameEquals(Node node, String desiredName) {\n\t\treturn desiredName.equals(node.getNodeName()) || desiredName.equals(getLocalName(node));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parse(element,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tparserContext.getReaderContext().error(\n\t\t\t\t\"Class [\" + getClass().getName() + \"] does not support custom elements.\", element);\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseArrayElement(arrayEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse an array element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arrayEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1117
    },
    "return": "Object",
    "signature": "public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {\n\t\tString elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = arrayEle.getChildNodes();\n\t\tManagedArray target = new ManagedArray(elementType, nl.getLength());\n\t\ttarget.setSource(extractSource(arrayEle));\n\t\ttarget.setElementTypeName(elementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(arrayEle));\n\t\tparseCollectionElements(nl, target, bd, elementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionAttributes(ele,beanName,containingBean,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,beanName,containingBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\tparseMetaElements(ele, bd);\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,containingBean)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parses the supplied {@code <bean>} element. May return {@code null}\n\t * if there were errors during parse. Errors are reported to the\n\t * {@link org.springframework.beans.factory.parsing.ProblemReporter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n\t\tList<String> aliases = new ArrayList<>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\t\tif (beanDefinition != null) {\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// Register an alias for the plain bean class name, if still possible,\n\t\t\t\t\t\t// if the generator returned the class name plus a suffix.\n\t\t\t\t\t\t// This is expected for Spring 1.2/2.0 backwards compatibility.\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n\t\t\t\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitions(root,delegate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the elements at the root level in the document:\n\t * \"import\", \"alias\", \"bean\".\n\t * @param root the DOM root element of the document\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "root",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n\t\tif (delegate.isDefaultNamespace(root)) {\n\t\t\tNodeList nl = root.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (node instanceof Element ele) {\n\t\t\t\t\tif (delegate.isDefaultNamespace(ele)) {\n\t\t\t\t\t\tparseDefaultElement(ele, delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdelegate.parseCustomElement(ele);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdelegate.parseCustomElement(root);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseCollectionElements(elementNodes,target,bd,defaultElementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementNodes",
      "target",
      "bd",
      "defaultElementType"
    ],
    "position": {
      "column": 1,
      "line": 1156
    },
    "return": "void",
    "signature": "protected void parseCollectionElements(NodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType)",
    "source_code": "\tprotected void parseCollectionElements(\n\t\t\tNodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType) {\n\n\t\tfor (int i = 0; i < elementNodes.getLength(); i++) {\n\t\t\tNode node = elementNodes.item(i);\n\t\t\tif (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {\n\t\t\t\ttarget.add(parsePropertySubElement((Element) node, bd, defaultElementType));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseConstructorArgElement(ele,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a constructor-arg element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 778
    },
    "return": "void",
    "signature": "public void parseConstructorArgElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n\t\tString indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n\t\tString typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (StringUtils.hasLength(indexAttr)) {\n\t\t\ttry {\n\t\t\t\tint index = Integer.parseInt(indexAttr);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\terror(\"'index' cannot be lower than 0\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry(index));\n\t\t\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\t\t\tif (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {\n\t\t\t\t\t\t\terror(\"Ambiguous constructor-arg entries for index \" + index, ele);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tthis.parseState.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\terror(\"Attribute 'index' of tag 'constructor-arg' must be an integer\", ele);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry());\n\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t}\n\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.parseState.pop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseConstructorArgElements(beanEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse constructor-arg sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 694
    },
    "return": "void",
    "signature": "public void parseConstructorArgElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n\t\t\t\tparseConstructorArgElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseCustomElement(ele,containingBd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a custom element (outside of the default namespace).\n\t * @param ele the element to parse\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the resulting bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1380
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\tif (namespaceUri == null) {\n\t\t\treturn null;\n\t\t}\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseKeyElement(keyEle,bd,defaultKeyTypeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a key sub-element of a map element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "keyEle",
      "bd",
      "defaultKeyTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1307
    },
    "return": "Object",
    "signature": "protected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName)",
    "source_code": "\tprotected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName) {\n\t\tNodeList nl = keyEle.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(\"<key> element must not contain more than one value sub-element\", keyEle);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = (Element) node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (subElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsePropertySubElement(subElement, bd, defaultKeyTypeName);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseListElement(collectionEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a list element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1131
    },
    "return": "List<Object>",
    "signature": "public List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedList<Object> target = new ManagedList<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseLookupOverrideSubElements(beanEle,overrides)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse lookup-override sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "overrides"
    ],
    "position": {
      "column": 1,
      "line": 733
    },
    "return": "void",
    "signature": "public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides)",
    "source_code": "\tpublic void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {\n\t\t\t\tElement ele = (Element) node;\n\t\t\t\tString methodName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString beanRef = ele.getAttribute(BEAN_ELEMENT);\n\t\t\t\tLookupOverride override = new LookupOverride(methodName, beanRef);\n\t\t\t\toverride.setSource(extractSource(ele));\n\t\t\t\toverrides.addOverride(override);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseMapElement(mapEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a map element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1170
    },
    "return": "Object>",
    "signature": "public Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Map<Object, Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {\n\t\tString defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);\n\t\tString defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\n\t\tList<Element> entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);\n\t\tManagedMap<Object, Object> map = new ManagedMap<>(entryEles.size());\n\t\tmap.setSource(extractSource(mapEle));\n\t\tmap.setKeyTypeName(defaultKeyType);\n\t\tmap.setValueTypeName(defaultValueType);\n\t\tmap.setMergeEnabled(parseMergeAttribute(mapEle));\n\n\t\tfor (Element entryEle : entryEles) {\n\t\t\t// Should only have one value child element: ref, value, list, etc.\n\t\t\t// Optionally, there might be a key child element.\n\t\t\tNodeList entrySubNodes = entryEle.getChildNodes();\n\t\t\tElement keyEle = null;\n\t\t\tElement valueEle = null;\n\t\t\tfor (int j = 0; j < entrySubNodes.getLength(); j++) {\n\t\t\t\tNode node = entrySubNodes.item(j);\n\t\t\t\tif (node instanceof Element candidateEle) {\n\t\t\t\t\tif (nodeNameEquals(candidateEle, KEY_ELEMENT)) {\n\t\t\t\t\t\tif (keyEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element is only allowed to contain one <key> sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tkeyEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Child element is what we're looking for.\n\t\t\t\t\t\tif (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {\n\t\t\t\t\t\t\t// the element is a <description> -> ignore it\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (valueEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element must not contain more than one value sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvalueEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extract key from attribute or sub-element.\n\t\t\tObject key = null;\n\t\t\tboolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);\n\t\t\tboolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);\n\t\t\tif ((hasKeyAttribute && hasKeyRefAttribute) ||\n\t\t\t\t\t(hasKeyAttribute || hasKeyRefAttribute) && keyEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"a 'key' attribute OR a 'key-ref' attribute OR a <key> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif (hasKeyAttribute) {\n\t\t\t\tkey = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);\n\t\t\t}\n\t\t\telse if (hasKeyRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'key-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tkey = ref;\n\t\t\t}\n\t\t\telse if (keyEle != null) {\n\t\t\t\tkey = parseKeyElement(keyEle, bd, defaultKeyType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a key\", entryEle);\n\t\t\t}\n\n\t\t\t// Extract value from attribute or sub-element.\n\t\t\tObject value = null;\n\t\t\tboolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);\n\t\t\tboolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\tboolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\tif ((hasValueAttribute && hasValueRefAttribute) ||\n\t\t\t\t\t(hasValueAttribute || hasValueRefAttribute) && valueEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"'value' attribute OR 'value-ref' attribute OR <value> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif ((hasValueTypeAttribute && hasValueRefAttribute) ||\n\t\t\t\t(hasValueTypeAttribute && !hasValueAttribute) ||\n\t\t\t\t\t(hasValueTypeAttribute && valueEle != null)) {\n\t\t\t\terror(\"<entry> element is only allowed to contain a 'value-type' \" +\n\t\t\t\t\t\t\"attribute when it has a 'value' attribute\", entryEle);\n\t\t\t}\n\t\t\tif (hasValueAttribute) {\n\t\t\t\tString valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(valueType)) {\n\t\t\t\t\tvalueType = defaultValueType;\n\t\t\t\t}\n\t\t\t\tvalue = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);\n\t\t\t}\n\t\t\telse if (hasValueRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'value-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tvalue = ref;\n\t\t\t}\n\t\t\telse if (valueEle != null) {\n\t\t\t\tvalue = parsePropertySubElement(valueEle, bd, defaultValueType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a value\", entryEle);\n\t\t\t}\n\n\t\t\t// Add final key and value to the Map.\n\t\t\tmap.put(key, value);\n\t\t}\n\n\t\treturn map;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseMetaElements(ele,attributeAccessor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the meta elements underneath the given element, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "attributeAccessor"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor)",
    "source_code": "\tpublic void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {\n\t\tNodeList nl = ele.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\tElement metaElement = (Element) node;\n\t\t\t\tString key = metaElement.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\tString value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);\n\t\t\t\tattribute.setSource(extractSource(metaElement));\n\t\t\t\tattributeAccessor.addMetadataAttribute(attribute);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElement(ele,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a property element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 839
    },
    "return": "void",
    "signature": "public void parsePropertyElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElement(Element ele, BeanDefinition bd) {\n\t\tString propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(propertyName)) {\n\t\t\terror(\"Tag 'property' must have a 'name' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new PropertyEntry(propertyName));\n\t\ttry {\n\t\t\tif (bd.getPropertyValues().contains(propertyName)) {\n\t\t\t\terror(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject val = parsePropertyValue(ele, bd, propertyName);\n\t\t\tPropertyValue pv = new PropertyValue(propertyName, val);\n\t\t\tparseMetaElements(ele, pv);\n\t\t\tpv.setSource(extractSource(ele));\n\t\t\tbd.getPropertyValues().addPropertyValue(pv);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElements(beanEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse property sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void parsePropertyElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n\t\t\t\tparsePropertyElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertySubElement(ele,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 970
    },
    "return": "Object",
    "signature": "public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n\t\treturn parsePropertySubElement(ele, bd, null);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertySubElement(ele,bd,defaultValueType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t * @param defaultValueType the default type (class name) for any\n\t * {@code <value>} tag that might be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd",
      "defaultValueType"
    ],
    "position": {
      "column": 1,
      "line": 983
    },
    "return": "Object",
    "signature": "public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType)",
    "source_code": "\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {\n\t\tif (!isDefaultNamespace(ele)) {\n\t\t\treturn parseNestedCustomElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t\tBeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n\t\t\tif (nestedBd != null) {\n\t\t\t\tnestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n\t\t\t}\n\t\t\treturn nestedBd;\n\t\t}\n\t\telse if (nodeNameEquals(ele, REF_ELEMENT)) {\n\t\t\t// A generic reference to any name of any bean.\n\t\t\tString refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n\t\t\tboolean toParent = false;\n\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t// A reference to the id of another bean in a parent context.\n\t\t\t\trefName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n\t\t\t\ttoParent = true;\n\t\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t\terror(\"'bean' or 'parent' is required for <ref> element\", ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(\"<ref> element contains empty target attribute\", ele);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n\t\t\treturn parseIdRefElement(ele);\n\t\t}\n\t\telse if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n\t\t\treturn parseValueElement(ele, defaultValueType);\n\t\t}\n\t\telse if (nodeNameEquals(ele, NULL_ELEMENT)) {\n\t\t\t// It's a distinguished null value. Let's wrap it in a TypedStringValue\n\t\t\t// object in order to preserve the source location.\n\t\t\tTypedStringValue nullHolder = new TypedStringValue(null);\n\t\t\tnullHolder.setSource(extractSource(ele));\n\t\t\treturn nullHolder;\n\t\t}\n\t\telse if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n\t\t\treturn parseArrayElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, LIST_ELEMENT)) {\n\t\t\treturn parseListElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, SET_ELEMENT)) {\n\t\t\treturn parseSetElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, MAP_ELEMENT)) {\n\t\t\treturn parseMapElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n\t\t\treturn parsePropsElement(ele);\n\t\t}\n\t\telse {\n\t\t\terror(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyValue(ele,bd,propertyName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of a property element. May be a list etc.\n\t * Also used for constructor arguments, \"propertyName\" being null in this case.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 909
    },
    "return": "Object",
    "signature": "public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName)",
    "source_code": "\tpublic Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n\t\tString elementName = (propertyName != null ?\n\t\t\t\t\"<property> element for property '\" + propertyName + \"'\" :\n\t\t\t\t\"<constructor-arg> element\");\n\n\t\t// Should only have one child element: ref, value, list, etc.\n\t\tNodeList nl = ele.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&\n\t\t\t\t\t!nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(elementName + \" must not contain more than one sub-element\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = (Element) node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n\t\tboolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\t\tif ((hasRefAttribute && hasValueAttribute) ||\n\t\t\t\t((hasRefAttribute || hasValueAttribute) && subElement != null)) {\n\t\t\terror(elementName +\n\t\t\t\t\t\" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n\t\t}\n\n\t\tif (hasRefAttribute) {\n\t\t\tString refName = ele.getAttribute(REF_ATTRIBUTE);\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(elementName + \" contains empty 'ref' attribute\", ele);\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (hasValueAttribute) {\n\t\t\tTypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\treturn valueHolder;\n\t\t}\n\t\telse if (subElement != null) {\n\t\t\treturn parsePropertySubElement(subElement, bd);\n\t\t}\n\t\telse {\n\t\t\t// Neither child element nor \"ref\" or \"value\" attribute found.\n\t\t\terror(elementName + \" must specify a ref or value\", ele);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseQualifierElement(ele,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a qualifier element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 865
    },
    "return": "void",
    "signature": "public void parseQualifierElement(Element ele, AbstractBeanDefinition bd)",
    "source_code": "\tpublic void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {\n\t\tString typeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(typeName)) {\n\t\t\terror(\"Tag 'qualifier' must have a 'type' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new QualifierEntry(typeName));\n\t\ttry {\n\t\t\tAutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);\n\t\t\tqualifier.setSource(extractSource(ele));\n\t\t\tString value = ele.getAttribute(VALUE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasLength(value)) {\n\t\t\t\tqualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);\n\t\t\t}\n\t\t\tNodeList nl = ele.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {\n\t\t\t\t\tElement attributeEle = (Element) node;\n\t\t\t\t\tString attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\t\tString attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\t\tif (StringUtils.hasLength(attributeName) && StringUtils.hasLength(attributeValue)) {\n\t\t\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);\n\t\t\t\t\t\tattribute.setSource(extractSource(attributeEle));\n\t\t\t\t\t\tqualifier.addMetadataAttribute(attribute);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\terror(\"Qualifier 'attribute' tag must have a 'name' and 'value'\", attributeEle);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbd.addQualifier(qualifier);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseQualifierElements(beanEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse qualifier sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 720
    },
    "return": "void",
    "signature": "public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd)",
    "source_code": "\tpublic void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ELEMENT)) {\n\t\t\t\tparseQualifierElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseReplacedMethodSubElements(beanEle,overrides)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse replaced-method sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "overrides"
    ],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "void",
    "signature": "public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)",
    "source_code": "\tpublic void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {\n\t\t\t\tElement replacedMethodEle = (Element) node;\n\t\t\t\tString name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n\t\t\t\tReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n\t\t\t\t// Look for arg-type match elements.\n\t\t\t\tList<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n\t\t\t\tfor (Element argTypeEle : argTypeEles) {\n\t\t\t\t\tString match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n\t\t\t\t\tmatch = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));\n\t\t\t\t\tif (StringUtils.hasText(match)) {\n\t\t\t\t\t\treplaceOverride.addTypeIdentifier(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treplaceOverride.setSource(extractSource(replacedMethodEle));\n\t\t\t\toverrides.addOverride(replaceOverride);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseSetElement(collectionEle,bd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a set element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1145
    },
    "return": "Set<Object>",
    "signature": "public Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedSet<Object> target = new ManagedSet<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseValueElement(ele,defaultTypeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a typed String value Object for the given value element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "defaultTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1072
    },
    "return": "Object",
    "signature": "public Object parseValueElement(Element ele, @Nullable String defaultTypeName)",
    "source_code": "\tpublic Object parseValueElement(Element ele, @Nullable String defaultTypeName) {\n\t\t// It's a literal value.\n\t\tString value = DomUtils.getTextValue(ele);\n\t\tString specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString typeName = specifiedTypeName;\n\t\tif (!StringUtils.hasText(typeName)) {\n\t\t\ttypeName = defaultTypeName;\n\t\t}\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, typeName);\n\t\t\ttypedValue.setSource(extractSource(ele));\n\t\t\ttypedValue.setSpecifiedTypeName(specifiedTypeName);\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + typeName + \"] not found for <value> element\", ele, ex);\n\t\t\treturn value;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#populateDefaults(defaults,parentDefaults,root)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,\n\t * autowire, dependency check settings, init-method, destroy-method and merge settings.\n\t * Support nested 'beans' element use cases by falling back to {@code parentDefaults}\n\t * in case the defaults are not explicitly set locally.\n\t * @param defaults the defaults to populate\n\t * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to\n\t * @param root the root element of the current bean definition document (or nested beans element)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "defaults",
      "parentDefaults",
      "root"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root)",
    "source_code": "\tprotected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) {\n\t\tString lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tlazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setLazyInit(lazyInit);\n\n\t\tString merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);\n\t\tif (isDefaultValue(merge)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tmerge = (parentDefaults != null ? parentDefaults.getMerge() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setMerge(merge);\n\n\t\tString autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowire)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to 'no'.\n\t\t\tautowire = (parentDefaults != null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);\n\t\t}\n\t\tdefaults.setAutowire(autowire);\n\n\t\tif (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {\n\t\t\tdefaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setInitMethod(parentDefaults.getInitMethod());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setDestroyMethod(parentDefaults.getDestroyMethod());\n\t\t}\n\n\t\tdefaults.setSource(this.readerContext.extractSource(root));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#processBeanDefinition(ele,delegate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ele",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "void",
    "signature": "protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t// Register the final decorated instance.\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#registerBeanDefinitions(doc,readerContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation parses bean definitions according to the \"spring-beans\" XSD\n\t * (or DTD, historically).\n\t * <p>Opens a DOM Document; then initializes the default settings\n\t * specified at the {@code <beans/>} level; then parses the contained bean definitions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "doc",
      "readerContext"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)",
    "source_code": "\tpublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n\t\tthis.readerContext = readerContext;\n\t\tdoRegisterBeanDefinitions(doc.getDocumentElement());\n\t}"
  },
  "org.springframework.beans.propertyeditors.<unknown>#createCollection(collectionType,initialCapacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Collection of the given type, with the given\n\t * initial capacity (if supported by the Collection type).\n\t * @param collectionType a sub-interface of Collection\n\t * @param initialCapacity the initial capacity\n\t * @return the new Collection instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collectionType",
      "initialCapacity"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Collection<Object>",
    "signature": "protected Collection<Object> createCollection(Class<? extends Collection> collectionType, int initialCapacity)",
    "source_code": "\tprotected Collection<Object> createCollection(Class<? extends Collection> collectionType, int initialCapacity) {\n\t\tif (!collectionType.isInterface()) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Could not instantiate collection class: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse if (List.class == collectionType) {\n\t\t\treturn new ArrayList<>(initialCapacity);\n\t\t}\n\t\telse if (SortedSet.class == collectionType) {\n\t\t\treturn new TreeSet<>();\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashSet<>(initialCapacity);\n\t\t}\n\t}"
  },
  "org.springframework.beans.propertyeditors.<unknown>#createMap(mapType,initialCapacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Map of the given type, with the given\n\t * initial capacity (if supported by the Map type).\n\t * @param mapType a sub-interface of Map\n\t * @param initialCapacity the initial capacity\n\t * @return the new Map instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapType",
      "initialCapacity"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Object>",
    "signature": "protected Object> createMap(Class<? extends Map> mapType, int initialCapacity)",
    "source_code": "\tprotected Map<Object, Object> createMap(Class<? extends Map> mapType, int initialCapacity) {\n\t\tif (!mapType.isInterface()) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Could not instantiate map class: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse if (SortedMap.class == mapType) {\n\t\t\treturn new TreeMap<>();\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashMap<>(initialCapacity);\n\t\t}\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#addCacheMethod(methodName,ops)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a cacheable method.\n\t * <p>Method names can be exact matches, or of the pattern \"xxx*\",\n\t * \"*xxx\" or \"*xxx*\" for matching multiple methods.\n\t * @param methodName the name of the method\n\t * @param ops operation associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "ops"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void addCacheMethod(String methodName, Collection<CacheOperation> ops)",
    "source_code": "\tpublic void addCacheMethod(String methodName, Collection<CacheOperation> ops) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding method [\" + methodName + \"] with cache operations [\" + ops + \"]\");\n\t\t}\n\t\tthis.nameMap.put(methodName, ops);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#configure(errorHandler,keyGenerator,cacheResolver,cacheManager)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this aspect with the given error handler, key generator and cache resolver/manager\n\t * suppliers, applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler",
      "keyGenerator",
      "cacheResolver",
      "cacheManager"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager)",
    "source_code": "\tpublic void configure(\n\t\t\t@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager) {\n\n\t\tthis.errorHandler = new SingletonSupplier<>(errorHandler, SimpleCacheErrorHandler::new);\n\t\tthis.keyGenerator = new SingletonSupplier<>(keyGenerator, SimpleKeyGenerator::new);\n\t\tthis.cacheResolver = new SingletonSupplier<>(cacheResolver,\n\t\t\t\t() -> SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#execute(invoker,target,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "target",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args)",
    "source_code": "\tprotected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {\n\t\t// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)\n\t\tif (this.initialized) {\n\t\t\tClass<?> targetClass = getTargetClass(target);\n\t\t\tCacheOperationSource cacheOperationSource = getCacheOperationSource();\n\t\t\tif (cacheOperationSource != null) {\n\t\t\t\tCollection<CacheOperation> operations = cacheOperationSource.getCacheOperations(method, targetClass);\n\t\t\t\tif (!CollectionUtils.isEmpty(operations)) {\n\t\t\t\t\treturn execute(invoker, method,\n\t\t\t\t\t\t\tnew CacheOperationContexts(operations, method, args, target, targetClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invoker.invoke();\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getBean(beanName,expectedType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a bean with the specified name and type. Used to resolve services that\n\t * are referenced by name in a {@link CacheOperation}.\n\t * @param beanName the name of the bean, as defined by the operation\n\t * @param expectedType type for the bean\n\t * @return the bean matching that name\n\t * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist\n\t * @see CacheOperation#getKeyGenerator()\n\t * @see CacheOperation#getCacheManager()\n\t * @see CacheOperation#getCacheResolver()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "expectedType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "T",
    "signature": "protected T getBean(String beanName, Class<T> expectedType)",
    "source_code": "\tprotected <T> T getBean(String beanName, Class<T> expectedType) {\n\t\tif (this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"BeanFactory must be set on cache aspect for \" + expectedType.getSimpleName() + \" retrieval\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, expectedType, beanName);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperationMetadata(operation,method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link CacheOperationMetadata} for the specified operation.\n\t * <p>Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be\n\t * used for the operation.\n\t * @param operation the operation\n\t * @param method the method on which the operation is invoked\n\t * @param targetClass the target type\n\t * @return the resolved metadata for the operation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "CacheOperationMetadata",
    "signature": "protected CacheOperationMetadata getCacheOperationMetadata(CacheOperation operation, Method method, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationMetadata getCacheOperationMetadata(\n\t\t\tCacheOperation operation, Method method, Class<?> targetClass) {\n\n\t\tCacheOperationCacheKey cacheKey = new CacheOperationCacheKey(operation, method, targetClass);\n\t\tCacheOperationMetadata metadata = this.metadataCache.get(cacheKey);\n\t\tif (metadata == null) {\n\t\t\tKeyGenerator operationKeyGenerator;\n\t\t\tif (StringUtils.hasText(operation.getKeyGenerator())) {\n\t\t\t\toperationKeyGenerator = getBean(operation.getKeyGenerator(), KeyGenerator.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationKeyGenerator = getKeyGenerator();\n\t\t\t}\n\t\t\tCacheResolver operationCacheResolver;\n\t\t\tif (StringUtils.hasText(operation.getCacheResolver())) {\n\t\t\t\toperationCacheResolver = getBean(operation.getCacheResolver(), CacheResolver.class);\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(operation.getCacheManager())) {\n\t\t\t\tCacheManager cacheManager = getBean(operation.getCacheManager(), CacheManager.class);\n\t\t\t\toperationCacheResolver = new SimpleCacheResolver(cacheManager);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationCacheResolver = getCacheResolver();\n\t\t\t\tAssert.state(operationCacheResolver != null, \"No CacheResolver/CacheManager set\");\n\t\t\t}\n\t\t\tmetadata = new CacheOperationMetadata(operation, method, targetClass,\n\t\t\t\t\toperationKeyGenerator, operationCacheResolver);\n\t\t\tthis.metadataCache.put(cacheKey, metadata);\n\t\t}\n\t\treturn metadata;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperations(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Collection<CacheOperation>",
    "signature": "public Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass) {\n\t\t// look for direct name match\n\t\tString methodName = method.getName();\n\t\tCollection<CacheOperation> ops = this.nameMap.get(methodName);\n\n\t\tif (ops == null) {\n\t\t\t// Look for most specific name match.\n\t\t\tString bestNameMatch = null;\n\t\t\tfor (String mappedName : this.nameMap.keySet()) {\n\t\t\t\tif (isMatch(methodName, mappedName)\n\t\t\t\t\t\t&& (bestNameMatch == null || bestNameMatch.length() <= mappedName.length())) {\n\t\t\t\t\tops = this.nameMap.get(mappedName);\n\t\t\t\t\tbestNameMatch = mappedName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ops;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getOperationContext(operation,method,args,target,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "args",
      "target",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "CacheOperationContext",
    "signature": "protected CacheOperationContext getOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationContext getOperationContext(\n\t\t\tCacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {\n\n\t\tCacheOperationMetadata metadata = getCacheOperationMetadata(operation, method, targetClass);\n\t\treturn new CacheOperationContext(metadata, args, target);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#methodIdentification(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to return a String representation of this Method\n\t * for use in logging. Can be overridden in subclasses to provide a\n\t * different identifier for the given method.\n\t * @param method the method we're interested in\n\t * @param targetClass class the method is on\n\t * @return log message identifying this method\n\t * @see org.springframework.util.ClassUtils#getQualifiedMethodName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "String",
    "signature": "protected String methodIdentification(Method method, Class<?> targetClass)",
    "source_code": "\tprotected String methodIdentification(Method method, Class<?> targetClass) {\n\t\tMethod specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\n\t\treturn ClassUtils.getQualifiedMethodName(specificMethod);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#setNameMap(Map<String,nameMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of method names\n\t * (e.g. \"myMethod\") and CacheOperation instances\n\t * (or Strings to be converted to CacheOperation instances).\n\t * @see CacheOperation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "nameMap"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setNameMap(Map<String, Collection<CacheOperation>> nameMap)",
    "source_code": "\tpublic void setNameMap(Map<String, Collection<CacheOperation>> nameMap) {\n\t\tnameMap.forEach(this::addCacheMethod);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tJCacheOperationSource cas = getCacheOperationSource();\n\t\treturn (cas != null && cas.getCacheOperation(method, targetClass) != null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext,\n\t\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode) {\n\n\t\t\tMap<String, String> mappings = buildImportAwareMappings();\n\t\t\tif (!mappings.isEmpty()) {\n\t\t\t\tGeneratedMethod generatedMethod = beanFactoryInitializationCode\n\t\t\t\t\t\t.getMethodGenerator()\n\t\t\t\t\t\t.generateMethod(\"addImportAwareBeanPostProcessors\")\n\t\t\t\t\t\t.using(builder -> generateAddPostProcessorMethod(builder,\n\t\t\t\t\t\t\t\tmappings));\n\t\t\t\tbeanFactoryInitializationCode\n\t\t\t\t\t\t.addInitializer(MethodReference.of(generatedMethod.getName()));\n\t\t\t\tResourceHints hints = generationContext.getRuntimeHints().resources();\n\t\t\t\tmappings.forEach(\n\t\t\t\t\t\t(target, from) -> hints.registerType(TypeReference.of(from)));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#autowireResource(factory,element,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a resource object for the given name and type through autowiring\n\t * based on the given factory.\n\t * @param factory the factory to autowire against\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @throws NoSuchBeanDefinitionException if no corresponding target resource found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "Object",
    "signature": "protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tObject resource;\n\t\tSet<String> autowiredBeanNames;\n\t\tString name = element.name;\n\n\t\tif (factory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tDependencyDescriptor descriptor = element.getDependencyDescriptor();\n\t\t\tif (this.fallbackToDefaultTypeMatch && element.isDefaultName && !factory.containsBean(name)) {\n\t\t\t\tautowiredBeanNames = new LinkedHashSet<>();\n\t\t\t\tresource = autowireCapableBeanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, null);\n\t\t\t\tif (resource == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(element.getLookupType(), \"No resolvable resource object\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresource = autowireCapableBeanFactory.resolveBeanByName(name, descriptor);\n\t\t\t\tautowiredBeanNames = Collections.singleton(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresource = factory.getBean(name, element.lookupType);\n\t\t\tautowiredBeanNames = Collections.singleton(name);\n\t\t}\n\n\t\tif (factory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (requestingBeanName != null && configurableBeanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tconfigurableBeanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resource;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildDefaultBeanName(definition,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Derive a default bean name from the given bean definition.\n\t * <p>The default implementation delegates to {@link #buildDefaultBeanName(BeanDefinition)}.\n\t * @param definition the bean definition to build a bean name for\n\t * @param registry the registry that the given bean definition is being registered with\n\t * @return the default bean name (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definition",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "String",
    "signature": "protected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\treturn buildDefaultBeanName(definition);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildLazyResourceProxy(element,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a lazily resolving resource proxy for the given name and type,\n\t * delegating to {@link #getResource} on demand once a method call comes in.\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @since 4.2\n\t * @see #getResource\n\t * @see Lazy\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "Object",
    "signature": "protected Object buildLazyResourceProxy(final LookupElement element, final @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object buildLazyResourceProxy(final LookupElement element, final @Nullable String requestingBeanName) {\n\t\tTargetSource ts = new TargetSource() {\n\t\t\t@Override\n\t\t\tpublic Class<?> getTargetClass() {\n\t\t\t\treturn element.lookupType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isStatic() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Object getTarget() {\n\t\t\t\treturn getResource(element, requestingBeanName);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void releaseTarget(Object target) {\n\t\t\t}\n\t\t};\n\n\t\tProxyFactory pf = new ProxyFactory();\n\t\tpf.setTargetSource(ts);\n\t\tif (element.lookupType.isInterface()) {\n\t\t\tpf.addInterface(element.lookupType);\n\t\t}\n\t\tClassLoader classLoader = (this.beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory ?\n\t\t\t\tconfigurableBeanFactory.getBeanClassLoader() : null);\n\t\treturn pf.getProxy(classLoader);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#createTypeFiltersFor(filterAttributes,environment,resourceLoader,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@linkplain TypeFilter type filters} from the supplied\n\t * {@link AnnotationAttributes}, such as those sourced from\n\t * {@link ComponentScan#includeFilters()} or {@link ComponentScan#excludeFilters()}.\n\t * <p>Each {@link TypeFilter} will be instantiated using an appropriate\n\t * constructor, with {@code BeanClassLoaderAware}, {@code BeanFactoryAware},\n\t * {@code EnvironmentAware}, and {@code ResourceLoaderAware} contracts\n\t * invoked if they are implemented by the type filter.\n\t * @param filterAttributes {@code AnnotationAttributes} for a\n\t * {@link ComponentScan.Filter @Filter} declaration\n\t * @param environment the {@code Environment} to make available to filters\n\t * @param resourceLoader the {@code ResourceLoader} to make available to filters\n\t * @param registry the {@code BeanDefinitionRegistry} to make available to filters\n\t * as a {@link org.springframework.beans.factory.BeanFactory} if applicable\n\t * @return a list of instantiated and configured type filters\n\t * @see TypeFilter\n\t * @see AnnotationTypeFilter\n\t * @see AssignableTypeFilter\n\t * @see AspectJTypeFilter\n\t * @see RegexPatternTypeFilter\n\t * @see org.springframework.beans.factory.BeanClassLoaderAware\n\t * @see org.springframework.beans.factory.BeanFactoryAware\n\t * @see org.springframework.context.EnvironmentAware\n\t * @see org.springframework.context.ResourceLoaderAware\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterAttributes",
      "environment",
      "resourceLoader",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "List<TypeFilter>",
    "signature": "public List<TypeFilter> createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,\n\t\t\tResourceLoader resourceLoader, BeanDefinitionRegistry registry)",
    "source_code": "\tpublic static List<TypeFilter> createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,\n\t\t\tResourceLoader resourceLoader, BeanDefinitionRegistry registry) {\n\n\t\tList<TypeFilter> typeFilters = new ArrayList<>();\n\t\tFilterType filterType = filterAttributes.getEnum(\"type\");\n\n\t\tfor (Class<?> filterClass : filterAttributes.getClassArray(\"classes\")) {\n\t\t\tswitch (filterType) {\n\t\t\t\tcase ANNOTATION -> {\n\t\t\t\t\tAssert.isAssignable(Annotation.class, filterClass,\n\t\t\t\t\t\t\t\"@ComponentScan ANNOTATION type filter requires an annotation type\");\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tClass<Annotation> annotationType = (Class<Annotation>) filterClass;\n\t\t\t\t\ttypeFilters.add(new AnnotationTypeFilter(annotationType));\n\t\t\t\t}\n\t\t\t\tcase ASSIGNABLE_TYPE -> typeFilters.add(new AssignableTypeFilter(filterClass));\n\t\t\t\tcase CUSTOM -> {\n\t\t\t\t\tAssert.isAssignable(TypeFilter.class, filterClass,\n\t\t\t\t\t\t\t\"@ComponentScan CUSTOM type filter requires a TypeFilter implementation\");\n\t\t\t\t\tTypeFilter filter = ParserStrategyUtils.instantiateClass(filterClass, TypeFilter.class,\n\t\t\t\t\t\t\tenvironment, resourceLoader, registry);\n\t\t\t\t\ttypeFilters.add(filter);\n\t\t\t\t}\n\t\t\t\tdefault ->\n\t\t\t\t\tthrow new IllegalArgumentException(\"Filter type not supported with Class value: \" + filterType);\n\t\t\t}\n\t\t}\n\n\t\tfor (String expression : filterAttributes.getStringArray(\"pattern\")) {\n\t\t\tswitch (filterType) {\n\t\t\t\tcase ASPECTJ -> typeFilters.add(new AspectJTypeFilter(expression, resourceLoader.getClassLoader()));\n\t\t\t\tcase REGEX -> typeFilters.add(new RegexPatternTypeFilter(Pattern.compile(expression)));\n\t\t\t\tdefault ->\n\t\t\t\t\tthrow new IllegalArgumentException(\"Filter type not supported with String pattern: \" + filterType);\n\t\t\t}\n\t\t}\n\n\t\treturn typeFilters;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#doProcessConfigurationClass(configClass,sourceClass,filter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "sourceClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "SourceClass",
    "signature": "protected SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)",
    "source_code": "\tprotected final SourceClass doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass, filter);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateBeanName(definition,registry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "String",
    "signature": "public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)",
    "source_code": "\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\tif (definition instanceof AnnotatedBeanDefinition) {\n\t\t\tString beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n\t\t\tif (StringUtils.hasText(beanName)) {\n\t\t\t\t// Explicit bean name found.\n\t\t\t\treturn beanName;\n\t\t\t}\n\t\t}\n\t\t// Fallback: generate a unique default bean name.\n\t\treturn buildDefaultBeanName(definition, registry);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getAnnotationAttributes(annType,attribute)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annType",
      "attribute"
    ],
    "position": {
      "column": 1,
      "line": 1059
    },
    "return": "Collection<SourceClass>",
    "signature": "public Collection<SourceClass> getAnnotationAttributes(String annType, String attribute)",
    "source_code": "\t\tpublic Collection<SourceClass> getAnnotationAttributes(String annType, String attribute) throws IOException {\n\t\t\tMap<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true);\n\t\t\tif (annotationAttributes == null || !annotationAttributes.containsKey(attribute)) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tString[] classNames = (String[]) annotationAttributes.get(attribute);\n\t\t\tSet<SourceClass> result = new LinkedHashSet<>();\n\t\t\tfor (String className : classNames) {\n\t\t\t\tresult.add(getRelated(className));\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResource(element,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the resource object for the given name and type.\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @throws NoSuchBeanDefinitionException if no corresponding target resource found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "Object",
    "signature": "protected Object getResource(LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object getResource(LookupElement element, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\t// JNDI lookup to perform?\n\t\tString jndiName = null;\n\t\tif (StringUtils.hasLength(element.mappedName)) {\n\t\t\tjndiName = element.mappedName;\n\t\t}\n\t\telse if (this.alwaysUseJndiLookup) {\n\t\t\tjndiName = element.name;\n\t\t}\n\t\tif (jndiName != null) {\n\t\t\tif (this.jndiFactory == null) {\n\t\t\t\tthrow new NoSuchBeanDefinitionException(element.lookupType,\n\t\t\t\t\t\t\"No JNDI factory configured - specify the 'jndiFactory' property\");\n\t\t\t}\n\t\t\treturn this.jndiFactory.getBean(jndiName, element.lookupType);\n\t\t}\n\n\t\t// Regular resource autowiring\n\t\tif (this.resourceFactory == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(element.lookupType,\n\t\t\t\t\t\"No resource factory configured - specify the 'resourceFactory' property\");\n\t\t}\n\t\treturn autowireResource(this.resourceFactory, element, requestingBeanName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\tif (StringUtils.hasLength(this.beanName)) {\n\t\t\t\tif (beanFactory != null && beanFactory.containsBean(this.beanName)) {\n\t\t\t\t\t// Local match found for explicitly specified local bean name.\n\t\t\t\t\tObject bean = beanFactory.getBean(this.beanName, this.lookupType);\n\t\t\t\t\tif (requestingBeanName != null && beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\t\t\t\tconfigurableBeanFactory.registerDependentBean(this.beanName, requestingBeanName);\n\t\t\t\t\t}\n\t\t\t\t\treturn bean;\n\t\t\t\t}\n\t\t\t\telse if (this.isDefaultName && !StringUtils.hasLength(this.mappedName)) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.beanName,\n\t\t\t\t\t\t\t\"Cannot resolve 'beanName' in local BeanFactory. Consider specifying a general 'name' value instead.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// JNDI name lookup - may still go to a local BeanFactory.\n\t\t\treturn getResource(this, requestingBeanName);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#handle(configClass,importSelector)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Handle the specified {@link DeferredImportSelector}. If deferred import\n\t\t * selectors are being collected, this registers this instance to the list. If\n\t\t * they are being processed, the {@link DeferredImportSelector} is also processed\n\t\t * immediately according to its {@link DeferredImportSelector.Group}.\n\t\t * @param configClass the source configuration class\n\t\t * @param importSelector the selector to handle\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "configClass",
      "importSelector"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void handle(ConfigurationClass configClass, DeferredImportSelector importSelector)",
    "source_code": "\t\tpublic void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {\n\t\t\tDeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);\n\t\t\tif (this.deferredImportSelectors == null) {\n\t\t\t\tDeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();\n\t\t\t\thandler.register(holder);\n\t\t\t\thandler.processGroupImports();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.deferredImportSelectors.add(holder);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#isOverriddenByExistingDefinition(beanMethod,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanMethod",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "boolean",
    "signature": "protected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName)",
    "source_code": "\tprotected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName) {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn false;\n\t\t}\n\t\tBeanDefinition existingBeanDef = this.registry.getBeanDefinition(beanName);\n\n\t\t// Is the existing bean definition one that was created from a configuration class?\n\t\t// -> allow the current bean method to override, since both are at second-pass level.\n\t\t// However, if the bean method is an overloaded case on the same configuration class,\n\t\t// preserve the existing bean definition.\n\t\tif (existingBeanDef instanceof ConfigurationClassBeanDefinition ccbd) {\n\t\t\tif (ccbd.getMetadata().getClassName().equals(\n\t\t\t\t\tbeanMethod.getConfigurationClass().getMetadata().getClassName())) {\n\t\t\t\tif (ccbd.getFactoryMethodMetadata().getMethodName().equals(ccbd.getFactoryMethodName())) {\n\t\t\t\t\tccbd.setNonUniqueFactoryMethodName(ccbd.getFactoryMethodMetadata().getMethodName());\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// A bean definition resulting from a component scan can be silently overridden\n\t\t// by an @Bean method, as of 4.2...\n\t\tif (existingBeanDef instanceof ScannedGenericBeanDefinition) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Has the existing bean definition bean marked as a framework-generated bean?\n\t\t// -> allow the current bean method to override it, since it is application-level\n\t\tif (existingBeanDef.getRole() > BeanDefinition.ROLE_APPLICATION) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// At this point, it's a top-level override (probably XML), just having been parsed\n\t\t// before configuration class processing kicks in...\n\t\tif (this.registry instanceof DefaultListableBeanFactory dlbf &&\n\t\t\t\t!dlbf.isAllowBeanDefinitionOverriding()) {\n\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\tbeanName, \"@Bean definition illegally overridden by existing bean definition: \" + existingBeanDef);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Skipping bean definition for %s: a definition for bean '%s' \" +\n\t\t\t\t\t\"already exists. This top-level bean definition is considered as an override.\",\n\t\t\t\t\tbeanMethod, beanName));\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#isStereotypeWithNameValue(annotationType,metaAnnotationTypes,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given annotation is a stereotype that is allowed\n\t * to suggest a component name through its annotation {@code value()}.\n\t * @param annotationType the name of the annotation class to check\n\t * @param metaAnnotationTypes the names of meta-annotations on the given annotation\n\t * @param attributes the map of attributes for the given annotation\n\t * @return whether the annotation qualifies as a stereotype with component name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "metaAnnotationTypes",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "protected boolean isStereotypeWithNameValue(String annotationType,\n\t\t\tSet<String> metaAnnotationTypes, @Nullable Map<String, Object> attributes)",
    "source_code": "\tprotected boolean isStereotypeWithNameValue(String annotationType,\n\t\t\tSet<String> metaAnnotationTypes, @Nullable Map<String, Object> attributes) {\n\n\t\tboolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||\n\t\t\t\tmetaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) ||\n\t\t\t\tannotationType.equals(\"jakarta.annotation.ManagedBean\") ||\n\t\t\t\tannotationType.equals(\"jakarta.inject.Named\");\n\n\t\treturn (isStereotype && attributes != null && attributes.containsKey(\"value\"));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(className,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "void",
    "signature": "protected void parse(@Nullable String className, String beanName)",
    "source_code": "\tprotected final void parse(@Nullable String className, String beanName) throws IOException {\n\t\tAssert.notNull(className, \"No bean class name for configuration class bean definition\");\n\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);\n\t\tprocessConfigurationClass(new ConfigurationClass(reader, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(clazz,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "protected void parse(Class<?> clazz, String beanName)",
    "source_code": "\tprotected final void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(metadata,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "metadata",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "protected void parse(AnnotationMetadata metadata, String beanName)",
    "source_code": "\tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessAfterInstantiation(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "boolean",
    "signature": "public boolean postProcessAfterInstantiation(Object bean, String beanName)",
    "source_code": "\tpublic boolean postProcessAfterInstantiation(Object bean, String beanName) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\tif (bean instanceof ImportAware importAware) {\n\t\t\t\tImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);\n\t\t\t\tAnnotationMetadata importingClass = ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());\n\t\t\t\tif (importingClass != null) {\n\t\t\t\t\timportAware.setImportMetadata(importingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tsuper.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);\n\t\tmetadata.checkConfigMembers(beanDefinition);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#process(metadata,selector)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 902
    },
    "return": "void",
    "signature": "public void process(AnnotationMetadata metadata, DeferredImportSelector selector)",
    "source_code": "\t\tpublic void process(AnnotationMetadata metadata, DeferredImportSelector selector) {\n\t\t\tfor (String importClassName : selector.selectImports(metadata)) {\n\t\t\t\tthis.imports.add(new Entry(metadata, importClassName));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#processConfigurationClass(configClass,filter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)",
    "source_code": "\tprotected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) throws IOException {\n\t\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClass existingClass = this.configurationClasses.get(configClass);\n\t\tif (existingClass != null) {\n\t\t\tif (configClass.isImported()) {\n\t\t\t\tif (existingClass.isImported()) {\n\t\t\t\t\texistingClass.mergeImportedBy(configClass);\n\t\t\t\t}\n\t\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t\t// Let's remove the old one and go with the new one.\n\t\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);\n\t\t\t}\n\t\t}\n\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tSourceClass sourceClass = asSourceClass(configClass, filter);\n\t\tdo {\n\t\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);\n\t\t}\n\t\twhile (sourceClass != null);\n\n\t\tthis.configurationClasses.put(configClass, configClass);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerImport(importingClass,importedClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "importingClass",
      "importedClass"
    ],
    "position": {
      "column": 1,
      "line": 704
    },
    "return": "void",
    "signature": "public void registerImport(AnnotationMetadata importingClass, String importedClass)",
    "source_code": "\t\tpublic void registerImport(AnnotationMetadata importingClass, String importedClass) {\n\t\t\tthis.imports.add(importedClass, importingClass);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerScope(annotationType,scopeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register an extended JSR-330 scope annotation, mapping it onto a\n\t * specific Spring scope by name.\n\t * @param annotationType the JSR-330 annotation type by name\n\t * @param scopeName the Spring scope name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "scopeName"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void registerScope(String annotationType, String scopeName)",
    "source_code": "\tpublic final void registerScope(String annotationType, String scopeName) {\n\t\tthis.scopeMap.put(annotationType, scopeName);\n\t}"
  },
  "org.springframework.context.event.<unknown>#getDetailedErrorMessage(bean,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add additional details such as the bean type and method signature to\n\t * the given error message.\n\t * @param message error message to append the HandlerMethod details to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "String",
    "signature": "protected String getDetailedErrorMessage(Object bean, String message)",
    "source_code": "\tprotected String getDetailedErrorMessage(Object bean, String message) {\n\t\tStringBuilder sb = new StringBuilder(message).append('\\n');\n\t\tsb.append(\"HandlerMethod details: \\n\");\n\t\tsb.append(\"Bean [\").append(bean.getClass().getName()).append(\"]\\n\");\n\t\tsb.append(\"Method [\").append(this.method.toGenericString()).append(\"]\\n\");\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.context.event.<unknown>#supportsEvent(listener,eventType,sourceType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given listener supports the given event.\n\t * <p>The default implementation detects the {@link SmartApplicationListener}\n\t * and {@link GenericApplicationListener} interfaces. In case of a standard\n\t * {@link ApplicationListener}, a {@link GenericApplicationListenerAdapter}\n\t * will be used to introspect the generically declared type of the target listener.\n\t * @param listener the target listener to check\n\t * @param eventType the event type to check against\n\t * @param sourceType the source type to check against\n\t * @return whether the given listener should be included in the candidates\n\t * for the given event type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "eventType",
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "boolean",
    "signature": "protected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType)",
    "source_code": "\tprotected boolean supportsEvent(\n\t\t\tApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {\n\n\t\tGenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ?\n\t\t\t\t(GenericApplicationListener) listener : new GenericApplicationListenerAdapter(listener));\n\t\treturn (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));\n\t}"
  },
  "org.springframework.context.event.<unknown>#supportsEvent(listenerType,eventType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Filter a listener early through checking its generically declared event\n\t * type before trying to instantiate it.\n\t * <p>If this method returns {@code true} for a given listener as a first pass,\n\t * the listener instance will get retrieved and fully evaluated through a\n\t * {@link #supportsEvent(ApplicationListener, ResolvableType, Class)} call afterwards.\n\t * @param listenerType the listener's type as determined by the BeanFactory\n\t * @param eventType the event type to check\n\t * @return whether the given listener should be included in the candidates\n\t * for the given event type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listenerType",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "boolean",
    "signature": "protected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType)",
    "source_code": "\tprotected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType) {\n\t\tResolvableType declaredEventType = GenericApplicationListenerAdapter.resolveDeclaredEventType(listenerType);\n\t\treturn (declaredEventType == null || declaredEventType.isAssignableFrom(eventType));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canRead(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof Map<?, ?> map && map.containsKey(name));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.expression.<unknown>#generateCode(propertyName,mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\tString descriptor = cf.lastDescriptor();\n\t\tif (descriptor == null || !descriptor.equals(\"Ljava/util/Map\")) {\n\t\t\tif (descriptor == null) {\n\t\t\t\tcf.loadTarget(mv);\n\t\t\t}\n\t\t\tCodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n\t\t}\n\t\tmv.visitLdcInsn(propertyName);\n\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\",\"(Ljava/lang/Object;)Ljava/lang/Object;\",true);\n\t}"
  },
  "org.springframework.context.expression.<unknown>#getExpression(Map<ExpressionKey,cache,elementKey,expression)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link Expression} for the specified SpEL value\n\t * <p>{@link #parseExpression(String) Parse the expression} if it hasn't been already.\n\t * @param cache the cache to use\n\t * @param elementKey the element on which the expression is defined\n\t * @param expression the expression to parse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<ExpressionKey",
      "cache",
      "elementKey",
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Expression",
    "signature": "protected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression)",
    "source_code": "\tprotected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression) {\n\n\t\tExpressionKey expressionKey = createKey(elementKey, expression);\n\t\tExpression expr = cache.get(expressionKey);\n\t\tif (expr == null) {\n\t\t\texpr = parseExpression(expression);\n\t\t\tcache.put(expressionKey, expr);\n\t\t}\n\t\treturn expr;\n\t}"
  },
  "org.springframework.context.expression.<unknown>#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof Map, \"Target must be of type Map\");\n\t\tMap<?, ?> map = (Map<?, ?>) target;\n\t\tObject value = map.get(name);\n\t\tif (value == null && !map.containsKey(name)) {\n\t\t\tthrow new MapAccessException(name);\n\t\t}\n\t\treturn new TypedValue(value);\n\t}"
  },
  "org.springframework.context.expression.<unknown>#write(context,target,name,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)\n\t\t\tthrows AccessException {\n\n\t\tAssert.state(target instanceof Map, \"Target must be a Map\");\n\t\tMap<Object, Object> map = (Map<Object, Object>) target;\n\t\tmap.put(name, newValue);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 1314
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 1323
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(name,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1151
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(name,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1145
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name, requiredType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1163
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(requiredType, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1279
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1255
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1291
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1364
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn getMessageSource().getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1369
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(resolvable,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1374
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#invokeBeanFactoryPostProcessors(beanFactory,beanFactoryPostProcessors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanFactoryPostProcessors"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)",
    "source_code": "\tpublic static void invokeBeanFactoryPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.\n\t\tSet<String> processedBeans = new HashSet<>();\n\n\t\tif (beanFactory instanceof BeanDefinitionRegistry registry) {\n\t\t\tList<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n\t\t\tList<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor registryProcessor) {\n\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t\t\t\tregistryProcessors.add(registryProcessor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregularPostProcessors.add(postProcessor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement\n\t\t\t// PriorityOrdered, Ordered, and the rest.\n\t\t\tList<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n\t\t\tString[] postProcessorNames =\n\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n\t\t\tboolean reiterate = true;\n\t\t\twhile (reiterate) {\n\t\t\t\treiterate = false;\n\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\t\tif (!processedBeans.contains(ppName)) {\n\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t\t\treiterate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\t\tcurrentRegistryProcessors.clear();\n\t\t\t}\n\n\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n\t\t}\n\n\t\telse {\n\t\t\t// Invoke factory processors registered with the context instance.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\tString[] postProcessorNames =\n\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (processedBeans.contains(ppName)) {\n\t\t\t\t// skip - already processed in first phase above\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n\t\tList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : orderedPostProcessorNames) {\n\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n\t\t// Finally, invoke all other BeanFactoryPostProcessors.\n\t\tList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) {\n\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n\t\t// Clear cached merged bean definitions since the post-processors might have\n\t\t// modified the original metadata, e.g. replacing placeholders in values...\n\t\tbeanFactory.clearMetadataCache();\n\t}"
  },
  "org.springframework.context.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 1204
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\t\tif (!(bean instanceof BeanPostProcessor) && !isInfrastructureBean(beanName) &&\n\t\t\t\t\tthis.beanFactory.getBeanPostProcessorCount() < this.beanPostProcessorTargetCount) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Bean '\" + beanName + \"' of type [\" + bean.getClass().getName() +\n\t\t\t\t\t\t\t\"] is not eligible for getting processed by all BeanPostProcessors \" +\n\t\t\t\t\t\t\t\"(for example: not eligible for auto-proxying)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactory,props)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Implemented for compatibility with\n\t * {@link org.springframework.beans.factory.config.PlaceholderConfigurerSupport}.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @deprecated in favor of\n\t * {@link #processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"Call processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver) instead\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactoryToProcess,propertyResolver)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Visit each bean definition in the given bean factory and attempt to replace ${...} property\n\t * placeholders with values from the given properties.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactoryToProcess",
      "propertyResolver"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,\n\t\t\tfinal ConfigurablePropertyResolver propertyResolver)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,\n\t\t\tfinal ConfigurablePropertyResolver propertyResolver) throws BeansException {\n\n\t\tpropertyResolver.setPlaceholderPrefix(this.placeholderPrefix);\n\t\tpropertyResolver.setPlaceholderSuffix(this.placeholderSuffix);\n\t\tpropertyResolver.setValueSeparator(this.valueSeparator);\n\n\t\tStringValueResolver valueResolver = strVal -> {\n\t\t\tString resolved = (this.ignoreUnresolvablePlaceholders ?\n\t\t\t\t\tpropertyResolver.resolvePlaceholders(strVal) :\n\t\t\t\t\tpropertyResolver.resolveRequiredPlaceholders(strVal));\n\t\t\tif (this.trimValues) {\n\t\t\t\tresolved = resolved.trim();\n\t\t\t}\n\t\t\treturn (resolved.equals(this.nullValue) ? null : resolved);\n\t\t};\n\n\t\tdoProcessProperties(beanFactoryToProcess, valueResolver);\n\t}"
  },
  "org.springframework.context.support.<unknown>#publishEvent(event,eventType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Publish the given event to all listeners.\n\t * @param event the event to publish (may be an {@link ApplicationEvent}\n\t * or a payload object to be turned into a {@link PayloadApplicationEvent})\n\t * @param eventType the resolved event type, if known\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "event",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "void",
    "signature": "protected void publishEvent(Object event, @Nullable ResolvableType eventType)",
    "source_code": "\tprotected void publishEvent(Object event, @Nullable ResolvableType eventType) {\n\t\tAssert.notNull(event, \"Event must not be null\");\n\n\t\t// Decorate event as an ApplicationEvent if necessary\n\t\tApplicationEvent applicationEvent;\n\t\tif (event instanceof ApplicationEvent) {\n\t\t\tapplicationEvent = (ApplicationEvent) event;\n\t\t}\n\t\telse {\n\t\t\tapplicationEvent = new PayloadApplicationEvent<>(this, event, eventType);\n\t\t\tif (eventType == null) {\n\t\t\t\teventType = ((PayloadApplicationEvent<?>) applicationEvent).getResolvableType();\n\t\t\t}\n\t\t}\n\n\t\t// Multicast right now if possible - or lazily once the multicaster is initialized\n\t\tif (this.earlyApplicationEvents != null) {\n\t\t\tthis.earlyApplicationEvents.add(applicationEvent);\n\t\t}\n\t\telse {\n\t\t\tgetApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);\n\t\t}\n\n\t\t// Publish event via parent context as well...\n\t\tif (this.parent != null) {\n\t\t\tif (this.parent instanceof AbstractApplicationContext) {\n\t\t\t\t((AbstractApplicationContext) this.parent).publishEvent(event, eventType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.parent.publishEvent(event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanPostProcessors(beanFactory,applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "public void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)",
    "source_code": "\tpublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n\t\t// Register BeanPostProcessorChecker that logs an info message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n\t\tbeanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n\t\t// Separate between BeanPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, register the BeanPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t// Next, register the BeanPostProcessors that implement Ordered.\n\t\tList<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t// Now, register all regular BeanPostProcessors.\n\t\tList<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t// Finally, re-register all internal BeanPostProcessors.\n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}"
  },
  "org.springframework.core.<unknown>#createApproximateCollection(collection,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most approximate collection for the given collection.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the type of elements contained in the supplied\n\t * {@code collection}, type safety cannot be guaranteed if the supplied\n\t * {@code collection} is an {@link EnumSet}. In such scenarios, the caller\n\t * is responsible for ensuring that the element type for the supplied\n\t * {@code collection} is an enum type matching type {@code E}. As an\n\t * alternative, the caller may wish to treat the return value as a raw\n\t * collection or collection of {@link Object}.\n\t * @param collection the original collection object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty collection instance\n\t * @see #isApproximableCollectionType\n\t * @see java.util.LinkedList\n\t * @see java.util.ArrayList\n\t * @see java.util.EnumSet\n\t * @see java.util.TreeSet\n\t * @see java.util.LinkedHashSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createApproximateCollection(@Nullable Object collection, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {\n\t\tif (collection instanceof LinkedList) {\n\t\t\treturn new LinkedList<>();\n\t\t}\n\t\telse if (collection instanceof List) {\n\t\t\treturn new ArrayList<>(capacity);\n\t\t}\n\t\telse if (collection instanceof EnumSet enumSet) {\n\t\t\tCollection<E> copy = EnumSet.copyOf(enumSet);\n\t\t\tcopy.clear();\n\t\t\treturn copy;\n\t\t}\n\t\telse if (collection instanceof SortedSet sortedSet) {\n\t\t\treturn new TreeSet<>(sortedSet.comparator());\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createApproximateMap(map,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most approximate map for the given map.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K} is\n\t * not bound to the type of keys contained in the supplied {@code map},\n\t * type safety cannot be guaranteed if the supplied {@code map} is an\n\t * {@link EnumMap}. In such scenarios, the caller is responsible for\n\t * ensuring that the key type in the supplied {@code map} is an enum type\n\t * matching type {@code K}. As an alternative, the caller may wish to\n\t * treat the return value as a raw map or map keyed by {@link Object}.\n\t * @param map the original map object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty map instance\n\t * @see #isApproximableMapType\n\t * @see java.util.EnumMap\n\t * @see java.util.TreeMap\n\t * @see java.util.LinkedHashMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "map",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "V>",
    "signature": "public V> createApproximateMap(@Nullable Object map, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {\n\t\tif (map instanceof EnumMap enumMap) {\n\t\t\tEnumMap copy = new EnumMap(enumMap);\n\t\t\tcopy.clear();\n\t\t\treturn copy;\n\t\t}\n\t\telse if (map instanceof SortedMap sortedMap) {\n\t\t\treturn new TreeMap<>(sortedMap.comparator());\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p>Delegates to {@link #createCollection(Class, Class, int)} with a\n\t * {@code null} element type.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType}\n\t * is {@code null} or of type {@link EnumSet}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {\n\t\treturn createCollection(collectionType, null, capacity);\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,elementType,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the supplied {@code elementType}, type safety cannot be\n\t * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\n\t * In such scenarios, the caller is responsible for ensuring that the\n\t * supplied {@code elementType} is an enum type matching type {@code E}.\n\t * As an alternative, the caller may wish to treat the return value as a\n\t * raw collection or collection of {@link Object}.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param elementType the collection's element type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumSet} creation)\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType} is\n\t * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\n\t * the supplied {@code elementType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashSet\n\t * @see java.util.ArrayList\n\t * @see java.util.TreeSet\n\t * @see java.util.EnumSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (collectionType.isInterface()) {\n\t\t\tif (Set.class == collectionType || Collection.class == collectionType) {\n\t\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t\t}\n\t\t\telse if (List.class == collectionType) {\n\t\t\t\treturn new ArrayList<>(capacity);\n\t\t\t}\n\t\t\telse if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {\n\t\t\t\treturn new TreeSet<>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Collection interface: \" + collectionType.getName());\n\t\t\t}\n\t\t}\n\t\telse if (EnumSet.class.isAssignableFrom(collectionType)) {\n\t\t\tAssert.notNull(elementType, \"Cannot create EnumSet for unknown element type\");\n\t\t\treturn EnumSet.noneOf(asEnumType(elementType));\n\t\t}\n\t\telse {\n\t\t\tif (!Collection.class.isAssignableFrom(collectionType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Collection type: \" + collectionType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not instantiate Collection type: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p>Delegates to {@link #createMap(Class, Class, int)} with a\n\t * {@code null} key type.\n\t * @param mapType the desired type of the target map\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null} or of type {@link EnumMap}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {\n\t\treturn createMap(mapType, null, capacity);\n\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,keyType,capacity)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K}\n\t * is not bound to the supplied {@code keyType}, type safety cannot be\n\t * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\n\t * scenarios, the caller is responsible for ensuring that the {@code keyType}\n\t * is an enum type matching type {@code K}. As an alternative, the caller\n\t * may wish to treat the return value as a raw map or map keyed by\n\t * {@link Object}. Similarly, type safety cannot be enforced if the\n\t * desired {@code mapType} is {@link MultiValueMap}.\n\t * @param mapType the desired type of the target map (never {@code null})\n\t * @param keyType the map's key type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumMap} creation)\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\n\t * the supplied {@code keyType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashMap\n\t * @see java.util.TreeMap\n\t * @see org.springframework.util.LinkedMultiValueMap\n\t * @see java.util.EnumMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (mapType.isInterface()) {\n\t\t\tif (Map.class == mapType) {\n\t\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t\t}\n\t\t\telse if (SortedMap.class == mapType || NavigableMap.class == mapType) {\n\t\t\t\treturn new TreeMap<>();\n\t\t\t}\n\t\t\telse if (MultiValueMap.class == mapType) {\n\t\t\t\treturn new LinkedMultiValueMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map interface: \" + mapType.getName());\n\t\t\t}\n\t\t}\n\t\telse if (EnumMap.class == mapType) {\n\t\t\tAssert.notNull(keyType, \"Cannot create EnumMap for unknown key type\");\n\t\t\treturn new EnumMap(asEnumType(keyType));\n\t\t}\n\t\telse {\n\t\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map type: \" + mapType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not instantiate Map type: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createSortedProperties(properties,omitComments)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@code Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * <p>The returned {@code Properties} instance will be populated with\n\t * properties from the supplied {@code properties} object, but default\n\t * properties from the supplied {@code properties} object will not be copied.\n\t * @param properties the {@code Properties} object from which to copy the\n\t * initial properties\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "omitComments"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Properties",
    "signature": "public Properties createSortedProperties(Properties properties, boolean omitComments)",
    "source_code": "\tpublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\n\t\treturn new SortedProperties(properties, omitComments);\n\t}"
  },
  "org.springframework.core.<unknown>#forClass(baseType,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified base type\n\t * (interface or base class) with a given implementation class.\n\t * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\n\t * @param baseType the base type (must not be {@code null})\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified base type backed by the\n\t * given implementation class\n\t * @see #forClass(Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseType",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1050
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forClass(Class<?> baseType, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {\n\t\tAssert.notNull(baseType, \"Base type must not be null\");\n\t\tResolvableType asType = forType(implementationClass).as(baseType);\n\t\treturn (asType == NONE ? forType(baseType) : asType);\n\t}"
  },
  "org.springframework.core.<unknown>#forClassWithGenerics(clazz,generics)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@link ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "generics"
    ],
    "position": {
      "column": 1,
      "line": 1080
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forClassWithGenerics(Class<?> clazz, ResolvableType... generics)",
    "source_code": "\tpublic static ResolvableType forClassWithGenerics(Class<?> clazz, ResolvableType... generics) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(generics, \"Generics array must not be null\");\n\t\tTypeVariable<?>[] variables = clazz.getTypeParameters();\n\t\tAssert.isTrue(variables.length == generics.length, () -> \"Mismatched number of generics specified for \" + clazz.toGenericString());\n\n\t\tType[] arguments = new Type[generics.length];\n\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\tResolvableType generic = generics[i];\n\t\t\tType argument = (generic != null ? generic.getType() : null);\n\t\t\targuments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);\n\t\t}\n\n\t\tParameterizedType syntheticType = new SyntheticParameterizedType(clazz, arguments);\n\t\treturn forType(syntheticType, new TypeVariablesVariableResolver(variables, generics));\n\t}"
  },
  "org.springframework.core.<unknown>#forConstructorParameter(constructor,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Constructor} parameter.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@link ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1200
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(constructor, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forConstructorParameter(constructor,parameterIndex,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Constructor} parameter\n\t * with a given implementation. Use this variant when the class that declares the\n\t * constructor includes generic parameter variables that are satisfied by the\n\t * implementation class.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "parameterIndex",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1216
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass) {\n\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forExecutable(executable,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 810
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forExecutable(Executable executable, int parameterIndex)",
    "source_code": "\tpublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method) {\n\t\t\treturn new MethodParameter((Method) executable, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor) {\n\t\t\treturn new MethodParameter((Constructor<?>) executable, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1139
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation type.\n\t * @param field the source field\n\t * @param implementationType the implementation type\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1155
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, @Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = (implementationType != null ? implementationType : NONE);\n\t\towner = owner.as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with the\n\t * given nesting level.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1170
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, int nestingLevel)",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\treturn forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,nestingLevel,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Field} with a given\n\t * implementation and the given nesting level.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1187
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodOrConstructor(methodOrConstructor,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param methodOrConstructor the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @deprecated as of 5.0, in favor of {@link #forExecutable}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodOrConstructor",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex)",
    "source_code": "\tpublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\n\t\tif (!(methodOrConstructor instanceof Executable)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\n\t\t}\n\t\treturn forExecutable((Executable) methodOrConstructor, parameterIndex);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} parameter.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1258
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(method, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} parameter with a\n\t * given implementation. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation class.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1274
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,implementationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1299
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType) {\n\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\timplementationType = (implementationType != null ? implementationType :\n\t\t\t\tforType(methodParameter.getContainingClass()));\n\t\tResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\n\t\treturn forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter},\n\t * overriding the target type to resolve with a specific given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 1318
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\treturn forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodReturnType(method,implementationClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Method} return type.\n\t * <p>Use this variant when the class that declares the method includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param method the source for the method return type\n\t * @param implementationClass the implementation class\n\t * @return a {@link ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1244
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodReturnType(Method method, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forType(type,owner)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@link ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 1373
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner)",
    "source_code": "\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}"
  },
  "org.springframework.core.<unknown>#getNested(nestingLevel,Map<Integer,typeIndexesPerLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (e.g. a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (may be {@code null})\n\t * @return a {@link ResolvableType} for the nested level, or {@link #NONE}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel",
      "Map<Integer",
      "typeIndexesPerLevel"
    ],
    "position": {
      "column": 1,
      "line": 638
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel)",
    "source_code": "\tpublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\n\t\tResolvableType result = this;\n\t\tfor (int i = 2; i <= nestingLevel; i++) {\n\t\t\tif (result.isArray()) {\n\t\t\t\tresult = result.getComponentType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle derived types\n\t\t\t\twhile (result != ResolvableType.NONE && !result.hasGenerics()) {\n\t\t\t\t\tresult = result.getSuperType();\n\t\t\t\t}\n\t\t\t\tInteger index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\n\t\t\t\tindex = (index == null ? result.getGenerics().length - 1 : index);\n\t\t\t\tresult = result.getGeneric(index);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.<unknown>#getQualifiedAttributeName(enclosingClass,attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enclosingClass",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "String",
    "signature": "public String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName)",
    "source_code": "\tpublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\n\t\tAssert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\treturn enclosingClass.getName() + '.' + attributeName;\n\t}"
  },
  "org.springframework.core.<unknown>#getVariableNameForReturnType(method,resolvedType,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, e.g. {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "resolvedType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value)",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\n\t\tif (Object.class == resolvedType) {\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for an Object return type with null value\");\n\t\t\t}\n\t\t\treturn getVariableName(value);\n\t\t}\n\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (resolvedType.isArray()) {\n\t\t\tvalueClass = resolvedType.getComponentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(resolvedType)) {\n\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tif (!(value instanceof Collection<?> collection)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and a non-Collection value\");\n\t\t\t\t}\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and an empty Collection value\");\n\t\t\t\t}\n\t\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = resolvedType;\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}"
  },
  "org.springframework.core.<unknown>#getVariableNameForReturnType(method,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, e.g. {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String getVariableNameForReturnType(Method method, @Nullable Object value)",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), value);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#asMap(Function<MergedAnnotation<?>,factory,adaptations)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<MergedAnnotation<?>",
      "factory",
      "adaptations"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "T",
    "signature": "public T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations)",
    "source_code": "\tpublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\n\t\tT map = factory.apply(this);\n\t\tAssert.state(map != null, \"Factory used to create MergedAnnotation Map must not return null\");\n\t\tAttributeMethods attributes = this.mapping.getAttributes();\n\t\tfor (int i = 0; i < attributes.size(); i++) {\n\t\t\tMethod attribute = attributes.get(i);\n\t\t\tObject value = (isFiltered(attribute.getName()) ? null :\n\t\t\t\t\tgetValue(i, getTypeForMapOptions(attribute, adaptations)));\n\t\t\tif (value != null) {\n\t\t\t\tmap.put(attribute.getName(),\n\t\t\t\t\t\tadaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(annotatedElement,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the supplied element.\n\t * <p><strong>Warning</strong>: this method operates generically on\n\t * annotated elements. In other words, this method does not execute\n\t * specialized search algorithms for classes or methods. If you require\n\t * the more specific semantics of {@link #findAnnotation(Class, Class)}\n\t * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\n\t * instead.\n\t * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "A",
    "signature": "public A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(\n\t\t\tAnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\n\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link Class}, traversing its interfaces, annotations, and\n\t * superclasses if the annotation is not <em>directly present</em> on\n\t * the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\n\t * as meta-annotations and annotations on interfaces</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return it if found.\n\t * <li>Recursively search through all annotations that the given class declares.\n\t * <li>Recursively search through all interfaces that the given class declares.\n\t * <li>Recursively search through the superclass hierarchy of the given class.\n\t * </ol>\n\t * <p>Note: in this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current interface,\n\t * annotation, or superclass as the class to look for annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "A",
    "signature": "public A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\tA annotation = clazz.getDeclaredAnnotation(annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t\t// For backwards compatibility, perform a superclass search with plain annotations\n\t\t\t// even if not marked as @Inherited: e.g. a findAnnotation search for @Deprecated\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass == null || superclass == Object.class) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn findAnnotation(superclass, annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(method,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "A",
    "signature": "public A findAnnotation(Method method, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\n\t\t\treturn method.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#firstRunOf(MergedAnnotation<A>,valueExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches only\n\t * the first run of an extracted value. For example,\n\t * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\n\t * will match the first annotation, and any subsequent runs that have the\n\t * same distance.\n\t * <p>NOTE: This predicate only matches the first run. Once the extracted\n\t * value changes, the predicate always returns {@code false}. For example,\n\t * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\n\t * only the first two will match.\n\t * @param valueExtractor function used to extract the value to check\n\t * @return a {@link Predicate} that matches the first run of the extracted\n\t * values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MergedAnnotation<A>",
      "valueExtractor"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Predicate<MergedAnnotation<A>>",
    "signature": "public Predicate<MergedAnnotation<A>> firstRunOf(Function<? super MergedAnnotation<A>, ?> valueExtractor)",
    "source_code": "\tpublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(\n\t\t\tFunction<? super MergedAnnotation<A>, ?> valueExtractor) {\n\n\t\treturn new FirstRunOfPredicate<>(valueExtractor);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#forExecutable(executable,parameterIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new SynthesizingMethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding SynthesizingMethodParameter instance\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "SynthesizingMethodParameter",
    "signature": "public SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex)",
    "source_code": "\tpublic static SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new SynthesizingMethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new SynthesizingMethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#fromMap(Map<String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@link AnnotationAttributes} instance based on the given map.\n\t * <p>If the map is already an {@code AnnotationAttributes} instance, it\n\t * will be cast and returned immediately without creating a new instance.\n\t * Otherwise a new instance will be created by passing the supplied map\n\t * to the {@link #AnnotationAttributes(Map)} constructor.\n\t * @param map original source of annotation attribute <em>key-value</em> pairs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes fromMap(@Nullable Map<String, Object> map)",
    "source_code": "\tpublic static AnnotationAttributes fromMap(@Nullable Map<String, Object> map) {\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (map instanceof AnnotationAttributes annotationAttributes) {\n\t\t\treturn annotationAttributes;\n\t\t}\n\t\treturn new AnnotationAttributes(map);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotatedElement,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\n\t * <em>meta-present</em> on the {@code AnnotatedElement}.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(AnnotatedElement, Class)} instead.\n\t * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "A",
    "signature": "public A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotation,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * annotation: either the given annotation itself or a direct meta-annotation\n\t * thereof.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use one of the\n\t * {@code find*()} methods instead.\n\t * @param annotation the Annotation to check\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "A",
    "signature": "public A getAnnotation(Annotation annotation, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (annotationType.isInstance(annotation)) {\n\t\t\treturn synthesizeAnnotation((A) annotation, annotationType);\n\t\t}\n\t\t// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {\n\t\t\treturn null;\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotation, new Annotation[] {annotation}, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(attributeName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation of type {@code annotationType} stored under the\n\t * specified {@code attributeName}.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "A",
    "signature": "public A getAnnotation(String attributeName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {\n\t\treturn getRequiredAttribute(attributeName, annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "MergedAnnotation<T>",
    "signature": "public MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)\n\t\t\tthrows NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.isAssignable(type, attribute.getReturnType(),\n\t\t\t\t() -> \"Attribute \" + attributeName + \" type mismatch:\");\n\t\treturn (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(method,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the\n\t * supplied {@link Method}, where the annotation is either <em>present</em>\n\t * or <em>meta-present</em> on the method.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(Method, Class)} instead.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see #getAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "A",
    "signature": "public A getAnnotation(Method method, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {\n\t\tMethod resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\treturn getAnnotation((AnnotatedElement) resolvedMethod, annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationArray(attributeName,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the array of type {@code annotationType} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an {@code Annotation}, it will be wrapped in a single-element array\n\t * before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation array\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "A[]",
    "signature": "public A[] getAnnotationArray(String attributeName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {\n\t\tObject array = Array.newInstance(annotationType, 0);\n\t\treturn (A[]) getRequiredAttribute(attributeName, array.getClass());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationArray(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "MergedAnnotation<T>[]",
    "signature": "public MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(\n\t\t\tString attributeName, Class<T> type) throws NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tClass<?> componentType = attribute.getReturnType().getComponentType();\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.notNull(componentType, () -> \"Attribute \" + attributeName + \" is not an array\");\n\t\tAssert.isAssignable(type, componentType, () -> \"Attribute \" + attributeName + \" component type mismatch:\");\n\t\treturn (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\n\n\t\treturn getAnnotationAttributes(annotatedElement, annotation, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn MergedAnnotation.from(annotatedElement, annotation)\n\t\t\t\t.withNonMergedAttributes()\n\t\t\t\t.asMap(mergedAnnotation ->\n\t\t\t\t\t\tnew AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotation,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as a {@link Map}.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(Annotation annotation, boolean classValuesAsString)",
    "source_code": "\tpublic static Map<String, Object> getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString) {\n\n\t\treturn getAnnotationAttributes(annotation, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotation,classValuesAsString,nestedAnnotationsAsMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 3.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 825
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\treturn getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAttributeValue(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "T",
    "signature": "protected T getAttributeValue(String attributeName, Class<T> type)",
    "source_code": "\tprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\treturn (attributeIndex != -1 ? getValue(attributeIndex, type) : null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType",
      "containerAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables();\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotation,attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1134
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\treturn (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotationType,attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given the\n\t * {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @param attributeName the name of the attribute value to retrieve.\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1159
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(\n\t\t\t@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\n\n\t\tif (annotationType == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(attributeName,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> getDefaultValue(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\tif (attributeIndex == -1) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\treturn Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getOrder(type,defaultOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the order on the specified {@code type}, or the specified\n\t * default value if none can be found.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param type the type to handle\n\t * @return the priority value, or the specified default order if none can be found\n\t * @see #getPriority(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "defaultOrder"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Integer",
    "signature": "public Integer getOrder(Class<?> type, @Nullable Integer defaultOrder)",
    "source_code": "\tpublic static Integer getOrder(Class<?> type, @Nullable Integer defaultOrder) {\n\t\tInteger order = getOrder(type);\n\t\treturn (order != null ? order : defaultOrder);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getRepeatableAnnotations(annotatedElement,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Set<A>",
    "signature": "public Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType",
      "containerAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "Set<A>",
    "signature": "public Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = (containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables());\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getValue(annotation,attributeName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1046
    },
    "return": "Object",
    "signature": "public Object getValue(@Nullable Annotation annotation, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\tif (annotation == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = annotation.annotationType().getDeclaredMethod(attributeName);\n\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\treturn method.invoke(annotation);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\trethrowAnnotationConfigurationException(ex.getTargetException());\n\t\t\tthrow new IllegalStateException(\"Could not obtain value for annotation attribute '\" +\n\t\t\t\t\tattributeName + \"' in \" + annotation, ex);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleIntrospectionFailure(annotation.getClass(), ex);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\tpublic Object invoke(Object proxy, Method method, Object[] args) {\n\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\treturn annotationEquals(args[0]);\n\t\t}\n\t\tif (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\treturn annotationHashCode();\n\t\t}\n\t\tif (ReflectionUtils.isToStringMethod(method)) {\n\t\t\treturn annotationToString();\n\t\t}\n\t\tif (isAnnotationTypeMethod(method)) {\n\t\t\treturn this.type;\n\t\t}\n\t\tif (this.attributes.indexOf(method.getName()) != -1) {\n\t\t\treturn getAttributeValue(method);\n\t\t}\n\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\"Method [%s] is unsupported for synthesized annotation type [%s]\", method, this.type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationDeclaredLocally(annotationType,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is declared locally (i.e. <em>directly present</em>) on the supplied\n\t * {@code clazz}.\n\t * <p>The supplied {@link Class} may represent any type.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>Note: This method does <strong>not</strong> determine if the annotation\n\t * is {@linkplain java.lang.annotation.Inherited inherited}.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>directly present</em>\n\t * @see java.lang.Class#getDeclaredAnnotations()\n\t * @see java.lang.Class#getDeclaredAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationInherited(annotationType,clazz)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@code clazz} and is\n\t * {@linkplain java.lang.annotation.Inherited inherited}\n\t * (i.e. not <em>directly present</em>).\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked. In accordance with standard meta-annotation\n\t * semantics in Java, the inheritance hierarchy for interfaces will not\n\t * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\n\t * for the {@code @Inherited} meta-annotation for further details regarding\n\t * annotation inheritance.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> and <em>inherited</em>\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see #isAnnotationDeclaredLocally(Class, Class)\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotation::isDirectlyPresent)\n\t\t\t\t.findFirst().orElseGet(MergedAnnotation::missing)\n\t\t\t\t.getAggregateIndex() > 0;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationMetaPresent(annotationType,metaAnnotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of type {@code metaAnnotationType} is\n\t * <em>meta-present</em> on the supplied {@code annotationType}.\n\t * @param annotationType the annotation type to search on\n\t * @param metaAnnotationType the type of meta-annotation to search for\n\t * @return {@code true} if such an annotation is meta-present\n\t * @since 4.2.1\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "metaAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType)",
    "source_code": "\tpublic static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType) {\n\n\t\tif (metaAnnotationType == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(metaAnnotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {\n\t\t\treturn annotationType.isAnnotationPresent(metaAnnotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS,\n\t\t\t\tRepeatableContainers.none()).isPresent(metaAnnotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationName the fully-qualified name of the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, String annotationName)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\n\t\tif (annotationName.startsWith(\"java.\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationType the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn isCandidateClass(clazz, annotationType.getName());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying one of the specified\n\t * annotations (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationTypes the searchable annotation types\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t * @see #isCandidateClass(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tif (isCandidateClass(clazz, annotationType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#postProcessAnnotationAttributes(annotatedElement,attributes,classValuesAsString)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the supplied {@link AnnotationAttributes}, preserving nested\n\t * annotations as {@code Annotation} instances.\n\t * <p>Specifically, this method enforces <em>attribute alias</em> semantics\n\t * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\n\t * and replaces default value placeholders with their original default values.\n\t * @param annotatedElement the element that is annotated with an annotation or\n\t * annotation hierarchy from which the supplied attributes were created;\n\t * may be {@code null} if unknown\n\t * @param attributes the annotation attributes to post-process\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @since 4.3.2\n\t * @see #getDefaultValue(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "attributes",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 947
    },
    "return": "void",
    "signature": "public void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString)",
    "source_code": "\tpublic static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {\n\n\t\tif (attributes == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!attributes.validated) {\n\t\t\tClass<? extends Annotation> annotationType = attributes.annotationType();\n\t\t\tif (annotationType == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n\t\t\tfor (int i = 0; i < mapping.getMirrorSets().size(); i++) {\n\t\t\t\tMirrorSet mirrorSet = mapping.getMirrorSets().get(i);\n\t\t\t\tint resolved = mirrorSet.resolve(attributes.displayName, attributes,\n\t\t\t\t\t\tAnnotationUtils::getAttributeValueForMirrorResolution);\n\t\t\t\tif (resolved != -1) {\n\t\t\t\t\tMethod attribute = mapping.getAttributes().get(resolved);\n\t\t\t\t\tObject value = attributes.get(attribute.getName());\n\t\t\t\t\tfor (int j = 0; j < mirrorSet.size(); j++) {\n\t\t\t\t\t\tMethod mirror = mirrorSet.get(j);\n\t\t\t\t\t\tif (mirror != attribute) {\n\t\t\t\t\t\t\tattributes.put(mirror.getName(),\n\t\t\t\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {\n\t\t\tString attributeName = attributeEntry.getKey();\n\t\t\tObject value = attributeEntry.getValue();\n\t\t\tif (value instanceof DefaultValueHolder defaultValueHolder) {\n\t\t\t\tvalue = defaultValueHolder.defaultValue;\n\t\t\t\tattributes.put(attributeName,\n\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesizeAnnotation(Map<String,attributes,annotationType,annotatedElement)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Synthesize</em> an annotation from the supplied map of annotation\n\t * attributes by wrapping the map in a dynamic proxy that implements an\n\t * annotation of the specified {@code annotationType} and transparently\n\t * enforces <em>attribute alias</em> semantics for annotation attributes\n\t * that are annotated with {@link AliasFor @AliasFor}.\n\t * <p>The supplied map must contain a key-value pair for every attribute\n\t * defined in the supplied {@code annotationType} that is not aliased or\n\t * does not have a default value. Nested maps and nested arrays of maps\n\t * will be recursively synthesized into nested annotations or nested\n\t * arrays of annotations, respectively.\n\t * <p>Note that {@link AnnotationAttributes} is a specialized type of\n\t * {@link Map} that is an ideal candidate for this method's\n\t * {@code attributes} argument.\n\t * @param attributes the map of annotation attributes to synthesize\n\t * @param annotationType the type of annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the annotation\n\t * corresponding to the supplied attributes; may be {@code null} if unknown\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing or if an\n\t * attribute is not of the correct type\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes",
      "annotationType",
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 1242
    },
    "return": "A",
    "signature": "public A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement) {\n\n\t\ttry {\n\t\t\treturn MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();\n\t\t}\n\t\tcatch (NoSuchElementException | IllegalStateException ex) {\n\t\t\tthrow new IllegalArgumentException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesizeAnnotation(annotation,annotatedElement)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Synthesize</em> an annotation from the supplied {@code annotation}\n\t * by wrapping it in a dynamic proxy that transparently enforces\n\t * <em>attribute alias</em> semantics for annotation attributes that are\n\t * annotated with {@link AliasFor @AliasFor}.\n\t * @param annotation the annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * annotation; may be {@code null} if unknown\n\t * @return the synthesized annotation if the supplied annotation is\n\t * <em>synthesizable</em>; {@code null} if the supplied annotation is\n\t * {@code null}; otherwise the supplied annotation unmodified\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 1185
    },
    "return": "A",
    "signature": "public A synthesizeAnnotation(A annotation, @Nullable AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static <A extends Annotation> A synthesizeAnnotation(\n\t\t\tA annotation, @Nullable AnnotatedElement annotatedElement) {\n\n\t\tif (annotation instanceof SynthesizedAnnotation || AnnotationFilter.PLAIN.matches(annotation)) {\n\t\t\treturn annotation;\n\t\t}\n\t\treturn MergedAnnotation.from(annotatedElement, annotation).synthesize();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#unique(MergedAnnotation<A>,keyExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches\n\t * annotations that are unique based on the extracted key. For example\n\t * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\n\t * match the first time a unique type is encountered.\n\t * @param keyExtractor function used to extract the key used to test for\n\t * uniqueness\n\t * @return a {@link Predicate} that matches a unique annotation based on the\n\t * extracted key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MergedAnnotation<A>",
      "keyExtractor"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Predicate<MergedAnnotation<A>>",
    "signature": "public Predicate<MergedAnnotation<A>> unique(Function<? super MergedAnnotation<A>, K> keyExtractor)",
    "source_code": "\tpublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(\n\t\t\tFunction<? super MergedAnnotation<A>, K> keyExtractor) {\n\n\t\treturn new UniquePredicate<>(keyExtractor);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#collection(collectionType,elementTypeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new type descriptor from a {@link java.util.Collection} type.\n\t * <p>Useful for converting to typed Collections.\n\t * <p>For example, a {@code List<String>} could be converted to a\n\t * {@code List<EmailAddress>} by converting to a targetType built with this method.\n\t * The method call to construct such a {@code TypeDescriptor} would look something\n\t * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}\n\t * @param collectionType the collection type, which must implement {@link Collection}.\n\t * @param elementTypeDescriptor a descriptor for the collection's element type,\n\t * used to convert collection elements\n\t * @return the collection type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementTypeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor)",
    "source_code": "\tpublic static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (!Collection.class.isAssignableFrom(collectionType)) {\n\t\t\tthrow new IllegalArgumentException(\"Collection type must be a [java.util.Collection]\");\n\t\t}\n\t\tResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#map(mapType,keyTypeDescriptor,valueTypeDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new type descriptor from a {@link java.util.Map} type.\n\t * <p>Useful for converting to typed Maps.\n\t * <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt;\n\t * by converting to a targetType built with this method:\n\t * The method call to construct such a TypeDescriptor would look something like:\n\t * <pre class=\"code\">\n\t * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));\n\t * </pre>\n\t * @param mapType the map type, which must implement {@link Map}\n\t * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys\n\t * @param valueTypeDescriptor the map's value type, used to convert map values\n\t * @return the map type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyTypeDescriptor",
      "valueTypeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor)",
    "source_code": "\tpublic static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor) {\n\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\tthrow new IllegalArgumentException(\"Map type must be a [java.util.Map]\");\n\t\t}\n\t\tResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);\n\t\tResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(field,nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the field.\n\t * <p>For example, if the field is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the field is a {@code List<List<String>>} and the nesting level is\n\t * 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the field is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the field is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param field the field\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the field\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Field field, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Field field, int nestingLevel) {\n\t\treturn nested(new TypeDescriptor(field), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(methodParameter,nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the method parameter.\n\t * <p>For example, if the methodParameter is a {@code List<String>} and the\n\t * nesting level is 1, the nested type descriptor will be String.class.\n\t * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\n\t * level is 2, the nested type descriptor will also be a String.class.\n\t * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\n\t * level is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\n\t * nesting level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\n\t * For example, if the method parameter is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param methodParameter the method parameter with a nestingLevel of 1\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the method parameter\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the nesting level of the input\n\t * {@link MethodParameter} argument is not 1, or if the types up to the\n\t * specified nesting level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 643
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {\n\t\tif (methodParameter.getNestingLevel() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"MethodParameter nesting level must be 1: \" +\n\t\t\t\t\t\"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal\");\n\t\t}\n\t\treturn nested(new TypeDescriptor(methodParameter), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(property,nestingLevel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the property.\n\t * <p>For example, if the property is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the property is a {@code List<List<String>>} and the nesting level\n\t * is 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the property is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the property is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param property the property\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Property property, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Property property, int nestingLevel) {\n\t\treturn nested(new TypeDescriptor(property), nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(Converter<?,converter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Converter<?",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void addConverter(Converter<?, ?> converter)",
    "source_code": "\tpublic void addConverter(Converter<?, ?> converter) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);\n\t\tif (typeInfo == null && converter instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), Converter.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"Converter [\" + converter.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(sourceType,targetType,S,converter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType",
      "S",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter)",
    "source_code": "\tpublic <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter) {\n\t\taddConverter(new ConverterAdapter(\n\t\t\t\tconverter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverterFactory(ConverterFactory<?,factory)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ConverterFactory<?",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void addConverterFactory(ConverterFactory<?, ?> factory)",
    "source_code": "\tpublic void addConverterFactory(ConverterFactory<?, ?> factory) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);\n\t\tif (typeInfo == null && factory instanceof DecoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(((DecoratingProxy) factory).getDecoratedClass(), ConverterFactory.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"ConverterFactory [\" + factory.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterFactoryAdapter(factory,\n\t\t\t\tnew ConvertiblePair(typeInfo[0].toClass(), typeInfo[1].toClass())));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#canBypassConvert(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether conversion between the source type and the target type can be bypassed.\n\t * <p>More precisely, this method will return true if objects of sourceType can be\n\t * converted to the target type by returning the source object unchanged.\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return {@code true} if conversion can be bypassed; {@code false} otherwise\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "boolean",
    "signature": "public boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\tif (sourceType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tGenericConverter converter = getConverter(sourceType, targetType);\n\t\treturn (converter == NO_OP_CONVERTER);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#canConvert(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "boolean",
    "signature": "public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\tif (sourceType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tGenericConverter converter = getConverter(sourceType, targetType);\n\t\treturn (converter != null);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn source;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience operation for converting a source object to the specified targetType,\n\t * where the target type is a descriptor that provides additional conversion context.\n\t * Simply delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)} and\n\t * encapsulates the construction of the source type descriptor using\n\t * {@link TypeDescriptor#forObject(Object)}.\n\t * @param source the source object\n\t * @param targetType the target type\n\t * @return the converted value\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null},\n\t * or sourceType is {@code null} but source is not {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor targetType)",
    "source_code": "\tpublic Object convert(@Nullable Object source, TypeDescriptor targetType) {\n\t\treturn convert(source, TypeDescriptor.forObject(source), targetType);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convertNullSource(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method to convert a {@code null} source.\n\t * <p>The default implementation returns {@code null} or the Java 8\n\t * {@link java.util.Optional#empty()} instance if the target type is\n\t * {@code java.util.Optional}. Subclasses may override this to return\n\t * custom {@code null} objects for specific target types.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the converted null object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Object",
    "signature": "protected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tprotected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType.getObjectType() == Optional.class) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#find(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Find a {@link GenericConverter} given a source and target type.\n\t\t * <p>This method will attempt to match all possible converters by working\n\t\t * through the class and interface hierarchy of the types.\n\t\t * @param sourceType the source type\n\t\t * @param targetType the target type\n\t\t * @return a matching {@link GenericConverter}, or {@code null} if none found\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Search the full type hierarchy\n\t\t\tList<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());\n\t\t\tList<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());\n\t\t\tfor (Class<?> sourceCandidate : sourceCandidates) {\n\t\t\t\tfor (Class<?> targetCandidate : targetCandidates) {\n\t\t\t\t\tConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);\n\t\t\t\t\tGenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);\n\t\t\t\t\tif (converter != null) {\n\t\t\t\t\t\treturn converter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#getConverter(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tfor (GenericConverter converter : this.converters) {\n\t\t\t\tif (!(converter instanceof ConditionalGenericConverter) ||\n\t\t\t\t\t\t((ConditionalGenericConverter) converter).matches(sourceType, targetType)) {\n\t\t\t\t\treturn converter;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#getDefaultConverter(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default converter if no converter is found for the given sourceType/targetType pair.\n\t * <p>Returns a NO_OP Converter if the source type is assignable to the target type.\n\t * Returns {@code null} otherwise, indicating no suitable converter could be found.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the default generic converter that will perform the conversion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "GenericConverter",
    "signature": "protected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tprotected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#matches(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tboolean matches = true;\n\t\t\tif (this.converterFactory instanceof ConditionalConverter) {\n\t\t\t\tmatches = ((ConditionalConverter) this.converterFactory).matches(sourceType, targetType);\n\t\t\t}\n\t\t\tif (matches) {\n\t\t\t\tConverter<?, ?> converter = this.converterFactory.getConverter(targetType.getType());\n\t\t\t\tif (converter instanceof ConditionalConverter) {\n\t\t\t\t\tmatches = ((ConditionalConverter) converter).matches(sourceType, targetType);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matches;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#remove(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "public void remove(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\t\tpublic void remove(Class<?> sourceType, Class<?> targetType) {\n\t\t\tthis.converters.remove(new ConvertiblePair(sourceType, targetType));\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#removeConvertible(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "void",
    "signature": "public void removeConvertible(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\tpublic void removeConvertible(Class<?> sourceType, Class<?> targetType) {\n\t\tthis.converters.remove(sourceType, targetType);\n\t\tinvalidateCache();\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(read,dataBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "dataBuffer"
    ],
    "position": {
      "column": 1,
      "line": 973
    },
    "return": "void",
    "signature": "public void completed(Integer read, DataBuffer dataBuffer)",
    "source_code": "\t\tpublic void completed(Integer read, DataBuffer dataBuffer) {\n\t\t\tif (this.state.get().equals(State.DISPOSED)) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\t\t\tdataBuffer.writePosition(read);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(written,byteBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1124
    },
    "return": "void",
    "signature": "public void completed(Integer written, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void completed(Integer written, ByteBuffer byteBuffer) {\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, byteBuffer, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsinkDataBuffer();\n\n\t\t\tThrowable throwable = this.error.get();\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.sink.error(throwable);\n\t\t\t}\n\t\t\telse if (this.completed.get()) {\n\t\t\t\tthis.sink.complete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequest(1);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(exc,byteBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "byteBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1145
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, ByteBuffer byteBuffer)",
    "source_code": "\t\tpublic void failed(Throwable exc, ByteBuffer byteBuffer) {\n\t\t\tsinkDataBuffer();\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(exc,dataBuffer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exc",
      "dataBuffer"
    ],
    "position": {
      "column": 1,
      "line": 1005
    },
    "return": "void",
    "signature": "public void failed(Throwable exc, DataBuffer dataBuffer)",
    "source_code": "\t\tpublic void failed(Throwable exc, DataBuffer dataBuffer) {\n\t\t\trelease(dataBuffer);\n\t\t\tcloseChannel(this.channel);\n\t\t\tthis.state.set(State.DISPOSED);\n\t\t\tthis.sink.error(exc);\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#join(buffers,maxByteCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #join(Publisher)} that behaves the same way up until\n\t * the specified max number of bytes to buffer. Once the limit is exceeded,\n\t * {@link DataBufferLimitException} is raised.\n\t * @param buffers the data buffers that are to be composed\n\t * @param maxByteCount the max number of bytes to buffer, or -1 for unlimited\n\t * @return a buffer with the aggregated content, possibly an empty Mono if\n\t * the max number of bytes to buffer is exceeded.\n\t * @throws DataBufferLimitException if maxByteCount is exceeded\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 572
    },
    "return": "Mono<DataBuffer>",
    "signature": "public Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount)",
    "source_code": "\tpublic static Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount) {\n\t\tAssert.notNull(buffers, \"'dataBuffers' must not be null\");\n\n\t\tif (buffers instanceof Mono) {\n\t\t\treturn (Mono<DataBuffer>) buffers;\n\t\t}\n\n\t\treturn Flux.from(buffers)\n\t\t\t\t.collect(() -> new LimitedDataBufferList(maxByteCount), LimitedDataBufferList::add)\n\t\t\t\t.filter(list -> !list.isEmpty())\n\t\t\t\t.map(list -> list.get(0).factory().join(list))\n\t\t\t\t.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(path,bufferFactory,bufferSize,options)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read bytes from the given file {@code Path} into a {@code Flux} of {@code DataBuffer}s.\n\t * The method ensures that the file is closed when the flux is terminated.\n\t * @param path the path to read bytes from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "bufferFactory",
      "bufferSize",
      "options"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Path path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options)",
    "source_code": "\tpublic static Flux<DataBuffer> read(\n\t\t\tPath path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options) {\n\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tAssert.notNull(bufferFactory, \"BufferFactory must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\t\tif (options.length > 0) {\n\t\t\tfor (OpenOption option : options) {\n\t\t\t\tAssert.isTrue(!(option == StandardOpenOption.APPEND || option == StandardOpenOption.WRITE),\n\t\t\t\t\t\t\"'\" + option + \"' not allowed\");\n\t\t\t}\n\t\t}\n\n\t\treturn readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(path, options),\n\t\t\t\tbufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(resource,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s.\n\t * <p>If the resource is a file, it is read into an\n\t * {@code AsynchronousFileChannel} and turned to {@code Flux} via\n\t * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else\n\t * fall back to {@link #readByteChannel(Callable, DataBufferFactory, int)}.\n\t * Closes the channel when the flux is terminated.\n\t * @param resource the resource to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize) {\n\t\treturn read(resource, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(resource,position,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s\n\t * starting at the given position.\n\t * <p>If the resource is a file, it is read into an\n\t * {@code AsynchronousFileChannel} and turned to {@code Flux} via\n\t * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else\n\t * fall back on {@link #readByteChannel(Callable, DataBufferFactory, int)}.\n\t * Closes the channel when the flux is terminated.\n\t * @param resource the resource to read from\n\t * @param position the position to start reading from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "position",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Resource resource, long position, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> read(\n\t\t\tResource resource, long position, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\ttry {\n\t\t\tif (resource.isFile()) {\n\t\t\t\tFile file = resource.getFile();\n\t\t\t\treturn readAsynchronousFileChannel(\n\t\t\t\t\t\t() -> AsynchronousFileChannel.open(file.toPath(), StandardOpenOption.READ),\n\t\t\t\t\t\tposition, bufferFactory, bufferSize);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignore) {\n\t\t\t// fallback to resource.readableChannel(), below\n\t\t}\n\t\tFlux<DataBuffer> result = readByteChannel(resource::readableChannel, bufferFactory, bufferSize);\n\t\treturn position == 0 ? result : skipUntilByteCount(result, position);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@code AsynchronousFileChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\treturn readAsynchronousFileChannel(channelSupplier, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,position,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@code AsynchronousFileChannel} from the given supplier, and\n\t * read it into a {@code Flux} of {@code DataBuffer}s, starting at the given\n\t * position. Closes the channel when the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param position the position to start reading from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "position",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, long position,\n\t\t\tDataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, long position,\n\t\t\tDataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(channelSupplier, \"'channelSupplier' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'dataBufferFactory' must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be >= 0\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\n\t\tFlux<DataBuffer> flux = Flux.using(channelSupplier,\n\t\t\t\tchannel -> Flux.create(sink -> {\n\t\t\t\t\tReadCompletionHandler handler =\n\t\t\t\t\t\t\tnew ReadCompletionHandler(channel, sink, position, bufferFactory, bufferSize);\n\t\t\t\t\tsink.onCancel(handler::cancel);\n\t\t\t\t\tsink.onRequest(handler::request);\n\t\t\t\t}),\n\t\t\t\tchannel -> {\n\t\t\t\t\t// Do not close channel from here, rather wait for the current read callback\n\t\t\t\t\t// and then complete after releasing the DataBuffer.\n\t\t\t\t});\n\n\t\treturn flux.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readByteChannel(channelSupplier,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link ReadableByteChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readByteChannel(Callable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readByteChannel(\n\t\t\tCallable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(channelSupplier, \"'channelSupplier' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'dataBufferFactory' must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\n\t\treturn Flux.using(channelSupplier,\n\t\t\t\tchannel -> Flux.generate(new ReadableByteChannelGenerator(channel, bufferFactory, bufferSize)),\n\t\t\t\tDataBufferUtils::closeChannel);\n\n\t\t// No doOnDiscard as operators used do not cache\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readInputStream(inputStreamSupplier,bufferFactory,bufferSize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@link InputStream} from the given supplier, and read it into a\n\t * {@code Flux} of {@code DataBuffer}s. Closes the input stream when the\n\t * Flux is terminated.\n\t * @param inputStreamSupplier the supplier for the input stream to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStreamSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readInputStream(Callable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readInputStream(\n\t\t\tCallable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(inputStreamSupplier, \"'inputStreamSupplier' must not be null\");\n\t\treturn readByteChannel(() -> Channels.newChannel(inputStreamSupplier.call()), bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#skipUntilByteCount(publisher,maxByteCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Skip buffers from the given {@link Publisher} until the total\n\t * {@linkplain DataBuffer#readableByteCount() byte count} reaches\n\t * the given maximum byte count, or until the publisher is complete.\n\t * @param publisher the publisher to filter\n\t * @param maxByteCount the maximum byte count\n\t * @return a flux with the remaining part of the given publisher\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> skipUntilByteCount(Publisher<? extends DataBuffer> publisher, long maxByteCount)",
    "source_code": "\tpublic static Flux<DataBuffer> skipUntilByteCount(Publisher<? extends DataBuffer> publisher, long maxByteCount) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(maxByteCount >= 0, \"'maxByteCount' must be a positive number\");\n\n\t\treturn Flux.defer(() -> {\n\t\t\tAtomicLong countDown = new AtomicLong(maxByteCount);\n\t\t\treturn Flux.from(publisher)\n\t\t\t\t\t.skipUntil(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.addAndGet(-buffer.readableByteCount());\n\t\t\t\t\t\treturn remainder < 0;\n\t\t\t\t\t})\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.get();\n\t\t\t\t\t\tif (remainder < 0) {\n\t\t\t\t\t\t\tcountDown.set(0);\n\t\t\t\t\t\t\tint start = buffer.readableByteCount() + (int)remainder;\n\t\t\t\t\t\t\tint length = (int) -remainder;\n\t\t\t\t\t\t\treturn buffer.slice(start, length);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}).doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#takeUntilByteCount(publisher,maxByteCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Relay buffers from the given {@link Publisher} until the total\n\t * {@linkplain DataBuffer#readableByteCount() byte count} reaches\n\t * the given maximum byte count, or until the publisher is complete.\n\t * @param publisher the publisher to filter\n\t * @param maxByteCount the maximum byte count\n\t * @return a flux whose maximum byte count is {@code maxByteCount}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> takeUntilByteCount(Publisher<? extends DataBuffer> publisher, long maxByteCount)",
    "source_code": "\tpublic static Flux<DataBuffer> takeUntilByteCount(Publisher<? extends DataBuffer> publisher, long maxByteCount) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(maxByteCount >= 0, \"'maxByteCount' must be a positive number\");\n\n\t\treturn Flux.defer(() -> {\n\t\t\tAtomicLong countDown = new AtomicLong(maxByteCount);\n\t\t\treturn Flux.from(publisher)\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.addAndGet(-buffer.readableByteCount());\n\t\t\t\t\t\tif (remainder < 0) {\n\t\t\t\t\t\t\tint length = buffer.readableByteCount() + (int) remainder;\n\t\t\t\t\t\t\treturn buffer.slice(0, length);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.takeUntil(buffer -> countDown.get() <= 0);\n\t\t});\n\n\t\t// No doOnDiscard as operators used do not cache (and drop) buffers\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#touch(dataBuffer,hint)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given hint with the data buffer if it is a pooled buffer\n\t * and supports leak tracking.\n\t * @param dataBuffer the data buffer to attach the hint to\n\t * @param hint the hint to attach\n\t * @return the input buffer\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "T",
    "signature": "public T touch(T dataBuffer, Object hint)",
    "source_code": "\tpublic static <T extends DataBuffer> T touch(T dataBuffer, Object hint) {\n\t\tif (dataBuffer instanceof PooledDataBuffer) {\n\t\t\treturn (T) ((PooledDataBuffer) dataBuffer).touch(hint);\n\t\t}\n\t\telse {\n\t\t\treturn dataBuffer;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,channel)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the\n\t * channel when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux}\n\t * with a {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param channel the channel to write to\n\t * @return a Flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t * @since 5.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel)",
    "source_code": "\tpublic static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {\n\t\treturn write(source, channel, 0);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,channel,position)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the channel\n\t * when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux} with a\n\t * {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param channel the channel to write to\n\t * @param position the file position where writing is to begin; must be non-negative\n\t * @return a flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "channel",
      "position"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position)",
    "source_code": "\tpublic static Flux<DataBuffer> write(\n\t\t\tPublisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position) {\n\n\t\tAssert.notNull(source, \"'source' must not be null\");\n\t\tAssert.notNull(channel, \"'channel' must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be >= 0\");\n\n\t\tFlux<DataBuffer> flux = Flux.from(source);\n\t\treturn Flux.create(sink -> {\n\t\t\tWriteCompletionHandler handler = new WriteCompletionHandler(sink, channel, position);\n\t\t\tsink.onDispose(handler);\n\t\t\tflux.subscribe(handler);\n\t\t});\n\n\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,destination,options)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * file {@link Path}. The optional {@code options} parameter specifies\n\t * how the file is created or opened (defaults to\n\t * {@link StandardOpenOption#CREATE CREATE},\n\t * {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and\n\t * {@link StandardOpenOption#WRITE WRITE}).\n\t * @param source the stream of data buffers to be written\n\t * @param destination the path to the file\n\t * @param options the options specifying how the file is opened\n\t * @return a {@link Mono} that indicates completion or error\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "destination",
      "options"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options)",
    "source_code": "\tpublic static Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options) {\n\t\tAssert.notNull(source, \"Source must not be null\");\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSet<OpenOption> optionSet = checkWriteOptions(options);\n\n\t\treturn Mono.create(sink -> {\n\t\t\ttry {\n\t\t\t\tAsynchronousFileChannel channel = AsynchronousFileChannel.open(destination, optionSet, null);\n\t\t\t\tsink.onDispose(() -> closeChannel(channel));\n\t\t\t\twrite(source, channel).subscribe(DataBufferUtils::release,\n\t\t\t\t\t\tsink::error,\n\t\t\t\t\t\tsink::success);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsink.error(ex);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code OutputStream}. Does <strong>not</strong> close the output stream\n\t * when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux}\n\t * with a {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param outputStream the output stream to write to\n\t * @return a Flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream)",
    "source_code": "\tpublic static Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream) {\n\t\tAssert.notNull(source, \"'source' must not be null\");\n\t\tAssert.notNull(outputStream, \"'outputStream' must not be null\");\n\n\t\tWritableByteChannel channel = Channels.newChannel(outputStream);\n\t\treturn write(source, channel);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#addAllClassLoaderJarRoots(classLoader,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Search all {@link URLClassLoader} URLs for jar file references and add them to the\n\t * given set of resources in the form of pointers to the root of the jar file content.\n\t * @param classLoader the ClassLoader to search (including its ancestors)\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "protected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result)",
    "source_code": "\tprotected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {\n\t\tif (classLoader instanceof URLClassLoader urlClassLoader) {\n\t\t\ttry {\n\t\t\t\tfor (URL url : urlClassLoader.getURLs()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tUrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ?\n\t\t\t\t\t\t\t\tnew UrlResource(url) :\n\t\t\t\t\t\t\t\tnew UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));\n\t\t\t\t\t\tif (jarResource.exists()) {\n\t\t\t\t\t\t\tresult.add(jarResource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + url +\n\t\t\t\t\t\t\t\t\t\"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files since ClassLoader [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getURLs()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classLoader == ClassLoader.getSystemClassLoader()) {\n\t\t\t// \"java.class.path\" manifest evaluation...\n\t\t\taddClassPathManifestEntries(result);\n\t\t}\n\n\t\tif (classLoader != null) {\n\t\t\ttry {\n\t\t\t\t// Hierarchy traversal...\n\t\t\t\taddAllClassLoaderJarRoots(classLoader.getParent(), result);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files in parent ClassLoader since [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getParent()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindMatchingFileSystemResources(rootDir,subPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in the file system that match the given location pattern\n\t * via the Ant-style PathMatcher.\n\t * @param rootDir the root directory in the file system\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see #retrieveMatchingFiles\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDir",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 730
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindMatchingFileSystemResources(File rootDir, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Looking for matching resources in directory tree [\" + rootDir.getPath() + \"]\");\n\t\t}\n\t\tSet<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);\n\t\tSet<Resource> result = new LinkedHashSet<>(matchingFiles.size());\n\t\tfor (File file : matchingFiles) {\n\t\t\tresult.add(new FileSystemResource(file));\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindPathMatchingFileResources(rootDirResource,subPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in the file system that match the given location pattern\n\t * via the Ant-style PathMatcher.\n\t * @param rootDirResource the root directory as Resource\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see #retrieveMatchingFiles\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 697
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tFile rootDir;\n\t\ttry {\n\t\t\trootDir = rootDirResource.getFile().getAbsoluteFile();\n\t\t}\n\t\tcatch (FileNotFoundException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cannot search for matching files underneath \" + rootDirResource +\n\t\t\t\t\t\t\" in the file system: \" + ex.getMessage());\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Failed to resolve \" + rootDirResource + \" in the file system: \" + ex);\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\treturn doFindMatchingFileSystemResources(rootDir, subPattern);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindPathMatchingJarResources(rootDirResource,rootDirURL,subPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in jar files that match the given location pattern\n\t * via the Ant-style PathMatcher.\n\t * @param rootDirResource the root directory as Resource\n\t * @param rootDirURL the pre-resolved root directory URL\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see java.net.JarURLConnection\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "rootDirURL",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 591
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirURL, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirURL, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tURLConnection con = rootDirURL.openConnection();\n\t\tJarFile jarFile;\n\t\tString jarFileUrl;\n\t\tString rootEntryPath;\n\t\tboolean closeJarFile;\n\n\t\tif (con instanceof JarURLConnection jarCon) {\n\t\t\t// Should usually be the case for traditional JAR files.\n\t\t\tResourceUtils.useCachesIfNecessary(jarCon);\n\t\t\tjarFile = jarCon.getJarFile();\n\t\t\tjarFileUrl = jarCon.getJarFileURL().toExternalForm();\n\t\t\tJarEntry jarEntry = jarCon.getJarEntry();\n\t\t\trootEntryPath = (jarEntry != null ? jarEntry.getName() : \"\");\n\t\t\tcloseJarFile = !jarCon.getUseCaches();\n\t\t}\n\t\telse {\n\t\t\t// No JarURLConnection -> need to resort to URL file parsing.\n\t\t\t// We'll assume URLs of the format \"jar:path!/entry\", with the protocol\n\t\t\t// being arbitrary as long as following the entry format.\n\t\t\t// We'll also handle paths with and without leading \"file:\" prefix.\n\t\t\tString urlFile = rootDirURL.getFile();\n\t\t\ttry {\n\t\t\t\tint separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\n\t\t\t\tif (separatorIndex == -1) {\n\t\t\t\t\tseparatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tif (separatorIndex != -1) {\n\t\t\t\t\tjarFileUrl = urlFile.substring(0, separatorIndex);\n\t\t\t\t\trootEntryPath = urlFile.substring(separatorIndex + 2);  // both separators are 2 chars\n\t\t\t\t\tjarFile = getJarFile(jarFileUrl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjarFile = new JarFile(urlFile);\n\t\t\t\t\tjarFileUrl = urlFile;\n\t\t\t\t\trootEntryPath = \"\";\n\t\t\t\t}\n\t\t\t\tcloseJarFile = true;\n\t\t\t}\n\t\t\tcatch (ZipException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Skipping invalid jar classpath entry [\" + urlFile + \"]\");\n\t\t\t\t}\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Looking for matching resources in jar file [\" + jarFileUrl + \"]\");\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\n\t\t\t\t// Root entry path must end with slash to allow for proper matching.\n\t\t\t\t// The Sun JRE does not return a slash here, but BEA JRockit does.\n\t\t\t\trootEntryPath = rootEntryPath + \"/\";\n\t\t\t}\n\t\t\tSet<Resource> result = new LinkedHashSet<>(8);\n\t\t\tfor (Enumeration<JarEntry> entries = jarFile.entries(); entries.hasMoreElements();) {\n\t\t\t\tJarEntry entry = entries.nextElement();\n\t\t\t\tString entryPath = entry.getName();\n\t\t\t\tif (entryPath.startsWith(rootEntryPath)) {\n\t\t\t\t\tString relativePath = entryPath.substring(rootEntryPath.length());\n\t\t\t\t\tif (getPathMatcher().match(subPattern, relativePath)) {\n\t\t\t\t\t\tresult.add(rootDirResource.createRelative(relativePath));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tif (closeJarFile) {\n\t\t\t\tjarFile.close();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doRetrieveMatchingFiles(fullPattern,dir,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recursively retrieve files that match the given pattern,\n\t * adding them to the given result list.\n\t * @param fullPattern the pattern to match against,\n\t * with prepended root directory path\n\t * @param dir the current directory\n\t * @param result the Set of matching File instances to add to\n\t * @throws IOException if directory contents could not be retrieved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "fullPattern",
      "dir",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 792
    },
    "return": "void",
    "signature": "protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<File> result)",
    "source_code": "\tprotected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<File> result) throws IOException {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Searching directory [\" + dir.getAbsolutePath() +\n\t\t\t\t\t\"] for files matching pattern [\" + fullPattern + \"]\");\n\t\t}\n\t\tfor (File content : listDirectory(dir)) {\n\t\t\tString currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, \"/\");\n\t\t\tif (content.isDirectory() && getPathMatcher().matchStart(fullPattern, currPath + \"/\")) {\n\t\t\t\tif (!content.canRead()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Skipping subdirectory [\" + dir.getAbsolutePath() +\n\t\t\t\t\t\t\t\t\"] because the application is not allowed to read the directory\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoRetrieveMatchingFiles(fullPattern, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (getPathMatcher().match(fullPattern, currPath)) {\n\t\t\t\tresult.add(content);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#findMatchingResources(rootDirURL,locationPattern,pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootDirURL",
      "locationPattern",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 841
    },
    "return": "Set<Resource>",
    "signature": "public Set<Resource> findMatchingResources(URL rootDirURL, String locationPattern, PathMatcher pathMatcher)",
    "source_code": "\t\tpublic static Set<Resource> findMatchingResources(\n\t\t\t\tURL rootDirURL, String locationPattern, PathMatcher pathMatcher) throws IOException {\n\n\t\t\tObject root = VfsPatternUtils.findRoot(rootDirURL);\n\t\t\tPatternVirtualFileVisitor visitor =\n\t\t\t\t\tnew PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\n\t\t\tVfsPatternUtils.visit(root, visitor);\n\t\t\treturn visitor.getResources();\n\t\t}"
  },
  "org.springframework.core.io.support.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tString methodName = method.getName();\n\t\t\tif (Object.class == method.getDeclaringClass()) {\n\t\t\t\tif (methodName.equals(\"equals\")) {\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\telse if (methodName.equals(\"hashCode\")) {\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (\"getAttributes\".equals(methodName)) {\n\t\t\t\treturn getAttributes();\n\t\t\t}\n\t\t\telse if (\"visit\".equals(methodName)) {\n\t\t\t\tvisit(args[0]);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (\"toString\".equals(methodName)) {\n\t\t\t\treturn toString();\n\t\t\t}\n\n\t\t\tthrow new IllegalStateException(\"Unexpected method invocation: \" + method);\n\t\t}"
  },
  "org.springframework.core.io.support.<unknown>#retrieveMatchingFiles(rootDir,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve files that match the given path pattern,\n\t * checking the given directory and its subdirectories.\n\t * @param rootDir the directory to start from\n\t * @param pattern the pattern to match against,\n\t * relative to the root directory\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException if directory contents could not be retrieved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDir",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 751
    },
    "return": "Set<File>",
    "signature": "protected Set<File> retrieveMatchingFiles(File rootDir, String pattern)",
    "source_code": "\tprotected Set<File> retrieveMatchingFiles(File rootDir, String pattern) throws IOException {\n\t\tif (!rootDir.exists()) {\n\t\t\t// Silently skip non-existing directories.\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Skipping [\" + rootDir.getAbsolutePath() + \"] because it does not exist\");\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tif (!rootDir.isDirectory()) {\n\t\t\t// Complain louder if it exists but is no directory.\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Skipping [\" + rootDir.getAbsolutePath() + \"] because it does not denote a directory\");\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tif (!rootDir.canRead()) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Skipping search for matching files underneath directory [\" + rootDir.getAbsolutePath() +\n\t\t\t\t\t\t\"] because the application is not allowed to read the directory\");\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tString fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, \"/\");\n\t\tif (!pattern.startsWith(\"/\")) {\n\t\t\tfullPattern += \"/\";\n\t\t}\n\t\tfullPattern = fullPattern + StringUtils.replace(pattern, File.separator, \"/\");\n\t\tSet<File> result = new LinkedHashSet<>(8);\n\t\tdoRetrieveMatchingFiles(fullPattern, rootDir, result);\n\t\treturn result;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#checkNumericCompatibility(leftDeclaredDescriptor,rightDeclaredDescriptor,leftActualDescriptor,rightActualDescriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return an object that indicates whether the input descriptors are compatible.\n\t\t * <p>A declared descriptor is what could statically be determined (e.g. from looking\n\t\t * at the return value of a property accessor method) whilst an actual descriptor\n\t\t * is the type of an actual object that was returned, which may differ.\n\t\t * <p>For generic types with unbound type variables, the declared descriptor\n\t\t * discovered may be 'Object' but from the actual descriptor it is possible to\n\t\t * observe that the objects are really numeric values (e.g. ints).\n\t\t * @param leftDeclaredDescriptor the statically determinable left descriptor\n\t\t * @param rightDeclaredDescriptor the statically determinable right descriptor\n\t\t * @param leftActualDescriptor the dynamic/runtime left object descriptor\n\t\t * @param rightActualDescriptor the dynamic/runtime right object descriptor\n\t\t * @return a DescriptorComparison object indicating the type of compatibility, if any\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "leftDeclaredDescriptor",
      "rightDeclaredDescriptor",
      "leftActualDescriptor",
      "rightActualDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "DescriptorComparison",
    "signature": "public DescriptorComparison checkNumericCompatibility(@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,\n\t\t\t\t@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor)",
    "source_code": "\t\tpublic static DescriptorComparison checkNumericCompatibility(\n\t\t\t\t@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,\n\t\t\t\t@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {\n\n\t\t\tString ld = leftDeclaredDescriptor;\n\t\t\tString rd = rightDeclaredDescriptor;\n\n\t\t\tboolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld);\n\t\t\tboolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);\n\n\t\t\t// If the declared descriptors aren't providing the information, try the actual descriptors\n\t\t\tif (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {\n\t\t\t\tld = leftActualDescriptor;\n\t\t\t\tleftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld);\n\t\t\t}\n\t\t\tif (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {\n\t\t\t\trd = rightActualDescriptor;\n\t\t\t\trightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);\n\t\t\t}\n\n\t\t\tif (leftNumeric && rightNumeric) {\n\t\t\t\tif (CodeFlow.areBoxingCompatible(ld, rd)) {\n\t\t\t\t\treturn new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn DescriptorComparison.INCOMPATIBLE_NUMBERS;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn DescriptorComparison.NOT_NUMBERS;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#equalityCheck(context,left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform an equality check for the given operand values.\n\t * <p>This method is not just used for reflective comparisons in subclasses\n\t * but also from compiled expression code, which is why it needs to be\n\t * declared as {@code public static} here.\n\t * @param context the current evaluation context\n\t * @param left the left-hand operand value\n\t * @param right the right-hand operand value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "boolean",
    "signature": "public boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn (leftBigDecimal.compareTo(rightBigDecimal) == 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn (leftNumber.doubleValue() == rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn (leftNumber.floatValue() == rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn (leftBigInteger.compareTo(rightBigInteger) == 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn (leftNumber.longValue() == rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn (leftNumber.intValue() == rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn (leftNumber.shortValue() == rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn (leftNumber.byteValue() == rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtypes -> best guess is double comparison\n\t\t\t\treturn (leftNumber.doubleValue() == rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\tif (left instanceof CharSequence && right instanceof CharSequence) {\n\t\t\treturn left.toString().equals(right.toString());\n\t\t}\n\n\t\tif (left instanceof Boolean && right instanceof Boolean) {\n\t\t\treturn left.equals(right);\n\t\t}\n\n\t\tif (ObjectUtils.nullSafeEquals(left, right)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (context.getTypeComparator().canCompare(left, right)) {\n\t\t\treturn context.getTypeComparator().compare(left, right) == 0;\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCode(mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tgenerateComparisonCode(mv, cf, IFGE, IF_ICMPGE);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCode(mv,codeflow)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "codeflow"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow codeflow)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n\t\tfinal String constantFieldName = \"inlineList$\" + codeflow.nextFieldId();\n\t\tfinal String className = codeflow.getClassName();\n\n\t\tcodeflow.registerNewField((cw, cflow) ->\n\t\t\t\tcw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, constantFieldName, \"Ljava/util/List;\", null, null));\n\n\t\tcodeflow.registerNewClinit((mVisitor, cflow) ->\n\t\t\t\tgenerateClinitCode(className, constantFieldName, mVisitor, cflow, false));\n\n\t\tmv.visitFieldInsn(GETSTATIC, className, constantFieldName, \"Ljava/util/List;\");\n\t\tcodeflow.pushDescriptor(\"Ljava/util/List\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateComparisonCode(mv,cf,compInstruction1,compInstruction2)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Numeric comparison operators share very similar generated code, only differing in\n\t * two comparison instructions.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "compInstruction1",
      "compInstruction2"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2)",
    "source_code": "\tprotected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {\n\t\tSpelNodeImpl left = getLeftOperand();\n\t\tSpelNodeImpl right = getRightOperand();\n\t\tString leftDesc = left.exitTypeDescriptor;\n\t\tString rightDesc = right.exitTypeDescriptor;\n\t\tLabel elseTarget = new Label();\n\t\tLabel endOfIf = new Label();\n\t\tboolean unboxLeft = !CodeFlow.isPrimitive(leftDesc);\n\t\tboolean unboxRight = !CodeFlow.isPrimitive(rightDesc);\n\t\tDescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(\n\t\t\t\tleftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor);\n\t\tchar targetType = dc.compatibleType;  // CodeFlow.toPrimitiveTargetDesc(leftDesc);\n\n\t\tcf.enterCompilationScope();\n\t\tleft.generateCode(mv, cf);\n\t\tcf.exitCompilationScope();\n\t\tif (CodeFlow.isPrimitive(leftDesc)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, leftDesc);\n\t\t\tunboxLeft = true;\n\t\t}\n\n\t\tcf.enterCompilationScope();\n\t\tright.generateCode(mv, cf);\n\t\tcf.exitCompilationScope();\n\t\tif (CodeFlow.isPrimitive(rightDesc)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, rightDesc);\n\t\t\tunboxRight = true;\n\t\t}\n\n\t\t// This code block checks whether the left or right operand is null and handles\n\t\t// those cases before letting the original code (that only handled actual numbers) run\n\t\tLabel rightIsNonNull = new Label();\n\t\tmv.visitInsn(DUP);  // stack: left/right/right\n\t\tmv.visitJumpInsn(IFNONNULL, rightIsNonNull);  // stack: left/right\n\t\t// here: RIGHT==null LEFT==unknown\n\t\tmv.visitInsn(SWAP);  // right/left\n\t\tLabel leftNotNullRightIsNull = new Label();\n\t\tmv.visitJumpInsn(IFNONNULL, leftNotNullRightIsNull);  // stack: right\n\t\t// here: RIGHT==null LEFT==null\n\t\tmv.visitInsn(POP);  // stack: <nothing>\n\t\t// load 0 or 1 depending on comparison instruction\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFLE: // OpGT\n\t\t\tmv.visitInsn(ICONST_0);  // false - null is not < or > null\n\t\t\tbreak;\n\t\tcase IFGT: // OpLE\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_1);  // true - null is <= or >= null\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\t\tmv.visitLabel(leftNotNullRightIsNull);  // stack: right\n\t\t// RIGHT==null LEFT!=null\n\t\tmv.visitInsn(POP);  // stack: <nothing>\n\t\t// load 0 or 1 depending on comparison instruction\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFGT: // OpLE\n\t\t\tmv.visitInsn(ICONST_0);  // false - something is not < or <= null\n\t\t\tbreak;\n\t\tcase IFLE: // OpGT\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_1);  // true - something is > or >= null\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\n\t\tmv.visitLabel(rightIsNonNull);  // stack: left/right\n\t\t// here: RIGHT!=null LEFT==unknown\n\t\tmv.visitInsn(SWAP);  // stack: right/left\n\t\tmv.visitInsn(DUP);  // stack: right/left/left\n\t\tLabel neitherRightNorLeftAreNull = new Label();\n\t\tmv.visitJumpInsn(IFNONNULL, neitherRightNorLeftAreNull);  // stack: right/left\n\t\t// here: RIGHT!=null LEFT==null\n\t\tmv.visitInsn(POP2);  // stack: <nothing>\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFGT: // OpLE\n\t\t\tmv.visitInsn(ICONST_1);  // true - null is < or <= something\n\t\t\tbreak;\n\t\tcase IFLE: // OpGT\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_0);  // false - null is not > or >= something\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\t\tmv.visitLabel(neitherRightNorLeftAreNull);  // stack: right/left\n\t\t// neither were null so unbox and proceed with numeric comparison\n\t\tif (unboxLeft) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, leftDesc);\n\t\t}\n\t\t// What we just unboxed might be a double slot item (long/double)\n\t\t// so can't just use SWAP\n\t\t// stack: right/left(1or2slots)\n\t\tif (targetType == 'D' || targetType == 'J') {\n\t\t\tmv.visitInsn(DUP2_X1);\n\t\t\tmv.visitInsn(POP2);\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(SWAP);\n\t\t}\n\t\t// stack: left(1or2)/right\n\t\tif (unboxRight) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, rightDesc);\n\t\t}\n\n\t\t// assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)\n\t\tif (targetType == 'D') {\n\t\t\tmv.visitInsn(DCMPG);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'F') {\n\t\t\tmv.visitInsn(FCMPG);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'J') {\n\t\t\tmv.visitInsn(LCMP);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'I') {\n\t\t\tmv.visitJumpInsn(compInstruction2, elseTarget);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected descriptor \" + leftDesc);\n\t\t}\n\n\t\t// Other numbers are not yet supported (isCompilable will not have returned true)\n\t\tmv.visitInsn(ICONST_1);\n\t\tmv.visitJumpInsn(GOTO,endOfIf);\n\t\tmv.visitLabel(elseTarget);\n\t\tmv.visitInsn(ICONST_0);\n\t\tmv.visitLabel(endOfIf);\n\t\tcf.pushDescriptor(\"Z\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isWritableProperty(name,contextObject,evalContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "contextObject",
      "evalContext"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "boolean",
    "signature": "public boolean isWritableProperty(String name, TypedValue contextObject, EvaluationContext evalContext)",
    "source_code": "\tpublic boolean isWritableProperty(String name, TypedValue contextObject, EvaluationContext evalContext)\n\t\t\tthrows EvaluationException {\n\n\t\tObject value = contextObject.getValue();\n\t\tif (value != null) {\n\t\t\tList<PropertyAccessor> accessorsToTry =\n\t\t\t\t\tgetPropertyAccessorsToTry(contextObject.getValue(), evalContext.getPropertyAccessors());\n\t\t\tfor (PropertyAccessor accessor : accessorsToTry) {\n\t\t\t\ttry {\n\t\t\t\t\tif (accessor.canWrite(evalContext, value, name)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (AccessException ex) {\n\t\t\t\t\t// let others try\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValue(state,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void setValue(ExpressionState state, @Nullable Object newValue)",
    "source_code": "\tpublic void setValue(ExpressionState state, @Nullable Object newValue) throws EvaluationException {\n\t\tgetValueRef(state).setValue(newValue);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#subSequence(start,end)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "start",
      "end"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "CharSequence",
    "signature": "public CharSequence subSequence(int start, int end)",
    "source_code": "\t\tpublic CharSequence subSequence(int start, int end) {\n\t\t\treturn new MatcherInput(this.value.subSequence(start, end), this.access);\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canCompare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "boolean",
    "signature": "public boolean canCompare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic boolean canCompare(@Nullable Object left, @Nullable Object right) {\n\t\tif (left == null || right == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Number && right instanceof Number) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Comparable && right instanceof Comparable) {\n\t\t\tClass<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass());\n\t\t\treturn ancestor != null && Comparable.class.isAssignableFrom(ancestor);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canRead(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 654
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#compare(left,right)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "int",
    "signature": "public int compare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic int compare(@Nullable Object left, @Nullable Object right) throws SpelEvaluationException {\n\t\t// If one is null, check if the other is\n\t\tif (left == null) {\n\t\t\treturn (right == null ? 0 : -1);\n\t\t}\n\t\telse if (right == null) {\n\t\t\treturn 1;  // left cannot be null at this point\n\t\t}\n\n\t\t// Basic number comparisons\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn leftBigDecimal.compareTo(rightBigDecimal);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn Float.compare(leftNumber.floatValue(), rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn leftBigInteger.compareTo(rightBigInteger);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn Long.compare(leftNumber.longValue(), rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn Integer.compare(leftNumber.intValue(), rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn Short.compare(leftNumber.shortValue(), rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn Byte.compare(leftNumber.byteValue(), rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtype -> best guess is double multiplication\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (left instanceof Comparable) {\n\t\t\t\treturn ((Comparable<Object>) left).compareTo(right);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassCastException ex) {\n\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t\t}\n\n\t\tthrow new SpelEvaluationException(SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#createOptimalAccessor(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to create an optimized property accessor tailored for a property of a\n\t * particular name on a particular class. The general ReflectivePropertyAccessor\n\t * will always work but is not optimal due to the need to lookup which reflective\n\t * member (method/field) to use each time read() is called. This method will just\n\t * return the ReflectivePropertyAccessor instance if it is unable to build a more\n\t * optimal accessor.\n\t * <p>Note: An optimal accessor is currently only usable for read attempts.\n\t * Do not call this method if you need a read-write accessor.\n\t * @see OptimalPropertyAccessor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "PropertyAccessor",
    "signature": "public PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name) {\n\t\t// Don't be clever for arrays or a null target...\n\t\tif (target == null) {\n\t\t\treturn this;\n\t\t}\n\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\tif (type.isArray()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tPropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invocationTarget = this.readerCache.get(cacheKey);\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Method) {\n\t\t\tMethod method = (Method) (invocationTarget != null ? invocationTarget.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(method, -1));\n\t\t\t\t\tmethod = ClassUtils.getInterfaceMethodIfPossible(method, type);\n\t\t\t\t\tinvocationTarget = new InvokerPair(method, typeDescriptor);\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\tif (invocationTarget == null || invocationTarget.member instanceof Field) {\n\t\t\tField field = (invocationTarget != null ? (Field) invocationTarget.member : null);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target instanceof Class);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvocationTarget = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invocationTarget);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invocationTarget);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findField(name,clazz,mustBeStatic)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a field of a certain name on a specified class.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "Field",
    "signature": "protected Field findField(String name, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Field findField(String name, Class<?> clazz, boolean mustBeStatic) {\n\t\tField[] fields = clazz.getFields();\n\t\tfor (Field field : fields) {\n\t\t\tif (field.getName().equals(name) && (!mustBeStatic || Modifier.isStatic(field.getModifiers()))) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\t// We'll search superclasses and implemented interfaces explicitly,\n\t\t// although it shouldn't be necessary - however, see SPR-10125.\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tField field = findField(name, clazz.getSuperclass(), mustBeStatic);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\tfor (Class<?> implementedInterface : clazz.getInterfaces()) {\n\t\t\tField field = findField(name, implementedInterface, mustBeStatic);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findGetterForProperty(propertyName,clazz,mustBeStatic)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a getter method for the specified property.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Method",
    "signature": "protected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\tMethod method = findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"get\", clazz, mustBeStatic, 0, ANY_TYPES);\n\t\tif (method == null) {\n\t\t\tmethod = findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\t\"is\", clazz, mustBeStatic, 0, BOOLEAN_TYPES);\n\t\t\tif (method == null) {\n\t\t\t\t// Record-style plain accessor method, e.g. name()\n\t\t\t\tmethod = findMethodForProperty(new String[] {propertyName},\n\t\t\t\t\t\t\"\", clazz, mustBeStatic, 0, ANY_TYPES);\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findSetterForProperty(propertyName,clazz,mustBeStatic)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find a setter method for the specified property.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Method",
    "signature": "protected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\treturn findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"set\", clazz, mustBeStatic, 1, ANY_TYPES);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#generateCode(propertyName,mv,cf)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "void",
    "signature": "public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf)",
    "source_code": "\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\t\t\tString classDesc = this.member.getDeclaringClass().getName().replace('.', '/');\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack,\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tboolean isInterface = method.getDeclaringClass().isInterface();\n\t\t\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\t\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor(method), isInterface);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isCandidateForProperty(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for property access\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * non-user-declared properties on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForProperty(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForProperty(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 677
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#write(context,target,name,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.format.support.<unknown>#addFormatterForFieldType(fieldType,formatter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldType",
      "formatter"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter)",
    "source_code": "\tpublic void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter) {\n\t\taddConverter(new PrinterConverter(fieldType, formatter, this));\n\t\taddConverter(new ParserConverter(fieldType, formatter, this));\n\t}"
  },
  "org.springframework.format.support.<unknown>#addFormatterForFieldType(fieldType,printer,parser)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldType",
      "printer",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser)",
    "source_code": "\tpublic void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser) {\n\t\taddConverter(new PrinterConverter(fieldType, printer, this));\n\t\taddConverter(new ParserConverter(fieldType, parser, this));\n\t}"
  },
  "org.springframework.format.support.<unknown>#convert(source,sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tAnnotation ann = targetType.getAnnotation(this.annotationType);\n\t\t\tif (ann == null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Expected [\" + this.annotationType.getName() + \"] to be present on \" + targetType);\n\t\t\t}\n\t\t\tAnnotationConverterKey converterKey = new AnnotationConverterKey(ann, targetType.getObjectType());\n\t\t\tGenericConverter converter = cachedParsers.get(converterKey);\n\t\t\tif (converter == null) {\n\t\t\t\tParser<?> parser = this.annotationFormatterFactory.getParser(\n\t\t\t\t\t\tconverterKey.getAnnotation(), converterKey.getFieldType());\n\t\t\t\tconverter = new ParserConverter(this.fieldType, parser, FormattingConversionService.this);\n\t\t\t\tcachedParsers.put(converterKey, converter);\n\t\t\t}\n\t\t\treturn converter.convert(source, sourceType, targetType);\n\t\t}"
  },
  "org.springframework.format.support.<unknown>#matches(sourceType,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn targetType.hasAnnotation(this.annotationType);\n\t\t}"
  },
  "org.springframework.http.<unknown>#checkParameters(parameter,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "protected void checkParameters(String parameter, String value)",
    "source_code": "\tprotected void checkParameters(String parameter, String value) {\n\t\tsuper.checkParameters(parameter, value);\n\t\tif (PARAM_QUALITY_FACTOR.equals(parameter)) {\n\t\t\tvalue = unquote(value);\n\t\t\tdouble d = Double.parseDouble(value);\n\t\t\tAssert.isTrue(d >= 0D && d <= 1D,\n\t\t\t\t\t\"Invalid quality value \\\"\" + value + \"\\\": should be between 0.0 and 1.0\");\n\t\t}\n\t}"
  },
  "org.springframework.http.<unknown>#compareParameters(mediaType1,mediaType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mediaType1",
      "mediaType2"
    ],
    "position": {
      "column": 1,
      "line": 925
    },
    "return": "int",
    "signature": "protected int compareParameters(MediaType mediaType1, MediaType mediaType2)",
    "source_code": "\t\tprotected int compareParameters(MediaType mediaType1, MediaType mediaType2) {\n\t\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\t\tif (qualityComparison != 0) {\n\t\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t\t}\n\t\t\treturn super.compareParameters(mediaType1, mediaType2);\n\t\t}"
  },
  "org.springframework.http.<unknown>#createByteRange(firstBytePos,lastBytePos)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code HttpRange} from the given fist to last position.\n\t * @param firstBytePos the first byte position\n\t * @param lastBytePos the last byte position\n\t * @return a byte range that ranges from {@code firstPos} till {@code lastPos}\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7233#section-2.1\">Byte Ranges</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "firstBytePos",
      "lastBytePos"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "HttpRange",
    "signature": "public HttpRange createByteRange(long firstBytePos, long lastBytePos)",
    "source_code": "\tpublic static HttpRange createByteRange(long firstBytePos, long lastBytePos) {\n\t\treturn new ByteRange(firstBytePos, lastBytePos);\n\t}"
  },
  "org.springframework.http.<unknown>#filename(filename,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filename",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "Builder",
    "signature": "public Builder filename(String filename, Charset charset)",
    "source_code": "\t\tpublic Builder filename(String filename, Charset charset) {\n\t\t\tAssert.hasText(filename, \"No filename\");\n\t\t\tthis.filename = filename;\n\t\t\tthis.charset = charset;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#from(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie that starts\n\t * with a name-value pair and may also include attributes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder from(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder from(final String name, final String value) {\n\t\treturn from(name, value, false);\n\t}"
  },
  "org.springframework.http.<unknown>#fromClientResponse(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie. Unlike\n\t * {@link #from(String, String)} this option assumes input from a remote\n\t * server, which can be handled more leniently, e.g. ignoring a empty domain\n\t * name with double quotes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t * @since 5.2.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder fromClientResponse(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder fromClientResponse(final String name, final String value) {\n\t\treturn from(name, value, true);\n\t}"
  },
  "org.springframework.http.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#toResourceRegions(ranges,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert each {@code HttpRange} into a {@code ResourceRegion}, selecting the\n\t * appropriate segment of the given {@code Resource} using HTTP Range information.\n\t * @param ranges the list of ranges\n\t * @param resource the resource to select the regions from\n\t * @return the list of regions for the given resource\n\t * @throws IllegalArgumentException if the sum of all ranges exceeds the resource length\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ranges",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "List<ResourceRegion>",
    "signature": "public List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource)",
    "source_code": "\tpublic static List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource) {\n\t\tif (CollectionUtils.isEmpty(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<ResourceRegion> regions = new ArrayList<>(ranges.size());\n\t\tfor (HttpRange range : ranges) {\n\t\t\tregions.add(range.toResourceRegion(resource));\n\t\t}\n\t\tif (ranges.size() > 1) {\n\t\t\tlong length = getLengthFor(resource);\n\t\t\tlong total = 0;\n\t\t\tfor (ResourceRegion region : regions) {\n\t\t\t\ttotal += region.getCount();\n\t\t\t}\n\t\t\tif (total >= length) {\n\t\t\t\tthrow new IllegalArgumentException(\"The sum of all ranges (\" + total +\n\t\t\t\t\t\t\") should be less than the resource length (\" + length + \")\");\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part from {@link Publisher} content.\n\t * @param name the name of the part to add\n\t * @param publisher a Publisher of content for the part\n\t * @param elementClass the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(String name, P publisher, Class<T> elementClass) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, elementClass);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,typeReference)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #asyncPart(String, Publisher, Class)} with a\n\t * {@link ParameterizedTypeReference} for the element type information.\n\t * @param name the name of the part to add\n\t * @param publisher the part contents\n\t * @param typeReference the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(typeReference, \"'typeReference' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, typeReference);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(outputStream -> StreamUtils.copy(body, outputStream));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,bufferedOutput)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "bufferedOutput"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {\n\t\taddHeaders(this.httpRequest, headers);\n\n\t\tif (this.httpRequest instanceof HttpEntityEnclosingRequest entityEnclosingRequest) {\n\t\t\tHttpEntity requestEntity = new ByteArrayEntity(bufferedOutput);\n\t\t\tentityEnclosingRequest.setEntity(requestEntity);\n\t\t}\n\t\tHttpResponse httpResponse = this.httpClient.execute(this.httpRequest, this.httpContext);\n\t\treturn new HttpComponentsClientHttpResponse(httpResponse);\n\t}"
  },
  "org.springframework.http.client.<unknown>#header(headerName,headerValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic PartBuilder header(String headerName, String... headerValues) {\n\t\t\tinitHeadersIfNecessary().addAll(headerName, Arrays.asList(headerValues));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part where the Object may be:\n\t * <ul>\n\t * <li>String -- form field\n\t * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n\t * <li>Object -- content to be encoded (e.g. to JSON)\n\t * <li>{@link HttpEntity} -- part content and headers although generally it's\n\t * easier to add headers through the returned builder\n\t * <li>{@link Part} -- a part from a server request\n\t * </ul>\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part)",
    "source_code": "\tpublic PartBuilder part(String name, Object part) {\n\t\treturn part(name, part, null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #part(String, Object)} that also accepts a MediaType.\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @param contentType the media type to help with encoding the part\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part, @Nullable MediaType contentType)",
    "source_code": "\tpublic PartBuilder part(String name, Object part, @Nullable MediaType contentType) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(part, \"'part' must not be null\");\n\n\t\tif (part instanceof Part partObject) {\n\t\t\tPartBuilder builder = asyncPart(name, partObject.content(), DataBuffer.class);\n\t\t\tif (!partObject.headers().isEmpty()) {\n\t\t\t\tbuilder.headers(headers -> {\n\t\t\t\t\theaders.putAll(partObject.headers());\n\t\t\t\t\tString filename = headers.getContentDisposition().getFilename();\n\t\t\t\t\t// reset to parameter name\n\t\t\t\t\theaders.setContentDispositionFormData(name, filename);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\n\t\tif (part instanceof PublisherEntity<?,?> publisherEntity) {\n\t\t\tPublisherPartBuilder<?, ?> builder = new PublisherPartBuilder<>(name, publisherEntity);\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\tthis.parts.add(name, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tObject partBody;\n\t\tHttpHeaders partHeaders = null;\n\t\tif (part instanceof HttpEntity<?> httpEntity) {\n\t\t\tpartBody = httpEntity.getBody();\n\t\t\tpartHeaders = new HttpHeaders();\n\t\t\tpartHeaders.putAll(httpEntity.getHeaders());\n\t\t}\n\t\telse {\n\t\t\tpartBody = part;\n\t\t}\n\n\t\tif (partBody instanceof Publisher) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tUse asyncPart(String, Publisher, Class) \\\n\t\t\t\t\tor asyncPart(String, Publisher, ParameterizedTypeReference) \\\n\t\t\t\t\tor MultipartBodyBuilder.PublisherEntity\"\"\");\n\t\t}\n\n\t\tDefaultPartBuilder builder = new DefaultPartBuilder(name, partHeaders, partBody);\n\t\tif (contentType != null) {\n\t\t\tbuilder.contentType(contentType);\n\t\t}\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t\tmutableHttpFields.add(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t\tList<String> oldValues = get(key);\n\t\tmutableHttpFields.put(key, value);\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#put(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tif (!(this.headers instanceof HttpFields.Mutable mutableHttpFields)) {\n\t\t\tthrow new IllegalStateException(\"Immutable headers\");\n\t\t}\n\t\tmutableHttpFields.put(key, value);\n\t}"
  },
  "org.springframework.http.client.reactive.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#canEncode(elementType,mimeType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (!supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mimeType != null && mimeType.getCharset() != null) {\n\t\t\tCharset charset = mimeType.getCharset();\n\t\t\tif (!ENCODINGS.containsKey(charset.name())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> clazz = elementType.toClass();\n\t\tif (String.class.isAssignableFrom(elementType.resolve(clazz))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Object.class == clazz) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canSerialize(clazz);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canSerialize(clazz, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeWriter(writer,mimeType,elementType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "writer",
      "mimeType",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "ObjectWriter",
    "signature": "protected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable MimeType mimeType,\n\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable MimeType mimeType,\n\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn writer;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\n\t\tif (inputStream instanceof Mono) {\n\t\t\treturn Mono.from(inputStream)\n\t\t\t\t\t.map(value -> encodeValue(value, bufferFactory, elementType, mimeType, hints))\n\t\t\t\t\t.flux();\n\t\t}\n\t\telse {\n\t\t\tbyte[] separator = getStreamingMediaTypeSeparator(mimeType);\n\t\t\tif (separator != null) { // streaming\n\t\t\t\ttry {\n\t\t\t\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\t\t\t\tif (mapper == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + elementType);\n\t\t\t\t\t}\n\t\t\t\t\tObjectWriter writer = createObjectWriter(mapper, elementType, mimeType, null, hints);\n\t\t\t\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\t\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\t\t\t\t\tJsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding);\n\t\t\t\t\tSequenceWriter sequenceWriter = writer.writeValues(generator);\n\n\t\t\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t\t\t.map(value -> encodeStreamingValue(value, bufferFactory, hints, sequenceWriter, byteBuilder,\n\t\t\t\t\t\t\t\t\tseparator))\n\t\t\t\t\t\t\t.doAfterTerminate(() -> {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tbyteBuilder.release();\n\t\t\t\t\t\t\t\t\tgenerator.close();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\t\t\t\tlogger.error(\"Could not close Encoder resources\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\treturn Flux.error(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { // non-streaming\n\t\t\t\tResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\n\t\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t\t.collectList()\n\t\t\t\t\t\t.map(list -> encodeValue(list, bufferFactory, listType, mimeType, hints))\n\t\t\t\t\t\t.flux();\n\t\t\t}\n\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tClass<?> jsonView = null;\n\t\tFilterProvider filters = null;\n\t\tif (value instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\tvalueType = ResolvableType.forInstance(value);\n\t\t\tjsonView = mappingJacksonValue.getSerializationView();\n\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t}\n\n\t\tObjectMapper mapper = selectObjectMapper(valueType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + valueType);\n\t\t}\n\n\t\tObjectWriter writer = createObjectWriter(mapper, valueType, mimeType, jsonView, hints);\n\t\tif (filters != null) {\n\t\t\twriter = writer.with(filters);\n\t\t}\n\n\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\ttry {\n\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\n\t\t\tlogValue(hints, value);\n\n\t\t\ttry (JsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding)) {\n\t\t\t\twriter.writeValue(generator, value);\n\t\t\t\tgenerator.flush();\n\t\t\t}\n\t\t\tcatch (InvalidDefinitionException ex) {\n\t\t\t\tthrow new CodecException(\"Type definition error: \" + ex.getType(), ex);\n\t\t\t}\n\t\t\tcatch (JsonProcessingException ex) {\n\t\t\t\tthrow new EncodingException(\"JSON encoding error: \" + ex.getOriginalMessage(), ex);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Unexpected I/O error while writing to byte array builder\", ex);\n\t\t\t}\n\n\t\t\tbyte[] bytes = byteBuilder.toByteArray();\n\t\t\tDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\t\tbuffer.write(bytes);\n\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\n\t\t\treturn buffer;\n\t\t}\n\t\tfinally {\n\t\t\tbyteBuilder.release();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getAnnotation(parameter,annotType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "annotType"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "A",
    "signature": "protected A getAnnotation(MethodParameter parameter, Class<A> annotType)",
    "source_code": "\tprotected <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType) {\n\t\treturn parameter.getMethodAnnotation(annotType);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getEncodeHints(actualType,elementType,mediaType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "Object>",
    "signature": "public Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn (actualType != null ? getHints(actualType) : Hints.none());\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#tokenize(dataBuffers,jsonFactory,objectMapper,tokenizeArrays,forceUseOfBigDecimal,maxInMemorySize)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}.\n\t * @param dataBuffers the source data buffers\n\t * @param jsonFactory the factory to use\n\t * @param objectMapper the current mapper instance\n\t * @param tokenizeArrays if {@code true} and the \"top level\" JSON object is\n\t * an array, each element is returned individually immediately after it is received\n\t * @param forceUseOfBigDecimal if {@code true}, any floating point values encountered\n\t * in source will use {@link java.math.BigDecimal}\n\t * @param maxInMemorySize maximum memory size\n\t * @return the resulting token buffers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffers",
      "jsonFactory",
      "objectMapper",
      "tokenizeArrays",
      "forceUseOfBigDecimal",
      "maxInMemorySize"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Flux<TokenBuffer>",
    "signature": "public Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,\n\t\t\tObjectMapper objectMapper, boolean tokenizeArrays, boolean forceUseOfBigDecimal, int maxInMemorySize)",
    "source_code": "\tpublic static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,\n\t\t\tObjectMapper objectMapper, boolean tokenizeArrays, boolean forceUseOfBigDecimal, int maxInMemorySize) {\n\n\t\ttry {\n\t\t\tJsonParser parser = jsonFactory.createNonBlockingByteArrayParser();\n\t\t\tDeserializationContext context = objectMapper.getDeserializationContext();\n\t\t\tif (context instanceof DefaultDeserializationContext) {\n\t\t\t\tcontext = ((DefaultDeserializationContext) context).createInstance(\n\t\t\t\t\t\tobjectMapper.getDeserializationConfig(), parser, objectMapper.getInjectableValues());\n\t\t\t}\n\t\t\tJackson2Tokenizer tokenizer =\n\t\t\t\t\tnew Jackson2Tokenizer(parser, context, tokenizeArrays, forceUseOfBigDecimal, maxInMemorySize);\n\t\t\treturn dataBuffers.concatMapIterable(tokenizer::tokenize).concatWith(tokenizer.endOfInput());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\treturn Flux.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#addDefaultHeaders(headers,t,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add default headers to the output message.\n\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a\n\t * content type was not provided, set if necessary the default character set, calls\n\t * {@link #getContentLength}, and sets the corresponding headers.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "t",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "protected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType)",
    "source_code": "\tprotected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType) throws IOException {\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || !contentType.isConcrete()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType mediaType = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\tif (contentTypeToUse.getCharset() == null) {\n\t\t\t\t\tCharset defaultCharset = getDefaultCharset();\n\t\t\t\t\tif (defaultCharset != null) {\n\t\t\t\t\t\tcontentTypeToUse = new MediaType(contentTypeToUse, defaultCharset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() < 0 && !headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!MultiValueMap.class.isAssignableFrom(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mediaType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MediaType supportedMediaType : getSupportedMediaTypes()) {\n\t\t\tif (supportedMediaType.getType().equalsIgnoreCase(\"multipart\")) {\n\t\t\t\t// We can't read multipart, so skip this supported media type.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (supportedMediaType.includes(mediaType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(type,contextClass,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\treturn (type instanceof Class<?> clazz ? canRead(clazz, mediaType) : canRead(mediaType));\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!MultiValueMap.class.isAssignableFrom(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mediaType == null || MediaType.ALL.equals(mediaType)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (MediaType supportedMediaType : getSupportedMediaTypes()) {\n\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(type,clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canWrite(clazz, mediaType);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#getContentLength(t,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the content length for the given type.\n\t * <p>By default, this returns {@code null}, meaning that the content length is unknown.\n\t * Can be overridden in subclasses.\n\t * @param t the type to return the content length for\n\t * @return the content length, or {@code null} if not known\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Long",
    "signature": "protected Long getContentLength(T t, @Nullable MediaType contentType)",
    "source_code": "\tprotected Long getContentLength(T t, @Nullable MediaType contentType) throws IOException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(MultiValueMap<String,clazz,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "String>",
    "signature": "public String> read(@Nullable Class<? extends MultiValueMap<String, ?>> clazz,\n\t\t\tHttpInputMessage inputMessage)",
    "source_code": "\tpublic MultiValueMap<String, String> read(@Nullable Class<? extends MultiValueMap<String, ?>> clazz,\n\t\t\tHttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tCharset charset = (contentType != null && contentType.getCharset() != null ?\n\t\t\t\tcontentType.getCharset() : this.charset);\n\t\tString body = StreamUtils.copyToString(inputMessage.getBody(), charset);\n\n\t\tString[] pairs = StringUtils.tokenizeToStringArray(body, \"&\");\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(pairs.length);\n\t\tfor (String pair : pairs) {\n\t\t\tint idx = pair.indexOf('=');\n\t\t\tif (idx == -1) {\n\t\t\t\tresult.add(URLDecoder.decode(pair, charset), null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = URLDecoder.decode(pair.substring(0, idx), charset);\n\t\t\t\tString value = URLDecoder.decode(pair.substring(idx + 1), charset);\n\t\t\t\tresult.add(name, value);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "BufferedImage",
    "signature": "public BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tImageInputStream imageInputStream = null;\n\t\tImageReader imageReader = null;\n\t\t// We cannot use try-with-resources here for the ImageInputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\timageInputStream = createImageInputStream(inputMessage.getBody());\n\t\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\t\tif (contentType == null) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"No Content-Type header\", inputMessage);\n\t\t\t}\n\t\t\tIterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(contentType.toString());\n\t\t\tif (imageReaders.hasNext()) {\n\t\t\t\timageReader = imageReaders.next();\n\t\t\t\tImageReadParam irp = imageReader.getDefaultReadParam();\n\t\t\t\tprocess(irp);\n\t\t\t\timageReader.setInput(imageInputStream, true);\n\t\t\t\treturn imageReader.read(0, irp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\"Could not find javax.imageio.ImageReader for Content-Type [\" + contentType + \"]\",\n\t\t\t\t\t\tinputMessage);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (imageReader != null) {\n\t\t\t\timageReader.dispose();\n\t\t\t}\n\t\t\tif (imageInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\timageInputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(type,contextClass,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ResourceRegion",
    "signature": "protected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected ResourceRegion readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#serializeForm(MultiValueMap<String,formData,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "MultiValueMap<String",
      "formData",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "String",
    "signature": "protected String serializeForm(MultiValueMap<String, Object> formData, Charset charset)",
    "source_code": "\tprotected String serializeForm(MultiValueMap<String, Object> formData, Charset charset) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tformData.forEach((name, values) -> {\n\t\t\t\tif (name == null) {\n\t\t\t\t\tAssert.isTrue(CollectionUtils.isEmpty(values), \"Null name in form data: \" + formData);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvalues.forEach(value -> {\n\t\t\t\t\tif (builder.length() != 0) {\n\t\t\t\t\t\tbuilder.append('&');\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.append(URLEncoder.encode(name, charset));\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tbuilder.append('=');\n\t\t\t\t\t\tbuilder.append(URLEncoder.encode(String.valueOf(value), charset));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\n\t\treturn builder.toString();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(MultiValueMap<String,map,contentType,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "map",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "public void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tif (isMultipart(map, contentType)) {\n\t\t\twriteMultipart((MultiValueMap<String, Object>) map, contentType, outputMessage);\n\t\t}\n\t\telse {\n\t\t\twriteForm((MultiValueMap<String, Object>) map, contentType, outputMessage);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(image,contentType,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "image",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void write(final BufferedImage image, @Nullable final MediaType contentType,\n\t\t\tfinal HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(final BufferedImage image, @Nullable final MediaType contentType,\n\t\t\tfinal HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal MediaType selectedContentType = getContentType(contentType);\n\t\toutputMessage.getHeaders().setContentType(selectedContentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(image, selectedContentType, outputStream));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(image, selectedContentType, outputMessage.getBody());\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,contentType,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic final void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(t, new HttpOutputMessage() {\n\t\t\t\t@Override\n\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\treturn outputStream;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\treturn headers;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,type,contentType,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void write(final T t, @Nullable final Type type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage)",
    "source_code": "\tpublic final void write(final T t, @Nullable final Type type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(outputStream -> writeInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t@Override\n\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\treturn outputStream;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\treturn headers;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, type, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,type,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tif (object instanceof ResourceRegion resourceRegion) {\n\t\t\twriteResourceRegion(resourceRegion, outputMessage);\n\t\t}\n\t\telse {\n\t\t\tCollection<ResourceRegion> regions = (Collection<ResourceRegion>) object;\n\t\t\tif (regions.size() == 1) {\n\t\t\t\twriteResourceRegion(regions.iterator().next(), outputMessage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteResourceRegionCollection(regions, outputMessage);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(T t, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\twriteInternal(t, null, outputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,type,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write (may be {@code null})\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException;\n\n}"
  },
  "org.springframework.http.converter.<unknown>#writeResourceRegion(region,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "region",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "protected void writeResourceRegion(ResourceRegion region, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeResourceRegion(ResourceRegion region, HttpOutputMessage outputMessage) throws IOException {\n\t\tAssert.notNull(region, \"ResourceRegion must not be null\");\n\t\tHttpHeaders responseHeaders = outputMessage.getHeaders();\n\n\t\tlong start = region.getPosition();\n\t\tlong end = start + region.getCount() - 1;\n\t\tlong resourceLength = region.getResource().contentLength();\n\t\tend = Math.min(end, resourceLength - 1);\n\t\tlong rangeLength = end - start + 1;\n\t\tresponseHeaders.add(\"Content-Range\", \"bytes \" + start + '-' + end + '/' + resourceLength);\n\t\tresponseHeaders.setContentLength(rangeLength);\n\n\t\tInputStream in = region.getResource().getInputStream();\n\t\t// We cannot use try-with-resources here for the InputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\tStreamUtils.copyRange(in, outputMessage.getBody(), start, end);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canRead(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canRead(clazz, null, mediaType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canRead(type,contextClass,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\tif (!canRead(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\tObjectMapper objectMapper = selectObjectMapper(javaType.getRawClass(), mediaType);\n\t\tif (objectMapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canWrite(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!canWrite(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mediaType != null && mediaType.getCharset() != null) {\n\t\t\tCharset charset = mediaType.getCharset();\n\t\t\tif (!ENCODINGS.containsKey(charset.name())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, mediaType);\n\t\tif (objectMapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (objectMapper.canSerialize(clazz, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#getContentLength(object,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "Long",
    "signature": "protected Long getContentLength(Object object, @Nullable MediaType contentType)",
    "source_code": "\tprotected Long getContentLength(Object object, @Nullable MediaType contentType) throws IOException {\n\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\tobject = mappingJacksonValue.getValue();\n\t\t}\n\t\treturn super.getContentLength(object, contentType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#getJavaType(type,contextClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Jackson {@link JavaType} for the specified type and context class.\n\t * @param type the generic type to return the Jackson JavaType for\n\t * @param contextClass a context class for the target type, for example a class\n\t * in which the target type appears in a method signature (can be {@code null})\n\t * @return the Jackson JavaType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not log warning for serializer not found (note: different message wording on Jackson 2.9)\n\t\tboolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage().startsWith(\"Cannot find\"));\n\n\t\tif (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tif (debugLevel) {\n\t\t\t\tlogger.debug(msg, cause);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#read(type,contextClass,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#readInternal(clazz,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "Object",
    "signature": "protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(clazz, null);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MediaType,registrar)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and\n\t * {@link #setSupportedMediaTypes(List) supportedMediaTypes} for the given\n\t * class. Therefore it is important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MediaType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MediaType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MediaType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MediaType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeInternal(object,type,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tJsonEncoding encoding = getJsonEncoding(contentType);\n\n\t\tClass<?> clazz = (object instanceof MappingJacksonValue mappingJacksonValue ?\n\t\t\t\tmappingJacksonValue.getValue().getClass() : object.getClass());\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, contentType);\n\t\tAssert.state(objectMapper != null, \"No ObjectMapper for \" + clazz.getName());\n\n\t\tOutputStream outputStream = StreamUtils.nonClosing(outputMessage.getBody());\n\t\ttry (JsonGenerator generator = objectMapper.getFactory().createGenerator(outputStream, encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\t\t\tJavaType javaType = null;\n\n\t\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\t\tserializationView = mappingJacksonValue.getSerializationView();\n\t\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t\t}\n\t\t\tif (type != null && TypeUtils.isAssignable(type, value.getClass())) {\n\t\t\t\tjavaType = getJavaType(type, null);\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tobjectMapper.writerWithView(serializationView) : objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tif (javaType != null && javaType.isContainerType()) {\n\t\t\t\tobjectWriter = objectWriter.forType(javaType);\n\t\t\t}\n\t\t\tSerializationConfig config = objectWriter.getConfig();\n\t\t\tif (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &&\n\t\t\t\t\tconfig.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n\t\t\t\tobjectWriter = objectWriter.with(this.ssePrettyPrinter);\n\t\t\t}\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t\tcatch (InvalidDefinitionException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Type definition error: \" + ex.getType(), ex);\n\t\t}\n\t\tcatch (JsonProcessingException ex) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not write JSON: \" + ex.getOriginalMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writePrefix(generator,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write a prefix before the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "void",
    "signature": "protected void writePrefix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeSuffix(generator,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write a suffix after the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "protected void writeSuffix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writeSuffix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canRead(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * required generic type information in order to read a Collection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canRead(type,contextClass,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Jaxb2CollectionHttpMessageConverter can read a generic\n\t * {@link Collection} where the generic type is a JAXB type annotated with\n\t * {@link XmlRootElement} or {@link XmlType}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\tif (!(type instanceof ParameterizedType parameterizedType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(parameterizedType.getRawType() instanceof Class<?> rawType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Collection.class.isAssignableFrom(rawType))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterizedType.getActualTypeArguments().length != 1) {\n\t\t\treturn false;\n\t\t}\n\t\tType typeArgument = parameterizedType.getActualTypeArguments()[0];\n\t\tif (!(typeArgument instanceof Class<?> typeArgumentClass)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (typeArgumentClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\ttypeArgumentClass.isAnnotationPresent(XmlType.class)) && canRead(mediaType);\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canWrite(clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * does not convert collections to XML.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canWrite(type,clazz,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * does not convert collections to XML.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#read(type,contextClass,inputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "T",
    "signature": "public T read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic T read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\tT result = createCollection((Class<?>) parameterizedType.getRawType());\n\t\tClass<?> elementClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = createUnmarshaller(elementClass);\n\t\t\tXMLStreamReader streamReader = this.inputFactory.createXMLStreamReader(inputMessage.getBody());\n\t\t\tint event = moveToFirstChildOfRootElement(streamReader);\n\n\t\t\twhile (event != XMLStreamReader.END_DOCUMENT) {\n\t\t\t\tif (elementClass.isAnnotationPresent(XmlRootElement.class)) {\n\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader));\n\t\t\t\t}\n\t\t\t\telse if (elementClass.isAnnotationPresent(XmlType.class)) {\n\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader, elementClass).getValue());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should not happen, since we check in canRead(Type)\n\t\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\t\"Cannot unmarshal to [\" + elementClass + \"]\", inputMessage);\n\t\t\t\t}\n\t\t\t\tevent = moveToNextElement(streamReader);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (XMLStreamException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\"Failed to read XML stream: \" + ex.getMessage(), ex, inputMessage);\n\t\t}\n\t\tcatch (UnmarshalException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\"Could not unmarshal to [\" + elementClass + \"]: \" + ex.getMessage(), ex, inputMessage);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#readFromSource(clazz,headers,source)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "headers",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "T",
    "signature": "protected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source)",
    "source_code": "\tprotected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source) throws Exception {\n\t\t// should not be called, since we return false for canRead(Class)\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#write(t,type,contentType,outputMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(o,headers,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "protected void writeToResult(Object o, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object o, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = ClassUtils.getUserClass(o);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(o, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(t,headers,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "protected void writeToResult(T t, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(T t, HttpHeaders headers, Result result) throws Exception {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tthis.headers.addValue(key).setString(value);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createRequest(request,asyncContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "asyncContext"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext asyncContext)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext asyncContext)\n\t\t\tthrows IOException, URISyntaxException {\n\n\t\tAssert.notNull(getServletPath(), \"Servlet path is not initialized\");\n\t\treturn new TomcatServerHttpRequest(\n\t\t\t\trequest, asyncContext, getServletPath(), getDataBufferFactory(), getBufferSize());\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createRequest(request,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext context)\n\t\t\tthrows IOException, URISyntaxException {\n\n\t\tAssert.notNull(getServletPath(), \"Servlet path is not initialized\");\n\t\treturn new JettyServerHttpRequest(\n\t\t\t\trequest, context, getServletPath(), getDataBufferFactory(), getBufferSize());\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,asyncContext,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "asyncContext",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext asyncContext, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext asyncContext, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new TomcatServerHttpResponse(\n\t\t\t\tresponse, asyncContext, getDataBufferFactory(), getBufferSize(), request);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,context,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "context",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new JettyServerHttpResponse(\n\t\t\t\tresponse, context, getDataBufferFactory(), getBufferSize(), request);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tList<String> previousValues = get(key);\n\t\tthis.headers.removeHeader(key);\n\t\tvalue.forEach(v -> this.headers.addValue(key).setString(v));\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tthis.headers.setValue(key).setString(value);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs"
    ],
    "position": {
      "column": 1,
      "line": 1078
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs) throws DataAccessException {\n\t\treturn batchUpdate(sql, batchArgs, new int[0]);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1083
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes) throws DataAccessException {\n\t\tif (batchArgs.isEmpty()) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\treturn batchUpdate(\n\t\t\t\tsql,\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.size();\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,batchSize,pss)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "batchSize",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1120
    },
    "return": "int[][]",
    "signature": "public int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n\t\t\tfinal ParameterizedPreparedStatementSetter<T> pss)",
    "source_code": "\tpublic <T> int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n\t\t\tfinal ParameterizedPreparedStatementSetter<T> pss) throws DataAccessException {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL batch update [\" + sql + \"] with a batch size of \" + batchSize);\n\t\t}\n\t\tint[][] result = execute(sql, (PreparedStatementCallback<int[][]>) ps -> {\n\t\t\tList<int[]> rowsAffected = new ArrayList<>();\n\t\t\ttry {\n\t\t\t\tboolean batchSupported = JdbcUtils.supportsBatchUpdates(ps.getConnection());\n\t\t\t\tint n = 0;\n\t\t\t\tfor (T obj : batchArgs) {\n\t\t\t\t\tpss.setValues(ps, obj);\n\t\t\t\t\tn++;\n\t\t\t\t\tif (batchSupported) {\n\t\t\t\t\t\tps.addBatch();\n\t\t\t\t\t\tif (n % batchSize == 0 || n == batchArgs.size()) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tint batchIdx = (n % batchSize == 0) ? n / batchSize : (n / batchSize) + 1;\n\t\t\t\t\t\t\t\tint items = n - ((n % batchSize == 0) ? n / batchSize - 1 : (n / batchSize)) * batchSize;\n\t\t\t\t\t\t\t\tlogger.trace(\"Sending SQL batch update #\" + batchIdx + \" with \" + items + \" items\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trowsAffected.add(ps.executeBatch());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint i = ps.executeUpdate();\n\t\t\t\t\t\trowsAffected.add(new int[] {i});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint[][] result1 = new int[rowsAffected.size()][];\n\t\t\t\tfor (int i = 0; i < result1.length; i++) {\n\t\t\t\t\tresult1[i] = rowsAffected.get(i);\n\t\t\t\t}\n\t\t\t\treturn result1;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer) {\n\t\t\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,pss)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1029
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss)",
    "source_code": "\tpublic int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss) throws DataAccessException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL batch update [\" + sql + \"]\");\n\t\t}\n\n\t\tint[] result = execute(sql, (PreparedStatementCallback<int[]>) ps -> {\n\t\t\ttry {\n\t\t\t\tint batchSize = pss.getBatchSize();\n\t\t\t\tInterruptibleBatchPreparedStatementSetter ipss =\n\t\t\t\t\t\t(pss instanceof InterruptibleBatchPreparedStatementSetter ?\n\t\t\t\t\t\t(InterruptibleBatchPreparedStatementSetter) pss : null);\n\t\t\t\tif (JdbcUtils.supportsBatchUpdates(ps.getConnection())) {\n\t\t\t\t\tfor (int i = 0; i < batchSize; i++) {\n\t\t\t\t\t\tpss.setValues(ps, i);\n\t\t\t\t\t\tif (ipss != null && ipss.isBatchExhausted(i)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tps.addBatch();\n\t\t\t\t\t}\n\t\t\t\t\treturn ps.executeBatch();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tList<Integer> rowsAffected = new ArrayList<>();\n\t\t\t\t\tfor (int i = 0; i < batchSize; i++) {\n\t\t\t\t\t\tpss.setValues(ps, i);\n\t\t\t\t\t\tif (ipss != null && ipss.isBatchExhausted(i)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trowsAffected.add(ps.executeUpdate());\n\t\t\t\t\t}\n\t\t\t\t\tint[] rowsAffectedArray = new int[rowsAffected.size()];\n\t\t\t\t\tfor (int i = 0; i < rowsAffectedArray.length; i++) {\n\t\t\t\t\t\trowsAffectedArray[i] = rowsAffected.get(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn rowsAffectedArray;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer) {\n\t\t\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#call(csc,declaredParameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "declaredParameters"
    ],
    "position": {
      "column": 1,
      "line": 1223
    },
    "return": "Object>",
    "signature": "public Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)",
    "source_code": "\tpublic Map<String, Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)\n\t\t\tthrows DataAccessException {\n\n\t\tfinal List<SqlParameter> updateCountParameters = new ArrayList<>();\n\t\tfinal List<SqlParameter> resultSetParameters = new ArrayList<>();\n\t\tfinal List<SqlParameter> callParameters = new ArrayList<>();\n\n\t\tfor (SqlParameter parameter : declaredParameters) {\n\t\t\tif (parameter.isResultsParameter()) {\n\t\t\t\tif (parameter instanceof SqlReturnResultSet) {\n\t\t\t\t\tresultSetParameters.add(parameter);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateCountParameters.add(parameter);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcallParameters.add(parameter);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> result = execute(csc, cs -> {\n\t\t\tboolean retVal = cs.execute();\n\t\t\tint updateCount = cs.getUpdateCount();\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"CallableStatement.execute() returned '\" + retVal + \"'\");\n\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t}\n\t\t\tMap<String, Object> resultsMap = createResultsMap();\n\t\t\tif (retVal || updateCount != -1) {\n\t\t\t\tresultsMap.putAll(extractReturnedResults(cs, updateCountParameters, resultSetParameters, updateCount));\n\t\t\t}\n\t\t\tresultsMap.putAll(extractOutputParameters(cs, callParameters));\n\t\t\treturn resultsMap;\n\t\t});\n\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#doSetValue(ps,parameterPosition,argType,argValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the prepared statement's specified parameter position using the passed in\n\t * value and type. This method can be overridden by sub-classes if needed.\n\t * @param ps the PreparedStatement\n\t * @param parameterPosition index of the parameter position\n\t * @param argType the argument type\n\t * @param argValue the argument value\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ps",
      "parameterPosition",
      "argType",
      "argValue"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "protected void doSetValue(PreparedStatement ps, int parameterPosition, int argType, Object argValue)",
    "source_code": "\tprotected void doSetValue(PreparedStatement ps, int parameterPosition, int argType, Object argValue)\n\t\t\tthrows SQLException {\n\n\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, argType, argValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#doSetValue(ps,parameterPosition,argValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for prepared statements specified parameter index using the passed in value.\n\t * This method can be overridden by sub-classes if needed.\n\t * @param ps the PreparedStatement\n\t * @param parameterPosition index of the parameter position\n\t * @param argValue the value to set\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ps",
      "parameterPosition",
      "argValue"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "protected void doSetValue(PreparedStatement ps, int parameterPosition, Object argValue)",
    "source_code": "\tprotected void doSetValue(PreparedStatement ps, int parameterPosition, Object argValue) throws SQLException {\n\t\tif (argValue instanceof SqlParameterValue paramValue) {\n\t\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, paramValue, paramValue.getValue());\n\t\t}\n\t\telse {\n\t\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, SqlTypeValue.TYPE_UNKNOWN, argValue);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(callString,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callString",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1218
    },
    "return": "T",
    "signature": "public T execute(String callString, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String callString, CallableStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimpleCallableStatementCreator(callString), action);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(csc,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1174
    },
    "return": "T",
    "signature": "public T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(csc, \"CallableStatementCreator must not be null\");\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString sql = getSql(csc);\n\t\t\tlogger.debug(\"Calling stored procedure\" + (sql != null ? \" [\" + sql  + \"]\" : \"\"));\n\t\t}\n\n\t\tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n\t\tCallableStatement cs = null;\n\t\ttry {\n\t\t\tcs = csc.createCallableStatement(con);\n\t\t\tapplyStatementSettings(cs);\n\t\t\tT result = action.doInCallableStatement(cs);\n\t\t\thandleWarnings(cs);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\t// Release Connection early, to avoid potential connection pool deadlock\n\t\t\t// in the case when the exception translator hasn't been initialized yet.\n\t\t\tif (csc instanceof ParameterDisposer) {\n\t\t\t\t((ParameterDisposer) csc).cleanupParameters();\n\t\t\t}\n\t\t\tString sql = getSql(csc);\n\t\t\tcsc = null;\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tcs = null;\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\tcon = null;\n\t\t\tthrow translateException(\"CallableStatementCallback\", sql, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (csc instanceof ParameterDisposer) {\n\t\t\t\t((ParameterDisposer) csc).cleanupParameters();\n\t\t\t}\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(psc,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "T",
    "signature": "public T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(psc, action, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(sql,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "T",
    "signature": "public T execute(String sql, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimplePreparedStatementCreator(sql), action, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractOutputParameters(cs,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract output parameters from the completed stored procedure.\n\t * @param cs the JDBC wrapper for the stored procedure\n\t * @param parameters parameter list for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 1333
    },
    "return": "Object>",
    "signature": "protected Object> extractOutputParameters(CallableStatement cs, List<SqlParameter> parameters)",
    "source_code": "\tprotected Map<String, Object> extractOutputParameters(CallableStatement cs, List<SqlParameter> parameters)\n\t\t\tthrows SQLException {\n\n\t\tMap<String, Object> results = CollectionUtils.newLinkedHashMap(parameters.size());\n\t\tint sqlColIndex = 1;\n\t\tfor (SqlParameter param : parameters) {\n\t\t\tif (param instanceof SqlOutParameter outParam) {\n\t\t\t\tAssert.state(outParam.getName() != null, \"Anonymous parameters not allowed\");\n\t\t\t\tSqlReturnType returnType = outParam.getSqlReturnType();\n\t\t\t\tif (returnType != null) {\n\t\t\t\t\tObject out = returnType.getTypeValue(cs, sqlColIndex, outParam.getSqlType(), outParam.getTypeName());\n\t\t\t\t\tresults.put(outParam.getName(), out);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject out = cs.getObject(sqlColIndex);\n\t\t\t\t\tif (out instanceof ResultSet) {\n\t\t\t\t\t\tif (outParam.isResultSetSupported()) {\n\t\t\t\t\t\t\tresults.putAll(processResultSet((ResultSet) out, outParam));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tString rsName = outParam.getName();\n\t\t\t\t\t\t\tSqlReturnResultSet rsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tresults.putAll(processResultSet((ResultSet) out, rsParam));\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults.put(outParam.getName(), out);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(param.isResultsParameter())) {\n\t\t\t\tsqlColIndex++;\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractReturnedResults(cs,updateCountParameters,resultSetParameters,updateCount)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract returned ResultSets from the completed stored procedure.\n\t * @param cs a JDBC wrapper for the stored procedure\n\t * @param updateCountParameters the parameter list of declared update count parameters for the stored procedure\n\t * @param resultSetParameters the parameter list of declared resultSet parameters for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "updateCountParameters",
      "resultSetParameters",
      "updateCount"
    ],
    "position": {
      "column": 1,
      "line": 1270
    },
    "return": "Object>",
    "signature": "protected Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount)",
    "source_code": "\tprotected Map<String, Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount) throws SQLException {\n\n\t\tMap<String, Object> results = new LinkedHashMap<>(4);\n\t\tint rsIndex = 0;\n\t\tint updateIndex = 0;\n\t\tboolean moreResults;\n\t\tif (!this.skipResultsProcessing) {\n\t\t\tdo {\n\t\t\t\tif (updateCount == -1) {\n\t\t\t\t\tif (resultSetParameters != null && resultSetParameters.size() > rsIndex) {\n\t\t\t\t\t\tSqlReturnResultSet declaredRsParam = (SqlReturnResultSet) resultSetParameters.get(rsIndex);\n\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), declaredRsParam));\n\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString rsName = RETURN_RESULT_SET_PREFIX + (rsIndex + 1);\n\t\t\t\t\t\t\tSqlReturnResultSet undeclaredRsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), undeclaredRsParam));\n\t\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (updateCountParameters != null && updateCountParameters.size() > updateIndex) {\n\t\t\t\t\t\tSqlReturnUpdateCount ucParam = (SqlReturnUpdateCount) updateCountParameters.get(updateIndex);\n\t\t\t\t\t\tString declaredUcName = ucParam.getName();\n\t\t\t\t\t\tresults.put(declaredUcName, updateCount);\n\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString undeclaredName = RETURN_UPDATE_COUNT_PREFIX + (updateIndex + 1);\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnUpdateCount parameter named '\" + undeclaredName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.put(undeclaredName, updateCount);\n\t\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmoreResults = cs.getMoreResults();\n\t\t\t\tupdateCount = cs.getUpdateCount();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (moreResults || updateCount != -1);\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1586
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of PersistenceManager proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn null;\n\t\t\t\tcase \"isClosed\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"getTargetConnection\":\n\t\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\t\treturn this.target;\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\treturn (((Class<?>) args[0]).isInstance(proxy) ? proxy : this.target.unwrap((Class<?>) args[0]));\n\t\t\t\tcase \"isWrapperFor\":\n\t\t\t\t\treturn (((Class<?>) args[0]).isInstance(proxy) || this.target.isWrapperFor((Class<?>) args[0]));\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t// If return value is a JDBC Statement, apply statement settings\n\t\t\t\t// (fetch size, max rows, transaction timeout).\n\t\t\t\tif (retVal instanceof Statement) {\n\t\t\t\t\tapplyStatementSettings(((Statement) retVal));\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newArgTypePreparedStatementSetter(args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new arg-type-based PreparedStatementSetter using the args and types passed in.\n\t * <p>By default, we'll create an {@link ArgumentTypePreparedStatementSetter}.\n\t * This method allows for the creation to be overridden by subclasses.\n\t * @param args object array with arguments\n\t * @param argTypes int array of SQLTypes for the associated arguments\n\t * @return the new PreparedStatementSetter to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1490
    },
    "return": "PreparedStatementSetter",
    "signature": "protected PreparedStatementSetter newArgTypePreparedStatementSetter(Object[] args, int[] argTypes)",
    "source_code": "\tprotected PreparedStatementSetter newArgTypePreparedStatementSetter(Object[] args, int[] argTypes) {\n\t\treturn new ArgumentTypePreparedStatementSetter(args, argTypes);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newPreparedStatementCreator(sqlToUse,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new PreparedStatementCreator for the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sqlToUse",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "PreparedStatementCreator",
    "signature": "public PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params)",
    "source_code": "\tpublic PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params) {\n\t\treturn new PreparedStatementCreatorImpl(\n\t\t\t\tsqlToUse, params != null ? Arrays.asList(params) : Collections.emptyList());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#processResultSet(rs,param)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given ResultSet from a stored procedure.\n\t * @param rs the ResultSet to process\n\t * @param param the corresponding stored procedure parameter\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "param"
    ],
    "position": {
      "column": 1,
      "line": 1379
    },
    "return": "Object>",
    "signature": "protected Object> processResultSet(@Nullable ResultSet rs, ResultSetSupportingSqlParameter param)",
    "source_code": "\tprotected Map<String, Object> processResultSet(\n\t\t\t@Nullable ResultSet rs, ResultSetSupportingSqlParameter param) throws SQLException {\n\n\t\tif (rs != null) {\n\t\t\ttry {\n\t\t\t\tif (param.getRowMapper() != null) {\n\t\t\t\t\tRowMapper<?> rowMapper = param.getRowMapper();\n\t\t\t\t\tObject data = (new RowMapperResultSetExtractor<>(rowMapper)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t\telse if (param.getRowCallbackHandler() != null) {\n\t\t\t\t\tRowCallbackHandler rch = param.getRowCallbackHandler();\n\t\t\t\t\t(new RowCallbackHandlerResultSetExtractor(rch)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(),\n\t\t\t\t\t\t\t\"ResultSet returned from stored procedure was processed\");\n\t\t\t\t}\n\t\t\t\telse if (param.getResultSetExtractor() != null) {\n\t\t\t\t\tObject data = param.getResultSetExtractor().extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyMap();\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,pss,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if there is any problem\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(\n\t\t\tPreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tlogger.debug(\"Executing prepared SQL query\");\n\n\t\treturn execute(psc, new PreparedStatementCallback<T>() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\tif (pss != null) {\n\t\t\t\t\t\tpss.setValues(ps);\n\t\t\t\t\t}\n\t\t\t\t\trs = ps.executeQuery();\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\tif (pss instanceof ParameterDisposer) {\n\t\t\t\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 767
    },
    "return": "void",
    "signature": "public void query(PreparedStatementCreator psc, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(PreparedStatementCreator psc, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(psc, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "List<T>",
    "signature": "public List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(psc, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(psc, null, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 777
    },
    "return": "void",
    "signature": "public void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, newArgTypePreparedStatementSetter(args, argTypes), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, args, argTypes, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 749
    },
    "return": "T",
    "signature": "public T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, newArgTypePreparedStatementSetter(args, argTypes), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 783
    },
    "return": "void",
    "signature": "public void query(String sql, @Nullable Object[] args, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, @Nullable Object[] args, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, newArgPreparedStatementSetter(args), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 809
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, args, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 756
    },
    "return": "T",
    "signature": "public T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, newArgPreparedStatementSetter(args), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 772
    },
    "return": "void",
    "signature": "public void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, pss, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, pss, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "T",
    "signature": "public T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(new SimplePreparedStatementCreator(sql), pss, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch, @Nullable Object... args)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch, @Nullable Object... args) throws DataAccessException {\n\t\tquery(sql, newArgPreparedStatementSetter(args), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 474
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rowMapper,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 814
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(query(sql, args, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "public T query(final String sql, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL query [\" + sql + \"]\");\n\t\t}\n\n\t\t/**\n\t\t * Callback to execute the query.\n\t\t */\n\t\tclass QueryStatementCallback implements StatementCallback<T>, SqlProvider {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\trs = stmt.executeQuery(sql);\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn execute(new QueryStatementCallback(), true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 762
    },
    "return": "T",
    "signature": "public T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args)",
    "source_code": "\tpublic <T> T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, newArgPreparedStatementSetter(args), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 941
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, @Nullable Object... args)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 936
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn query(sql, args, argTypes, getColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,argTypes,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 920
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, args, argTypes, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 926
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 931
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, @Nullable Object... args)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 910
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, argTypes, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 892
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, args, argTypes, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\tList<T> results = query(sql, args, argTypes, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 878
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tList<T> results = query(sql, args, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 905
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 507
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tList<T> results = query(sql, rowMapper);\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,rowMapper,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 885
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\tList<T> results = query(sql, args, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForRowSet(sql,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 951
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, @Nullable Object... args)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(query(sql, args, new SqlRowSetResultSetExtractor()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForRowSet(sql,args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 946
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(query(sql, args, argTypes, new SqlRowSetResultSetExtractor()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,pss,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (e.g. through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper) throws DataAccessException {\n\n\t\treturn result(execute(psc, ps -> {\n\t\t\tif (pss != null) {\n\t\t\t\tpss.setValues(ps);\n\t\t\t}\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tConnection con = ps.getConnection();\n\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\tif (pss instanceof ParameterDisposer) {\n\t\t\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t\t\t}\n\t\t\t\tJdbcUtils.closeStatement(ps);\n\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t});\n\t\t}, false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 852
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn queryForStream(psc, null, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,pss,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), pss, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tclass StreamStatementCallback implements StatementCallback<Stream<T>>, SqlProvider {\n\t\t\t@Override\n\t\t\tpublic Stream<T> doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = stmt.executeQuery(sql);\n\t\t\t\tConnection con = stmt.getConnection();\n\t\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t\t});\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn result(execute(new StreamStatementCallback(), false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 862
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), newArgPreparedStatementSetter(args), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,param,inValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param param the parameter as it is declared including type\n\t * @param inValue the value to set\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "param",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,inValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,typeName,inValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * (optional, only used for SQL NULL and SqlTypeValue)\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setValues(ps,i)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 1092
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}"
  },
  "org.springframework.jdbc.core.<unknown>#translateException(task,sql,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given {@link SQLException} into a generic {@link DataAccessException}.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param ex the offending {@code SQLException}\n\t * @return a DataAccessException wrapping the {@code SQLException} (never {@code null})\n\t * @since 5.0\n\t * @see #getExceptionTranslator()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1538
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException translateException(String task, @Nullable String sql, SQLException ex)",
    "source_code": "\tprotected DataAccessException translateException(String task, @Nullable String sql, SQLException ex) {\n\t\tDataAccessException dae = getExceptionTranslator().translate(task, sql, ex);\n\t\treturn (dae != null ? dae : new UncategorizedSQLException(task, sql, ex));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,generatedKeyHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 985
    },
    "return": "int",
    "signature": "public int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(generatedKeyHolder, \"KeyHolder must not be null\");\n\t\tlogger.debug(\"Executing SQL update and returning generated keys\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\tint rows = ps.executeUpdate();\n\t\t\tList<Map<String, Object>> generatedKeys = generatedKeyHolder.getKeyList();\n\t\t\tgeneratedKeys.clear();\n\t\t\tResultSet keys = ps.getGeneratedKeys();\n\t\t\tif (keys != null) {\n\t\t\t\ttry {\n\t\t\t\t\tRowMapperResultSetExtractor<Map<String, Object>> rse =\n\t\t\t\t\t\t\tnew RowMapperResultSetExtractor<>(getColumnMapRowMapper(), 1);\n\t\t\t\t\tgeneratedKeys.addAll(result(rse.extractData(keys)));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(keys);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows and returned \" + generatedKeys.size() + \" keys\");\n\t\t\t}\n\t\t\treturn rows;\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,pss)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "psc",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 955
    },
    "return": "int",
    "signature": "protected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss)",
    "source_code": "\tprotected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss)\n\t\t\tthrows DataAccessException {\n\n\t\tlogger.debug(\"Executing prepared SQL update\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\ttry {\n\t\t\t\tif (pss != null) {\n\t\t\t\t\tpss.setValues(ps);\n\t\t\t\t}\n\t\t\t\tint rows = ps.executeUpdate();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows\");\n\t\t\t\t}\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer) {\n\t\t\t\t\t((ParameterDisposer) pss).cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1024
    },
    "return": "int",
    "signature": "public int update(String sql, @Nullable Object... args)",
    "source_code": "\tpublic int update(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn update(sql, newArgPreparedStatementSetter(args));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args,argTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1019
    },
    "return": "int",
    "signature": "public int update(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic int update(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn update(sql, newArgTypePreparedStatementSetter(args, argTypes));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,pss)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1014
    },
    "return": "int",
    "signature": "public int update(String sql, @Nullable PreparedStatementSetter pss)",
    "source_code": "\tpublic int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException {\n\t\treturn update(new SimplePreparedStatementCreator(sql), pss);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildSqlParameterList(parsedSql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters.\n\t * This is necessary in order to reuse existing methods on JdbcTemplate.\n\t * The SqlParameter for a named parameter is placed in the correct position in the\n\t * resulting list based on the parsed SQL statement info.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "List<SqlParameter>",
    "signature": "public List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tList<SqlParameter> params = new ArrayList<>(paramNames.size());\n\t\tfor (String paramName : paramNames) {\n\t\t\tparams.add(new SqlParameter(\n\t\t\t\t\tparamName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)));\n\t\t}\n\t\treturn params;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildSqlTypeArray(parsedSql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert parameter types from an SqlParameterSource into a corresponding int array.\n\t * This is necessary in order to reuse existing methods on JdbcTemplate.\n\t * Any named parameter types are placed in the correct position in the\n\t * Object array based on the parsed SQL statement info.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "int[]",
    "signature": "public int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {\n\t\tint[] sqlTypes = new int[parsedSql.getTotalParameterCount()];\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tsqlTypes[i] = paramSource.getSqlType(paramName);\n\t\t}\n\t\treturn sqlTypes;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(parsedSql,paramSource,declaredParams)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t * @param declaredParams the List of declared SqlParameter objects\n\t * (may be {@code null}). If specified, the parameter metadata will\n\t * be built into the value array in the form of SqlParameterValue objects.\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource",
      "declaredParams"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams)",
    "source_code": "\tpublic static Object[] buildValueArray(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {\n\n\t\tObject[] paramArray = new Object[parsedSql.getTotalParameterCount()];\n\t\tif (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Not allowed to mix named and traditional ? placeholders. You have \" +\n\t\t\t\t\tparsedSql.getNamedParameterCount() + \" named parameter(s) and \" +\n\t\t\t\t\tparsedSql.getUnnamedParameterCount() + \" traditional placeholder(s) in statement: \" +\n\t\t\t\t\tparsedSql.getOriginalSql());\n\t\t}\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\ttry {\n\t\t\t\tSqlParameter param = findParameter(declaredParams, paramName, i);\n\t\t\t\tObject paramValue = paramSource.getValue(paramName);\n\t\t\t\tif (paramValue instanceof SqlParameterValue) {\n\t\t\t\t\tparamArray[i] = paramValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparamArray[i] = (param != null ? new SqlParameterValue(param, paramValue) :\n\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(paramSource, paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"No value supplied for the SQL parameter '\" + paramName + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn paramArray;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(sql,Map<String,paramMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * <p>This is a shortcut version of\n\t * {@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}.\n\t * @param sql the SQL statement\n\t * @param paramMap the Map of parameters\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(parsedSql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters. Named\n\t * parameters are substituted for a JDBC placeholder, and any select list is expanded\n\t * to the required number of placeholders. Select lists may contain an array of\n\t * objects, and in that case the placeholders will be grouped and enclosed with\n\t * parentheses. This allows for the use of \"expression lists\" in the SQL statement\n\t * like: <br /><br />\n\t * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}\n\t * <p>The parameter values passed in are used to determine the number of placeholders to\n\t * be used for a select list. Select lists should be limited to 100 or fewer elements.\n\t * A larger number of elements is not guaranteed to be supported by the database and\n\t * is strictly vendor-dependent.\n\t * @param parsedSql the parsed representation of the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t * @see #parseSqlStatement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {\n\t\tString originalSql = parsedSql.getOriginalSql();\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tif (paramNames.isEmpty()) {\n\t\t\treturn originalSql;\n\t\t}\n\t\tStringBuilder actualSql = new StringBuilder(originalSql.length());\n\t\tint lastIndex = 0;\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tint[] indexes = parsedSql.getParameterIndexes(i);\n\t\t\tint startIndex = indexes[0];\n\t\t\tint endIndex = indexes[1];\n\t\t\tactualSql.append(originalSql, lastIndex, startIndex);\n\t\t\tif (paramSource != null && paramSource.hasValue(paramName)) {\n\t\t\t\tObject value = paramSource.getValue(paramName);\n\t\t\t\tif (value instanceof SqlParameterValue) {\n\t\t\t\t\tvalue = ((SqlParameterValue) value).getValue();\n\t\t\t\t}\n\t\t\t\tif (value instanceof Iterable) {\n\t\t\t\t\tIterator<?> entryIter = ((Iterable<?>) value).iterator();\n\t\t\t\t\tint k = 0;\n\t\t\t\t\twhile (entryIter.hasNext()) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tObject entryItem = entryIter.next();\n\t\t\t\t\t\tif (entryItem instanceof Object[] expressionList) {\n\t\t\t\t\t\t\tactualSql.append('(');\n\t\t\t\t\t\t\tfor (int m = 0; m < expressionList.length; m++) {\n\t\t\t\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactualSql.append('?');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactualSql.append(')');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactualSql.append('?');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactualSql.append('?');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactualSql.append('?');\n\t\t\t}\n\t\t\tlastIndex = endIndex;\n\t\t}\n\t\tactualSql.append(originalSql, lastIndex, originalSql.length());\n\t\treturn actualSql.toString();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(sql,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * Named parameters are substituted for a JDBC placeholder and any select list\n\t * is expanded to the required number of placeholders.\n\t * <p>This is a shortcut version of\n\t * {@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}.\n\t * @param sql the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 469
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, paramSource);\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#getConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\t\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\t\treturn this.dataSource.getConnection(username, password);\n\t\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#getConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\treturn determineTargetDataSource().getConnection(username, password);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#setTargetDataSources(Map<Object,targetDataSources)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target DataSources, with the lookup key as key.\n\t * The mapped value can either be a corresponding {@link javax.sql.DataSource}\n\t * instance or a data source name String (to be resolved via a\n\t * {@link #setDataSourceLookup DataSourceLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the\n\t * generic lookup process only. The concrete key representation will\n\t * be handled by {@link #resolveSpecifiedLookupKey(Object)} and\n\t * {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Object",
      "targetDataSources"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void setTargetDataSources(Map<Object, Object> targetDataSources)",
    "source_code": "\tpublic void setTargetDataSources(Map<Object, Object> targetDataSources) {\n\t\tthis.targetDataSources = targetDataSources;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#createCustomException(task,sql,sqlEx,exceptionClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a custom {@link DataAccessException}, based on a given exception\n\t * class from a {@link CustomSQLErrorCodesTranslation} definition.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param sqlEx the offending SQLException\n\t * @param exceptionClass the exception class to use, as defined in the\n\t * {@link CustomSQLErrorCodesTranslation} definition\n\t * @return {@code null} if the custom exception could not be created, otherwise\n\t * the resulting {@link DataAccessException}. This exception should include the\n\t * {@code sqlEx} parameter as a nested root cause.\n\t * @see CustomSQLErrorCodesTranslation#setExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "sqlEx",
      "exceptionClass"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException createCustomException(String task, @Nullable String sql, SQLException sqlEx, Class<?> exceptionClass)",
    "source_code": "\tprotected DataAccessException createCustomException(\n\t\t\tString task, @Nullable String sql, SQLException sqlEx, Class<?> exceptionClass) {\n\n\t\t// Find appropriate constructor for the given exception class\n\t\ttry {\n\t\t\tint constructorType = 0;\n\t\t\tConstructor<?>[] constructors = exceptionClass.getConstructors();\n\t\t\tfor (Constructor<?> constructor : constructors) {\n\t\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\t\tif (parameterTypes.length == 1 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_ONLY_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_ONLY_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 2 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tThrowable.class == parameterTypes[1] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_THROWABLE_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_THROWABLE_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 2 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tSQLException.class == parameterTypes[1] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQLEX_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQLEX_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 3 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tString.class == parameterTypes[1] && Throwable.class == parameterTypes[2] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQL_THROWABLE_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQL_THROWABLE_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 3 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tString.class == parameterTypes[1] && SQLException.class == parameterTypes[2] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQL_SQLEX_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQL_SQLEX_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// invoke constructor\n\t\t\tConstructor<?> exceptionConstructor;\n\t\t\treturn switch (constructorType) {\n\t\t\t\tcase MESSAGE_SQL_SQLEX_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlAndSqlExArgsClass = new Class<?>[] {String.class, String.class, SQLException.class};\n\t\t\t\t\tObject[] messageAndSqlAndSqlExArgs = new Object[] {task, sql, sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndSqlExArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndSqlExArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_SQL_THROWABLE_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlAndThrowableArgsClass = new Class<?>[] {String.class, String.class, Throwable.class};\n\t\t\t\t\tObject[] messageAndSqlAndThrowableArgs = new Object[] {task, sql, sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndThrowableArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndThrowableArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_SQLEX_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlExArgsClass = new Class<?>[] {String.class, SQLException.class};\n\t\t\t\t\tObject[] messageAndSqlExArgs = new Object[] {task + \": \" + sqlEx.getMessage(), sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlExArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlExArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_THROWABLE_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndThrowableArgsClass = new Class<?>[] {String.class, Throwable.class};\n\t\t\t\t\tObject[] messageAndThrowableArgs = new Object[] {task + \": \" + sqlEx.getMessage(), sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndThrowableArgsClass);\n\t\t\t\t\tyield (DataAccessException)exceptionConstructor.newInstance(messageAndThrowableArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_ONLY_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageOnlyArgsClass = new Class<?>[] {String.class};\n\t\t\t\t\tObject[] messageOnlyArgs = new Object[] {task + \": \" + sqlEx.getMessage()};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageOnlyArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageOnlyArgs);\n\t\t\t\t}\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Unable to find appropriate constructor of custom exception class [\" +\n\t\t\t\t\t\t\t\texceptionClass.getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tyield null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Unable to instantiate custom exception class [\" + exceptionClass.getName() + \"]\", ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#customTranslate(task,sql,sqlEx)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to attempt a custom mapping from\n\t * {@link SQLException} to {@link DataAccessException}.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param sqlEx the offending SQLException\n\t * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}\n\t * resulting from custom translation. This exception should include the {@code sqlEx} parameter\n\t * as a nested root cause. This implementation always returns {@code null}, meaning that the\n\t * translator always falls back to the default error codes.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "sqlEx"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlEx)",
    "source_code": "\tprotected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlEx) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#doTranslate(task,sql,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex)",
    "source_code": "\tprotected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex) {\n\t\tSQLException sqlEx = ex;\n\t\tif (sqlEx instanceof BatchUpdateException && sqlEx.getNextException() != null) {\n\t\t\tSQLException nestedSqlEx = sqlEx.getNextException();\n\t\t\tif (nestedSqlEx.getErrorCode() > 0 || nestedSqlEx.getSQLState() != null) {\n\t\t\t\tsqlEx = nestedSqlEx;\n\t\t\t}\n\t\t}\n\n\t\t// First, try custom translation from overridden method.\n\t\tDataAccessException dae = customTranslate(task, sql, sqlEx);\n\t\tif (dae != null) {\n\t\t\treturn dae;\n\t\t}\n\n\t\t// Next, try the custom SQLException translator, if available.\n\t\tSQLErrorCodes sqlErrorCodes = getSqlErrorCodes();\n\t\tif (sqlErrorCodes != null) {\n\t\t\tSQLExceptionTranslator customTranslator = sqlErrorCodes.getCustomSqlExceptionTranslator();\n\t\t\tif (customTranslator != null) {\n\t\t\t\tDataAccessException customDex = customTranslator.translate(task, sql, sqlEx);\n\t\t\t\tif (customDex != null) {\n\t\t\t\t\treturn customDex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check SQLErrorCodes with corresponding error code, if available.\n\t\tif (sqlErrorCodes != null) {\n\t\t\tString errorCode;\n\t\t\tif (sqlErrorCodes.isUseSqlStateForTranslation()) {\n\t\t\t\terrorCode = sqlEx.getSQLState();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try to find SQLException with actual error code, looping through the causes.\n\t\t\t\t// E.g. applicable to java.sql.DataTruncation as of JDK 1.6.\n\t\t\t\tSQLException current = sqlEx;\n\t\t\t\twhile (current.getErrorCode() == 0 && current.getCause() instanceof SQLException) {\n\t\t\t\t\tcurrent = (SQLException) current.getCause();\n\t\t\t\t}\n\t\t\t\terrorCode = Integer.toString(current.getErrorCode());\n\t\t\t}\n\n\t\t\tif (errorCode != null) {\n\t\t\t\t// Look for defined custom translations first.\n\t\t\t\tCustomSQLErrorCodesTranslation[] customTranslations = sqlErrorCodes.getCustomTranslations();\n\t\t\t\tif (customTranslations != null) {\n\t\t\t\t\tfor (CustomSQLErrorCodesTranslation customTranslation : customTranslations) {\n\t\t\t\t\t\tif (Arrays.binarySearch(customTranslation.getErrorCodes(), errorCode) >= 0 &&\n\t\t\t\t\t\t\t\tcustomTranslation.getExceptionClass() != null) {\n\t\t\t\t\t\t\tDataAccessException customException = createCustomException(\n\t\t\t\t\t\t\t\t\ttask, sql, sqlEx, customTranslation.getExceptionClass());\n\t\t\t\t\t\t\tif (customException != null) {\n\t\t\t\t\t\t\t\tlogTranslation(task, sql, sqlEx, true);\n\t\t\t\t\t\t\t\treturn customException;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Next, look for grouped error codes.\n\t\t\t\tif (Arrays.binarySearch(sqlErrorCodes.getBadSqlGrammarCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getInvalidResultSetAccessCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new InvalidResultSetAccessException(task, (sql != null ? sql : \"\"), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDuplicateKeyCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDataIntegrityViolationCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getPermissionDeniedCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDataAccessResourceFailureCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getTransientDataAccessResourceCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getCannotAcquireLockCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDeadlockLoserCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DeadlockLoserDataAccessException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getCannotSerializeTransactionCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new CannotSerializeTransactionException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// We couldn't identify it more precisely - let's hand it over to the SQLState fallback translator.\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString codes;\n\t\t\tif (sqlErrorCodes != null && sqlErrorCodes.isUseSqlStateForTranslation()) {\n\t\t\t\tcodes = \"SQL state '\" + sqlEx.getSQLState() + \"', error code '\" + sqlEx.getErrorCode();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcodes = \"Error code '\" + sqlEx.getErrorCode() + \"'\";\n\t\t\t}\n\t\t\tlogger.debug(\"Unable to translate SQLException with \" + codes + \", will now try the fallback translator\");\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,action)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract database meta-data via the given DatabaseMetaDataCallback.\n\t * <p>This method will open a connection to the database and retrieve its meta-data.\n\t * Since this method is called before the exception translation feature is configured\n\t * for a DataSource, this method can not rely on SQLException translation itself.\n\t * <p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked\n\t * exception and any calling code should catch and handle this exception. You can just\n\t * log the error and hope for the best, but there is probably a more serious error that\n\t * will reappear when you try to access the database again.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param action callback that will do the actual work\n\t * @return object containing the extracted information, as returned by\n\t * the DatabaseMetaDataCallback's {@code processMetaData} method\n\t * @throws MetaDataAccessException if meta-data access failed\n\t * @see java.sql.DatabaseMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)\n\t\t\tthrows MetaDataAccessException {\n\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = DataSourceUtils.getConnection(dataSource);\n\t\t\tDatabaseMetaData metaData;\n\t\t\ttry {\n\t\t\t\tmetaData = con.getMetaData();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tif (DataSourceUtils.isConnectionTransactional(con, dataSource)) {\n\t\t\t\t\t// Probably a closed thread-bound Connection - retry against fresh Connection\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t\t\t\tcon = null;\n\t\t\t\t\tlogger.debug(\"Failed to obtain DatabaseMetaData from transactional Connection - \" +\n\t\t\t\t\t\t\t\"retrying against fresh Connection\", ex);\n\t\t\t\t\tcon = dataSource.getConnection();\n\t\t\t\t\tmetaData = con.getMetaData();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metaData == null) {\n\t\t\t\t// should only happen in test environments\n\t\t\t\tthrow new MetaDataAccessException(\"DatabaseMetaData returned by Connection [\" + con + \"] was null\");\n\t\t\t}\n\t\t\treturn action.processMetaData(metaData);\n\t\t}\n\t\tcatch (CannotGetJdbcConnectionException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Could not get Connection for extracting meta-data\", ex);\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Error while extracting DatabaseMetaData\", ex);\n\t\t}\n\t\tcatch (AbstractMethodError err) {\n\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver\", err);\n\t\t}\n\t\tfinally {\n\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,metaDataMethodName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Call the specified method on DatabaseMetaData for the given DataSource,\n\t * and extract the invocation result.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param metaDataMethodName the name of the DatabaseMetaData method to call\n\t * @return the object returned by the specified DatabaseMetaData method\n\t * @throws MetaDataAccessException if we couldn't access the DatabaseMetaData\n\t * or failed to invoke the specified method\n\t * @see java.sql.DatabaseMetaData\n\t * @deprecated as of 5.2.9, in favor of\n\t * {@link #extractDatabaseMetaData(DataSource, DatabaseMetaDataCallback)}\n\t * with a lambda expression or method reference and a generically typed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "metaDataMethodName"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)\n\t\t\tthrows MetaDataAccessException {\n\n\t\treturn (T) extractDatabaseMetaData(dataSource,\n\t\t\t\tdbmd -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\"No method named '\" + metaDataMethodName +\n\t\t\t\t\t\t\t\t\"' found on DatabaseMetaData instance [\" + dbmd + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Could not access DatabaseMetaData method '\" + metaDataMethodName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tif (ex.getTargetException() instanceof SQLException) {\n\t\t\t\t\t\t\tthrow (SQLException) ex.getTargetException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Invocation of DatabaseMetaData method '\" + metaDataMethodName + \"' failed\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#getResultSetValue(rs,index)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC column value from a ResultSet, using the most appropriate\n\t * value type. The returned value should be a detached value object, not having\n\t * any ties to the active ResultSet: in particular, it should not be a Blob or\n\t * Clob object but rather a byte array or String representation, respectively.\n\t * <p>Uses the {@code getObject(index)} method, but includes additional \"hacks\"\n\t * to get around Oracle 10g returning a non-standard object for its TIMESTAMP\n\t * datatype and a {@code java.sql.Date} for DATE columns leaving out the\n\t * time portion: These columns will explicitly be extracted as standard\n\t * {@code java.sql.Timestamp} object.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see java.sql.Blob\n\t * @see java.sql.Clob\n\t * @see java.sql.Timestamp\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Object",
    "signature": "public Object getResultSetValue(ResultSet rs, int index)",
    "source_code": "\tpublic static Object getResultSetValue(ResultSet rs, int index) throws SQLException {\n\t\tObject obj = rs.getObject(index);\n\t\tString className = null;\n\t\tif (obj != null) {\n\t\t\tclassName = obj.getClass().getName();\n\t\t}\n\t\tif (obj instanceof Blob blob) {\n\t\t\tobj = blob.getBytes(1, (int) blob.length());\n\t\t}\n\t\telse if (obj instanceof Clob clob) {\n\t\t\tobj = clob.getSubString(1, (int) clob.length());\n\t\t}\n\t\telse if (\"oracle.sql.TIMESTAMP\".equals(className) || \"oracle.sql.TIMESTAMPTZ\".equals(className)) {\n\t\t\tobj = rs.getTimestamp(index);\n\t\t}\n\t\telse if (className != null && className.startsWith(\"oracle.sql.DATE\")) {\n\t\t\tString metaDataClassName = rs.getMetaData().getColumnClassName(index);\n\t\t\tif (\"java.sql.Timestamp\".equals(metaDataClassName) || \"oracle.sql.TIMESTAMP\".equals(metaDataClassName)) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = rs.getDate(index);\n\t\t\t}\n\t\t}\n\t\telse if (obj instanceof java.sql.Date) {\n\t\t\tif (\"java.sql.Timestamp\".equals(rs.getMetaData().getColumnClassName(index))) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#getResultSetValue(rs,index,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC column value from a ResultSet, using the specified value type.\n\t * <p>Uses the specifically typed ResultSet accessor methods, falling back to\n\t * {@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types.\n\t * <p>Note that the returned value may not be assignable to the specified\n\t * required type, in case of an unknown type. Calling code needs to deal\n\t * with this case appropriately, e.g. throwing a corresponding exception.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the required value type (may be {@code null})\n\t * @return the value object (possibly not of the specified required type,\n\t * with further conversion steps necessary)\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see #getResultSetValue(ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Object",
    "signature": "public Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tpublic static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType == null) {\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\tObject value;\n\n\t\t// Explicitly extract typed value, as far as possible.\n\t\tif (String.class == requiredType) {\n\t\t\treturn rs.getString(index);\n\t\t}\n\t\telse if (boolean.class == requiredType || Boolean.class == requiredType) {\n\t\t\tvalue = rs.getBoolean(index);\n\t\t}\n\t\telse if (byte.class == requiredType || Byte.class == requiredType) {\n\t\t\tvalue = rs.getByte(index);\n\t\t}\n\t\telse if (short.class == requiredType || Short.class == requiredType) {\n\t\t\tvalue = rs.getShort(index);\n\t\t}\n\t\telse if (int.class == requiredType || Integer.class == requiredType) {\n\t\t\tvalue = rs.getInt(index);\n\t\t}\n\t\telse if (long.class == requiredType || Long.class == requiredType) {\n\t\t\tvalue = rs.getLong(index);\n\t\t}\n\t\telse if (float.class == requiredType || Float.class == requiredType) {\n\t\t\tvalue = rs.getFloat(index);\n\t\t}\n\t\telse if (double.class == requiredType || Double.class == requiredType ||\n\t\t\t\tNumber.class == requiredType) {\n\t\t\tvalue = rs.getDouble(index);\n\t\t}\n\t\telse if (BigDecimal.class == requiredType) {\n\t\t\treturn rs.getBigDecimal(index);\n\t\t}\n\t\telse if (java.sql.Date.class == requiredType) {\n\t\t\treturn rs.getDate(index);\n\t\t}\n\t\telse if (java.sql.Time.class == requiredType) {\n\t\t\treturn rs.getTime(index);\n\t\t}\n\t\telse if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {\n\t\t\treturn rs.getTimestamp(index);\n\t\t}\n\t\telse if (byte[].class == requiredType) {\n\t\t\treturn rs.getBytes(index);\n\t\t}\n\t\telse if (Blob.class == requiredType) {\n\t\t\treturn rs.getBlob(index);\n\t\t}\n\t\telse if (Clob.class == requiredType) {\n\t\t\treturn rs.getClob(index);\n\t\t}\n\t\telse if (requiredType.isEnum()) {\n\t\t\t// Enums can either be represented through a String or an enum index value:\n\t\t\t// leave enum type conversion up to the caller (e.g. a ConversionService)\n\t\t\t// but make sure that we return nothing other than a String or an Integer.\n\t\t\tObject obj = rs.getObject(index);\n\t\t\tif (obj instanceof String) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\telse if (obj instanceof Number) {\n\t\t\t\t// Defensively convert any Number to an Integer (as needed by our\n\t\t\t\t// ConversionService's IntegerToEnumConverterFactory) for use as index\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// e.g. on Postgres: getObject returns a PGObject but we need a String\n\t\t\t\treturn rs.getString(index);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Some unknown type desired -> rely on getObject.\n\t\t\ttry {\n\t\t\t\treturn rs.getObject(index, requiredType);\n\t\t\t}\n\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\tlogger.debug(\"JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method\", err);\n\t\t\t}\n\t\t\tcatch (SQLFeatureNotSupportedException ex) {\n\t\t\t\tlogger.debug(\"JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method\", ex);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tlogger.debug(\"JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method\", ex);\n\t\t\t}\n\n\t\t\t// Corresponding SQL types for JSR-310 / Joda-Time types, left up\n\t\t\t// to the caller to convert them (e.g. through a ConversionService).\n\t\t\tString typeName = requiredType.getSimpleName();\n\t\t\tif (\"LocalDate\".equals(typeName)) {\n\t\t\t\treturn rs.getDate(index);\n\t\t\t}\n\t\t\telse if (\"LocalTime\".equals(typeName)) {\n\t\t\t\treturn rs.getTime(index);\n\t\t\t}\n\t\t\telse if (\"LocalDateTime\".equals(typeName)) {\n\t\t\t\treturn rs.getTimestamp(index);\n\t\t\t}\n\n\t\t\t// Fall back to getObject without type specification, again\n\t\t\t// left up to the caller to convert the value if necessary.\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\t// Perform was-null check if necessary (for results that the JDBC driver returns as primitives).\n\t\treturn (rs.wasNull() ? null : value);\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#lookupColumnName(resultSetMetaData,columnIndex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the column name to use. The column name is determined based on a\n\t * lookup using ResultSetMetaData.\n\t * <p>This method implementation takes into account recent clarifications\n\t * expressed in the JDBC 4.0 specification:\n\t * <p><i>columnLabel - the label for the column specified with the SQL AS clause.\n\t * If the SQL AS clause was not specified, then the label is the name of the column</i>.\n\t * @param resultSetMetaData the current meta-data to use\n\t * @param columnIndex the index of the column for the look up\n\t * @return the column name to use\n\t * @throws SQLException in case of lookup failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultSetMetaData",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "String",
    "signature": "public String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex)",
    "source_code": "\tpublic static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {\n\t\tString name = resultSetMetaData.getColumnLabel(columnIndex);\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\tname = resultSetMetaData.getColumnName(columnIndex);\n\t\t}\n\t\treturn name;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate the call straight to the target ConnectionFactory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\treturn doCreateConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createContext(userName,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createContext(userName,password,sessionMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password, int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password, int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password, sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createQueueConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate the call straight to the target QueueConnectionFactory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\treturn doCreateQueueConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createTopicConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate the call straight to the target TopicConnectionFactory.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection(String username, String password)",
    "source_code": "\tpublic TopicConnection createTopicConnection(String username, String password) throws JMSException {\n\t\treturn doCreateTopicConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createConnection(username, password)}\n\t * method of the target ConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.ConnectionFactory#createConnection(String, String)\n\t * @see jakarta.jms.ConnectionFactory#createConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Connection",
    "signature": "protected Connection doCreateConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected Connection doCreateConnection(@Nullable String username, @Nullable String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn target.createConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn target.createConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateQueueConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createQueueConnection(username, password)}\n\t * method of the target QueueConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createQueueConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.QueueConnectionFactory#createQueueConnection(String, String)\n\t * @see jakarta.jms.QueueConnectionFactory#createQueueConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "QueueConnection",
    "signature": "protected QueueConnection doCreateQueueConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected QueueConnection doCreateQueueConnection(\n\t\t\t@Nullable String username, @Nullable String password) throws JMSException {\n\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (!(target instanceof QueueConnectionFactory queueFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t}\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn queueFactory.createQueueConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn queueFactory.createQueueConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateTopicConnection(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createTopicConnection(username, password)}\n\t * method of the target TopicConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createTopicConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.TopicConnectionFactory#createTopicConnection(String, String)\n\t * @see jakarta.jms.TopicConnectionFactory#createTopicConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "TopicConnection",
    "signature": "protected TopicConnection doCreateTopicConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected TopicConnection doCreateTopicConnection(\n\t\t\t@Nullable String username, @Nullable String password) throws JMSException {\n\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (!(target instanceof TopicConnectionFactory queueFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t}\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn queueFactory.createTopicConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn queueFactory.createTopicConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getCachedSessionProxy(target,sessionList)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given Session with a proxy that delegates every method call to it\n\t * but adapts close calls. This is useful for allowing application code to\n\t * handle a special framework Session just like an ordinary Session.\n\t * @param target the original Session to wrap\n\t * @param sessionList the List of cached Sessions that the given Session belongs to\n\t * @return the wrapped Session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "sessionList"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "Session",
    "signature": "protected Session getCachedSessionProxy(Session target, Deque<Session> sessionList)",
    "source_code": "\tprotected Session getCachedSessionProxy(Session target, Deque<Session> sessionList) {\n\t\tList<Class<?>> classes = new ArrayList<>(3);\n\t\tclasses.add(SessionProxy.class);\n\t\tif (target instanceof QueueSession) {\n\t\t\tclasses.add(QueueSession.class);\n\t\t}\n\t\tif (target instanceof TopicSession) {\n\t\t\tclasses.add(TopicSession.class);\n\t\t}\n\t\treturn (Session) Proxy.newProxyInstance(SessionProxy.class.getClassLoader(),\n\t\t\t\tClassUtils.toClassArray(classes), new CachedSessionInvocationHandler(target, sessionList));\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getSession(con,mode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks for a cached Session for the given mode.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Session",
    "signature": "protected Session getSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session getSession(Connection con, Integer mode) throws JMSException {\n\t\tif (!this.active) {\n\t\t\treturn null;\n\t\t}\n\n\t\tDeque<Session> sessionList = this.cachedSessions.computeIfAbsent(mode, k -> new ArrayDeque<>());\n\t\tSession session = null;\n\t\tsynchronized (sessionList) {\n\t\t\tif (!sessionList.isEmpty()) {\n\t\t\t\tsession = sessionList.removeFirst();\n\t\t\t}\n\t\t}\n\t\tif (session != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Found cached JMS Session for mode \" + mode + \": \" +\n\t\t\t\t\t\t(session instanceof SessionProxy ? ((SessionProxy) session).getTargetSession() : session));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSession targetSession = createSession(con, mode);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Registering cached JMS Session for mode \" + mode + \": \" + targetSession);\n\t\t\t}\n\t\t\tsession = getCachedSessionProxy(targetSession, sessionList);\n\t\t}\n\t\treturn session;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tString methodName = method.getName();\n\t\t\tif (methodName.equals(\"equals\")) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (methodName.equals(\"hashCode\")) {\n\t\t\t\t// Use hashCode of Session proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (methodName.equals(\"toString\")) {\n\t\t\t\treturn \"Cached JMS Session: \" + this.target;\n\t\t\t}\n\t\t\telse if (methodName.equals(\"close\")) {\n\t\t\t\t// Handle close method: don't pass the call on.\n\t\t\t\tif (active) {\n\t\t\t\t\tsynchronized (this.sessionList) {\n\t\t\t\t\t\tif (this.sessionList.size() < getSessionCacheSize()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogicalClose((Session) proxy);\n\t\t\t\t\t\t\t\t// Remain open in the session list.\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JMSException ex) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Logical close of cached JMS Session failed - discarding it\", ex);\n\t\t\t\t\t\t\t\t// Proceed to physical close from here...\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we get here, we're supposed to shut down.\n\t\t\t\tphysicalClose();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (methodName.equals(\"getTargetSession\")) {\n\t\t\t\t// Handle getTargetSession method: return underlying Session.\n\t\t\t\treturn this.target;\n\t\t\t}\n\t\t\telse if (methodName.equals(\"commit\") || methodName.equals(\"rollback\")) {\n\t\t\t\tthis.transactionOpen = false;\n\t\t\t}\n\t\t\telse if (methodName.startsWith(\"create\")) {\n\t\t\t\tthis.transactionOpen = true;\n\t\t\t\tif (isCacheProducers() && (methodName.equals(\"createProducer\") ||\n\t\t\t\t\t\tmethodName.equals(\"createSender\") || methodName.equals(\"createPublisher\"))) {\n\t\t\t\t\t// Destination argument being null is ok for a producer\n\t\t\t\t\tDestination dest = (Destination) args[0];\n\t\t\t\t\tif (!(dest instanceof TemporaryQueue || dest instanceof TemporaryTopic)) {\n\t\t\t\t\t\treturn getCachedProducer(dest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isCacheConsumers()) {\n\t\t\t\t\t// let raw JMS invocation throw an exception if Destination (i.e. args[0]) is null\n\t\t\t\t\tif ((methodName.equals(\"createConsumer\") || methodName.equals(\"createReceiver\") ||\n\t\t\t\t\t\t\tmethodName.equals(\"createSubscriber\"))) {\n\t\t\t\t\t\tDestination dest = (Destination) args[0];\n\t\t\t\t\t\tif (dest != null && !(dest instanceof TemporaryQueue || dest instanceof TemporaryTopic)) {\n\t\t\t\t\t\t\treturn getCachedConsumer(dest,\n\t\t\t\t\t\t\t\t\t(args.length > 1 ? (String) args[1] : null),\n\t\t\t\t\t\t\t\t\t(args.length > 2 && (Boolean) args[2]),\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tfalse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (methodName.equals(\"createDurableConsumer\") || methodName.equals(\"createDurableSubscriber\")) {\n\t\t\t\t\t\tDestination dest = (Destination) args[0];\n\t\t\t\t\t\tif (dest != null) {\n\t\t\t\t\t\t\treturn getCachedConsumer(dest,\n\t\t\t\t\t\t\t\t\t(args.length > 2 ? (String) args[2] : null),\n\t\t\t\t\t\t\t\t\t(args.length > 3 && (Boolean) args[3]),\n\t\t\t\t\t\t\t\t\t(String) args[1],\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (methodName.equals(\"createSharedConsumer\")) {\n\t\t\t\t\t\tDestination dest = (Destination) args[0];\n\t\t\t\t\t\tif (dest != null) {\n\t\t\t\t\t\t\treturn getCachedConsumer(dest,\n\t\t\t\t\t\t\t\t\t(args.length > 2 ? (String) args[2] : null),\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t(String) args[1],\n\t\t\t\t\t\t\t\t\tfalse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (methodName.equals(\"createSharedDurableConsumer\")) {\n\t\t\t\t\t\tDestination dest = (Destination) args[0];\n\t\t\t\t\t\tif (dest != null) {\n\t\t\t\t\t\t\treturn getCachedConsumer(dest,\n\t\t\t\t\t\t\t\t\t(args.length > 2 ? (String) args[2] : null),\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t(String) args[1],\n\t\t\t\t\t\t\t\t\ttrue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.target, args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#setCredentialsForCurrentThread(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set user credententials for this proxy and the current thread.\n\t * The given username and password will be applied to all subsequent\n\t * {@code createConnection()} calls on this ConnectionFactory proxy.\n\t * <p>This will override any statically specified user credentials,\n\t * that is, values of the \"username\" and \"password\" bean properties.\n\t * @param username the username to apply\n\t * @param password the password to apply\n\t * @see #removeCredentialsFromCurrentThread\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void setCredentialsForCurrentThread(String username, String password)",
    "source_code": "\tpublic void setCredentialsForCurrentThread(String username, String password) {\n\t\tthis.threadBoundCredentials.set(new JmsUserCredentials(username, password));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#buildMessage(session,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a JMS message to be sent as response based on the given result object.\n\t * @param session the JMS Session to operate on\n\t * @param result the content of the message, as returned from the listener method\n\t * @return the JMS {@code Message} (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "Message",
    "signature": "protected Message buildMessage(Session session, Object result)",
    "source_code": "\tprotected Message buildMessage(Session session, Object result) throws JMSException {\n\t\tObject content = preProcessResponse(result instanceof JmsResponse\n\t\t\t\t? ((JmsResponse<?>) result).getResponse() : result);\n\n\t\tMessageConverter converter = getMessageConverter();\n\t\tif (converter != null) {\n\t\t\tif (content instanceof org.springframework.messaging.Message) {\n\t\t\t\treturn this.messagingMessageConverter.toMessage(content, session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn converter.toMessage(content, session);\n\t\t\t}\n\t\t}\n\n\t\tif (!(content instanceof Message)) {\n\t\t\tthrow new MessageConversionException(\n\t\t\t\t\t\"No MessageConverter specified - cannot handle message [\" + content + \"]\");\n\t\t}\n\t\treturn (Message) content;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#createMessageForPayload(payload,session,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "Message",
    "signature": "protected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)",
    "source_code": "\t\tprotected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)\n\t\t\t\tthrows JMSException {\n\n\t\t\tMessageConverter converter = getMessageConverter();\n\t\t\tif (converter == null) {\n\t\t\t\tthrow new IllegalStateException(\"No message converter, cannot handle '\" + payload + \"'\");\n\t\t\t}\n\t\t\tif (converter instanceof SmartMessageConverter) {\n\t\t\t\treturn ((SmartMessageConverter) converter).toMessage(payload, session, conversionHint);\n\n\t\t\t}\n\t\t\treturn converter.toMessage(payload, session);\n\t\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forDestination(result,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the specified {@link Destination}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forDestination(T result, Destination destination)",
    "source_code": "\tpublic static <T> JmsResponse<T> forDestination(T result, Destination destination) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\t\treturn new JmsResponse<>(result, destination);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forQueue(result,queueName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the queue with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "queueName"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forQueue(T result, String queueName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forQueue(T result, String queueName) {\n\t\tAssert.notNull(queueName, \"Queue name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(queueName, false));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forTopic(result,topicName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the topic with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "topicName"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forTopic(T result, String topicName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forTopic(T result, String topicName) {\n\t\tAssert.notNull(topicName, \"Topic name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(topicName, true));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getResponseDestination(request,response,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a response destination for the given message.\n\t * <p>The default implementation first checks the JMS Reply-To\n\t * {@link Destination} of the supplied request; if that is not {@code null}\n\t * it is returned; if it is {@code null}, then the configured\n\t * {@link #resolveDefaultResponseDestination default response destination}\n\t * is returned; if this too is {@code null}, then an\n\t * {@link jakarta.jms.InvalidDestinationException} is thrown.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @param session the JMS Session to operate on\n\t * @return the response destination (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @throws jakarta.jms.InvalidDestinationException if no {@link Destination} can be determined\n\t * @see #setDefaultResponseDestination\n\t * @see jakarta.jms.Message#getJMSReplyTo()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "Destination",
    "signature": "protected Destination getResponseDestination(Message request, Message response, Session session)",
    "source_code": "\tprotected Destination getResponseDestination(Message request, Message response, Session session)\n\t\t\tthrows JMSException {\n\n\t\tDestination replyTo = request.getJMSReplyTo();\n\t\tif (replyTo == null) {\n\t\t\treplyTo = resolveDefaultResponseDestination(session);\n\t\t\tif (replyTo == null) {\n\t\t\t\tthrow new InvalidDestinationException(\"Cannot determine response destination: \" +\n\t\t\t\t\t\t\"Request message does not contain reply-to destination, and no default response destination set.\");\n\t\t\t}\n\t\t}\n\t\treturn replyTo;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#handleResult(result,request,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given result object returned from the listener method,\n\t * sending a response message back.\n\t * @param result the result object to handle (never {@code null})\n\t * @param request the original request message\n\t * @param session the JMS Session to operate on (may be {@code null})\n\t * @throws ReplyFailureException if the response message could not be sent\n\t * @see #buildMessage\n\t * @see #postProcessResponse\n\t * @see #getResponseDestination\n\t * @see #sendResponse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result",
      "request",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "protected void handleResult(Object result, Message request, @Nullable Session session)",
    "source_code": "\tprotected void handleResult(Object result, Message request, @Nullable Session session) {\n\t\tif (session != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Listener method returned result [\" + result +\n\t\t\t\t\t\t\"] - generating response message for it\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tMessage response = buildMessage(session, result);\n\t\t\t\tpostProcessResponse(request, response);\n\t\t\t\tDestination destination = getResponseDestination(request, response, session, result);\n\t\t\t\tsendResponse(session, destination, response);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new ReplyFailureException(\"Failed to send reply with payload [\" + result + \"]\", ex);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// No JMS Session available\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Listener method returned result [\" + result +\n\t\t\t\t\t\t\"]: not generating response message for it because of no JMS Session given\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#onMessage(message,session)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void onMessage(Message message, @Nullable Session session)",
    "source_code": "\tpublic abstract void onMessage(Message message, @Nullable Session session) throws JMSException;"
  },
  "org.springframework.jms.listener.adapter.<unknown>#postProcessProducer(producer,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given message producer before using it to send the response.\n\t * <p>The default implementation is empty.\n\t * @param producer the JMS message producer that will be used to send the message\n\t * @param response the outgoing JMS message about to be sent\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "void",
    "signature": "protected void postProcessProducer(MessageProducer producer, Message response)",
    "source_code": "\tprotected void postProcessProducer(MessageProducer producer, Message response) throws JMSException {\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#postProcessResponse(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given response message before it will be sent.\n\t * <p>The default implementation sets the response's correlation id\n\t * to the request message's correlation id, if any; otherwise to the\n\t * request message id.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.Message#setJMSCorrelationID\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void postProcessResponse(Message request, Message response)",
    "source_code": "\tprotected void postProcessResponse(Message request, Message response) throws JMSException {\n\t\tString correlation = request.getJMSCorrelationID();\n\t\tif (correlation == null) {\n\t\t\tcorrelation = request.getJMSMessageID();\n\t\t}\n\t\tresponse.setJMSCorrelationID(correlation);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#resolveDestination(destinationResolver,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link Destination} to use for this instance. The {@link DestinationResolver}\n\t * and {@link Session} can be used to resolve a destination at runtime.\n\t * @param destinationResolver the destination resolver to use if necessary\n\t * @param session the session to use, if necessary\n\t * @return the {@link Destination} to use\n\t * @throws JMSException if the DestinationResolver failed to resolve the destination\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationResolver",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "Destination",
    "signature": "public Destination resolveDestination(DestinationResolver destinationResolver, Session session)",
    "source_code": "\tpublic Destination resolveDestination(DestinationResolver destinationResolver, Session session)\n\t\t\tthrows JMSException {\n\n\t\tif (this.destination instanceof Destination) {\n\t\t\treturn (Destination) this.destination;\n\t\t}\n\t\tif (this.destination instanceof DestinationNameHolder nameHolder) {\n\t\t\treturn destinationResolver.resolveDestinationName(session,\n\t\t\t\t\tnameHolder.destinationName, nameHolder.pubSubDomain);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#sendResponse(session,destination,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given response message to the given destination.\n\t * @param response the JMS message to send\n\t * @param destination the JMS destination to send to\n\t * @param session the JMS session to operate on\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #postProcessProducer\n\t * @see jakarta.jms.Session#createProducer\n\t * @see jakarta.jms.MessageProducer#send\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "void",
    "signature": "protected void sendResponse(Session session, Destination destination, Message response)",
    "source_code": "\tprotected void sendResponse(Session session, Destination destination, Message response) throws JMSException {\n\t\tMessageProducer producer = session.createProducer(destination);\n\t\ttry {\n\t\t\tpostProcessProducer(producer, response);\n\t\t\tQosSettings settings = getResponseQosSettings();\n\t\t\tif (settings != null) {\n\t\t\t\tproducer.send(response, settings.getDeliveryMode(), settings.getPriority(),\n\t\t\t\t\t\tsettings.getTimeToLive());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproducer.send(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromBytesMessage(message,targetJavaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a BytesMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "Object",
    "signature": "protected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tString encoding = this.encoding;\n\t\tif (this.encodingPropertyName != null && message.propertyExists(this.encodingPropertyName)) {\n\t\t\tencoding = message.getStringProperty(this.encodingPropertyName);\n\t\t}\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\tif (encoding != null) {\n\t\t\ttry {\n\t\t\t\tString body = new String(bytes, encoding);\n\t\t\t\treturn this.objectMapper.readValue(body, targetJavaType);\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert bytes to String\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Jackson internally performs encoding detection, falling back to UTF-8.\n\t\t\treturn this.objectMapper.readValue(bytes, targetJavaType);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromMessage(message,targetJavaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message mapping.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "Object",
    "signature": "protected Object convertFromMessage(Message message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromMessage(Message message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + message.getClass() +\n\t\t\t\t\"]. MappingJacksonMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromTextMessage(message,targetJavaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a TextMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Object",
    "signature": "protected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tString body = message.getText();\n\t\treturn this.objectMapper.readValue(body, targetJavaType);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToBytesMessage(object,session,objectWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Map the given object to a {@link BytesMessage}.\n\t * @param object the object to be mapped\n\t * @param session current JMS session\n\t * @param objectWriter the writer to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, IOException {\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n\t\tif (this.encoding != null) {\n\t\t\tOutputStreamWriter writer = new OutputStreamWriter(bos, this.encoding);\n\t\t\tobjectWriter.writeValue(writer, object);\n\t\t}\n\t\telse {\n\t\t\t// Jackson usually defaults to UTF-8 but can also go straight to bytes, e.g. for Smile.\n\t\t\t// We use a direct byte array argument for the latter case to work as well.\n\t\t\tobjectWriter.writeValue(bos, object);\n\t\t}\n\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bos.toByteArray());\n\t\tif (this.encodingPropertyName != null) {\n\t\t\tmessage.setStringProperty(this.encodingPropertyName,\n\t\t\t\t\t(this.encoding != null ? this.encoding : DEFAULT_ENCODING));\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToMessage(object,session,objectWriter,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message mapping.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS Session\n\t * @param objectWriter the writer to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "Message",
    "signature": "protected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)",
    "source_code": "\tprotected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + targetType +\n\t\t\t\t\"]. MappingJackson2MessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToTextMessage(object,session,objectWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Map the given object to a {@link TextMessage}.\n\t * @param object the object to be mapped\n\t * @param session current JMS session\n\t * @param objectWriter the writer to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "TextMessage",
    "signature": "protected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, IOException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tobjectWriter.writeValue(writer, object);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToBytesMessage(object,session,marshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link BytesMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createBytesMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage marshalToBytesMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected BytesMessage marshalToBytesMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n\t\tStreamResult streamResult = new StreamResult(bos);\n\t\tmarshaller.marshal(object, streamResult);\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bos.toByteArray());\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToMessage(object,session,marshaller,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message marshalling.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS session\n\t * @param marshaller the marshaller to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Message",
    "signature": "protected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)",
    "source_code": "\tprotected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + targetType +\n\t\t\t\t\"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToTextMessage(object,session,marshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link TextMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createTextMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "TextMessage",
    "signature": "protected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tResult result = new StreamResult(writer);\n\t\tmarshaller.marshal(object, result);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#setTypeIdMappings(Map<String,typeIdMappings)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify mappings from type ids to Java classes, if desired.\n\t * This allows for synthetic ids in the type id message property,\n\t * instead of transferring Java class names.\n\t * <p>Default is no custom mappings, i.e. transferring raw Java class names.\n\t * @param typeIdMappings a Map with type id values as keys and Java classes as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "typeIdMappings"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void setTypeIdMappings(Map<String, Class<?>> typeIdMappings)",
    "source_code": "\tpublic void setTypeIdMappings(Map<String, Class<?>> typeIdMappings) {\n\t\tthis.idClassMappings = new HashMap<>();\n\t\ttypeIdMappings.forEach((id, clazz) -> {\n\t\t\tthis.idClassMappings.put(id, clazz);\n\t\t\tthis.classIdMappings.put(clazz, id);\n\t\t});\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#setTypeIdOnMessage(object,message)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a type id for the given payload object on the given JMS Message.\n\t * <p>The default implementation consults the configured type id mapping and\n\t * sets the resulting value (either a mapped id or the raw Java class name)\n\t * into the configured type id message property.\n\t * @param object the payload object to set a type id for\n\t * @param message the JMS Message on which to set the type id property\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #getJavaTypeForMessage(jakarta.jms.Message)\n\t * @see #setTypeIdPropertyName(String)\n\t * @see #setTypeIdMappings(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "void",
    "signature": "protected void setTypeIdOnMessage(Object object, Message message)",
    "source_code": "\tprotected void setTypeIdOnMessage(Object object, Message message) throws JMSException {\n\t\tif (this.typeIdPropertyName != null) {\n\t\t\tString typeId = this.classIdMappings.get(object.getClass());\n\t\t\tif (typeId == null) {\n\t\t\t\ttypeId = object.getClass().getName();\n\t\t\t}\n\t\t\tmessage.setStringProperty(this.typeIdPropertyName, typeId);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation marshals the given object to a {@link jakarta.jms.TextMessage} or\n\t * {@link jakarta.jms.BytesMessage}. The desired message type can be defined by setting\n\t * the {@link #setTargetType \"marshalTo\"} property.\n\t * @see #marshalToTextMessage\n\t * @see #marshalToBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session)",
    "source_code": "\tpublic Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\ttry {\n\t\t\treturn switch (this.targetType) {\n\t\t\t\tcase TEXT -> marshalToTextMessage(object, session, this.marshaller);\n\t\t\t\tcase BYTES -> marshalToBytesMessage(object, session, this.marshaller);\n\t\t\t\tdefault -> marshalToMessage(object, session, this.marshaller, this.targetType);\n\t\t\t};\n\t\t}\n\t\tcatch (XmlMappingException | IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not marshal [\" + object + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Object conversionHint)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Object conversionHint)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\treturn toMessage(object, session, getSerializationView(conversionHint));\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,jsonView)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Java object to a JMS Message using the specified json view\n\t * and the supplied session  to create the message object.\n\t * @param object the object to convert\n\t * @param session the Session to use for creating a JMS Message\n\t * @param jsonView the view to use to filter the content\n\t * @return the JMS Message\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @throws MessageConversionException in case of conversion failure\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "jsonView"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tif (jsonView != null) {\n\t\t\treturn toMessage(object, session, this.objectMapper.writerWithView(jsonView));\n\t\t}\n\t\telse {\n\t\t\treturn toMessage(object, session, this.objectMapper.writer());\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,objectWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "Message",
    "signature": "protected Message toMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected Message toMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tMessage message;\n\t\ttry {\n\t\t\tmessage = switch (this.targetType) {\n\t\t\t\tcase TEXT -> mapToTextMessage(object, session, objectWriter);\n\t\t\t\tcase BYTES -> mapToBytesMessage(object, session, objectWriter);\n\t\t\t\tdefault -> mapToMessage(object, session, objectWriter, this.targetType);\n\t\t\t};\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not map JSON object [\" + object + \"]\", ex);\n\t\t}\n\t\tsetTypeIdOnMessage(object, message);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromBytesMessage(message,unmarshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshal the given {@link BytesMessage} into an object.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Unmarshaller#unmarshal(Source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\tStreamSource source = new StreamSource(bis);\n\t\treturn unmarshaller.unmarshal(source);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromMessage(message,unmarshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message unmarshalling.\n\t * Invoked when {@link #fromMessage(Message)} is invoked with a message\n\t * that is not a {@link TextMessage} or {@link BytesMessage}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromMessage(Message message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromMessage(Message message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + message.getClass() +\n\t\t\t\t\"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromTextMessage(message,unmarshaller)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshal the given {@link TextMessage} into an object.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Unmarshaller#unmarshal(Source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tSource source = new StreamSource(new StringReader(message.getText()));\n\t\treturn unmarshaller.unmarshal(source);\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#convertResultValueIfNecessary(result,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given result object (from attribute access or operation invocation)\n\t * to the specified target class for returning from the proxy method.\n\t * @param result the result object as returned by the {@code MBeanServer}\n\t * @param parameter the method parameter of the proxy method that's been invoked\n\t * @return the converted result object, or the passed-in object if no conversion\n\t * is necessary\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "Object",
    "signature": "protected Object convertResultValueIfNecessary(@Nullable Object result, MethodParameter parameter)",
    "source_code": "\tprotected Object convertResultValueIfNecessary(@Nullable Object result, MethodParameter parameter) {\n\t\tClass<?> targetClass = parameter.getParameterType();\n\t\ttry {\n\t\t\tif (result == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (result instanceof CompositeData) {\n\t\t\t\tMethod fromMethod = targetClass.getMethod(\"from\", CompositeData.class);\n\t\t\t\treturn ReflectionUtils.invokeMethod(fromMethod, null, result);\n\t\t\t}\n\t\t\telse if (result instanceof CompositeData[] array) {\n\t\t\t\tif (targetClass.isArray()) {\n\t\t\t\t\treturn convertDataArrayToTargetArray(array, targetClass);\n\t\t\t\t}\n\t\t\t\telse if (Collection.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\tClass<?> elementType =\n\t\t\t\t\t\t\tResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\t\t\tif (elementType != null) {\n\t\t\t\t\t\treturn convertDataArrayToTargetCollection(array, targetClass, elementType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result instanceof TabularData) {\n\t\t\t\tMethod fromMethod = targetClass.getMethod(\"from\", TabularData.class);\n\t\t\t\treturn ReflectionUtils.invokeMethod(fromMethod, null, result);\n\t\t\t}\n\t\t\telse if (result instanceof TabularData[] array) {\n\t\t\t\tif (targetClass.isArray()) {\n\t\t\t\t\treturn convertDataArrayToTargetArray(array, targetClass);\n\t\t\t\t}\n\t\t\t\telse if (Collection.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\tClass<?> elementType =\n\t\t\t\t\t\t\tResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\t\t\tif (elementType != null) {\n\t\t\t\t\t\treturn convertDataArrayToTargetCollection(array, targetClass, elementType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new InvocationFailureException(\n\t\t\t\t\t\"Incompatible result value [\" + result + \"] for target type [\" + targetClass.getName() + \"]\");\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new InvocationFailureException(\n\t\t\t\t\t\"Could not obtain 'from(CompositeData)' / 'from(TabularData)' method on target type [\" +\n\t\t\t\t\t\t\ttargetClass.getName() + \"] for conversion of MXBean data structure [\" + result + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#handleConnectFailure(invocation,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the connection and retry the MBean invocation if possible.\n\t * <p>If not configured to refresh on connect failure, this method\n\t * simply rethrows the original exception.\n\t * @param invocation the invocation that failed\n\t * @param ex the exception raised on remote invocation\n\t * @return the result value of the new invocation, if succeeded\n\t * @throws Throwable an exception raised by the new invocation,\n\t * if it failed as well\n\t * @see #setRefreshOnConnectFailure\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Object",
    "signature": "protected Object handleConnectFailure(MethodInvocation invocation, Exception ex)",
    "source_code": "\tprotected Object handleConnectFailure(MethodInvocation invocation, Exception ex) throws Throwable {\n\t\tif (this.refreshOnConnectFailure) {\n\t\t\tString msg = \"Could not connect to JMX server - retrying\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, ex);\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(msg);\n\t\t\t}\n\t\t\tprepare();\n\t\t\treturn doInvoke(invocation);\n\t\t}\n\t\telse {\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#setEnvironment(Map<String,environment)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the environment for the JMX connector.\n\t * @see javax.management.remote.JMXConnectorFactory#connect(javax.management.remote.JMXServiceURL, java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setEnvironment(@Nullable Map<String, ?> environment)",
    "source_code": "\tpublic void setEnvironment(@Nullable Map<String, ?> environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#getNotificationInfo(managedBean,beanKey)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedBean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "ModelMBeanNotificationInfo[]",
    "signature": "protected ModelMBeanNotificationInfo[] getNotificationInfo(Object managedBean, String beanKey)",
    "source_code": "\tprotected ModelMBeanNotificationInfo[] getNotificationInfo(Object managedBean, String beanKey) {\n\t\tModelMBeanNotificationInfo[] result = null;\n\t\tif (StringUtils.hasText(beanKey)) {\n\t\t\tresult = this.notificationInfoMappings.get(beanKey);\n\t\t}\n\t\tif (result == null) {\n\t\t\tresult = this.notificationInfos;\n\t\t}\n\t\treturn (result != null ? result : new ModelMBeanNotificationInfo[0]);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#setNotificationInfoMappings(Map<String,notificationInfoMappings)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "notificationInfoMappings"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setNotificationInfoMappings(Map<String, Object> notificationInfoMappings)",
    "source_code": "\tpublic void setNotificationInfoMappings(Map<String, Object> notificationInfoMappings) {\n\t\tnotificationInfoMappings.forEach((beanKey, result) ->\n\t\t\t\tthis.notificationInfoMappings.put(beanKey, extractNotificationMetadata(result)));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail (the content type will be determined by this)\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)\n\t * @see #addAttachment(String, java.io.File)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 1016
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, DataSource dataSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, DataSource dataSource) throws MessagingException {\n\t\tAssert.notNull(attachmentFilename, \"Attachment filename must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\ttry {\n\t\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\t\tmimeBodyPart.setDisposition(Part.ATTACHMENT);\n\t\t\tmimeBodyPart.setFileName(isEncodeFilenames() ?\n\t\t\t\t\tMimeUtility.encodeText(attachmentFilename) : attachmentFilename);\n\t\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\t\tgetRootMimeMultipart().addBodyPart(mimeBodyPart);\n\t\t}\n\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\tthrow new MessagingException(\"Failed to encode attachment filename\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,file)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 1045
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, File file)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddAttachment(attachmentFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>The content type will be determined by the given filename for\n\t * the attachment. Thus, any content source will be fine, including\n\t * temporary files with arbitrary filenames.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1070
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)\n\t\t\tthrows MessagingException {\n\n\t\tString contentType = getFileTypeMap().getContentType(attachmentFilename);\n\t\taddAttachment(attachmentFilename, inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1093
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addAttachment(\n\t\t\tString attachmentFilename, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, attachmentFilename);\n\t\taddAttachment(attachmentFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addBcc(bcc,personal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bcc",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "public void addBcc(String bcc, String personal)",
    "source_code": "\tpublic void addBcc(String bcc, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(bcc, \"Bcc address must not be null\");\n\t\taddBcc(getEncoding() != null ?\n\t\t\tnew InternetAddress(bcc, personal, getEncoding()) :\n\t\t\tnew InternetAddress(bcc, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addCc(cc,personal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cc",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "void",
    "signature": "public void addCc(String cc, String personal)",
    "source_code": "\tpublic void addCc(String cc, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(cc, \"Cc address must not be null\");\n\t\taddCc(getEncoding() != null ?\n\t\t\tnew InternetAddress(cc, personal, getEncoding()) :\n\t\t\tnew InternetAddress(cc, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,dataSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 907
    },
    "return": "void",
    "signature": "public void addInline(String contentId, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, DataSource dataSource) throws MessagingException {\n\t\tAssert.notNull(contentId, \"Content ID must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\tmimeBodyPart.setDisposition(Part.INLINE);\n\t\tmimeBodyPart.setContentID(\"<\" + contentId + \">\");\n\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\tgetMimeMultipart().addBodyPart(mimeBodyPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,file)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 934
    },
    "return": "void",
    "signature": "public void addInline(String contentId, File file)",
    "source_code": "\tpublic void addInline(String contentId, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddInline(contentId, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inputStreamSource,contentType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 989
    },
    "return": "void",
    "signature": "public void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, \"inline\");\n\t\taddInline(contentId, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code org.springframework.core.io.Resource}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p>Note that the InputStream returned by the Resource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: e.g. \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param resource the resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 961
    },
    "return": "void",
    "signature": "public void addInline(String contentId, Resource resource)",
    "source_code": "\tpublic void addInline(String contentId, Resource resource) throws MessagingException {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tString contentType = getFileTypeMap().getContentType(resource.getFilename());\n\t\taddInline(contentId, resource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addTo(to,personal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "to",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "void",
    "signature": "public void addTo(String to, String personal)",
    "source_code": "\tpublic void addTo(String to, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(to, \"To address must not be null\");\n\t\taddTo(getEncoding() != null ?\n\t\t\tnew InternetAddress(to, personal, getEncoding()) :\n\t\t\tnew InternetAddress(to, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createDataSource(inputStreamSource,contentType,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an Activation Framework DataSource for the given InputStreamSource.\n\t * @param inputStreamSource the InputStreamSource (typically a Spring Resource)\n\t * @param contentType the content type\n\t * @param name the name of the DataSource\n\t * @return the Activation Framework DataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStreamSource",
      "contentType",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "DataSource",
    "signature": "protected DataSource createDataSource(final InputStreamSource inputStreamSource, final String contentType, final String name)",
    "source_code": "\tprotected DataSource createDataSource(\n\t\tfinal InputStreamSource inputStreamSource, final String contentType, final String name) {\n\n\t\treturn new DataSource() {\n\t\t\t@Override\n\t\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\t\treturn inputStreamSource.getInputStream();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic OutputStream getOutputStream() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Read-only jakarta.activation.DataSource\");\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getContentType() {\n\t\t\t\treturn contentType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createMimeMultiparts(mimeMessage,multipartMode)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the MimeMultipart objects to use, which will be used\n\t * to store attachments on the one hand and text(s) and inline elements\n\t * on the other hand.\n\t * <p>Texts and inline elements can either be stored in the root element\n\t * itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED) or in a nested element\n\t * rather than the root element directly (MULTIPART_MODE_MIXED_RELATED).\n\t * <p>By default, the root MimeMultipart element will be of type \"mixed\"\n\t * (MULTIPART_MODE_MIXED) or \"related\" (MULTIPART_MODE_RELATED).\n\t * The main multipart element will either be added as nested element of\n\t * type \"related\" (MULTIPART_MODE_MIXED_RELATED) or be identical to the root\n\t * element itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED).\n\t * @param mimeMessage the MimeMessage object to add the root MimeMultipart\n\t * object to\n\t * @param multipartMode the multipart mode, as passed into the constructor\n\t * (MIXED, RELATED, MIXED_RELATED, or NO)\n\t * @throws MessagingException if multipart creation failed\n\t * @see #setMimeMultiparts\n\t * @see #MULTIPART_MODE_NO\n\t * @see #MULTIPART_MODE_MIXED\n\t * @see #MULTIPART_MODE_RELATED\n\t * @see #MULTIPART_MODE_MIXED_RELATED\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeMessage",
      "multipartMode"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "protected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode)",
    "source_code": "\tprotected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode) throws MessagingException {\n\t\tswitch (multipartMode) {\n\t\t\tcase MULTIPART_MODE_NO -> setMimeMultiparts(null, null);\n\t\t\tcase MULTIPART_MODE_MIXED -> {\n\t\t\t\tMimeMultipart mixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);\n\t\t\t\tmimeMessage.setContent(mixedMultipart);\n\t\t\t\tsetMimeMultiparts(mixedMultipart, mixedMultipart);\n\t\t\t}\n\t\t\tcase MULTIPART_MODE_RELATED -> {\n\t\t\t\tMimeMultipart relatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);\n\t\t\t\tmimeMessage.setContent(relatedMultipart);\n\t\t\t\tsetMimeMultiparts(relatedMultipart, relatedMultipart);\n\t\t\t}\n\t\t\tcase MULTIPART_MODE_MIXED_RELATED -> {\n\t\t\t\tMimeMultipart rootMixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);\n\t\t\t\tmimeMessage.setContent(rootMixedMultipart);\n\t\t\t\tMimeMultipart nestedRelatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);\n\t\t\t\tMimeBodyPart relatedBodyPart = new MimeBodyPart();\n\t\t\t\trelatedBodyPart.setContent(nestedRelatedMultipart);\n\t\t\t\trootMixedMultipart.addBodyPart(relatedBodyPart);\n\t\t\t\tsetMimeMultiparts(rootMixedMultipart, nestedRelatedMultipart);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Only multipart modes MIXED_RELATED, RELATED and NO supported\");\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setFrom(from,personal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "from",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "void",
    "signature": "public void setFrom(String from, String personal)",
    "source_code": "\tpublic void setFrom(String from, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(from, \"From address must not be null\");\n\t\tsetFrom(getEncoding() != null ?\n\t\t\tnew InternetAddress(from, personal, getEncoding()) : new InternetAddress(from, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setMimeMultiparts(root,main)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given MimeMultipart objects for use by this MimeMessageHelper.\n\t * @param root the root MimeMultipart object, which attachments will be added to;\n\t * or {@code null} to indicate no multipart at all\n\t * @param main the main MimeMultipart object, which text(s) and inline elements\n\t * will be added to (can be the same as the root multipart object, or an element\n\t * nested underneath the root multipart element)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "root",
      "main"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "protected void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main)",
    "source_code": "\tprotected final void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main) {\n\t\tthis.rootMimeMultipart = root;\n\t\tthis.mimeMultipart = main;\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setReplyTo(replyTo,personal)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyTo",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "public void setReplyTo(String replyTo, String personal)",
    "source_code": "\tpublic void setReplyTo(String replyTo, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(replyTo, \"Reply-to address must not be null\");\n\t\tInternetAddress replyToAddress = (getEncoding() != null) ?\n\t\t\t\tnew InternetAddress(replyTo, personal, getEncoding()) : new InternetAddress(replyTo, personal);\n\t\tsetReplyTo(replyToAddress);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setText(plainText,htmlText)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given plain text and HTML text as alternatives, offering\n\t * both options to the email client. Requires multipart mode.\n\t * <p><b>NOTE:</b> Invoke {@link #addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param plainText the plain text for the message\n\t * @param htmlText the HTML text for the message\n\t * @throws MessagingException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "plainText",
      "htmlText"
    ],
    "position": {
      "column": 1,
      "line": 836
    },
    "return": "void",
    "signature": "public void setText(String plainText, String htmlText)",
    "source_code": "\tpublic void setText(String plainText, String htmlText) throws MessagingException {\n\t\tAssert.notNull(plainText, \"Plain text must not be null\");\n\t\tAssert.notNull(htmlText, \"HTML text must not be null\");\n\n\t\tMimeMultipart messageBody = new MimeMultipart(MULTIPART_SUBTYPE_ALTERNATIVE);\n\t\tgetMainPart().setContent(messageBody, CONTENT_TYPE_ALTERNATIVE);\n\n\t\t// Create the plain text part of the message.\n\t\tMimeBodyPart plainTextPart = new MimeBodyPart();\n\t\tsetPlainTextToMimePart(plainTextPart, plainText);\n\t\tmessageBody.addBodyPart(plainTextPart);\n\n\t\t// Create the HTML text part of the message.\n\t\tMimeBodyPart htmlTextPart = new MimeBodyPart();\n\t\tsetHtmlTextToMimePart(htmlTextPart, htmlText);\n\t\tmessageBody.addBodyPart(htmlTextPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setText(text,html)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given text directly as content in non-multipart mode\n\t * or as default body part in multipart mode.\n\t * The \"html\" flag determines the content type to apply.\n\t * <p><b>NOTE:</b> Invoke {@link #addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param text the text for the message\n\t * @param html whether to apply content type \"text/html\" for an\n\t * HTML mail, using default content type (\"text/plain\") else\n\t * @throws MessagingException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "html"
    ],
    "position": {
      "column": 1,
      "line": 810
    },
    "return": "void",
    "signature": "public void setText(String text, boolean html)",
    "source_code": "\tpublic void setText(String text, boolean html) throws MessagingException {\n\t\tAssert.notNull(text, \"Text must not be null\");\n\t\tMimePart partToUse;\n\t\tif (isMultipart()) {\n\t\t\tpartToUse = getMainPart();\n\t\t}\n\t\telse {\n\t\t\tpartToUse = this.mimeMessage;\n\t\t}\n\t\tif (html) {\n\t\t\tsetHtmlTextToMimePart(partToUse, text);\n\t\t}\n\t\telse {\n\t\t\tsetPlainTextToMimePart(partToUse, text);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertFrom(message,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "boolean",
    "signature": "protected boolean canConvertFrom(Message<?> message, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected boolean canConvertFrom(Message<?> message, @Nullable Class<?> targetClass) {\n\t\tif (targetClass == null || !supportsMimeType(message.getHeaders())) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = this.objectMapper.constructType(targetClass);\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (this.objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertTo(payload,headers)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "boolean",
    "signature": "protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers)",
    "source_code": "\tprotected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {\n\t\tif (!supportsMimeType(headers)) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (this.objectMapper.canSerialize(payload.getClass(), causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(payload.getClass(), causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#convertFromInternal(message,targetClass,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Object",
    "signature": "protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tJavaType javaType = this.objectMapper.constructType(getResolvedType(targetClass, conversionHint));\n\t\tObject payload = message.getPayload();\n\t\tClass<?> view = getSerializationView(conversionHint);\n\t\ttry {\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, payload)) {\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\telse if (payload instanceof byte[]) {\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn this.objectMapper.readerWithView(view).forType(javaType).readValue((byte[]) payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.objectMapper.readValue((byte[]) payload, javaType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based source payload\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn this.objectMapper.readerWithView(view).forType(javaType).readValue(payload.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.objectMapper.readValue(payload.toString(), javaType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(message, \"Could not read JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#convertToInternal(payload,headers,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "Object",
    "signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,\n\t\t\t@Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertToInternal(Object payload, @Nullable MessageHeaders headers,\n\t\t\t@Nullable Object conversionHint) {\n\n\t\ttry {\n\t\t\tClass<?> view = getSerializationView(conversionHint);\n\t\t\tif (byte[].class == getSerializedPayloadClass()) {\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n\t\t\t\tJsonEncoding encoding = getJsonEncoding(getMimeType(headers));\n\t\t\t\ttry (JsonGenerator generator = this.objectMapper.getFactory().createGenerator(out, encoding)) {\n\t\t\t\t\tif (view != null) {\n\t\t\t\t\t\tthis.objectMapper.writerWithView(view).writeValue(generator, payload);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.objectMapper.writeValue(generator, payload);\n\t\t\t\t\t}\n\t\t\t\t\tpayload = out.toByteArray();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Assuming a text-based target payload\n\t\t\t\tWriter writer = new StringWriter(1024);\n\t\t\t\tif (view != null) {\n\t\t\t\t\tthis.objectMapper.writerWithView(view).writeValue(writer, payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.objectMapper.writeValue(writer, payload);\n\t\t\t\t}\n\t\t\t\tpayload = writer.toString();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not write JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t\treturn payload;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromMessage(message,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass)",
    "source_code": "\tpublic final Object fromMessage(Message<?> message, Class<?> targetClass) {\n\t\treturn fromMessage(message, targetClass, null);\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromMessage(message,targetClass,conversionHint)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tpublic final Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tif (!canConvertFrom(message, targetClass)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn convertFromInternal(message, targetClass, conversionHint);\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#logWarningIfNecessary(type,cause)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not log warning for serializer not found (note: different message wording on Jackson 2.9)\n\t\tboolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage().startsWith(\"Cannot find\"));\n\n\t\tif (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tif (debugLevel) {\n\t\t\t\tlogger.debug(msg, cause);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#assertTargetBean(method,targetBean,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual endpoint instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). Endpoint classes that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetBean",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "protected void assertTargetBean(Method method, Object targetBean, Object[] args)",
    "source_code": "\tprotected void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString text = \"The mapped handler method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual endpoint bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the endpoint requires proxying \" +\n\t\t\t\t\t\"(e.g. due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args));\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#compareTo(other,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "int",
    "signature": "public int compareTo(CompositeMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(CompositeMessageCondition other, Message<?> message) {\n\t\tcheckCompatible(other);\n\t\tList<MessageCondition<?>> otherConditions = other.getMessageConditions();\n\t\tfor (int i = 0; i < this.messageConditions.size(); i++) {\n\t\t\tint result = compare (this.messageConditions.get(i), otherConditions.get(i), message);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatArgumentError(param,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatInvokeError(text,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Endpoint [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#resolveArgument(parameter,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tObject payload = message.getPayload();\n\t\tif (isEmptyPayload(payload)) {\n\t\t\tif (ann == null || ann.required()) {\n\t\t\t\tString paramName = getParameterName(parameter);\n\t\t\t\tBindingResult bindingResult = new BeanPropertyBindingResult(payload, paramName);\n\t\t\t\tbindingResult.addError(new ObjectError(paramName, \"Payload value must not be empty\"));\n\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tClass<?> targetClass = resolveTargetClass(parameter, message);\n\t\tClass<?> payloadClass = payload.getClass();\n\t\tif (ClassUtils.isAssignable(targetClass, payloadClass)) {\n\t\t\tvalidate(message, parameter, payload);\n\t\t\treturn payload;\n\t\t}\n\t\telse {\n\t\t\tif (this.converter instanceof SmartMessageConverter smartConverter) {\n\t\t\t\tpayload = smartConverter.fromMessage(message, targetClass, parameter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpayload = this.converter.fromMessage(message, targetClass);\n\t\t\t}\n\t\t\tif (payload == null) {\n\t\t\t\tthrow new MessageConversionException(message, \"Cannot convert from [\" +\n\t\t\t\t\t\tpayloadClass.getName() + \"] to [\" + targetClass.getName() + \"] for \" + message);\n\t\t\t}\n\t\t\tvalidate(message, parameter, payload);\n\t\t\treturn payload;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#validate(message,parameter,target)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the payload if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param message the currently processed message\n\t * @param parameter the method parameter\n\t * @param target the target payload object\n\t * @throws MethodArgumentNotValidException in case of binding errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "parameter",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "protected void validate(Message<?> message, MethodParameter parameter, Object target)",
    "source_code": "\tprotected void validate(Message<?> message, MethodParameter parameter, Object target) {\n\t\tif (this.validator == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tValidated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n\t\t\tif (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) {\n\t\t\t\tObject hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n\t\t\t\tObject[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n\t\t\t\tBeanPropertyBindingResult bindingResult =\n\t\t\t\t\t\tnew BeanPropertyBindingResult(target, getParameterName(parameter));\n\t\t\t\tif (!ObjectUtils.isEmpty(validationHints) && this.validator instanceof SmartValidator) {\n\t\t\t\t\t((SmartValidator) this.validator).validate(target, bindingResult, validationHints);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.validator.validate(target, bindingResult);\n\t\t\t\t}\n\t\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#invoke(message,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method for the given exchange.\n\t * @param message the current message\n\t * @param providedArgs optional list of argument values to match by type\n\t * @return a Mono with the result from the invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> invoke(Message<?> message, Object... providedArgs)",
    "source_code": "\tpublic Mono<Object> invoke(Message<?> message, Object... providedArgs) {\n\t\treturn getMethodArgumentValues(message, providedArgs).flatMap(args -> {\n\t\t\tObject value;\n\t\t\tboolean isSuspendingFunction = false;\n\t\t\ttry {\n\t\t\t\tMethod method = getBridgedMethod();\n\t\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\t\tisSuspendingFunction = true;\n\t\t\t\t\tvalue = CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = method.invoke(getBean(), args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(text, args), ex));\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\treturn Mono.error(ex.getTargetException());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Unlikely to ever get here, but it must be handled...\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(\"Invocation failure\", args), ex));\n\t\t\t}\n\n\t\t\tMethodParameter returnType = getReturnType();\n\t\t\tClass<?> reactiveType = (isSuspendingFunction ? value.getClass() : returnType.getParameterType());\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType);\n\t\t\treturn (isAsyncVoidReturnType(returnType, adapter) ?\n\t\t\t\t\tMono.from(adapter.toPublisher(value)) : Mono.justOrEmpty(value));\n\t\t});\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#compareTo(other,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "int",
    "signature": "public int compareTo(RSocketFrameTypeMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(RSocketFrameTypeMessageCondition other, Message<?> message) {\n\t\treturn other.frameTypes.size() - this.frameTypes.size();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#getCondition(cardinalityIn,cardinalityOut)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a condition for matching the RSocket request interaction type with\n\t * that is selected based on the delcared request and response cardinality\n\t * of some handler method.\n\t * <p>The table below shows the selections made:\n\t * <table>\n\t * <tr>\n\t * <th>Request Cardinality</th>\n\t * <th>Response Cardinality</th>\n\t * <th>Interaction Types</th>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>0</td>\n\t * <td>Fire-And-Forget, Request-Response</td>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>1</td>\n\t * <td>Request-Response</td>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>2</td>\n\t * <td>Request-Stream</td>\n\t * </tr>\n\t * <tr>\n\t * <td>2</td>\n\t * <td>Any</td>\n\t * <td>Request-Channel</td>\n\t * </tr>\n\t * </table>\n\t * @param cardinalityIn -- the request cardinality: 1 for a single payload,\n\t * 2 for many payloads, and 0 if input is not handled.\n\t * @param cardinalityOut -- the response cardinality: 0 for no output\n\t * payloads, 1 for a single payload, and 2 for many payloads.\n\t * @return a condition to use for matching the interaction type\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cardinalityIn",
      "cardinalityOut"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "RSocketFrameTypeMessageCondition",
    "signature": "public RSocketFrameTypeMessageCondition getCondition(int cardinalityIn, int cardinalityOut)",
    "source_code": "\tpublic static RSocketFrameTypeMessageCondition getCondition(int cardinalityIn, int cardinalityOut) {\n\t\treturn switch (cardinalityIn) {\n\t\t\tcase 0, 1 -> switch (cardinalityOut) {\n\t\t\t\tcase 0 -> REQUEST_FNF_OR_RESPONSE_CONDITION;\n\t\t\t\tcase 1 -> REQUEST_RESPONSE_CONDITION;\n\t\t\t\tcase 2 -> REQUEST_STREAM_CONDITION;\n\t\t\t\tdefault -> throw new IllegalStateException(\"Invalid response cardinality: \" + cardinalityOut);\n\t\t\t};\n\t\t\tcase 2 -> REQUEST_CHANNEL_CONDITION;\n\t\t\tdefault -> throw new IllegalStateException(\"Invalid request cardinality: \" + cardinalityIn);\n\t\t};\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscription(sessionId,subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void addSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void addSubscription(String sessionId, Subscription subscription) {\n\t\t\tSessionInfo info = this.sessions.computeIfAbsent(sessionId, _sessionId -> new SessionInfo());\n\t\t\tinfo.addSubscription(subscription);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscriptionInternal(sessionId,subscriptionId,destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId",
      "subscriptionId",
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "protected void addSubscriptionInternal(String sessionId, String subscriptionId, String destination, Message<?> message)",
    "source_code": "\tprotected void addSubscriptionInternal(\n\t\t\tString sessionId, String subscriptionId, String destination, Message<?> message) {\n\n\t\tboolean isPattern = this.pathMatcher.isPattern(destination);\n\t\tExpression expression = getSelectorExpression(message.getHeaders());\n\t\tSubscription subscription = new Subscription(subscriptionId, destination, isPattern, expression);\n\n\t\tthis.sessionRegistry.addSubscription(sessionId, subscription);\n\t\tthis.destinationCache.updateAfterNewSubscription(sessionId, subscription);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#afterMessageHandled(message,ch,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "ch",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void afterMessageHandled(Message<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterMessageHandled(\n\t\t\t\tMessage<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex) {\n\n\t\t\tRunnable task = getNextMessageTask(message);\n\t\t\tif (task != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#canRead(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 502
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#canWrite(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#configureInterceptor(channel,preserveOrder)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Install or remove an {@link ExecutorChannelInterceptor} that invokes a\n\t * completion task, if found in the headers of the message.\n\t * @param channel the channel to configure\n\t * @param preserveOrder whether preserve the order or publication; when\n\t * \"true\" an interceptor is inserted, when \"false\" it removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "preserveOrder"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void configureInterceptor(MessageChannel channel, boolean preserveOrder)",
    "source_code": "\tpublic static void configureInterceptor(MessageChannel channel, boolean preserveOrder) {\n\t\tif (preserveOrder) {\n\t\t\tAssert.isInstanceOf(ExecutorSubscribableChannel.class, channel,\n\t\t\t\t\t\"An ExecutorSubscribableChannel is required for `preservePublishOrder`\");\n\t\t\tExecutorSubscribableChannel execChannel = (ExecutorSubscribableChannel) channel;\n\t\t\tif (execChannel.getInterceptors().stream().noneMatch(i -> i instanceof CallbackInterceptor)) {\n\t\t\t\texecChannel.addInterceptor(0, new CallbackInterceptor());\n\t\t\t}\n\t\t}\n\t\telse if (channel instanceof ExecutorSubscribableChannel execChannel) {\n\t\t\texecChannel.getInterceptors().stream().filter(i -> i instanceof CallbackInterceptor)\n\t\t\t\t\t.findFirst().map(execChannel::removeInterceptor);\n\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#find(serverState,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serverState",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "String>",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#findSubscriptionsInternal(destination,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "String>",
    "signature": "protected String> findSubscriptionsInternal(String destination, Message<?> message)",
    "source_code": "\tprotected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n\t\tMultiValueMap<String, String> allMatches = this.destinationCache.getSubscriptions(destination);\n\t\tif (!this.selectorHeaderInUse) {\n\t\t\treturn allMatches;\n\t\t}\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n\t\tallMatches.forEach((sessionId, subscriptionIds) -> {\n\t\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\t\tif (info != null) {\n\t\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\t\tSubscription subscription = info.getSubscription(subscriptionId);\n\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelector(), message)) {\n\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#forEachSubscription(BiConsumer<String,consumer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "public void forEachSubscription(BiConsumer<String, Subscription> consumer)",
    "source_code": "\t\tpublic void forEachSubscription(BiConsumer<String, Subscription> consumer) {\n\t\t\tthis.sessions.forEach((sessionId, info) ->\n\t\t\t\tinfo.getSubscriptions().forEach(subscription -> consumer.accept(sessionId, subscription)));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#read(context,target,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tObject value;\n\t\t\tif (target instanceof Message) {\n\t\t\t\tvalue = name.equals(\"headers\") ? ((Message) target).getHeaders() : null;\n\t\t\t}\n\t\t\telse if (target instanceof MessageHeaders headers) {\n\t\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\t\tMessageHeaderAccessor.getAccessor(headers, SimpMessageHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No SimpMessageHeaderAccessor\");\n\t\t\t\tif (\"destination\".equalsIgnoreCase(name)) {\n\t\t\t\t\tvalue = accessor.getDestination();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = accessor.getFirstNativeHeader(name);\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tvalue = headers.get(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Should never happen...\n\t\t\t\tthrow new IllegalStateException(\"Expected Message or MessageHeaders.\");\n\t\t\t}\n\t\t\treturn new TypedValue(value);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#registerSubscriptions(sessionId,destination)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#registerUnregister(serverState,request,blackhole)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serverState",
      "request",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#removeSubscriptionInternal(sessionId,subscriptionId,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId",
      "subscriptionId",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "protected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message)",
    "source_code": "\tprotected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message) {\n\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\tif (info != null) {\n\t\t\tSubscription subscription = info.removeSubscription(subscriptionId);\n\t\t\tif (subscription != null) {\n\t\t\t\tthis.destinationCache.updateAfterRemovedSubscription(sessionId, subscription);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#send(message,timeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean send(Message<?> message, long timeout) {\n\t\tthis.messages.add(message);\n\t\ttrySend();\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterNewSubscription(sessionId,subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "public void updateAfterNewSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterNewSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tfor (String cachedDestination : this.destinationCache.keySet()) {\n\t\t\t\t\tif (pathMatcher.match(subscription.getDestination(), cachedDestination)) {\n\t\t\t\t\t\taddToDestination(cachedDestination, sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddToDestination(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSession(sessionId,info)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "info"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSession(String sessionId, SessionInfo info)",
    "source_code": "\t\tpublic void updateAfterRemovedSession(String sessionId, SessionInfo info) {\n\t\t\tfor (Subscription subscription : info.getSubscriptions()) {\n\t\t\t\tupdateAfterRemovedSubscription(sessionId, subscription);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSubscription(sessionId,subscription)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterRemovedSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tString subscriptionId = subscription.getId();\n\t\t\t\tthis.destinationCache.forEach((destination, sessionIdToSubscriptionIds) -> {\n\t\t\t\t\tList<String> subscriptionIds = sessionIdToSubscriptionIds.get(sessionId);\n\t\t\t\t\tif (subscriptionIds != null && subscriptionIds.contains(subscriptionId)) {\n\t\t\t\t\t\tremoveInternal(destination, sessionId, subscriptionId);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveInternal(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#write(context,target,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value) {\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#encode(Map<String,headers,payload)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Encodes the given payload and headers into a {@code byte[]}.\n\t * @param headers the headers\n\t * @param payload the payload\n\t * @return the encoded message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "byte[]",
    "signature": "public byte[] encode(Map<String, Object> headers, byte[] payload)",
    "source_code": "\tpublic byte[] encode(Map<String, Object> headers, byte[] payload) {\n\t\tAssert.notNull(headers, \"'headers' is required\");\n\t\tAssert.notNull(payload, \"'payload' is required\");\n\n\t\tif (SimpMessageType.HEARTBEAT.equals(SimpMessageHeaderAccessor.getMessageType(headers))) {\n\t\t\tlogger.trace(\"Encoding heartbeat\");\n\t\t\treturn StompDecoder.HEARTBEAT_PAYLOAD;\n\t\t}\n\n\t\tStompCommand command = StompHeaderAccessor.getCommand(headers);\n\t\tif (command == null) {\n\t\t\tthrow new IllegalStateException(\"Missing STOMP command: \" + headers);\n\t\t}\n\n\t\tResult result = new DefaultResult();\n\t\tresult.add(command.toString().getBytes(StandardCharsets.UTF_8));\n\t\tresult.add(LINE_FEED_BYTE);\n\t\twriteHeaders(command, headers, payload, result);\n\t\tresult.add(LINE_FEED_BYTE);\n\t\tresult.add(payload);\n\t\tresult.add((byte) 0);\n\t\treturn result.toByteArray();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#removeEldestEntry(Map.Entry<String,eldest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<String",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest)",
    "source_code": "\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {\n\t\t\t\t\tif (size() > HEADER_KEY_CACHE_LIMIT) {\n\t\t\t\t\t\theaderKeyAccessCache.remove(eldest.getKey());\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#init(expirationPeriod,sessionLookup)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expirationPeriod",
      "sessionLookup"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "public void init(long expirationPeriod, SessionLookup sessionLookup)",
    "source_code": "\t\tpublic void init(long expirationPeriod, SessionLookup sessionLookup) {\n\t\t\tthis.expirationTime = System.currentTimeMillis() + expirationPeriod;\n\t\t\tfor (TransferSimpUser user : this.users.values()) {\n\t\t\t\tuser.afterDeserialization(sessionLookup);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#setUserMap(Map<String,users)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "users"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void setUserMap(Map<String, TransferSimpUser> users)",
    "source_code": "\t\tpublic void setUserMap(Map<String, TransferSimpUser> users) {\n\t\t\tthis.users = users;\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map.\n\t * <p>This operation will overwrite any existing values. Use\n\t * {@link #copyHeadersIfAbsent(Map)} to avoid overwriting values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "void",
    "signature": "public void copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic void copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tif (headersToCopy == null || this.headers == headersToCopy) {\n\t\t\treturn;\n\t\t}\n\t\theadersToCopy.forEach((key, value) -> {\n\t\t\tif (!isReadOnly(key)) {\n\t\t\t\tsetHeader(key, value);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map.\n\t * <p>This operation will <em>not</em> overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "public void copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic void copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tif (headersToCopy == null || this.headers == headersToCopy) {\n\t\t\treturn;\n\t\t}\n\t\theadersToCopy.forEach((key, value) -> {\n\t\t\tif (!isReadOnly(key)) {\n\t\t\t\tsetHeaderIfAbsent(key, value);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getAccessor(message,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the original {@code MessageHeaderAccessor} used to create the headers\n\t * of the given {@code Message}, or {@code null} if that's not available or if\n\t * its type does not match the required type.\n\t * <p>This is for cases where the existence of an accessor is strongly expected\n\t * (followed up with an assertion) or where an accessor will be created otherwise.\n\t * @param message the message to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "T",
    "signature": "public T getAccessor(Message<?> message, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(Message<?> message, @Nullable Class<T> requiredType) {\n\t\treturn getAccessor(message.getHeaders(), requiredType);\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getAccessor(messageHeaders,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A variation of {@link #getAccessor(org.springframework.messaging.Message, Class)}\n\t * with a {@code MessageHeaders} instance instead of a {@code Message}.\n\t * <p>This is for cases when a full message may not have been created yet.\n\t * @param messageHeaders the message headers to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHeaders",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "T",
    "signature": "public T getAccessor(MessageHeaders messageHeaders, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(\n\t\t\tMessageHeaders messageHeaders, @Nullable Class<T> requiredType) {\n\n\t\tif (messageHeaders instanceof MutableMessageHeaders mutableHeaders) {\n\t\t\tMessageHeaderAccessor headerAccessor = mutableHeaders.getAccessor();\n\t\t\tif (requiredType == null || requiredType.isInstance(headerAccessor))  {\n\t\t\t\treturn (T) headerAccessor;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name.\n\t * <p>If the provided value is {@code null}, the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void setHeader(String name, @Nullable Object value)",
    "source_code": "\tpublic void setHeader(String name, @Nullable Object value) {\n\t\tif (isReadOnly(name)) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + name + \"' header is read-only\");\n\t\t}\n\t\tverifyType(name, value);\n\t\tif (value != null) {\n\t\t\t// Modify header if necessary\n\t\t\tif (!ObjectUtils.nullSafeEquals(value, getHeader(name))) {\n\t\t\t\tthis.modified = true;\n\t\t\t\tthis.headers.getRawHeaders().put(name, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Remove header if available\n\t\t\tif (this.headers.containsKey(name)) {\n\t\t\t\tthis.modified = true;\n\t\t\t\tthis.headers.getRawHeaders().remove(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not\n\t * already associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "void",
    "signature": "public void setHeaderIfAbsent(String name, Object value)",
    "source_code": "\tpublic void setHeaderIfAbsent(String name, Object value) {\n\t\tif (getHeader(name) == null) {\n\t\t\tsetHeader(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#verifyType(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "void",
    "signature": "protected void verifyType(@Nullable String headerName, @Nullable Object headerValue)",
    "source_code": "\tprotected void verifyType(@Nullable String headerName, @Nullable Object headerValue) {\n\t\tif (headerName != null && headerValue != null) {\n\t\t\tif (MessageHeaders.ERROR_CHANNEL.equals(headerName) ||\n\t\t\t\t\tMessageHeaders.REPLY_CHANNEL.endsWith(headerName)) {\n\t\t\t\tif (!(headerValue instanceof MessageChannel || headerValue instanceof String)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"'\" + headerName + \"' header value must be a MessageChannel or String\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.mock.http.client.reactive.<unknown>#setBody(body,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setBody(String body, Charset charset)",
    "source_code": "\tpublic void setBody(String body, Charset charset) {\n\t\tDataBuffer buffer = toDataBuffer(body, charset);\n\t\tthis.body = Flux.just(buffer);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addDateHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "void",
    "signature": "public void addDateHeader(String name, long value)",
    "source_code": "\tpublic void addDateHeader(String name, long value) {\n\t\taddHeaderValue(name, formatDate(value));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an HTTP header entry for the given name.\n\t * <p>While this method can take any {@code Object} as a parameter,\n\t * it is recommended to use the following types:\n\t * <ul>\n\t * <li>String or any Object to be converted using {@code toString()}; see {@link #getHeader}.</li>\n\t * <li>String, Number, or Date for date headers; see {@link #getDateHeader}.</li>\n\t * <li>String or Number for integer headers; see {@link #getIntHeader}.</li>\n\t * <li>{@code String[]} or {@code Collection<String>} for multiple values; see {@link #getHeaders}.</li>\n\t * </ul>\n\t * @see #getHeaderNames\n\t * @see #getHeaders\n\t * @see #getHeader\n\t * @see #getDateHeader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1020
    },
    "return": "void",
    "signature": "public void addHeader(String name, Object value)",
    "source_code": "\tpublic void addHeader(String name, Object value) {\n\t\tif (HttpHeaders.CONTENT_TYPE.equalsIgnoreCase(name) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_TYPE)) {\n\t\t\tsetContentType(value.toString());\n\t\t}\n\t\telse if (HttpHeaders.ACCEPT_LANGUAGE.equalsIgnoreCase(name) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.ACCEPT_LANGUAGE)) {\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.add(HttpHeaders.ACCEPT_LANGUAGE, value.toString());\n\t\t\t\tList<Locale> locales = headers.getAcceptLanguageAsLocales();\n\t\t\t\tthis.locales.clear();\n\t\t\t\tthis.locales.addAll(locales);\n\t\t\t\tif (this.locales.isEmpty()) {\n\t\t\t\t\tthis.locales.add(Locale.ENGLISH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid Accept-Language format -> just store plain header\n\t\t\t}\n\t\t\tdoAddHeaderValue(name, value, true);\n\t\t}\n\t\telse {\n\t\t\tdoAddHeaderValue(name, value, false);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addIntHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\tpublic void addIntHeader(String name, int value) {\n\t\taddHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a single value for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given value will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 564
    },
    "return": "void",
    "signature": "public void addParameter(String name, @Nullable String value)",
    "source_code": "\tpublic void addParameter(String name, @Nullable String value) {\n\t\taddParameter(name, new String[] {value});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given values will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "void",
    "signature": "public void addParameter(String name, String... values)",
    "source_code": "\tpublic void addParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tString[] oldArr = this.parameters.get(name);\n\t\tif (oldArr != null) {\n\t\t\tString[] newArr = new String[oldArr.length + values.length];\n\t\t\tSystem.arraycopy(oldArr, 0, newArr, 0, oldArr.length);\n\t\t\tSystem.arraycopy(values, 0, newArr, oldArr.length, values.length);\n\t\t\tthis.parameters.put(name, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.parameters.put(name, values);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameters(Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add all provided parameters <strong>without</strong> replacing any\n\t * existing values. To replace existing values, use\n\t * {@link #setParameters(java.util.Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 592
    },
    "return": "void",
    "signature": "public void addParameters(Map<String, ?> params)",
    "source_code": "\tpublic void addParameters(Map<String, ?> params) {\n\t\tAssert.notNull(params, \"Parameter map must not be null\");\n\t\tparams.forEach((key, value) -> {\n\t\t\tif (value instanceof String) {\n\t\t\t\taddParameter(key, (String) value);\n\t\t\t}\n\t\t\telse if (value instanceof String[]) {\n\t\t\t\taddParameter(key, (String[]) value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Parameter map value must be single value \" +\n\t\t\t\t\t\t\" or array of type [\" + String.class.getName() + \"]\");\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#getAttribute(name,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\tpublic Object getAttribute(String name, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\treturn switch (scope) {\n\t\t\tcase PAGE_SCOPE -> getAttribute(name);\n\t\t\tcase REQUEST_SCOPE -> this.request.getAttribute(name);\n\t\t\tcase SESSION_SCOPE -> {\n\t\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\t\tyield (session != null ? session.getAttribute(name) : null);\n\t\t\t}\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.getAttribute(name);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t};\n\t}"
  },
  "org.springframework.mock.web.<unknown>#include(path,flush)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "flush"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void include(String path, boolean flush)",
    "source_code": "\tpublic void include(String path, boolean flush) throws ServletException, IOException {\n\t\tthis.request.getRequestDispatcher(path).include(this.request, this.response);\n\t\tif (flush) {\n\t\t\tthis.response.flushBuffer();\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#initialize(servlet,request,response,errorPageURL,needsSession,bufferSize,autoFlush)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servlet",
      "request",
      "response",
      "errorPageURL",
      "needsSession",
      "bufferSize",
      "autoFlush"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void initialize(Servlet servlet, ServletRequest request, ServletResponse response,\n\t\t\tString errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush)",
    "source_code": "\tpublic void initialize(\n\t\t\tServlet servlet, ServletRequest request, ServletResponse response,\n\t\t\tString errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush) {\n\n\t\tthrow new UnsupportedOperationException(\"Use appropriate constructor\");\n\t}"
  },
  "org.springframework.mock.web.<unknown>#login(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 1362
    },
    "return": "void",
    "signature": "public void login(String username, String password)",
    "source_code": "\tpublic void login(String username, String password) throws ServletException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.mock.web.<unknown>#removeAttribute(name,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\tpublic void removeAttribute(String name, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tswitch (scope) {\n\t\t\tcase PAGE_SCOPE -> this.attributes.remove(name);\n\t\t\tcase REQUEST_SCOPE -> this.request.removeAttribute(name);\n\t\t\tcase SESSION_SCOPE -> this.request.getSession().removeAttribute(name);\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.removeAttribute(name);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendError(status,errorMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "errorMessage"
    ],
    "position": {
      "column": 1,
      "line": 585
    },
    "return": "void",
    "signature": "public void sendError(int status, String errorMessage)",
    "source_code": "\tpublic void sendError(int status, String errorMessage) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot set error status - response is already committed\");\n\t\tthis.status = status;\n\t\tthis.errorMessage = errorMessage;\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tcheckActive();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tif (value != null) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}\n\t\telse {\n\t\t\tthis.attributes.remove(name);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setAttribute(name,value,scope)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value, int scope)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tswitch (scope) {\n\t\t\tcase PAGE_SCOPE -> setAttribute(name, value);\n\t\t\tcase REQUEST_SCOPE -> this.request.setAttribute(name, value);\n\t\t\tcase SESSION_SCOPE -> this.request.getSession().setAttribute(name, value);\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.setAttribute(name, value);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setDateHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 614
    },
    "return": "void",
    "signature": "public void setDateHeader(String name, long value)",
    "source_code": "\tpublic void setDateHeader(String name, long value) {\n\t\tsetHeaderValue(name, formatDate(value));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 648
    },
    "return": "void",
    "signature": "public void setHeader(String name, @Nullable String value)",
    "source_code": "\tpublic void setHeader(String name, @Nullable String value) {\n\t\tsetHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setIntHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "void",
    "signature": "public void setIntHeader(String name, int value)",
    "source_code": "\tpublic void setIntHeader(String name, int value) {\n\t\tsetHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameter(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a single value for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, they will be replaced.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "public void setParameter(String name, String value)",
    "source_code": "\tpublic void setParameter(String name, String value) {\n\t\tsetParameter(name, new String[] {value});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameter(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, they will be replaced.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "public void setParameter(String name, String... values)",
    "source_code": "\tpublic void setParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tthis.parameters.put(name, values);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameters(Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set all provided parameters <strong>replacing</strong> any existing\n\t * values for the provided parameter names. To add without replacing\n\t * existing values, use {@link #addParameters(java.util.Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "void",
    "signature": "public void setParameters(Map<String, ?> params)",
    "source_code": "\tpublic void setParameters(Map<String, ?> params) {\n\t\tAssert.notNull(params, \"Parameter map must not be null\");\n\t\tparams.forEach((key, value) -> {\n\t\t\tif (value instanceof String) {\n\t\t\t\tsetParameter(key, (String) value);\n\t\t\t}\n\t\t\telse if (value instanceof String[]) {\n\t\t\t\tsetParameter(key, (String[]) value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Parameter map value must be single value \" + \" or array of type [\" + String.class.getName() + \"]\");\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setStatus(status,errorMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "errorMessage"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "void",
    "signature": "public void setStatus(int status, String errorMessage)",
    "source_code": "\tpublic void setStatus(int status, String errorMessage) {\n\t\tif (!this.isCommitted()) {\n\t\t\tthis.status = status;\n\t\t\tthis.errorMessage = errorMessage;\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#startAsync(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 924
    },
    "return": "AsyncContext",
    "signature": "public AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response)",
    "source_code": "\tpublic AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response) {\n\t\tAssert.state(this.asyncSupported, \"Async not supported\");\n\t\tthis.asyncStarted = true;\n\t\tthis.asyncContext = new MockAsyncContext(request, response);\n\t\treturn this.asyncContext;\n\t}"
  },
  "org.springframework.mock.web.<unknown>#write(buf,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buf",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 852
    },
    "return": "void",
    "signature": "public void write(char[] buf, int off, int len)",
    "source_code": "\t\tpublic void write(char[] buf, int off, int len) {\n\t\t\tsuper.write(buf, off, len);\n\t\t\tsuper.flush();\n\t\t\tsetCommittedIfBufferSizeExceeded();\n\t\t}"
  },
  "org.springframework.mock.web.<unknown>#write(s,off,len)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 859
    },
    "return": "void",
    "signature": "public void write(String s, int off, int len)",
    "source_code": "\t\tpublic void write(String s, int off, int len) {\n\t\t\tsuper.write(s, off, len);\n\t\t\tsuper.flush();\n\t\t\tsetCommittedIfBufferSizeExceeded();\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#applyTransactionTimeout(query,emf)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the current transaction timeout, if any, to the given JPA Query object.\n\t * <p>This method sets the JPA query hint \"jakarta.persistence.query.timeout\" accordingly.\n\t * @param query the JPA Query object\n\t * @param emf the JPA EntityManagerFactory that the Query was created for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "emf"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "void",
    "signature": "public void applyTransactionTimeout(Query query, EntityManagerFactory emf)",
    "source_code": "\tpublic static void applyTransactionTimeout(Query query, EntityManagerFactory emf) {\n\t\tEntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null && emHolder.hasTimeout()) {\n\t\t\tint timeoutValue = (int) emHolder.getTimeToLiveInMillis();\n\t\t\ttry {\n\t\t\t\tquery.setHint(\"jakarta.persistence.query.timeout\", timeoutValue);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// oh well, at least we tried...\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#cleanupResource(resourceHolder,resourceKey,committed)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey",
      "committed"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "void",
    "signature": "protected void cleanupResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey, boolean committed)",
    "source_code": "\t\tprotected void cleanupResource(\n\t\t\t\tEntityManagerHolder resourceHolder, EntityManagerFactory resourceKey, boolean committed) {\n\n\t\t\tif (!committed) {\n\t\t\t\t// Clear all pending inserts/updates/deletes in the EntityManager.\n\t\t\t\t// Necessary for pre-bound EntityManagers, to avoid inconsistent state.\n\t\t\t\tresourceHolder.getEntityManager().clear();\n\t\t\t}\n\t\t\tcleanupTransaction(this.transactionData, resourceKey);\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createApplicationManagedEntityManager(rawEntityManager,emfInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "EntityManager",
    "signature": "public EntityManager createApplicationManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo)",
    "source_code": "\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, false);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createApplicationManagedEntityManager(rawEntityManager,emfInfo,synchronizedWithTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "EntityManager",
    "signature": "public EntityManager createApplicationManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, synchronizedWithTransaction);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(emf,Map<?,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createContainerManagedEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a container-managed EntityManager that expects container-driven lifecycle\n\t * management but may opt out of automatic transaction synchronization\n\t * @since 4.0\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tAssert.notNull(emf, \"EntityManagerFactory must not be null\");\n\t\tif (emf instanceof EntityManagerFactoryInfo emfInfo) {\n\t\t\tEntityManager rawEntityManager = emfInfo.createNativeEntityManager(properties);\n\t\t\treturn createProxy(rawEntityManager, emfInfo, true, synchronizedWithTransaction);\n\t\t}\n\t\telse {\n\t\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\t\temf.createEntityManager(properties) : emf.createEntityManager());\n\t\t\treturn createProxy(rawEntityManager, null, null, null, null, true, synchronizedWithTransaction);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(rawEntityManager,emfInfo)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, true, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createNativeEntityManager(Map<?,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 581
    },
    "return": "EntityManager",
    "signature": "public EntityManager createNativeEntityManager(@Nullable Map<?, ?> properties)",
    "source_code": "\tpublic EntityManager createNativeEntityManager(@Nullable Map<?, ?> properties) {\n\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\tgetNativeEntityManagerFactory().createEntityManager(properties) :\n\t\t\t\tgetNativeEntityManagerFactory().createEntityManager());\n\t\tpostProcessEntityManager(rawEntityManager);\n\t\treturn rawEntityManager;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to delegate to.\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @return a shareable transaction EntityManager proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createSharedEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,entityManagerInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "entityManagerInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces) {\n\n\t\treturn createSharedEntityManager(emf, properties, true, entityManagerInterfaces);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to delegate to.\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a shareable transaction EntityManager proxy\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tClass<?> emIfc = (emf instanceof EntityManagerFactoryInfo ?\n\t\t\t\t((EntityManagerFactoryInfo) emf).getEntityManagerInterface() : EntityManager.class);\n\t\treturn createSharedEntityManager(emf, properties, synchronizedWithTransaction,\n\t\t\t\t(emIfc == null ? NO_ENTITY_MANAGER_INTERFACES : new Class<?>[] {emIfc}));\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,synchronizedWithTransaction,entityManagerInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction",
      "entityManagerInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces) {\n\n\t\tClassLoader cl = null;\n\t\tif (emf instanceof EntityManagerFactoryInfo) {\n\t\t\tcl = ((EntityManagerFactoryInfo) emf).getBeanClassLoader();\n\t\t}\n\t\tClass<?>[] ifcs = new Class<?>[entityManagerInterfaces.length + 1];\n\t\tSystem.arraycopy(entityManagerInterfaces, 0, ifcs, 0, entityManagerInterfaces.length);\n\t\tifcs[entityManagerInterfaces.length] = EntityManagerProxy.class;\n\t\treturn (EntityManager) Proxy.newProxyInstance(\n\t\t\t\t(cl != null ? cl : SharedEntityManagerCreator.class.getClassLoader()),\n\t\t\t\tifcs, new SharedEntityManagerInvocationHandler(emf, properties, synchronizedWithTransaction));\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doBegin(transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tJpaTransactionObject txObject = (JpaTransactionObject) transaction;\n\n\t\tif (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Pre-bound JDBC Connection found! JpaTransactionManager does not support \" +\n\t\t\t\t\t\"running within DataSourceTransactionManager if told to manage the DataSource itself. \" +\n\t\t\t\t\t\"It is recommended to use a single JpaTransactionManager for all transactions \" +\n\t\t\t\t\t\"on a single DataSource, no matter whether JPA or JDBC access.\");\n\t\t}\n\n\t\ttry {\n\t\t\tif (!txObject.hasEntityManagerHolder() ||\n\t\t\t\t\ttxObject.getEntityManagerHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tEntityManager newEm = createEntityManagerForTransaction();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Opened new EntityManager [\" + newEm + \"] for JPA transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setEntityManagerHolder(new EntityManagerHolder(newEm), true);\n\t\t\t}\n\n\t\t\tEntityManager em = txObject.getEntityManagerHolder().getEntityManager();\n\n\t\t\t// Delegate to JpaDialect for actual transaction begin.\n\t\t\tint timeoutToUse = determineTimeout(definition);\n\t\t\tObject transactionData = getJpaDialect().beginTransaction(em,\n\t\t\t\t\tnew JpaTransactionDefinition(definition, timeoutToUse, txObject.isNewEntityManagerHolder()));\n\t\t\ttxObject.setTransactionData(transactionData);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Register transaction timeout.\n\t\t\tif (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getEntityManagerHolder().setTimeoutInSeconds(timeoutToUse);\n\t\t\t}\n\n\t\t\t// Register the JPA EntityManager's JDBC Connection for the DataSource, if set.\n\t\t\tif (getDataSource() != null) {\n\t\t\t\tConnectionHandle conHandle = getJpaDialect().getJdbcConnection(em, definition.isReadOnly());\n\t\t\t\tif (conHandle != null) {\n\t\t\t\t\tConnectionHolder conHolder = new ConnectionHolder(conHandle);\n\t\t\t\t\tif (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t\t\tconHolder.setTimeoutInSeconds(timeoutToUse);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Exposing JPA transaction as JDBC [\" + conHandle + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), conHolder);\n\t\t\t\t\ttxObject.setConnectionHolder(conHolder);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not exposing JPA transaction [\" + em + \"] as JDBC transaction because \" +\n\t\t\t\t\t\t\t\t\"JpaDialect [\" + getJpaDialect() + \"] does not support JDBC Connection retrieval\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Bind the entity manager holder to the thread.\n\t\t\tif (txObject.isNewEntityManagerHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\tobtainEntityManagerFactory(), txObject.getEntityManagerHolder());\n\t\t\t}\n\t\t\ttxObject.getEntityManagerHolder().setSynchronizedWithTransaction(true);\n\t\t}\n\n\t\tcatch (TransactionException ex) {\n\t\t\tcloseEntityManagerAfterFailedBegin(txObject);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tcloseEntityManagerAfterFailedBegin(txObject);\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JPA EntityManager for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map<?, ?> properties)\n\t\t\tthrows PersistenceException {\n\n\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)\n\t\t\tthrows PersistenceException {\n\n\t\tAssert.notNull(emf, \"No EntityManagerFactory specified\");\n\n\t\tEntityManagerHolder emHolder =\n\t\t\t\t(EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null) {\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tif (!emHolder.isSynchronizedWithTransaction()) {\n\t\t\t\t\tif (TransactionSynchronizationManager.isActualTransactionActive()) {\n\t\t\t\t\t\t// Try to explicitly synchronize the EntityManager itself\n\t\t\t\t\t\t// with an ongoing JTA transaction, if any.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\temHolder.getEntityManager().joinTransaction();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (TransactionRequiredException ex) {\n\t\t\t\t\t\t\tlogger.debug(\"Could not join transaction because none was actually active\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\tObject transactionData = prepareTransaction(emHolder.getEntityManager(), emf);\n\t\t\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, false));\n\t\t\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Use holder's reference count to track synchronizedWithTransaction access.\n\t\t\t\t// isOpen() check used below to find out about it.\n\t\t\t\temHolder.requested();\n\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// unsynchronized EntityManager demanded\n\t\t\t\tif (emHolder.isTransactionActive() && !emHolder.isOpen()) {\n\t\t\t\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// EntityManagerHolder with an active transaction coming from JpaTransactionManager,\n\t\t\t\t\t// with no synchronized EntityManager having been requested by application code before.\n\t\t\t\t\t// Unbind in order to register a new unsynchronized EntityManager instead.\n\t\t\t\t\tTransactionSynchronizationManager.unbindResource(emf);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Either a previously bound unsynchronized EntityManager, or the application\n\t\t\t\t\t// has requested a synchronized EntityManager before and therefore upgraded\n\t\t\t\t\t// this transaction's EntityManager to synchronized before.\n\t\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t// Indicate that we can't obtain a transactional EntityManager.\n\t\t\treturn null;\n\t\t}\n\n\t\t// Create a new EntityManager for use within the current transaction.\n\t\tlogger.debug(\"Opening JPA EntityManager\");\n\t\tEntityManager em = null;\n\t\tif (!synchronizedWithTransaction) {\n\t\t\ttry {\n\t\t\t\tem = emf.createEntityManager(SynchronizationType.UNSYNCHRONIZED, properties);\n\t\t\t}\n\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\t// JPA 2.1 API available but method not actually implemented in persistence provider:\n\t\t\t\t// falling back to regular createEntityManager method.\n\t\t\t}\n\t\t}\n\t\tif (em == null) {\n\t\t\tem = (!CollectionUtils.isEmpty(properties) ? emf.createEntityManager(properties) : emf.createEntityManager());\n\t\t}\n\n\t\ttry {\n\t\t\t// Use same EntityManager for further JPA operations within the transaction.\n\t\t\t// Thread-bound object will get removed by synchronization at transaction completion.\n\t\t\temHolder = new EntityManagerHolder(em);\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tObject transactionData = prepareTransaction(em, emf);\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, true));\n\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unsynchronized - just scope it for the transaction, as demanded by the JPA 2.1 spec...\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionScopedEntityManagerSynchronization(emHolder, emf));\n\t\t\t}\n\t\t\tTransactionSynchronizationManager.bindResource(emf, emHolder);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Unexpected exception from external delegation call -> close EntityManager and rethrow.\n\t\t\tcloseEntityManager(em);\n\t\t\tthrow ex;\n\t\t}\n\n\t\treturn em;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doResume(transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tSuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;\n\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\tobtainEntityManagerFactory(), resourcesHolder.getEntityManagerHolder());\n\t\tif (getDataSource() != null && resourcesHolder.getConnectionHolder() != null) {\n\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), resourcesHolder.getConnectionHolder());\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#findEntityManagerFactory(beanFactory,unitName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the given\n\t * Spring application context (represented as ListableBeanFactory).\n\t * <p>The specified unit name will be matched against the configured\n\t * persistence unit, provided that a discovered EntityManagerFactory\n\t * implements the {@link EntityManagerFactoryInfo} interface. If not,\n\t * the persistence unit name will be matched against the Spring bean name,\n\t * assuming that the EntityManagerFactory bean names follow that convention.\n\t * <p>If no unit name has been given, this method will search for a default\n\t * EntityManagerFactory through {@link ListableBeanFactory#getBean(Class)}.\n\t * @param beanFactory the ListableBeanFactory to search\n\t * @param unitName the name of the persistence unit (may be {@code null} or empty,\n\t * in which case a single bean of type EntityManagerFactory will be searched for)\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t * @see EntityManagerFactoryInfo#getPersistenceUnitName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "unitName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory findEntityManagerFactory(ListableBeanFactory beanFactory, @Nullable String unitName)",
    "source_code": "\tpublic static EntityManagerFactory findEntityManagerFactory(\n\t\t\tListableBeanFactory beanFactory, @Nullable String unitName) throws NoSuchBeanDefinitionException {\n\n\t\tAssert.notNull(beanFactory, \"ListableBeanFactory must not be null\");\n\t\tif (StringUtils.hasLength(unitName)) {\n\t\t\t// See whether we can find an EntityManagerFactory with matching persistence unit name.\n\t\t\tString[] candidateNames =\n\t\t\t\t\tBeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, EntityManagerFactory.class);\n\t\t\tfor (String candidateName : candidateNames) {\n\t\t\t\tEntityManagerFactory emf = (EntityManagerFactory) beanFactory.getBean(candidateName);\n\t\t\t\tif (emf instanceof EntityManagerFactoryInfo &&\n\t\t\t\t\t\tunitName.equals(((EntityManagerFactoryInfo) emf).getPersistenceUnitName())) {\n\t\t\t\t\treturn emf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// No matching persistence unit found - simply take the EntityManagerFactory\n\t\t\t// with the persistence unit name as bean name (by convention).\n\t\t\treturn beanFactory.getBean(unitName, EntityManagerFactory.class);\n\t\t}\n\t\telse {\n\t\t\t// Find unique EntityManagerFactory bean in the context, falling back to parent contexts.\n\t\t\treturn beanFactory.getBean(EntityManagerFactory.class);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#getTransactionalEntityManager(emf,Map<?,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, e.g. when using JpaTransactionManager.\n\t * <p>Note: Will return {@code null} if no thread-bound EntityManager found!\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws DataAccessResourceFailureException if the EntityManager couldn't be obtained\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "EntityManager",
    "signature": "public EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)\n\t\t\tthrows DataAccessResourceFailureException {\n\t\ttry {\n\t\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Could not obtain JPA EntityManager\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Query interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of EntityManager proxy.\n\t\t\t\t\treturn hashCode();\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\t// Handle JPA 2.0 unwrap method - could be a proxy match.\n\t\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\t\tif (targetClass == null) {\n\t\t\t\t\t\treturn this.target;\n\t\t\t\t\t}\n\t\t\t\t\telse if (targetClass.isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"getOutputParameterValue\":\n\t\t\t\t\tif (this.entityManager == null) {\n\t\t\t\t\t\tObject key = args[0];\n\t\t\t\t\t\tif (this.outputParameters == null || !this.outputParameters.containsKey(key)) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"OUT/INOUT parameter not available: \" + key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject value = this.outputParameters.get(key);\n\t\t\t\t\t\tif (value instanceof IllegalArgumentException) {\n\t\t\t\t\t\t\tthrow (IllegalArgumentException) value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Invoke method on actual Query object.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\t\t\t\tif (method.getName().equals(\"registerStoredProcedureParameter\") && args.length == 3 &&\n\t\t\t\t\t\t(args[2] == ParameterMode.OUT || args[2] == ParameterMode.INOUT)) {\n\t\t\t\t\tif (this.outputParameters == null) {\n\t\t\t\t\t\tthis.outputParameters = new LinkedHashMap<>();\n\t\t\t\t\t}\n\t\t\t\t\tthis.outputParameters.put(args[0], null);\n\t\t\t\t}\n\t\t\t\treturn (retVal == this.target ? proxy : retVal);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (queryTerminatingMethods.contains(method.getName())) {\n\t\t\t\t\t// Actual execution of the query: close the EntityManager right\n\t\t\t\t\t// afterwards, since that was the only reason we kept it open.\n\t\t\t\t\tif (this.outputParameters != null && this.target instanceof StoredProcedureQuery storedProc) {\n\t\t\t\t\t\tfor (Map.Entry<Object, Object> entry : this.outputParameters.entrySet()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObject key = entry.getKey();\n\t\t\t\t\t\t\t\tif (key instanceof Integer) {\n\t\t\t\t\t\t\t\t\tentry.setValue(storedProc.getOutputParameterValue((Integer) key));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tentry.setValue(storedProc.getOutputParameterValue(key.toString()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\t\t\tentry.setValue(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tEntityManagerFactoryUtils.closeEntityManager(this.entityManager);\n\t\t\t\t\tthis.entityManager = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#releaseResource(resourceHolder,resourceKey)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey)",
    "source_code": "\t\tprotected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey) {\n\t\t\tcloseEntityManager(resourceHolder.getEntityManager());\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setEntityManagerHolder(entityManagerHolder,newEntityManagerHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManagerHolder",
      "newEntityManagerHolder"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void setEntityManagerHolder(@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder)",
    "source_code": "\t\tpublic void setEntityManagerHolder(\n\t\t\t\t@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder) {\n\n\t\t\tthis.entityManagerHolder = entityManagerHolder;\n\t\t\tthis.newEntityManagerHolder = newEntityManagerHolder;\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setJpaPropertyMap(Map<String,jpaProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify JPA properties as a Map, to be passed into\n\t * {@code Persistence.createEntityManagerFactory} (if any).\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @see jakarta.persistence.Persistence#createEntityManagerFactory(String, Map)\n\t * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(PersistenceUnitInfo, Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jpaProperties"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties)",
    "source_code": "\tpublic void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties) {\n\t\tif (jpaProperties != null) {\n\t\t\tthis.jpaPropertyMap.putAll(jpaProperties);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 790
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext,\n\t\t\t\tBeanRegistrationCode beanRegistrationCode) {\n\t\t\tClassName className = generationContext.getClassNameGenerator()\n\t\t\t\t\t.generateClassName(this.target, \"PersistenceInjection\");\n\t\t\tTypeSpec.Builder classBuilder = TypeSpec.classBuilder(className);\n\t\t\tclassBuilder.addJavadoc(\"Persistence injection for {@link $T}.\", this.target);\n\t\t\tclassBuilder.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\tGeneratedMethods methods = new GeneratedMethods(\n\t\t\t\t\tnew MethodNameGenerator(APPLY_METHOD));\n\t\t\tclassBuilder.addMethod(generateMethod(generationContext.getRuntimeHints(),\n\t\t\t\t\tclassName, methods));\n\t\t\tmethods.doWithMethodSpecs(classBuilder::addMethod);\n\t\t\tJavaFile javaFile = JavaFile\n\t\t\t\t\t.builder(className.packageName(), classBuilder.build()).build();\n\t\t\tgenerationContext.getGeneratedFiles().addSourceFile(javaFile);\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(\n\t\t\t\t\tMethodReference.ofStatic(className, APPLY_METHOD));\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findEntityManagerFactory(unitName,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current Spring\n\t * application context, falling back to a single default EntityManagerFactory\n\t * (if any) in case of no unit name specified.\n\t * @param unitName the name of the persistence unit (may be {@code null} or empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString unitNameForLookup = (unitName != null ? unitName : \"\");\n\t\tif (unitNameForLookup.isEmpty()) {\n\t\t\tunitNameForLookup = this.defaultPersistenceUnitName;\n\t\t}\n\t\tif (!unitNameForLookup.isEmpty()) {\n\t\t\treturn findNamedEntityManagerFactory(unitNameForLookup, requestingBeanName);\n\t\t}\n\t\telse {\n\t\t\treturn findDefaultEntityManagerFactory(requestingBeanName);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findNamedEntityManagerFactory(unitName,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current\n\t * Spring application context.\n\t * @param unitName the name of the persistence unit (never empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 572
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tAssert.state(this.beanFactory != null, \"ListableBeanFactory required for EntityManagerFactory bean lookup\");\n\n\t\tEntityManagerFactory emf = EntityManagerFactoryUtils.findEntityManagerFactory(this.beanFactory, unitName);\n\t\tif (requestingBeanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tcbf.registerDependentBean(unitName, requestingBeanName);\n\t\t}\n\t\treturn emf;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#getPersistenceContext(unitName,extended)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a specified persistence context for the given unit name, as defined\n\t * through the \"persistenceContexts\" (or \"extendedPersistenceContexts\") map.\n\t * @param unitName the name of the persistence unit\n\t * @param extended whether to obtain an extended persistence context\n\t * @return the corresponding EntityManager, or {@code null} if none found\n\t * @see #setPersistenceContexts\n\t * @see #setExtendedPersistenceContexts\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "extended"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "EntityManager",
    "signature": "protected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended)",
    "source_code": "\tprotected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended) {\n\t\tMap<String, String> contexts = (extended ? this.extendedPersistenceContexts : this.persistenceContexts);\n\t\tif (contexts != null) {\n\t\t\tString unitNameForLookup = (unitName != null ? unitName : \"\");\n\t\t\tif (unitNameForLookup.isEmpty()) {\n\t\t\t\tunitNameForLookup = this.defaultPersistenceUnitName;\n\t\t\t}\n\t\t\tString jndiName = contexts.get(unitNameForLookup);\n\t\t\tif (jndiName == null && unitNameForLookup.isEmpty() && contexts.size() == 1) {\n\t\t\t\tjndiName = contexts.values().iterator().next();\n\t\t\t}\n\t\t\tif (jndiName != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn lookup(jndiName, EntityManager.class);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Could not obtain EntityManager [\" + jndiName + \"] from JNDI\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Resolve the object against the application context.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 695
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\t// Resolves to EntityManagerFactory or EntityManager.\n\t\t\tif (this.type != null) {\n\t\t\t\treturn (this.type == PersistenceContextType.EXTENDED ?\n\t\t\t\t\t\tresolveExtendedEntityManager(target, requestingBeanName) :\n\t\t\t\t\t\tresolveEntityManager(requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// OK, so we need an EntityManagerFactory...\n\t\t\t\treturn resolveEntityManagerFactory(requestingBeanName);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#lookup(jndiName,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jndiName",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "T",
    "signature": "public T lookup(String jndiName, Class<T> requiredType)",
    "source_code": "\t\tpublic <T> T lookup(String jndiName, Class<T> requiredType) throws Exception {\n\t\t\tJndiLocatorDelegate locator = new JndiLocatorDelegate();\n\t\t\tif (jndiEnvironment instanceof JndiTemplate jndiTemplate) {\n\t\t\t\tlocator.setJndiTemplate(jndiTemplate);\n\t\t\t}\n\t\t\telse if (jndiEnvironment instanceof Properties properties) {\n\t\t\t\tlocator.setJndiEnvironment(properties);\n\t\t\t}\n\t\t\telse if (jndiEnvironment != null) {\n\t\t\t\tthrow new IllegalStateException(\"Illegal 'jndiEnvironment' type: \" + jndiEnvironment.getClass());\n\t\t\t}\n\t\t\tlocator.setResourceRef(resourceRef);\n\t\t\treturn locator.lookup(jndiName, requiredType);\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tEntityManager emToClose = this.extendedEntityManagersToClose.remove(bean);\n\t\tEntityManagerFactoryUtils.closeEntityManager(emToClose);\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanDefinition, beanType, beanName);\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findPersistenceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of persistence dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setExtendedPersistenceContexts(Map<String,extendedPersistenceContexts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <i>extended</i> persistence contexts for EntityManager lookups,\n\t * as a Map from persistence unit name to persistence context JNDI name\n\t * (which needs to resolve to an EntityManager instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-context-ref}\n\t * entries in the Jakarta EE deployment descriptors, matching the target persistence unit\n\t * and being set up with persistence context type {@code Extended}.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all\n\t * lookup driven by the standard JPA annotations, and all EntityManager\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario, and all EntityManager\n\t * handling is done by the Jakarta EE server itself.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extendedPersistenceContexts"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "void",
    "signature": "public void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts)",
    "source_code": "\tpublic void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts) {\n\t\tthis.extendedPersistenceContexts = extendedPersistenceContexts;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceContexts(Map<String,persistenceContexts)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <i>transactional</i> persistence contexts for EntityManager lookups,\n\t * as a Map from persistence unit name to persistence context JNDI name\n\t * (which needs to resolve to an EntityManager instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-context-ref}\n\t * entries in the Jakarta EE deployment descriptors, matching the target persistence unit\n\t * and being set up with persistence context type {@code Transaction}.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all\n\t * lookup driven by the standard JPA annotations, and all EntityManager\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario, and all EntityManager\n\t * handling is done by the Jakarta EE server itself.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceContexts"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "public void setPersistenceContexts(Map<String, String> persistenceContexts)",
    "source_code": "\tpublic void setPersistenceContexts(Map<String, String> persistenceContexts) {\n\t\tthis.persistenceContexts = persistenceContexts;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceUnits(Map<String,persistenceUnits)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the persistence units for EntityManagerFactory lookups,\n\t * as a Map from persistence unit name to persistence unit JNDI name\n\t * (which needs to resolve to an EntityManagerFactory instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-unit-ref}\n\t * entries in the Jakarta EE deployment descriptor, matching the target persistence unit.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all lookup\n\t * driven by the standard JPA annotations, and all EntityManagerFactory\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario.\n\t * <p>If no corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\"\n\t * are specified, {@code @PersistenceContext} will be resolved to\n\t * EntityManagers built on top of the EntityManagerFactory defined here.\n\t * Note that those will be Spring-managed EntityManagers, which implement\n\t * transaction synchronization based on Spring's facilities.\n\t * If you prefer the Jakarta EE server's own EntityManager handling,\n\t * specify corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceUnits"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void setPersistenceUnits(Map<String, String> persistenceUnits)",
    "source_code": "\tpublic void setPersistenceUnits(Map<String, String> persistenceUnits) {\n\t\tthis.persistenceUnits = persistenceUnits;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#beginTransaction(entityManager,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Object",
    "signature": "public Object beginTransaction(EntityManager entityManager, TransactionDefinition definition)",
    "source_code": "\tpublic Object beginTransaction(EntityManager entityManager, TransactionDefinition definition)\n\t\t\tthrows PersistenceException, SQLException, TransactionException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\n\t\tif (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\tsession.getTransaction().setTimeout(definition.getTimeout());\n\t\t}\n\n\t\tboolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);\n\t\tInteger previousIsolationLevel = null;\n\t\tConnection preparedCon = null;\n\n\t\tif (isolationLevelNeeded || definition.isReadOnly()) {\n\t\t\tif (this.prepareConnection && ConnectionReleaseMode.ON_CLOSE.equals(\n\t\t\t\t\tsession.getJdbcCoordinator().getLogicalConnection().getConnectionHandlingMode().getReleaseMode())) {\n\t\t\t\tpreparedCon = session.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection();\n\t\t\t\tpreviousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(preparedCon, definition);\n\t\t\t}\n\t\t\telse if (isolationLevelNeeded) {\n\t\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\t\"HibernateJpaDialect is not allowed to support custom isolation levels: \" +\n\t\t\t\t\t\t\"make sure that its 'prepareConnection' flag is on (the default) and that the \" +\n\t\t\t\t\t\t\"Hibernate connection release mode is set to ON_CLOSE.\");\n\t\t\t}\n\t\t}\n\n\t\t// Standard JPA transaction begin call for full JPA context setup...\n\t\tentityManager.getTransaction().begin();\n\n\t\t// Adapt flush mode and store previous isolation level, if any.\n\t\tFlushMode previousFlushMode = prepareFlushMode(session, definition.isReadOnly());\n\t\tif (definition instanceof ResourceTransactionDefinition &&\n\t\t\t\t((ResourceTransactionDefinition) definition).isLocalResource()) {\n\t\t\t// As of 5.1, we explicitly optimize for a transaction-local EntityManager,\n\t\t\t// aligned with native HibernateTransactionManager behavior.\n\t\t\tpreviousFlushMode = null;\n\t\t\tif (definition.isReadOnly()) {\n\t\t\t\tsession.setDefaultReadOnly(true);\n\t\t\t}\n\t\t}\n\t\treturn new SessionTransactionData(\n\t\t\t\tsession, previousFlushMode, (preparedCon != null), previousIsolationLevel, definition.isReadOnly());\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#getJdbcConnection(entityManager,readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "ConnectionHandle",
    "signature": "public ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)",
    "source_code": "\tpublic ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)\n\t\t\tthrows PersistenceException, SQLException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\treturn new HibernateConnectionHandle(session);\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#prepareFlushMode(session,readOnly)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "FlushMode",
    "signature": "protected FlushMode prepareFlushMode(Session session, boolean readOnly)",
    "source_code": "\tprotected FlushMode prepareFlushMode(Session session, boolean readOnly) throws PersistenceException {\n\t\tFlushMode flushMode = session.getHibernateFlushMode();\n\t\tif (readOnly) {\n\t\t\t// We should suppress flushing for a read-only transaction.\n\t\t\tif (!flushMode.equals(FlushMode.MANUAL)) {\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\t\treturn flushMode;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We need AUTO or COMMIT for a non-read-only transaction.\n\t\t\tif (flushMode.lessThan(FlushMode.COMMIT)) {\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.AUTO);\n\t\t\t\treturn flushMode;\n\t\t\t}\n\t\t}\n\t\t// No FlushMode change needed...\n\t\treturn null;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#prepareTransaction(entityManager,readOnly,name)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "Object",
    "signature": "public Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name)",
    "source_code": "\tpublic Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name)\n\t\t\tthrows PersistenceException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\tFlushMode previousFlushMode = prepareFlushMode(session, readOnly);\n\t\treturn new SessionTransactionData(session, previousFlushMode, false, null, readOnly);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(data,offset,length,mimeType,elementNamespace,elementLocalName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "offset",
      "length",
      "mimeType",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 971
    },
    "return": "String",
    "signature": "public String addMtomAttachment(byte[] data, int offset, int length, String mimeType,\n\t\t\t\tString elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(byte[] data, int offset, int length, String mimeType,\n\t\t\t\tString elementNamespace, String elementLocalName) {\n\t\t\tByteArrayDataSource dataSource = new ByteArrayDataSource(mimeType, data, offset, length);\n\t\t\treturn addMtomAttachment(new DataHandler(dataSource), elementNamespace, elementLocalName);\n\t\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(dataHandler,elementNamespace,elementLocalName)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataHandler",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 978
    },
    "return": "String",
    "signature": "public String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName) {\n\t\t\tString host = getHost(elementNamespace, dataHandler);\n\t\t\tString contentId = UUID.randomUUID() + \"@\" + host;\n\t\t\tthis.mimeContainer.addAttachment(\"<\" + contentId + \">\", dataHandler);\n\t\t\tcontentId = URLEncoder.encode(contentId, StandardCharsets.UTF_8);\n\t\t\treturn CID + contentId;\n\t\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic void marshal(Object graph, Result result) throws XmlMappingException {\n\t\tmarshal(graph, result, null);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result,mimeContainer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\ttry {\n\t\t\tMarshaller marshaller = createMarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tmarshaller.setAttachmentMarshaller(new Jaxb2AttachmentMarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxResult(result)) {\n\t\t\t\tmarshalStaxResult(marshaller, graph, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmarshaller.marshal(graph, result);\n\t\t\t}\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setAdapters(XmlAdapter<?,adapters)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@code XmlAdapter}s to be registered with the JAXB {@code Marshaller}\n\t * and {@code Unmarshaller}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "XmlAdapter<?",
      "adapters"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void setAdapters(XmlAdapter<?, ?>... adapters)",
    "source_code": "\tpublic void setAdapters(XmlAdapter<?, ?>... adapters) {\n\t\tthis.adapters = adapters;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setJaxbContextProperties(Map<String,jaxbContextProperties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code JAXBContext} properties. These implementation-specific\n\t * properties will be set on the underlying {@code JAXBContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jaxbContextProperties"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "public void setJaxbContextProperties(Map<String, ?> jaxbContextProperties)",
    "source_code": "\tpublic void setJaxbContextProperties(Map<String, ?> jaxbContextProperties) {\n\t\tthis.jaxbContextProperties = jaxbContextProperties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setMarshallerProperties(Map<String,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Marshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Marshaller},\n\t * and allow for features such as indentation.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Marshaller#setProperty(String, Object)\n\t * @see jakarta.xml.bind.Marshaller#JAXB_ENCODING\n\t * @see jakarta.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT\n\t * @see jakarta.xml.bind.Marshaller#JAXB_NO_NAMESPACE_SCHEMA_LOCATION\n\t * @see jakarta.xml.bind.Marshaller#JAXB_SCHEMA_LOCATION\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "void",
    "signature": "public void setMarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setMarshallerProperties(Map<String, ?> properties) {\n\t\tthis.marshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setUnmarshallerProperties(Map<String,properties)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Unmarshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Unmarshaller}.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Unmarshaller#setProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "void",
    "signature": "public void setUnmarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setUnmarshallerProperties(Map<String, ?> properties) {\n\t\tthis.unmarshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#unmarshal(source,mimeContainer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 794
    },
    "return": "Object",
    "signature": "public Object unmarshal(Source source, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic Object unmarshal(Source source, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\tsource = processSource(source);\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = createUnmarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tunmarshaller.setAttachmentUnmarshaller(new Jaxb2AttachmentUnmarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxSource(source)) {\n\t\t\t\treturn unmarshalStaxSource(unmarshaller, source);\n\t\t\t}\n\t\t\telse if (this.mappedClass != null) {\n\t\t\t\treturn unmarshaller.unmarshal(source, this.mappedClass).getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn unmarshaller.unmarshal(source);\n\t\t\t}\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling: \" +\n\t\t\t\t\t\t\"This can happen due to the presence of DTD declarations which are disabled.\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#unmarshalStaxSource(jaxbUnmarshaller,staxSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jaxbUnmarshaller",
      "staxSource"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "Object",
    "signature": "protected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource)",
    "source_code": "\tprotected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException {\n\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);\n\t\tif (streamReader != null) {\n\t\t\treturn (this.mappedClass != null ?\n\t\t\t\t\tjaxbUnmarshaller.unmarshal(streamReader, this.mappedClass).getValue() :\n\t\t\t\t\tjaxbUnmarshaller.unmarshal(streamReader));\n\t\t}\n\t\telse {\n\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);\n\t\t\tif (eventReader != null) {\n\t\t\t\treturn (this.mappedClass != null ?\n\t\t\t\t\t\tjaxbUnmarshaller.unmarshal(eventReader, this.mappedClass).getValue() :\n\t\t\t\t\t\tjaxbUnmarshaller.unmarshal(eventReader));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxSource contains neither XMLStreamReader nor XMLEventReader\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#convertXStreamException(ex,marshalling)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given XStream exception to an appropriate exception from the\n\t * {@code org.springframework.oxm} hierarchy.\n\t * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or\n\t * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.\n\t * @param ex the XStream exception that occurred\n\t * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),\n\t * or unmarshalling ({@code false})\n\t * @return the corresponding {@code XmlMappingException}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "marshalling"
    ],
    "position": {
      "column": 1,
      "line": 876
    },
    "return": "XmlMappingException",
    "signature": "protected XmlMappingException convertXStreamException(Exception ex, boolean marshalling)",
    "source_code": "\tprotected XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {\n\t\tif (ex instanceof StreamException || ex instanceof CannotResolveClassException ||\n\t\t\t\tex instanceof ForbiddenClassException || ex instanceof ConversionException) {\n\t\t\tif (marshalling) {\n\t\t\t\treturn new MarshallingFailureException(\"XStream marshalling exception\",  ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new UnmarshallingFailureException(\"XStream unmarshalling exception\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// fallback\n\t\t\treturn new UncategorizedMappingException(\"Unknown XStream exception\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalDomNode(graph,node)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "node"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "void",
    "signature": "protected void marshalDomNode(Object graph, Node node)",
    "source_code": "\tprotected void marshalDomNode(Object graph, Node node) throws XmlMappingException {\n\t\tHierarchicalStreamWriter streamWriter;\n\t\tif (node instanceof Document document) {\n\t\t\tstreamWriter = new DomWriter(document, this.nameCoder);\n\t\t}\n\t\telse if (node instanceof Element element) {\n\t\t\tstreamWriter = new DomWriter(element, node.getOwnerDocument(), this.nameCoder);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"DOMResult contains neither Document nor Element\");\n\t\t}\n\t\tdoMarshal(graph, streamWriter, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalOutputStream(graph,outputStream)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "public void marshalOutputStream(Object graph, OutputStream outputStream)",
    "source_code": "\tpublic void marshalOutputStream(Object graph, OutputStream outputStream) throws XmlMappingException, IOException {\n\t\tmarshalOutputStream(graph, outputStream, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalOutputStream(graph,outputStream,dataHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "outputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "void",
    "signature": "public void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (this.streamDriver != null) {\n\t\t\tdoMarshal(graph, this.streamDriver.createWriter(outputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\tmarshalWriter(graph, new OutputStreamWriter(outputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException {\n\n\t\tSaxWriter saxWriter = new SaxWriter(this.nameCoder);\n\t\tsaxWriter.setContentHandler(contentHandler);\n\t\tdoMarshal(graph, saxWriter, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalWriter(graph,writer)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 738
    },
    "return": "void",
    "signature": "public void marshalWriter(Object graph, Writer writer)",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {\n\t\tmarshalWriter(graph, writer, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalWriter(graph,writer,dataHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "writer",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (this.streamDriver != null) {\n\t\t\tdoMarshal(graph, this.streamDriver.createWriter(writer), dataHolder);\n\t\t}\n\t\telse {\n\t\t\tdoMarshal(graph, new CompactWriter(writer), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalXmlEventWriter(graph,eventWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 689
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter) throws XmlMappingException {\n\t\tContentHandler contentHandler = StaxUtils.createContentHandler(eventWriter);\n\t\tLexicalHandler lexicalHandler = (contentHandler instanceof LexicalHandler handler ? handler : null);\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalXmlStreamWriter(graph,streamWriter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamWriter"
    ],
    "position": {
      "column": 1,
      "line": 696
    },
    "return": "void",
    "signature": "protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)",
    "source_code": "\tprotected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter) throws XmlMappingException {\n\t\ttry {\n\t\t\tStaxWriter writer;\n\t\t\tif (this.streamDriver instanceof StaxDriver staxDriver) {\n\t\t\t\twriter = staxDriver.createStaxWriter(streamWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriter = new StaxWriter(new QNameMap(), streamWriter, this.nameCoder);\n\t\t\t}\n\t\t\tdoMarshal(graph, writer, null);\n\t\t}\n\t\tcatch (XMLStreamException ex) {\n\t\t\tthrow convertXStreamException(ex, true);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliases(Map<String,aliases)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the alias/type map, consisting of string aliases mapped to classes.\n\t * <p>Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#alias(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliases"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void setAliases(Map<String, ?> aliases)",
    "source_code": "\tpublic void setAliases(Map<String, ?> aliases) {\n\t\tthis.aliases = aliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliasesByType(Map<String,aliasesByType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the <em>aliases by type</em> map, consisting of string aliases mapped to classes.\n\t * <p>Any class that is assignable to this type will be aliased to the same name.\n\t * Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#aliasType(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliasesByType"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void setAliasesByType(Map<String, ?> aliasesByType)",
    "source_code": "\tpublic void setAliasesByType(Map<String, ?> aliasesByType) {\n\t\tthis.aliasesByType = aliasesByType;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setFieldAliases(Map<String,fieldAliases)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field alias/type map, consisting of field names.\n\t * @see XStream#aliasField(String, Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "fieldAliases"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void setFieldAliases(Map<String, String> fieldAliases)",
    "source_code": "\tpublic void setFieldAliases(Map<String, String> fieldAliases) {\n\t\tthis.fieldAliases = fieldAliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setImplicitCollections(Map<Class<?>,implicitCollections)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify implicit collection fields, as a Map consisting of {@code Class} instances\n\t * mapped to comma separated collection field names.\n\t * @see XStream#addImplicitCollection(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "implicitCollections"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "public void setImplicitCollections(Map<Class<?>, String> implicitCollections)",
    "source_code": "\tpublic void setImplicitCollections(Map<Class<?>, String> implicitCollections) {\n\t\tthis.implicitCollections = implicitCollections;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setOmittedFields(Map<Class<?>,omittedFields)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Specify omitted fields, as a Map consisting of {@code Class} instances\n\t * mapped to comma separated field names.\n\t * @see XStream#omitField(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "omittedFields"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "void",
    "signature": "public void setOmittedFields(Map<Class<?>, String> omittedFields)",
    "source_code": "\tpublic void setOmittedFields(Map<Class<?>, String> omittedFields) {\n\t\tthis.omittedFields = omittedFields;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setUseAttributeFor(Map<?,useAttributeFor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the types to use XML attributes for. The given map can contain\n\t * either {@code <String, Class>} pairs, in which case\n\t * {@link XStream#useAttributeFor(String, Class)} is called.\n\t * Alternatively, the map can contain {@code <Class, String>}\n\t * or {@code <Class, List<String>>} pairs, which results\n\t * in {@link XStream#useAttributeFor(Class, String)} calls.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "useAttributeFor"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "public void setUseAttributeFor(Map<?, ?> useAttributeFor)",
    "source_code": "\tpublic void setUseAttributeFor(Map<?, ?> useAttributeFor) {\n\t\tthis.useAttributeFor = useAttributeFor;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalInputStream(inputStream,dataHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 834
    },
    "return": "Object",
    "signature": "public Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\tif (this.streamDriver != null) {\n\t\t\treturn doUnmarshal(this.streamDriver.createReader(inputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\treturn unmarshalReader(new InputStreamReader(inputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalReader(reader,dataHolder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reader",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 848
    },
    "return": "Object",
    "signature": "public Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\treturn doUnmarshal(getDefaultDriver().createReader(reader), dataHolder);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalSaxReader(xmlReader,inputSource)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xmlReader",
      "inputSource"
    ],
    "position": {
      "column": 1,
      "line": 822
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)",
    "source_code": "\tprotected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"XStreamMarshaller does not support unmarshalling using SAX XMLReaders\");\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doBegin(synchronizationManager,transaction,definition)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,\n\t\t\tTransactionDefinition definition)",
    "source_code": "\tprotected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,\n\t\t\tTransactionDefinition definition) throws TransactionException {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\treturn Mono.defer(() -> {\n\t\t\tMono<Connection> connectionMono;\n\n\t\t\tif (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tMono<Connection> newCon = Mono.from(obtainConnectionFactory().create());\n\t\t\t\tconnectionMono = newCon.doOnNext(connection -> {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + newCon + \"] for R2DBC transaction\");\n\t\t\t\t\t}\n\t\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(connection), true);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\t\tconnectionMono = Mono.just(txObject.getConnectionHolder().getConnection());\n\t\t\t}\n\n\t\t\treturn connectionMono.flatMap(con -> {\n\t\t\t\treturn prepareTransactionalConnection(con, definition, transaction)\n\t\t\t\t\t\t.then(Mono.from(doBegin(definition, con)))\n\t\t\t\t\t\t.doOnSuccess(v -> {\n\t\t\t\t\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\t\t\t\t\t\t\tDuration timeout = determineTimeout(definition);\n\t\t\t\t\t\t\tif (!timeout.isNegative() && !timeout.isZero()) {\n\t\t\t\t\t\t\t\ttxObject.getConnectionHolder().setTimeoutInMillis(timeout.toMillis());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Bind the connection holder to the thread.\n\t\t\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\t\t\tsynchronizationManager.bindResource(obtainConnectionFactory(), txObject.getConnectionHolder());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).thenReturn(con).onErrorResume(e -> {\n\t\t\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\t\t\treturn ConnectionFactoryUtils.releaseConnection(con, obtainConnectionFactory())\n\t\t\t\t\t\t\t\t\t\t.doOnTerminate(() -> txObject.setConnectionHolder(null, false))\n\t\t\t\t\t\t\t\t\t\t.then(Mono.error(e));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn Mono.error(e);\n\t\t\t\t\t\t});\n\t\t\t}).onErrorResume(e -> {\n\t\t\t\tCannotCreateTransactionException ex = new CannotCreateTransactionException(\n\t\t\t\t\t\t\"Could not open R2DBC Connection for transaction\", e);\n\t\t\t\treturn Mono.error(ex);\n\t\t\t});\n\t\t}).then();\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCleanupAfterCompletion(synchronizationManager,transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,\n\t\t\tObject transaction)",
    "source_code": "\tprotected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,\n\t\t\tObject transaction) {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\t\t// Remove the connection holder from the context, if exposed.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tsynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t}\n\n\t\t\t// Reset connection.\n\t\t\tConnection con = txObject.getConnectionHolder().getConnection();\n\n\t\t\tMono<Void> afterCleanup = Mono.empty();\n\n\t\t\tif (txObject.isMustRestoreAutoCommit()) {\n\t\t\t\tafterCleanup = afterCleanup.then(Mono.from(con.setAutoCommit(true)));\n\t\t\t}\n\n\t\t\treturn afterCleanup.then(Mono.defer(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Releasing R2DBC Connection [\" + con + \"] after transaction\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ConnectionFactoryUtils.releaseConnection(con, obtainConnectionFactory());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\ttxObject.getConnectionHolder().clear();\n\t\t\t\t}\n\t\t\t\treturn Mono.empty();\n\t\t\t}));\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCommit(TransactionSynchronizationManager,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) throws TransactionException {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tConnection connection = txObject.getConnectionHolder().getConnection();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Committing R2DBC transaction on Connection [\" + connection + \"]\");\n\t\t}\n\t\treturn Mono.from(connection.commitTransaction())\n\t\t\t\t.onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC commit\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doResume(synchronizationManager,transaction,suspendedResources)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager,\n\t\t\t@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager,\n\t\t\t@Nullable Object transaction, Object suspendedResources) throws TransactionException {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tsynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t\t\treturn Mono.empty();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doRollback(TransactionSynchronizationManager,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) throws TransactionException {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tConnection connection = txObject.getConnectionHolder().getConnection();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Rolling back R2DBC transaction on Connection [\" + connection + \"]\");\n\t\t}\n\t\treturn Mono.from(connection.rollbackTransaction())\n\t\t\t\t.onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC rollback\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doSetRollbackOnly(synchronizationManager,status)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status) throws TransactionException {\n\n\t\treturn Mono.fromRunnable(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\t\tif (status.isDebug()) {\n\t\t\t\tlogger.debug(\"Setting R2DBC transaction [\" + txObject.getConnectionHolder().getConnection() +\n\t\t\t\t\t\t\"] rollback-only\");\n\t\t\t}\n\t\t\ttxObject.setRollbackOnly();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doSuspend(synchronizationManager,transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction)",
    "source_code": "\tprotected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction)\n\t\t\tthrows TransactionException {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\t\t\ttxObject.setConnectionHolder(null);\n\t\t\treturn Mono.justOrEmpty(synchronizationManager.unbindResource(obtainConnectionFactory()));\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#prepareTransactionalConnection(con,definition,transaction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@link Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement if the\n\t * {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true} and the\n\t * transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional R2DBC Connection\n\t * @param definition the current transaction definition\n\t * @param transaction the transaction object\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> prepareTransactionalConnection(Connection con, TransactionDefinition definition, Object transaction)",
    "source_code": "\tprotected Mono<Void> prepareTransactionalConnection(\n\t\t\tConnection con, TransactionDefinition definition, Object transaction) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\tMono<Void> prepare = Mono.empty();\n\n\t\tif (isEnforceReadOnly() && definition.isReadOnly()) {\n\t\t\tprepare = Mono.from(con.createStatement(\"SET TRANSACTION READ ONLY\").execute())\n\t\t\t\t\t.flatMapMany(Result::getRowsUpdated)\n\t\t\t\t\t.then();\n\t\t}\n\n\t\t// Switch to manual commit if necessary. This is very expensive in some R2DBC drivers,\n\t\t// so we don't want to do it unnecessarily (for example if we've explicitly\n\t\t// configured the connection pool to set it already).\n\t\tif (con.isAutoCommit()) {\n\t\t\ttxObject.setMustRestoreAutoCommit(true);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Switching R2DBC Connection [\" + con + \"] to manual commit\");\n\t\t\t}\n\t\t\tprepare = prepare.then(Mono.from(con.setAutoCommit(false)));\n\t\t}\n\n\t\treturn prepare;\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#translateException(task,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given R2DBC commit/rollback exception to a common Spring exception to propagate\n\t * from the {@link #commit}/{@link #rollback} call.\n\t * @param task the task description (commit or rollback).\n\t * @param ex the SQLException thrown from commit/rollback.\n\t * @return the translated exception to emit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, R2dbcException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, R2dbcException ex) {\n\t\treturn ConnectionFactoryUtils.convertR2dbcException(task, null, ex);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(identifier,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "void",
    "signature": "public void bind(String identifier, Object value)",
    "source_code": "\t\tpublic void bind(String identifier, Object value) {\n\t\t\tthis.statement.bind(identifier, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(index,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "void",
    "signature": "public void bind(int index, Object value)",
    "source_code": "\t\tpublic void bind(int index, Object value) {\n\t\t\tthis.statement.bind(index, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bind(String name, Object value)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bind(String name, Object value) {\n\t\t\tassertNotPreparedOperation();\n\n\t\t\tAssert.hasText(name, \"Parameter name must not be null or empty!\");\n\t\t\tAssert.notNull(value, () -> String.format(\n\t\t\t\t\t\"Value for parameter %s must not be null. Use bindNull(\u2026) instead.\", name));\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tif (value instanceof Parameter p) {\n\t\t\t\tbyName.put(name, p);\n\t\t\t}\n\t\t\telse if (value instanceof org.springframework.r2dbc.core.Parameter p) {\n\t\t\t\tbyName.put(name, p.hasValue() ? Parameters.in(p.getValue()) : Parameters.in(p.getType()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbyName.put(name, Parameters.in(value));\n\t\t\t}\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(target,identifier,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "identifier",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "void",
    "signature": "public void bind(BindTarget target, String identifier, Parameter parameter)",
    "source_code": "\t\tpublic void bind(BindTarget target, String identifier, Parameter parameter) {\n\t\t\tList<BindMarker> bindMarkers = getBindMarkers(identifier);\n\t\t\tif (bindMarkers == null) {\n\t\t\t\ttarget.bind(identifier, parameter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (parameter.getValue() instanceof Collection) {\n\t\t\t\tCollection<Object> collection = (Collection<Object>) parameter.getValue();\n\t\t\t\tIterator<Object> iterator = collection.iterator();\n\t\t\t\tIterator<BindMarker> markers = bindMarkers.iterator();\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tObject valueToBind = iterator.next();\n\t\t\t\t\tif (valueToBind instanceof Object[] objects) {\n\t\t\t\t\t\tfor (Object object : objects) {\n\t\t\t\t\t\t\tbind(target, markers, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbind(target, markers, valueToBind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (BindMarker bindMarker : bindMarkers) {\n\t\t\t\t\tbindMarker.bind(target, parameter);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(identifier,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "void",
    "signature": "public void bindNull(String identifier, Class<?> type)",
    "source_code": "\t\tpublic void bindNull(String identifier, Class<?> type) {\n\t\t\tthis.statement.bindNull(identifier, type);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(index,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "void",
    "signature": "public void bindNull(int index, Class<?> type)",
    "source_code": "\t\tpublic void bindNull(int index, Class<?> type) {\n\t\t\tthis.statement.bindNull(index, type);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(name,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bindNull(String name, Class<?> type)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bindNull(String name, Class<?> type) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.hasText(name, \"Parameter name must not be null or empty!\");\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tbyName.put(name, Parameters.in(type));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(target,identifier,parameter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "identifier",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void bindNull(BindTarget target, String identifier, Parameter parameter)",
    "source_code": "\t\tpublic void bindNull(BindTarget target, String identifier, Parameter parameter) {\n\t\t\tList<BindMarker> bindMarkers = getBindMarkers(identifier);\n\t\t\tif (bindMarkers == null) {\n\t\t\t\ttarget.bind(identifier, parameter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (BindMarker bindMarker : bindMarkers) {\n\t\t\t\tbindMarker.bind(target, parameter);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#flatMap(Function<Result,mappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Result",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Flux<R>",
    "signature": "public Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction)",
    "source_code": "\t\tpublic <R> Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn flatMap(this.sqlSupplier, mappingFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#fromOrEmpty(value,type)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link Parameter} from {@code value} and {@code type}.\n\t * @param value the parameter value (can be {@code null})\n\t * @param type the parameter type\n\t * @return the {@link Parameter} value for {@code value}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Parameter",
    "signature": "public Parameter fromOrEmpty(@Nullable Object value, Class<?> type)",
    "source_code": "\tpublic static Parameter fromOrEmpty(@Nullable Object value, Class<?> type) {\n\t\treturn (value == null ? empty(type) : new Parameter(value, ClassUtils.getUserClass(value)));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnection(Function<Connection,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> inConnection(Function<Connection, Mono<T>> action)",
    "source_code": "\tpublic <T> Mono<T> inConnection(Function<Connection, Mono<T>> action) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Mono.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Mono.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnection\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"execute\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnectionMany(Function<Connection,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> inConnectionMany(Function<Connection, Flux<T>> action)",
    "source_code": "\tpublic <T> Flux<T> inConnectionMany(Function<Connection, Flux<T>> action) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Flux.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy, also preparing returned Statements.\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Flux.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnectionMany\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"executeMany\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#invoke(proxy,method,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\":\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn proxy == args[0];\n\t\t\t\tcase \"hashCode\":\n\t\t\t\t\t// Use hashCode of PersistenceManager proxy.\n\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\tcase \"unwrap\":\n\t\t\t\t\treturn this.target;\n\t\t\t\tcase \"close\":\n\t\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\t\treturn Mono.error(\n\t\t\t\t\t\t\tnew UnsupportedOperationException(\"Close is not supported!\"));\n\t\t\t}\n\n\t\t\t// Invoke method on target Connection.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.target, args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(BiFunction<Row,RowMetadata,mappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<Row",
      "RowMetadata",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(BiFunction<Row, RowMetadata, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(BiFunction<Row, RowMetadata, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(Readable,mappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Readable",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(Function<? super Readable, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(Function<? super Readable, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#substituteNamedParameters(parsedSql,bindMarkersFactory,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters. Named\n\t * parameters are substituted for a R2DBC placeholder, and any select list is expanded\n\t * to the required number of placeholders. Select lists may contain an array of objects,\n\t * and in that case the placeholders will be grouped and enclosed with parentheses.\n\t * This allows for the use of \"expression lists\" in the SQL statement like:\n\t * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}\n\t * <p>The parameter values passed in are used to determine the number of placeholders to\n\t * be used for a select list. Select lists should be limited to 100 or fewer elements.\n\t * A larger number of elements is not guaranteed to be supported by the database and\n\t * is strictly vendor-dependent.\n\t * @param parsedSql the parsed representation of the SQL statement\n\t * @param bindMarkersFactory the bind marker factory.\n\t * @param paramSource the source for named parameters\n\t * @return the expanded query that accepts bind parameters and allows for execution\n\t * without further translation\n\t * @see #parseSqlStatement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "bindMarkersFactory",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "PreparedOperation<String>",
    "signature": "public PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource)",
    "source_code": "\tpublic static PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {\n\n\t\tNamedParameters markerHolder = new NamedParameters(bindMarkersFactory);\n\t\tString originalSql = parsedSql.getOriginalSql();\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tif (paramNames.isEmpty()) {\n\t\t\treturn new ExpandedQuery(originalSql, markerHolder, paramSource);\n\t\t}\n\n\t\tStringBuilder actualSql = new StringBuilder(originalSql.length());\n\t\tint lastIndex = 0;\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tint[] indexes = parsedSql.getParameterIndexes(i);\n\t\t\tint startIndex = indexes[0];\n\t\t\tint endIndex = indexes[1];\n\t\t\tactualSql.append(originalSql, lastIndex, startIndex);\n\t\t\tNamedParameters.NamedParameter marker = markerHolder.getOrCreate(paramName);\n\t\t\tif (paramSource.hasValue(paramName)) {\n\t\t\t\tParameter parameter = paramSource.getValue(paramName);\n\t\t\t\tif (parameter.getValue() instanceof Collection<?> c) {\n\n\t\t\t\t\tIterator<?> entryIter = c.iterator();\n\t\t\t\t\tint k = 0;\n\t\t\t\t\tint counter = 0;\n\t\t\t\t\twhile (entryIter.hasNext()) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tObject entryItem = entryIter.next();\n\t\t\t\t\t\tif (entryItem instanceof Object[] expressionList) {\n\t\t\t\t\t\t\tactualSql.append('(');\n\t\t\t\t\t\t\tfor (int m = 0; m < expressionList.length; m++) {\n\t\t\t\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactualSql.append(marker.getPlaceholder(counter));\n\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactualSql.append(')');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactualSql.append(marker.getPlaceholder(counter));\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactualSql.append(marker.getPlaceholder());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactualSql.append(marker.getPlaceholder());\n\t\t\t}\n\t\t\tlastIndex = endIndex;\n\t\t}\n\t\tactualSql.append(originalSql, lastIndex, originalSql.length());\n\n\t\treturn new ExpandedQuery(actualSql.toString(), markerHolder, paramSource);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#substituteNamedParameters(sql,bindMarkersFactory,paramSource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * Named parameters are substituted for a native placeholder and any\n\t * select list is expanded to the required number of placeholders.\n\t * @param sql the SQL statement\n\t * @param bindMarkersFactory the bind marker factory\n\t * @param paramSource the source for named parameters\n\t * @return the expanded query that accepts bind parameters and allows for execution\n\t * without further translation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "bindMarkersFactory",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "PreparedOperation<String>",
    "signature": "public PreparedOperation<String> substituteNamedParameters(String sql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource)",
    "source_code": "\tpublic static PreparedOperation<String> substituteNamedParameters(String sql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {\n\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, bindMarkersFactory, paramSource);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#createExecutor(poolSize,threadFactory,rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ScheduledExecutorService} instance.\n\t * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.\n\t * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.\n\t * @param poolSize the specified pool size\n\t * @param threadFactory the ThreadFactory to use\n\t * @param rejectedExecutionHandler the RejectedExecutionHandler to use\n\t * @return a new ScheduledExecutorService instance\n\t * @see #afterPropertiesSet()\n\t * @see java.util.concurrent.ScheduledThreadPoolExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "poolSize",
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "ScheduledExecutorService",
    "signature": "protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ScheduledExecutorService createExecutor(\n\t\t\tint poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {\n\n\t\treturn new ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#execute(task,startTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\texecute(task);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#initializeExecutor(threadFactory,rejectedExecutionHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "ExecutorService",
    "signature": "protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ExecutorService initializeExecutor(\n\t\t\tThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {\n\n\t\tthis.scheduledExecutor = createExecutor(this.poolSize, threadFactory, rejectedExecutionHandler);\n\n\t\tif (this.scheduledExecutor instanceof ScheduledThreadPoolExecutor scheduledPoolExecutor) {\n\t\t\tif (this.removeOnCancelPolicy) {\n\t\t\t\tscheduledPoolExecutor.setRemoveOnCancelPolicy(true);\n\t\t\t}\n\t\t\tif (this.continueExistingPeriodicTasksAfterShutdownPolicy) {\n\t\t\t\tscheduledPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n\t\t\t}\n\t\t\tif (!this.executeExistingDelayedTasksAfterShutdownPolicy) {\n\t\t\t\tscheduledPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n\t\t\t}\n\t\t}\n\n\t\treturn this.scheduledExecutor;\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#compose(fields,type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Composes the given fields into a {@link CronField}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fields",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "CronField",
    "signature": "public CronField compose(CronField[] fields, Type type, String value)",
    "source_code": "\tpublic static CronField compose(CronField[] fields, Type type, String value) {\n\t\tAssert.notEmpty(fields, \"Fields must not be empty\");\n\t\tAssert.hasLength(value, \"Value must not be empty\");\n\n\t\tif (fields.length == 1) {\n\t\t\treturn fields[0];\n\t\t}\n\t\telse {\n\t\t\treturn new CompositeCronField(type, fields, value);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#adaptToInterfaces(script,scriptSource,actualInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "script",
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Object",
    "signature": "protected Object adaptToInterfaces(@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces)",
    "source_code": "\tprotected Object adaptToInterfaces(\n\t\t\t@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces) {\n\n\t\tClass<?> adaptedIfc;\n\t\tif (actualInterfaces.length == 1) {\n\t\t\tadaptedIfc = actualInterfaces[0];\n\t\t}\n\t\telse {\n\t\t\tadaptedIfc = ClassUtils.createCompositeInterface(actualInterfaces, this.beanClassLoader);\n\t\t}\n\n\t\tif (adaptedIfc != null) {\n\t\t\tScriptEngine scriptEngine = this.scriptEngine;\n\t\t\tif (!(scriptEngine instanceof Invocable invocable)) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\"ScriptEngine must implement Invocable in order to adapt it to an interface: \" + scriptEngine);\n\t\t\t}\n\t\t\tif (script != null) {\n\t\t\t\tscript = invocable.getInterface(script, adaptedIfc);\n\t\t\t}\n\t\t\tif (script == null) {\n\t\t\t\tscript = invocable.getInterface(adaptedIfc);\n\t\t\t\tif (script == null) {\n\t\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\t\"Could not adapt script to interface [\" + adaptedIfc.getName() + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Load and parse the script via JSR-223's ScriptEngine.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tObject script = evaluateScript(scriptSource);\n\n\t\tif (!ObjectUtils.isEmpty(actualInterfaces)) {\n\t\t\tboolean adaptationRequired = false;\n\t\t\tfor (Class<?> requestedIfc : actualInterfaces) {\n\t\t\t\tif (script instanceof Class ? !requestedIfc.isAssignableFrom((Class<?>) script) :\n\t\t\t\t\t\t!requestedIfc.isInstance(script)) {\n\t\t\t\t\tadaptationRequired = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (adaptationRequired) {\n\t\t\t\tscript = adaptToInterfaces(script, scriptSource, actualInterfaces);\n\t\t\t}\n\t\t}\n\n\t\tif (script instanceof Class) {\n\t\t\tClass<?> scriptClass = (Class<?>) script;\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"No default constructor on script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Unable to instantiate script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not access script constructor: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"Failed to invoke script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#closeContext(mergedContextConfiguration,hierarchyMode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedContextConfiguration",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedContextConfiguration, @Nullable HierarchyMode hierarchyMode) {\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedContextConfiguration, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#computeAttribute(name,Function<String,computeFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#resolveContextLoader(testClass,configAttributesList)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the\n\t * supplied list of {@link ContextConfigurationAttributes} and then instantiate\n\t * and return that {@code ContextLoader}.\n\t * <p>If the user has not explicitly declared which loader to use, the value\n\t * returned from {@link #getDefaultContextLoaderClass} will be used as the\n\t * default context loader class. For details on the class resolution process,\n\t * see {@link #resolveExplicitContextLoaderClass} and\n\t * {@link #getDefaultContextLoaderClass}.\n\t * @param testClass the test class for which the {@code ContextLoader} should be\n\t * resolved; must not be {@code null}\n\t * @param configAttributesList the list of configuration attributes to process; must\n\t * not be {@code null}; must be ordered <em>bottom-up</em>\n\t * (i.e., as if we were traversing up the class hierarchy)\n\t * @return the resolved {@code ContextLoader} for the supplied {@code testClass}\n\t * (never {@code null})\n\t * @throws IllegalStateException if {@link #getDefaultContextLoaderClass(Class)}\n\t * returns {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testClass",
      "configAttributesList"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "ContextLoader",
    "signature": "protected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList)",
    "source_code": "\tprotected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList) {\n\n\t\tAssert.notNull(testClass, \"Class must not be null\");\n\t\tAssert.notNull(configAttributesList, \"ContextConfigurationAttributes list must not be null\");\n\n\t\tClass<? extends ContextLoader> contextLoaderClass = resolveExplicitContextLoaderClass(configAttributesList);\n\t\tif (contextLoaderClass == null) {\n\t\t\tcontextLoaderClass = getDefaultContextLoaderClass(testClass);\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Using ContextLoader class [%s] for test class [%s]\",\n\t\t\t\t\tcontextLoaderClass.getName(), testClass.getName()));\n\t\t}\n\t\treturn BeanUtils.instantiateClass(contextLoaderClass, ContextLoader.class);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#setAttribute(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tsynchronized (this.attributes) {\n\t\t\tif (value != null) {\n\t\t\t\tthis.attributes.put(name, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.attributes.remove(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#updateState(testInstance,testMethod,testException)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "testException"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void updateState(@Nullable Object testInstance, @Nullable Method testMethod, @Nullable Throwable testException)",
    "source_code": "\tpublic void updateState(@Nullable Object testInstance, @Nullable Method testMethod, @Nullable Throwable testException) {\n\t\tthis.testInstance = testInstance;\n\t\tthis.testMethod = testMethod;\n\t\tthis.testException = testException;\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#createDelegatingTransactionAttribute(testContext,targetAttribute)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a delegating {@link TransactionAttribute} for the supplied target\n\t * {@link TransactionAttribute} and {@link TestContext}, using the names of\n\t * the test class and test method to build the name of the transaction.\n\t * @param testContext the {@code TestContext} upon which to base the name\n\t * @param targetAttribute the {@code TransactionAttribute} to delegate to\n\t * @return the delegating {@code TransactionAttribute}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "targetAttribute"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute createDelegatingTransactionAttribute(TestContext testContext, TransactionAttribute targetAttribute)",
    "source_code": "\tpublic static TransactionAttribute createDelegatingTransactionAttribute(\n\t\t\tTestContext testContext, TransactionAttribute targetAttribute) {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(targetAttribute, \"Target TransactionAttribute must not be null\");\n\t\treturn new TestContextTransactionAttribute(targetAttribute, testContext);\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#retrieveDataSource(testContext,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@link DataSource} to use for the supplied {@linkplain TestContext\n\t * test context}.\n\t * <p>The following algorithm is used to retrieve the {@code DataSource} from\n\t * the {@link org.springframework.context.ApplicationContext ApplicationContext}\n\t * of the supplied test context:\n\t * <ol>\n\t * <li>Look up the {@code DataSource} by type and name, if the supplied\n\t * {@code name} is non-empty, throwing a {@link BeansException} if the named\n\t * {@code DataSource} does not exist.\n\t * <li>Attempt to look up the single {@code DataSource} by type.\n\t * <li>Attempt to look up the <em>primary</em> {@code DataSource} by type.\n\t * <li>Attempt to look up the {@code DataSource} by type and the\n\t * {@linkplain #DEFAULT_DATA_SOURCE_NAME default data source name}.\n\t * </ol>\n\t * @param testContext the test context for which the {@code DataSource}\n\t * should be retrieved; never {@code null}\n\t * @param name the name of the {@code DataSource} to retrieve\n\t * (may be {@code null} or <em>empty</em>)\n\t * @return the {@code DataSource} to use, or {@code null} if not found\n\t * @throws BeansException if an error occurs while retrieving an explicitly\n\t * named {@code DataSource}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "DataSource",
    "signature": "public DataSource retrieveDataSource(TestContext testContext, @Nullable String name)",
    "source_code": "\tpublic static DataSource retrieveDataSource(TestContext testContext, @Nullable String name) {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\n\t\ttry {\n\t\t\t// Look up by type and explicit name\n\t\t\tif (StringUtils.hasText(name)) {\n\t\t\t\treturn bf.getBean(name, DataSource.class);\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.error(String.format(\"Failed to retrieve DataSource named '%s' for test context %s\",\n\t\t\t\t\tname, testContext), ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\ttry {\n\t\t\tif (bf instanceof ListableBeanFactory lbf) {\n\t\t\t\t// Look up single bean by type\n\t\t\t\tMap<String, DataSource> dataSources =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, DataSource.class);\n\t\t\t\tif (dataSources.size() == 1) {\n\t\t\t\t\treturn dataSources.values().iterator().next();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// look up single bean by type, with support for 'primary' beans\n\t\t\t\t\treturn bf.getBean(DataSource.class);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name\n\t\t\treturn bf.getBean(DEFAULT_DATA_SOURCE_NAME, DataSource.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogBeansException(testContext, ex, DataSource.class);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#retrieveTransactionManager(testContext,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@linkplain PlatformTransactionManager transaction manager}\n\t * to use for the supplied {@linkplain TestContext test context}.\n\t * <p>The following algorithm is used to retrieve the transaction manager\n\t * from the {@link org.springframework.context.ApplicationContext ApplicationContext}\n\t * of the supplied test context:\n\t * <ol>\n\t * <li>Look up the transaction manager by type and explicit name, if the supplied\n\t * {@code name} is non-empty, throwing a {@link BeansException} if the named\n\t * transaction manager does not exist.\n\t * <li>Attempt to look up the transaction manager via a\n\t * {@link TransactionManagementConfigurer}, if present.\n\t * <li>Attempt to look up the single transaction manager by type.\n\t * <li>Attempt to look up the <em>primary</em> transaction manager by type.\n\t * <li>Attempt to look up the transaction manager by type and the\n\t * {@linkplain #DEFAULT_TRANSACTION_MANAGER_NAME default transaction manager\n\t * name}.\n\t * </ol>\n\t * @param testContext the test context for which the transaction manager\n\t * should be retrieved; never {@code null}\n\t * @param name the name of the transaction manager to retrieve\n\t * (may be {@code null} or <em>empty</em>)\n\t * @return the transaction manager to use, or {@code null} if not found\n\t * @throws BeansException if an error occurs while retrieving an explicitly\n\t * named transaction manager\n\t * @throws IllegalStateException if more than one TransactionManagementConfigurer\n\t * exists in the ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "PlatformTransactionManager",
    "signature": "public PlatformTransactionManager retrieveTransactionManager(TestContext testContext, @Nullable String name)",
    "source_code": "\tpublic static PlatformTransactionManager retrieveTransactionManager(TestContext testContext, @Nullable String name) {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\n\t\ttry {\n\t\t\t// Look up by type and explicit name\n\t\t\tif (StringUtils.hasText(name)) {\n\t\t\t\treturn bf.getBean(name, PlatformTransactionManager.class);\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.error(String.format(\"Failed to retrieve transaction manager named '%s' for test context %s\",\n\t\t\t\t\tname, testContext), ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\ttry {\n\t\t\tif (bf instanceof ListableBeanFactory lbf) {\n\t\t\t\t// Look up single TransactionManagementConfigurer\n\t\t\t\tMap<String, TransactionManagementConfigurer> configurers =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, TransactionManagementConfigurer.class);\n\t\t\t\tAssert.state(configurers.size() <= 1,\n\t\t\t\t\t\t\"Only one TransactionManagementConfigurer may exist in the ApplicationContext\");\n\t\t\t\tif (configurers.size() == 1) {\n\t\t\t\t\tTransactionManager tm = configurers.values().iterator().next().annotationDrivenTransactionManager();\n\t\t\t\t\tAssert.state(tm instanceof PlatformTransactionManager, () ->\n\t\t\t\t\t\t\"Transaction manager specified via TransactionManagementConfigurer \" +\n\t\t\t\t\t\t\"is not a PlatformTransactionManager: \" + tm);\n\t\t\t\t\treturn (PlatformTransactionManager) tm;\n\t\t\t\t}\n\n\t\t\t\t// Look up single bean by type\n\t\t\t\tMap<String, PlatformTransactionManager> txMgrs =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, PlatformTransactionManager.class);\n\t\t\t\tif (txMgrs.size() == 1) {\n\t\t\t\t\treturn txMgrs.values().iterator().next();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// Look up single bean by type, with support for 'primary' beans\n\t\t\t\t\treturn bf.getBean(PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name\n\t\t\treturn bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.socket.<unknown>#customizeContext(context,mergedConfig)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tif (context instanceof WebApplicationContext wac) {\n\t\t\tServletContext sc = wac.getServletContext();\n\t\t\tif (sc != null) {\n\t\t\t\tsc.setAttribute(\"jakarta.websocket.server.ServerContainer\", new MockServerContainer());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,expectedValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the JSON path expression against the supplied {@code content}\n\t * and assert that the result is equal to the expected value.\n\t * @param content the JSON content\n\t * @param expectedValue the expected value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void assertValue(String content, @Nullable Object expectedValue)",
    "source_code": "\tpublic void assertValue(String content, @Nullable Object expectedValue) {\n\t\tObject actualValue = evaluateJsonPath(content);\n\t\tif ((actualValue instanceof List<?> actualValueList) && !(expectedValue instanceof List)) {\n\t\t\tif (actualValueList.isEmpty()) {\n\t\t\t\tAssertionErrors.fail(\"No matching value at JSON path \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tif (actualValueList.size() != 1) {\n\t\t\t\tAssertionErrors.fail(\"Got a list of values \" + actualValue +\n\t\t\t\t\t\t\" instead of the expected single value \" + expectedValue);\n\t\t\t}\n\t\t\tactualValue = actualValueList.get(0);\n\t\t}\n\t\telse if (actualValue != null && expectedValue != null &&\n\t\t\t\t!actualValue.getClass().equals(expectedValue.getClass())) {\n\t\t\ttry {\n\t\t\t\tactualValue = evaluateJsonPath(content, expectedValue.getClass());\n\t\t\t}\n\t\t\tcatch (AssertionError error) {\n\t\t\t\tString message = String.format(\n\t\t\t\t\t\"At JSON path \\\"%s\\\", value <%s> of type <%s> cannot be converted to type <%s>\",\n\t\t\t\t\tthis.expression, actualValue, ClassUtils.getDescriptiveType(actualValue),\n\t\t\t\t\tClassUtils.getDescriptiveType(expectedValue));\n\t\t\t\tthrow new AssertionError(message, error.getCause());\n\t\t\t}\n\t\t}\n\t\tAssertionErrors.assertEquals(\"JSON path \\\"\" + this.expression + \"\\\"\", expectedValue, actualValue);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,matcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the JSON path expression against the supplied {@code content}\n\t * and assert the resulting value with the given {@code Matcher}.\n\t * @param content the JSON content\n\t * @param matcher the matcher with which to assert the result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void assertValue(String content, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> void assertValue(String content, Matcher<? super T> matcher) {\n\t\tT value = (T) evaluateJsonPath(content);\n\t\tMatcherAssert.assertThat(\"JSON path \\\"\" + this.expression + \"\\\"\", value, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,matcher,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded variant of {@link #assertValue(String, Matcher)} that also\n\t * accepts a target type for the resulting value. This can be useful for\n\t * matching numbers reliably for example coercing an integer into a double.\n\t * @param content the JSON content\n\t * @param matcher the matcher with which to assert the result\n\t * @param targetType the expected type of the resulting value\n\t * @since 4.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "matcher",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void assertValue(String content, Matcher<? super T> matcher, Class<T> targetType)",
    "source_code": "\tpublic <T> void assertValue(String content, Matcher<? super T> matcher, Class<T> targetType) {\n\t\tT value = (T) evaluateJsonPath(content, targetType);\n\t\tMatcherAssert.assertThat(\"JSON path \\\"\" + this.expression + \"\\\"\", value, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateJsonPath(content,targetType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type.\n\t * <p>This can be useful for matching numbers reliably for example coercing an\n\t * integer into a double.\n\t * @param content the content to evaluate against\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "Object",
    "signature": "public Object evaluateJsonPath(String content, Class<?> targetType)",
    "source_code": "\tpublic Object evaluateJsonPath(String content, Class<?> targetType) {\n\t\ttry {\n\t\t\treturn JsonPath.parse(content).read(this.expression, targetType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tString message = \"No value at JSON path \\\"\" + this.expression + \"\\\"\";\n\t\t\tthrow new AssertionError(message, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#file(name,content)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MockMultipartFile with the given content.\n\t * @param name the name of the file\n\t * @param content the content of the file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "MockMultipartHttpServletRequestBuilder",
    "signature": "public MockMultipartHttpServletRequestBuilder file(String name, byte[] content)",
    "source_code": "\tpublic MockMultipartHttpServletRequestBuilder file(String name, byte[] content) {\n\t\tthis.files.add(new MockMultipartFile(name, content));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttrs(Map<String,flashAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#header(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder header(String name, Object... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#param(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder param(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#params(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParam(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParam(String name, String... values)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap)}  request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#requestAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder requestAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttr(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttr(String name, Object value)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttrs(Map<String,sessionAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "MockHttpServletRequestBuilder",
    "signature": "public MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#printHandler(handler,interceptors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Print the handler.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "protected void printHandler(@Nullable Object handler, @Nullable HandlerInterceptor[] interceptors)",
    "source_code": "\tprotected void printHandler(@Nullable Object handler, @Nullable HandlerInterceptor[] interceptors)\n\t\t\tthrows Exception {\n\n\t\tif (handler == null) {\n\t\t\tthis.printer.printValue(\"Type\", null);\n\t\t}\n\t\telse {\n\t\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\t\tthis.printer.printValue(\"Type\", handlerMethod.getBeanType().getName());\n\t\t\t\tthis.printer.printValue(\"Method\", handlerMethod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.printer.printValue(\"Type\", handler.getClass().getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(clazz,mappedName,attr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * Method names can end or start with \"*\" for matching multiple methods.\n\t * @param clazz target interface or class\n\t * @param mappedName mapped method name\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mappedName",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(mappedName, \"Mapped name must not be null\");\n\t\tString name = clazz.getName() + '.'  + mappedName;\n\n\t\tMethod[] methods = clazz.getDeclaredMethods();\n\t\tList<Method> matchingMethods = new ArrayList<>();\n\t\tfor (Method method : methods) {\n\t\t\tif (isMatch(method.getName(), mappedName)) {\n\t\t\t\tmatchingMethods.add(method);\n\t\t\t}\n\t\t}\n\t\tif (matchingMethods.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not find method '\" + mappedName + \"' on class [\" + clazz.getName() + \"]\");\n\t\t}\n\n\t\t// Register all matching methods\n\t\tfor (Method method : matchingMethods) {\n\t\t\tString regMethodName = this.methodNameMap.get(method);\n\t\t\tif (regMethodName == null || (!regMethodName.equals(name) && regMethodName.length() <= name.length())) {\n\t\t\t\t// No already registered method name, or more specific\n\t\t\t\t// method name specification now -> (re-)register method.\n\t\t\t\tif (logger.isDebugEnabled() && regMethodName != null) {\n\t\t\t\t\tlogger.debug(\"Replacing attribute for transactional method [\" + method + \"]: current name '\" +\n\t\t\t\t\t\t\tname + \"' is more specific than '\" + regMethodName + \"'\");\n\t\t\t\t}\n\t\t\t\tthis.methodNameMap.put(method, name);\n\t\t\t\taddTransactionalMethod(method, attr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Keeping attribute for transactional method [\" + method + \"]: current name '\" +\n\t\t\t\t\t\t\tname + \"' is not more specific than '\" + regMethodName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(method,attr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * @param method the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Method method, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Method method, TransactionAttribute attr) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tAssert.notNull(attr, \"TransactionAttribute must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + method + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.transactionAttributeMap.put(method, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(methodName,attr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can be exact matches, or of the pattern \"xxx*\",\n\t * \"*xxx\", or \"*xxx*\" for matching multiple methods.\n\t * @param methodName the name of the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String methodName, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String methodName, TransactionAttribute attr) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + methodName + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.nameMap.put(methodName, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(name,attr)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can end or start with \"*\" for matching multiple methods.\n\t * @param name class and method name, separated by a dot\n\t * @param attr attribute associated with the method\n\t * @throws IllegalArgumentException in case of an invalid name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String name, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String name, TransactionAttribute attr) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tint lastDotIndex = name.lastIndexOf('.');\n\t\tif (lastDotIndex == -1) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + name + \"' is not a valid method name: format is FQN.methodName\");\n\t\t}\n\t\tString className = name.substring(0, lastDotIndex);\n\t\tString methodName = name.substring(lastDotIndex + 1);\n\t\tClass<?> clazz = ClassUtils.resolveClassName(className, this.beanClassLoader);\n\t\taddTransactionalMethod(clazz, methodName, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#computeTransactionAttribute(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Same signature as {@link #getTransactionAttribute}, but doesn't cache the result.\n\t * {@link #getTransactionAttribute} is effectively a caching decorator for this method.\n\t * <p>As of 4.1.8, this method can be overridden.\n\t * @since 4.1.8\n\t * @see #getTransactionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "TransactionAttribute",
    "signature": "protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\t// Don't allow non-public methods, as configured.\n\t\tif (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// The method may be on an interface, but we need attributes from the target class.\n\t\t// If the target class is null, the method will be unchanged.\n\t\tMethod specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\n\t\t// First try is the method in the target class.\n\t\tTransactionAttribute txAttr = findTransactionAttribute(specificMethod);\n\t\tif (txAttr != null) {\n\t\t\treturn txAttr;\n\t\t}\n\n\t\t// Second try is the transaction attribute on the target class.\n\t\ttxAttr = findTransactionAttribute(specificMethod.getDeclaringClass());\n\t\tif (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n\t\t\treturn txAttr;\n\t\t}\n\n\t\tif (specificMethod != method) {\n\t\t\t// Fallback is to look at the original method.\n\t\t\ttxAttr = findTransactionAttribute(method);\n\t\t\tif (txAttr != null) {\n\t\t\t\treturn txAttr;\n\t\t\t}\n\t\t\t// Last fallback is the class of the original method.\n\t\t\ttxAttr = findTransactionAttribute(method.getDeclaringClass());\n\t\t\tif (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n\t\t\t\treturn txAttr;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getCacheKey(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a cache key for the given method and target class.\n\t * <p>Must not produce same key for overloaded methods.\n\t * Must produce same key for different instances of the same method.\n\t * @param method the method (never {@code null})\n\t * @param targetClass the target class (may be {@code null})\n\t * @return the cache key (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {\n\t\treturn new MethodClassKey(method, targetClass);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getTransactionAttribute(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (ClassUtils.isUserLevelMethod(method) ? this.transactionAttribute : null);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#initMethodMap(Map<String,methodMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the specified {@link #setMethodMap(java.util.Map) \"methodMap\"}, if any.\n\t * @param methodMap a Map from method names to {@code TransactionAttribute} instances\n\t * @see #setMethodMap\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "methodMap"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "protected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap)",
    "source_code": "\tprotected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap) {\n\t\tif (methodMap != null) {\n\t\t\tmethodMap.forEach(this::addTransactionalMethod);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\"\n\t * matches, as well as direct equality.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#matches(method,targetClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tTransactionAttributeSource tas = getTransactionAttributeSource();\n\t\treturn (tas == null || tas.getTransactionAttribute(method, targetClass) != null);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#setMethodMap(Map<String,methodMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of \"FQCN.method\" method names\n\t * (e.g. \"com.mycompany.mycode.MyClass.myMethod\") and\n\t * {@link TransactionAttribute} instances (or Strings to be converted\n\t * to {@code TransactionAttribute} instances).\n\t * <p>Intended for configuration via setter injection, typically within\n\t * a Spring bean factory. Relies on {@link #afterPropertiesSet()}\n\t * being called afterwards.\n\t * @param methodMap said {@link Map} from method name to attribute value\n\t * @see TransactionAttribute\n\t * @see TransactionAttributeEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "methodMap"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMethodMap(Map<String, TransactionAttribute> methodMap)",
    "source_code": "\tpublic void setMethodMap(Map<String, TransactionAttribute> methodMap) {\n\t\tthis.methodMap = methodMap;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#setNameMap(Map<String,nameMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of method names\n\t * (e.g. \"myMethod\") and {@link TransactionAttribute} instances.\n\t * @see #setProperties\n\t * @see TransactionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "nameMap"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void setNameMap(Map<String, TransactionAttribute> nameMap)",
    "source_code": "\tpublic void setNameMap(Map<String, TransactionAttribute> nameMap) {\n\t\tnameMap.forEach(this::addTransactionalMethod);\n\t}"
  },
  "org.springframework.util.<unknown>#add(Entry<K,kListEntry)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "kListEntry"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "boolean",
    "signature": "public boolean add(Entry<K, List<V>> kListEntry)",
    "source_code": "\t\tpublic boolean add(Entry<K, List<V>> kListEntry) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#add(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "void",
    "signature": "public void add(K key, @Nullable V value)",
    "source_code": "\tpublic void add(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(Entry<K,c)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "boolean",
    "signature": "public boolean addAll(Collection<? extends Entry<K, List<V>>> c)",
    "source_code": "\t\tpublic boolean addAll(Collection<? extends Entry<K, List<V>>> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#addAll(MultiValueMap<K,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<K",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<K, V> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<K, V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(key,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void addAll(K key, List<? extends V> values)",
    "source_code": "\tpublic void addAll(K key, List<? extends V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addIfAbsent(K key, @Nullable V value)",
    "source_code": "\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#calculateShift(minimumValue,maximumValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate a shift value that can be used to create a power-of-two value between\n\t * the specified maximum and minimum values.\n\t * @param minimumValue the minimum value\n\t * @param maximumValue the maximum value\n\t * @return the calculated shift (use {@code 1 << shift} to obtain a value)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "minimumValue",
      "maximumValue"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "int",
    "signature": "protected int calculateShift(int minimumValue, int maximumValue)",
    "source_code": "\tprotected static int calculateShift(int minimumValue, int maximumValue) {\n\t\tint shift = 0;\n\t\tint value = 1;\n\t\twhile (value < minimumValue && value < maximumValue) {\n\t\t\tvalue <<= 1;\n\t\t\tshift++;\n\t\t}\n\t\treturn shift;\n\t}"
  },
  "org.springframework.util.<unknown>#checkParameters(parameter,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void checkParameters(String parameter, String value)",
    "source_code": "\tprotected void checkParameters(String parameter, String value) {\n\t\tAssert.hasLength(parameter, \"'parameter' must not be empty\");\n\t\tAssert.hasLength(value, \"'value' must not be empty\");\n\t\tcheckToken(parameter);\n\t\tif (PARAM_CHARSET.equals(parameter)) {\n\t\t\tif (this.resolvedCharset == null) {\n\t\t\t\tthis.resolvedCharset = Charset.forName(unquote(value));\n\t\t\t}\n\t\t}\n\t\telse if (!isQuotedString(value)) {\n\t\t\tcheckToken(value);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#compare(mimeType1,mimeType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 714
    },
    "return": "int",
    "signature": "public int compare(T mimeType1, T mimeType2)",
    "source_code": "\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#compareParameters(mimeType1,mimeType2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 740
    },
    "return": "int",
    "signature": "protected int compareParameters(T mimeType1, T mimeType2)",
    "source_code": "\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}"
  },
  "org.springframework.util.<unknown>#compute(key,K,List<V>,remappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "List<V>",
    "signature": "public List<V> compute(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> compute(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfAbsent(key,K,mappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "List<V>",
    "signature": "public List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction)",
    "source_code": "\tpublic List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfPresent(key,K,List<V>,remappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "List<V>",
    "signature": "public List<V> computeIfPresent(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> computeIfPresent(K key,\n\t\t\tBiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#createReference(Entry<K,entry,hash,Reference<K,next)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Factory method used to create a new {@link Reference}.\n\t\t * @param entry the entry contained in the reference\n\t\t * @param hash the hash\n\t\t * @param next the next reference in the chain, or {@code null} if none\n\t\t * @return a new {@link Reference}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "entry",
      "hash",
      "Reference<K",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 995
    },
    "return": "V>",
    "signature": "public V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next)",
    "source_code": "\t\tpublic Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\n\t\t\tif (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\n\t\t\t\treturn new WeakEntryReference<>(entry, hash, next, this.queue);\n\t\t\t}\n\t\t\treturn new SoftEntryReference<>(entry, hash, next, this.queue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#doTask(hash,key,task)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Apply an update operation to this segment.\n\t\t * The segment will be locked during the update.\n\t\t * @param hash the hash of the key\n\t\t * @param key the key\n\t\t * @param task the update operation\n\t\t * @return the result of the operation\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hash",
      "key",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "T",
    "signature": "public T doTask(final int hash, @Nullable final Object key, final Task<T> task)",
    "source_code": "\t\tpublic <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {\n\t\t\tboolean resize = task.hasOption(TaskOption.RESIZE);\n\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\n\t\t\t\trestructureIfNecessary(resize);\n\t\t\t}\n\t\t\tif (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\n\t\t\t\treturn task.execute(null, null, null);\n\t\t\t}\n\t\t\tlock();\n\t\t\ttry {\n\t\t\t\tfinal int index = getIndex(hash, this.references);\n\t\t\t\tfinal Reference<K, V> head = this.references[index];\n\t\t\t\tReference<K, V> ref = findInChain(head, key, hash);\n\t\t\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\t\t\tEntries<V> entries = value -> {\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tEntry<K, V> newEntry = new Entry<>((K) key, value);\n\t\t\t\t\tReference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\n\t\t\t\t\tSegment.this.references[index] = newReference;\n\t\t\t\t\tSegment.this.count.incrementAndGet();\n\t\t\t\t};\n\t\t\t\treturn task.execute(ref, entry, entries);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tunlock();\n\t\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\n\t\t\t\t\trestructureIfNecessary(resize);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#execute(Reference<K,ref,Entry<K,entry)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Convenience method that can be used for tasks that do not need access to {@link Entries}.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry, Entries)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Reference<K",
      "ref",
      "Entry<K",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 815
    },
    "return": "T",
    "signature": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry)",
    "source_code": "\t\tprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.util.<unknown>#execute(Reference<K,ref,Entry<K,entry,entries)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Execute the task.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @param entries access to the underlying entries\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Reference<K",
      "ref",
      "Entry<K",
      "entry",
      "entries"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "T",
    "signature": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries)",
    "source_code": "\t\tprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\n\t\t\treturn execute(ref, entry);\n\t\t}"
  },
  "org.springframework.util.<unknown>#forEach(Entry<K,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "void",
    "signature": "public void forEach(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\tpublic void forEach(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\tthis.delegate.forEach(e -> action.accept(new UnmodifiableEntry<>(e)));\n\t\t}"
  },
  "org.springframework.util.<unknown>#forEach(K,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void forEach(BiConsumer<? super K, ? super List<V>> action)",
    "source_code": "\tpublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\n\t\tthis.delegate.forEach((k, vs) -> action.accept(k, Collections.unmodifiableList(vs)));\n\t}"
  },
  "org.springframework.util.<unknown>#forEachRemaining(Entry<K,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "void",
    "signature": "public void forEachRemaining(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\t\tpublic void forEachRemaining(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\tthis.delegate.forEachRemaining(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}"
  },
  "org.springframework.util.<unknown>#getOrDefault(key,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "V",
    "signature": "public V getOrDefault(@Nullable Object key, @Nullable V defaultValue)",
    "source_code": "\tpublic V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n\t\tReference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\n\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\treturn (entry != null ? entry.getValue() : defaultValue);\n\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,hash,restructure)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hash",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "V>",
    "signature": "public V> getReference(@Nullable Object key, int hash, Restructure restructure)",
    "source_code": "\t\tpublic Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\n\t\t\tif (restructure == Restructure.WHEN_NECESSARY) {\n\t\t\t\trestructureIfNecessary(false);\n\t\t\t}\n\t\t\tif (this.count.get() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Use a local copy to protect against other threads writing\n\t\t\tReference<K, V>[] references = this.references;\n\t\t\tint index = getIndex(hash, references);\n\t\t\tReference<K, V> head = references[index];\n\t\t\treturn findInChain(head, key, hash);\n\t\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,restructure)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\n\t * or {@code null} if not found.\n\t * @param key the key (can be {@code null})\n\t * @param restructure types of restructure allowed during this call\n\t * @return the reference, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "V>",
    "signature": "protected V> getReference(@Nullable Object key, Restructure restructure)",
    "source_code": "\tprotected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {\n\t\tint hash = getHash(key);\n\t\treturn getSegmentForHash(hash).getReference(key, hash, restructure);\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(lhsType,rhsType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type following the Java generics rules.\n\t * @param lhsType the target type\n\t * @param rhsType the value type that should be assigned to the target type\n\t * @return true if rhs is assignable to lhs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean isAssignable(Type lhsType, Type rhsType)",
    "source_code": "\tpublic static boolean isAssignable(Type lhsType, Type rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\n\t\t// all types are assignable to themselves and to class Object\n\t\tif (lhsType.equals(rhsType) || Object.class == lhsType) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lhsType instanceof Class<?> lhsClass) {\n\t\t\t// just comparing two classes\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t}\n\n\t\t\tif (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\tType rhsRaw = rhsParameterizedType.getRawType();\n\n\t\t\t\t// a parameterized type is always assignable to its raw class type\n\t\t\t\tif (rhsRaw instanceof Class<?> rhRawClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhRawClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lhsClass.isArray() && rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsClass.getComponentType(), rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\t// parameterized types are only assignable to other parameterized types and class types\n\t\tif (lhsType instanceof ParameterizedType lhsParameterizedType) {\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\tType lhsRaw = lhsParameterizedType.getRawType();\n\n\t\t\t\tif (lhsRaw instanceof Class<?> lhsClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\treturn isAssignable(lhsParameterizedType, rhsParameterizedType);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof GenericArrayType lhsGenericArrayType) {\n\t\t\tType lhsComponent = lhsGenericArrayType.getGenericComponentType();\n\n\t\t\tif (rhsType instanceof Class<?> rhsClass && rhsClass.isArray()) {\n\t\t\t\treturn isAssignable(lhsComponent, rhsClass.getComponentType());\n\t\t\t}\n\t\t\telse if (rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsComponent, rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof WildcardType lhsWildcardType) {\n\t\t\treturn isAssignable(lhsWildcardType, rhsType);\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignableBound(lhsType,rhsType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "boolean",
    "signature": "public boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType)",
    "source_code": "\tpublic static boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType) {\n\t\tif (rhsType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lhsType == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn isAssignable(lhsType, rhsType);\n\t}"
  },
  "org.springframework.util.<unknown>#merge(key,value,List<V>,List<V>,remappingFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "List<V>",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "List<V>",
    "signature": "public List<V> merge(K key, List<V> value,\n\t\t\tBiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> merge(K key, List<V> value,\n\t\t\tBiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "V",
    "signature": "public V put(@Nullable K key, @Nullable V value)",
    "source_code": "\tpublic V put(@Nullable K key, @Nullable V value) {\n\t\treturn put(key, value, true);\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,m)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "m"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends List<V>> m)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends List<V>> m) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#putIfAbsent(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "V",
    "signature": "public V putIfAbsent(@Nullable K key, @Nullable V value)",
    "source_code": "\tpublic V putIfAbsent(@Nullable K key, @Nullable V value) {\n\t\treturn put(key, value, false);\n\t}"
  },
  "org.springframework.util.<unknown>#remove(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "boolean",
    "signature": "public boolean remove(@Nullable Object key, final @Nullable Object value)",
    "source_code": "\tpublic boolean remove(@Nullable Object key, final @Nullable Object value) {\n\t\tBoolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {\n\t\t\t\t\tif (ref != null) {\n\t\t\t\t\t\tref.release();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn (Boolean.TRUE.equals(result));\n\t}"
  },
  "org.springframework.util.<unknown>#removeIf(Entry<K,filter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "boolean",
    "signature": "public boolean removeIf(Predicate<? super Entry<K, List<V>>> filter)",
    "source_code": "\t\tpublic boolean removeIf(Predicate<? super Entry<K, List<V>>> filter) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#replace(key,oldValue,newValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "oldValue",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "public boolean replace(@Nullable K key, final @Nullable V oldValue, final @Nullable V newValue)",
    "source_code": "\tpublic boolean replace(@Nullable K key, final @Nullable V oldValue, final @Nullable V newValue) {\n\t\tBoolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {\n\t\t\t\t\tentry.setValue(newValue);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn (Boolean.TRUE.equals(result));\n\t}"
  },
  "org.springframework.util.<unknown>#replace(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "V",
    "signature": "public V replace(@Nullable K key, final @Nullable V value)",
    "source_code": "\tpublic V replace(@Nullable K key, final @Nullable V value) {\n\t\treturn doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tprotected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null) {\n\t\t\t\t\tV oldValue = entry.getValue();\n\t\t\t\t\tentry.setValue(value);\n\t\t\t\t\treturn oldValue;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.util.<unknown>#replaceAll(K,List<V>,function)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "List<V>",
      "function"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function)",
    "source_code": "\tpublic void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#set(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void set(K key, @Nullable V value)",
    "source_code": "\tpublic void set(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#setAll(Map<K,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setAll(Map<K, V> values)",
    "source_code": "\tpublic void setAll(Map<K, V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#tryAdvance(Entry<K,action)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "boolean",
    "signature": "public boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\t\tpublic boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\treturn this.delegate.tryAdvance(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}"
  },
  "org.springframework.validation.<unknown>#findEditor(field,valueType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the\n\t * {@link #getPropertyEditorRegistry() PropertyEditorRegistry}'s\n\t * editor lookup facility, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType)",
    "source_code": "\tpublic PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType) {\n\t\tPropertyEditorRegistry editorRegistry = getPropertyEditorRegistry();\n\t\tif (editorRegistry != null) {\n\t\t\tClass<?> valueTypeToUse = valueType;\n\t\t\tif (valueTypeToUse == null) {\n\t\t\t\tvalueTypeToUse = getFieldType(field);\n\t\t\t}\n\t\t\treturn editorRegistry.findCustomEditor(valueTypeToUse, fixedField(field));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#formatFieldValue(field,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Format the given value for the specified field.\n\t * <p>The default implementation simply returns the field value as-is.\n\t * @param field the field to check\n\t * @param value the value of the field (either a rejected value\n\t * other than from a binding error, or an actual field value)\n\t * @return the formatted value\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "Object",
    "signature": "protected Object formatFieldValue(String field, @Nullable Object value)",
    "source_code": "\tprotected Object formatFieldValue(String field, @Nullable Object value) {\n\t\treturn value;\n\t}"
  },
  "org.springframework.validation.<unknown>#recordFieldValue(field,type,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void recordFieldValue(String field, Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.fieldTypes.put(field, type);\n\t\tthis.fieldValues.put(field, value);\n\t}"
  },
  "org.springframework.validation.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\taddError(new ObjectError(getObjectName(), resolveMessageCodes(errorCode), errorArgs, defaultMessage));\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage) {\n\n\t\tif (!StringUtils.hasLength(getNestedPath()) && !StringUtils.hasLength(field)) {\n\t\t\t// We're at the top of the nested object hierarchy,\n\t\t\t// so the present level is not a field but rather the top object.\n\t\t\t// The best we can do is register a global error here...\n\t\t\treject(errorCode, errorArgs, defaultMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tString fixedField = fixedField(field);\n\t\tObject newVal = getActualFieldValue(fixedField);\n\t\tFieldError fe = new FieldError(getObjectName(), fixedField, newVal, false,\n\t\t\t\tresolveMessageCodes(errorCode, field), errorArgs, defaultMessage);\n\t\taddError(fe);\n\t}"
  },
  "org.springframework.validation.<unknown>#resolveMessageCodes(errorCode,field)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode, @Nullable String field)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode, @Nullable String field) {\n\t\treturn getMessageCodesResolver().resolveMessageCodes(\n\t\t\t\terrorCode, getObjectName(), fixedField(field), getFieldType(field));\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getArgumentsForConstraint(objectName,field,descriptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return FieldError arguments for a validation error on the given field.\n\t * Invoked for each violated constraint.\n\t * <p>The default implementation returns a first argument indicating the field name\n\t * (see {@link #getResolvableField}). Afterwards, it adds all actual constraint\n\t * annotation attributes (i.e. excluding \"message\", \"groups\" and \"payload\") in\n\t * alphabetical order of their attribute names.\n\t * <p>Can be overridden to e.g. add further attributes from the constraint descriptor.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @param descriptor the JSR-303 constraint descriptor\n\t * @return the Object array that represents the FieldError arguments\n\t * @see org.springframework.validation.FieldError#getArguments\n\t * @see org.springframework.context.support.DefaultMessageSourceResolvable\n\t * @see org.springframework.validation.DefaultBindingErrorProcessor#getArgumentsForBindError\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName",
      "field",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Object[]",
    "signature": "protected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor)",
    "source_code": "\tprotected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor) {\n\t\tList<Object> arguments = new ArrayList<>();\n\t\targuments.add(getResolvableField(objectName, field));\n\t\t// Using a TreeMap for alphabetical ordering of attribute names\n\t\tMap<String, Object> attributesToExpose = new TreeMap<>();\n\t\tdescriptor.getAttributes().forEach((attributeName, attributeValue) -> {\n\t\t\tif (!internalAnnotationAttributes.contains(attributeName)) {\n\t\t\t\tif (attributeValue instanceof String str) {\n\t\t\t\t\tattributeValue = new ResolvableAttribute(str);\n\t\t\t\t}\n\t\t\t\tattributesToExpose.put(attributeName, attributeValue);\n\t\t\t}\n\t\t});\n\t\targuments.addAll(attributesToExpose.values());\n\t\treturn arguments.toArray();\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getRejectedValue(field,violation,bindingResult)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the rejected value behind the given constraint violation,\n\t * for exposure through the Spring errors representation.\n\t * @param field the field that caused the binding error\n\t * @param violation the corresponding JSR-303 ConstraintViolation\n\t * @param bindingResult a Spring BindingResult for the backing object\n\t * which contains the current field's value\n\t * @return the invalid value to expose as part of the field error\n\t * @since 4.2\n\t * @see jakarta.validation.ConstraintViolation#getInvalidValue()\n\t * @see org.springframework.validation.FieldError#getRejectedValue()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field",
      "violation",
      "bindingResult"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Object",
    "signature": "protected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult)",
    "source_code": "\tprotected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult) {\n\t\tObject invalidValue = violation.getInvalidValue();\n\t\tif (!field.isEmpty() && !field.contains(\"[]\") &&\n\t\t\t\t(invalidValue == violation.getLeafBean() || field.contains(\"[\") || field.contains(\".\"))) {\n\t\t\t// Possibly a bean constraint with property path: retrieve the actual property value.\n\t\t\t// However, explicitly avoid this for \"address[]\" style paths that we can't handle.\n\t\t\tinvalidValue = bindingResult.getRawFieldValue(field);\n\t\t}\n\t\treturn invalidValue;\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getResolvableField(objectName,field)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a resolvable wrapper for the specified field, allowing to resolve the field's\n\t * name in a {@code MessageSource}.\n\t * <p>The default implementation returns a first argument indicating the field:\n\t * of type {@code DefaultMessageSourceResolvable}, with \"objectName.field\" and \"field\"\n\t * as codes, and with the plain field name as default message.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @return a corresponding {@code MessageSourceResolvable} for the specified field\n\t * @since 4.3\n\t * @see #getArgumentsForConstraint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "MessageSourceResolvable",
    "signature": "protected MessageSourceResolvable getResolvableField(String objectName, String field)",
    "source_code": "\tprotected MessageSourceResolvable getResolvableField(String objectName, String field) {\n\t\tString[] codes = new String[] {objectName + Errors.NESTED_PATH_SEPARATOR + field, field};\n\t\treturn new DefaultMessageSourceResolvable(codes, field);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#processConstraintViolations(violations,errors)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given JSR-303 ConstraintViolations, adding corresponding errors to\n\t * the provided Spring {@link Errors} object.\n\t * @param violations the JSR-303 ConstraintViolation results\n\t * @param errors the Spring errors object to register to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "violations",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "protected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors)",
    "source_code": "\tprotected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors) {\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tString field = determineField(violation);\n\t\t\tFieldError fieldError = errors.getFieldError(field);\n\t\t\tif (fieldError == null || !fieldError.isBindingFailure()) {\n\t\t\t\ttry {\n\t\t\t\t\tConstraintDescriptor<?> cd = violation.getConstraintDescriptor();\n\t\t\t\t\tString errorCode = determineErrorCode(cd);\n\t\t\t\t\tObject[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, cd);\n\t\t\t\t\tif (errors instanceof BindingResult bindingResult) {\n\t\t\t\t\t\t// Can do custom FieldError registration with invalid value from ConstraintViolation,\n\t\t\t\t\t\t// as necessary for Hibernate Validator compatibility (non-indexed set path in field)\n\t\t\t\t\t\tString nestedField = bindingResult.getNestedPath() + field;\n\t\t\t\t\t\tif (nestedField.isEmpty()) {\n\t\t\t\t\t\t\tString[] errorCodes = bindingResult.resolveMessageCodes(errorCode);\n\t\t\t\t\t\t\tObjectError error = new ViolationObjectError(\n\t\t\t\t\t\t\t\t\terrors.getObjectName(), errorCodes, errorArgs, violation, this);\n\t\t\t\t\t\t\tbindingResult.addError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tObject rejectedValue = getRejectedValue(field, violation, bindingResult);\n\t\t\t\t\t\t\tString[] errorCodes = bindingResult.resolveMessageCodes(errorCode, field);\n\t\t\t\t\t\t\tFieldError error = new ViolationFieldError(errors.getObjectName(), nestedField,\n\t\t\t\t\t\t\t\t\trejectedValue, errorCodes, errorArgs, violation, this);\n\t\t\t\t\t\t\tbindingResult.addError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Got no BindingResult - can only do standard rejectValue call\n\t\t\t\t\t\t// with automatic extraction of the current field value\n\t\t\t\t\t\terrors.rejectValue(field, errorCode, errorArgs, violation.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"JSR-303 validated property '\" + field +\n\t\t\t\t\t\t\t\"' does not have a corresponding accessor for Spring data binding - \" +\n\t\t\t\t\t\t\t\"check your DataBinder's configuration (bean property versus direct field access)\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(object,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validate(T object, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validate(object, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors)",
    "source_code": "\tpublic void validate(Object target, Errors errors) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(this.targetValidator.validate(target), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors,validationHints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateProperty(object,propertyName,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "propertyName",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validateProperty(object, propertyName, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateValue(beanType,propertyName,value,groups)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "propertyName",
      "value",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validateValue(\n\t\t\tClass<T> beanType, String propertyName, Object value, Class<?>... groups) {\n\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validateValue(beanType, propertyName, value, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateValue(targetType,fieldName,value,errors,validationHints)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType",
      "fieldName",
      "value",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "public void validateValue(Class<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validateValue(\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints) {\n\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(this.targetValidator.validateValue(\n\t\t\t\t\t(Class) targetType, fieldName, value, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.support.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "Object",
    "signature": "public Object put(String key, @Nullable Object value)",
    "source_code": "\tpublic Object put(String key, @Nullable Object value) {\n\t\tremoveBindingResultIfNecessary(key, value);\n\t\treturn super.put(key, value);\n\t}"
  },
  "org.springframework.validation.support.<unknown>#putAll(String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ?> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tmap.forEach(this::removeBindingResultIfNecessary);\n\t\tsuper.putAll(map);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#reject(errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.source.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.source.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.source.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.source.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, @Nullable Object[] errorArgs,\n\t\t\t@Nullable String defaultMessage) {\n\n\t\tthis.source.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(message,statusCode,statusText,headers,body,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #create(HttpStatusCode, String, HttpHeaders, byte[], Charset)}\n\t * with an optional prepared message.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\tif (statusCode instanceof HttpStatus status) {\n\t\t\treturn switch (status) {\n\t\t\t\tcase BAD_REQUEST -> message != null ?\n\t\t\t\t\t\tnew BadRequest(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew BadRequest(statusText, headers, body, charset);\n\t\t\t\tcase UNAUTHORIZED -> message != null ?\n\t\t\t\t\t\tnew Unauthorized(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Unauthorized(statusText, headers, body, charset);\n\t\t\t\tcase FORBIDDEN -> message != null ?\n\t\t\t\t\t\tnew Forbidden(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Forbidden(statusText, headers, body, charset);\n\t\t\t\tcase NOT_FOUND -> message != null ?\n\t\t\t\t\t\tnew NotFound(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotFound(statusText, headers, body, charset);\n\t\t\t\tcase METHOD_NOT_ALLOWED -> message != null ?\n\t\t\t\t\t\tnew MethodNotAllowed(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew MethodNotAllowed(statusText, headers, body, charset);\n\t\t\t\tcase NOT_ACCEPTABLE -> message != null ?\n\t\t\t\t\t\tnew NotAcceptable(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotAcceptable(statusText, headers, body, charset);\n\t\t\t\tcase CONFLICT -> message != null ?\n\t\t\t\t\t\tnew Conflict(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Conflict(statusText, headers, body, charset);\n\t\t\t\tcase GONE -> message != null ?\n\t\t\t\t\t\tnew Gone(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Gone(statusText, headers, body, charset);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE -> message != null ?\n\t\t\t\t\t\tnew UnsupportedMediaType(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnsupportedMediaType(statusText, headers, body, charset);\n\t\t\t\tcase TOO_MANY_REQUESTS -> message != null ?\n\t\t\t\t\t\tnew TooManyRequests(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew TooManyRequests(statusText, headers, body, charset);\n\t\t\t\tcase UNPROCESSABLE_ENTITY -> message != null ?\n\t\t\t\t\t\tnew UnprocessableEntity(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnprocessableEntity(statusText, headers, body, charset);\n\t\t\t\tdefault -> message != null ?\n\t\t\t\t\t\tnew HttpClientErrorException(message, statusCode, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t\t};\n\t\t}\n\t\tif (message != null) {\n\t\t\treturn new HttpClientErrorException(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\treturn new HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code HttpClientErrorException} or an HTTP status specific sub-class.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(null, statusCode, statusText, headers, body, charset);\n\t}"
  },
  "org.springframework.web.client.<unknown>#delete(url,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 560
    },
    "return": "void",
    "signature": "public void delete(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic void delete(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\texecute(url, HttpMethod.DELETE, null, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#delete(url,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "void",
    "signature": "public void delete(String url, Object... uriVariables)",
    "source_code": "\tpublic void delete(String url, Object... uriVariables) throws RestClientException {\n\t\texecute(url, HttpMethod.DELETE, null, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#doExecute(url,method,requestCallback,responseExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 766
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\tAssert.notNull(url, \"URI is required\");\n\t\tAssert.notNull(method, \"HttpMethod is required\");\n\t\tClientHttpResponse response = null;\n\t\ttry {\n\t\t\tClientHttpRequest request = createRequest(url, method);\n\t\t\tif (requestCallback != null) {\n\t\t\t\trequestCallback.doWithRequest(request);\n\t\t\t}\n\t\t\tresponse = request.execute();\n\t\t\thandleResponse(url, method, response);\n\t\t\treturn (responseExtractor != null ? responseExtractor.extractData(response) : null);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tString resource = url.toString();\n\t\t\tString query = url.getRawQuery();\n\t\t\tresource = (query != null ? resource.substring(0, resource.indexOf('?')) : resource);\n\t\t\tthrow new ResourceAccessException(\"I/O error on \" + method.name() +\n\t\t\t\t\t\" request for \\\"\" + resource + \"\\\": \" + ex.getMessage(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (response != null) {\n\t\t\t\tresponse.close();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(entity,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(entity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(doExecute(resolveUrl(entity), entity.getMethod(), requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 646
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 636
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(url,method,requestCallback,responseExtractor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 749
    },
    "return": "T",
    "signature": "public T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tpublic <T> T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\treturn doExecute(url, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(url,method,requestCallback,responseExtractor,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "T",
    "signature": "public T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tURI expanded = getUriTemplateHandler().expand(url, uriVariables);\n\t\treturn doExecute(expanded, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(url,method,requestCallback,responseExtractor,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "T",
    "signature": "public T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables)",
    "source_code": "\tpublic <T> T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {\n\n\t\tURI expanded = getUriTemplateHandler().expand(url, uriVariables);\n\t\treturn doExecute(expanded, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(URI url, Class<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "T",
    "signature": "public T getForObject(URI url, Class<T> responseType)",
    "source_code": "\tpublic <T> T getForObject(URI url, Class<T> responseType) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "T",
    "signature": "public T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "T",
    "signature": "public T getForObject(String url, Class<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#handleResponse(url,method,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given response, performing appropriate logging and\n\t * invoking the {@link ResponseErrorHandler} if necessary.\n\t * <p>Can be overridden in subclasses.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param response the resulting {@link ClientHttpResponse}\n\t * @throws IOException if propagated from {@link ResponseErrorHandler}\n\t * @since 4.1.6\n\t * @see #setErrorHandler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 806
    },
    "return": "void",
    "signature": "protected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response)",
    "source_code": "\tprotected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\t\tResponseErrorHandler errorHandler = getErrorHandler();\n\t\tboolean hasError = errorHandler.hasError(response);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\ttry {\n\t\t\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\t\t\tlogger.debug(\"Response \" + statusCode);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tif (hasError) {\n\t\t\terrorHandler.handleError(url, method, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#headForHeaders(url,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\treturn nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#headForHeaders(url,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headForHeaders(String url, Object... uriVariables)",
    "source_code": "\tpublic HttpHeaders headForHeaders(String url, Object... uriVariables) throws RestClientException {\n\t\treturn nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#httpEntityCallback(requestBody,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestCallback} implementation that:\n\t * <ol>\n\t * <li>Sets the request {@code Accept} header based on the given response\n\t * type, cross-checked against the configured message converters.\n\t * <li>Writes the given object to the request stream.\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBody",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 848
    },
    "return": "RequestCallback",
    "signature": "public RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType)",
    "source_code": "\tpublic <T> RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType) {\n\t\treturn new HttpEntityRequestCallback(requestBody, responseType);\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 573
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Object... uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Object... uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "T",
    "signature": "public T patchForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T patchForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "T",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "T",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables)",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Object... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "URI",
    "signature": "public URI postForLocation(URI url, @Nullable Object request)",
    "source_code": "\tpublic URI postForLocation(URI url, @Nullable Object request) throws RestClientException {\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor());\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "T",
    "signature": "public T postForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T postForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "T",
    "signature": "public T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables)",
    "source_code": "\tpublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "void",
    "signature": "public void put(URI url, @Nullable Object request)",
    "source_code": "\tpublic void put(URI url, @Nullable Object request) throws RestClientException {\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 502
    },
    "return": "void",
    "signature": "public void put(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic void put(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void put(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic void put(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#setDefaultUriVariables(Map<String,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure default URI variable values. This is a shortcut for:\n\t * <pre class=\"code\">\n\t * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory();\n\t * handler.setDefaultUriVariables(...);\n\t *\n\t * RestTemplate restTemplate = new RestTemplate();\n\t * restTemplate.setUriTemplateHandler(handler);\n\t * </pre>\n\t * @param uriVars the default URI variable values\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "void",
    "signature": "public void setDefaultUriVariables(Map<String, ?> uriVars)",
    "source_code": "\tpublic void setDefaultUriVariables(Map<String, ?> uriVars) {\n\t\tif (this.uriTemplateHandler instanceof DefaultUriBuilderFactory) {\n\t\t\t((DefaultUriBuilderFactory) this.uriTemplateHandler).setDefaultUriVariables(uriVars);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"This property is not supported with the configured UriTemplateHandler.\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.<unknown>#configureAndRefreshWebApplicationContext(wac,sc)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "wac",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc)",
    "source_code": "\tprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n\t\t\tif (idParam != null) {\n\t\t\t\twac.setId(idParam);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Generate default id...\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\tObjectUtils.getDisplayString(sc.getContextPath()));\n\t\t\t}\n\t\t}\n\n\t\twac.setServletContext(sc);\n\t\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n\t\tif (configLocationParam != null) {\n\t\t\twac.setConfigLocation(configLocationParam);\n\t\t}\n\n\t\t// The wac environment's #initPropertySources will be called in any case when the context\n\t\t// is refreshed; do it eagerly here to ensure servlet property sources are in place for\n\t\t// use in any post-processing or initialization that occurs below prior to #refresh\n\t\tConfigurableEnvironment env = wac.getEnvironment();\n\t\tif (env instanceof ConfigurableWebEnvironment cwe) {\n\t\t\tcwe.initPropertySources(sc, null);\n\t\t}\n\n\t\tcustomizeContext(sc, wac);\n\t\twac.refresh();\n\t}"
  },
  "org.springframework.web.context.<unknown>#customizeContext(sc,wac)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the {@link ConfigurableWebApplicationContext} created by this\n\t * ContextLoader after config locations have been supplied to the context\n\t * but before the context is <em>refreshed</em>.\n\t * <p>The default implementation {@linkplain #determineContextInitializerClasses(ServletContext)\n\t * determines} what (if any) context initializer classes have been specified through\n\t * {@linkplain #CONTEXT_INITIALIZER_CLASSES_PARAM context init parameters} and\n\t * {@linkplain ApplicationContextInitializer#initialize invokes each} with the\n\t * given web application context.\n\t * <p>Any {@code ApplicationContextInitializers} implementing\n\t * {@link org.springframework.core.Ordered Ordered} or marked with @{@link\n\t * org.springframework.core.annotation.Order Order} will be sorted appropriately.\n\t * @param sc the current servlet context\n\t * @param wac the newly created application context\n\t * @see #CONTEXT_INITIALIZER_CLASSES_PARAM\n\t * @see ApplicationContextInitializer#initialize(ConfigurableApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sc",
      "wac"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "void",
    "signature": "protected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac)",
    "source_code": "\tprotected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {\n\t\tList<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> initializerClasses =\n\t\t\t\tdetermineContextInitializerClasses(sc);\n\n\t\tfor (Class<ApplicationContextInitializer<ConfigurableApplicationContext>> initializerClass : initializerClasses) {\n\t\t\tClass<?> initializerContextClass =\n\t\t\t\t\tGenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);\n\t\t\tif (initializerContextClass != null && !initializerContextClass.isInstance(wac)) {\n\t\t\t\tthrow new ApplicationContextException(String.format(\n\t\t\t\t\t\t\"Could not apply context initializer [%s] since its generic parameter [%s] \" +\n\t\t\t\t\t\t\"is not assignable from the type of application context used by this \" +\n\t\t\t\t\t\t\"context loader: [%s]\", initializerClass.getName(), initializerContextClass.getName(),\n\t\t\t\t\t\twac.getClass().getName()));\n\t\t\t}\n\t\t\tthis.contextInitializers.add(BeanUtils.instantiateClass(initializerClass));\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(this.contextInitializers);\n\t\tfor (ApplicationContextInitializer<ConfigurableApplicationContext> initializer : this.contextInitializers) {\n\t\t\tinitializer.initialize(wac);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#doFindPathMatchingFileResources(rootDirResource,subPattern)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden version which checks for ServletContextResource\n\t * and uses {@code ServletContext.getResourcePaths} to find\n\t * matching resources below the web application root directory.\n\t * In case of other resources, delegates to the superclass version.\n\t * @see #doRetrieveMatchingServletContextResources\n\t * @see ServletContextResource\n\t * @see jakarta.servlet.ServletContext#getResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tif (rootDirResource instanceof ServletContextResource scResource) {\n\t\t\tServletContext sc = scResource.getServletContext();\n\t\t\tString fullPattern = scResource.getPath() + subPattern;\n\t\t\tSet<Resource> result = new LinkedHashSet<>(8);\n\t\t\tdoRetrieveMatchingServletContextResources(sc, fullPattern, scResource.getPath(), result);\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\treturn super.doFindPathMatchingFileResources(rootDirResource, subPattern);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#doRetrieveMatchingServletContextResources(servletContext,fullPattern,dir,result)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Recursively retrieve ServletContextResources that match the given pattern,\n\t * adding them to the given result set.\n\t * @param servletContext the ServletContext to work on\n\t * @param fullPattern the pattern to match against,\n\t * with preprended root directory path\n\t * @param dir the current directory\n\t * @param result the Set of matching Resources to add to\n\t * @throws IOException if directory contents could not be retrieved\n\t * @see ServletContextResource\n\t * @see jakarta.servlet.ServletContext#getResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext",
      "fullPattern",
      "dir",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "protected void doRetrieveMatchingServletContextResources(ServletContext servletContext, String fullPattern, String dir, Set<Resource> result)",
    "source_code": "\tprotected void doRetrieveMatchingServletContextResources(\n\t\t\tServletContext servletContext, String fullPattern, String dir, Set<Resource> result)\n\t\t\tthrows IOException {\n\n\t\tSet<String> candidates = servletContext.getResourcePaths(dir);\n\t\tif (candidates != null) {\n\t\t\tboolean dirDepthNotFixed = fullPattern.contains(\"**\");\n\t\t\tint jarFileSep = fullPattern.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t\tString jarFilePath = null;\n\t\t\tString pathInJarFile = null;\n\t\t\tif (jarFileSep > 0 && jarFileSep + ResourceUtils.JAR_URL_SEPARATOR.length() < fullPattern.length()) {\n\t\t\t\tjarFilePath = fullPattern.substring(0, jarFileSep);\n\t\t\t\tpathInJarFile = fullPattern.substring(jarFileSep + ResourceUtils.JAR_URL_SEPARATOR.length());\n\t\t\t}\n\t\t\tfor (String currPath : candidates) {\n\t\t\t\tif (!currPath.startsWith(dir)) {\n\t\t\t\t\t// Returned resource path does not start with relative directory:\n\t\t\t\t\t// assuming absolute path returned -> strip absolute path.\n\t\t\t\t\tint dirIndex = currPath.indexOf(dir);\n\t\t\t\t\tif (dirIndex != -1) {\n\t\t\t\t\t\tcurrPath = currPath.substring(dirIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currPath.endsWith(\"/\") && (dirDepthNotFixed || StringUtils.countOccurrencesOf(currPath, \"/\") <=\n\t\t\t\t\t\tStringUtils.countOccurrencesOf(fullPattern, \"/\"))) {\n\t\t\t\t\t// Search subdirectories recursively: ServletContext.getResourcePaths\n\t\t\t\t\t// only returns entries for one directory level.\n\t\t\t\t\tdoRetrieveMatchingServletContextResources(servletContext, fullPattern, currPath, result);\n\t\t\t\t}\n\t\t\t\tif (jarFilePath != null && getPathMatcher().match(jarFilePath, currPath)) {\n\t\t\t\t\t// Base pattern matches a jar file - search for matching entries within.\n\t\t\t\t\tString absoluteJarPath = servletContext.getRealPath(currPath);\n\t\t\t\t\tif (absoluteJarPath != null) {\n\t\t\t\t\t\tdoRetrieveMatchingJarEntries(absoluteJarPath, pathInJarFile, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (getPathMatcher().match(fullPattern, currPath)) {\n\t\t\t\t\tresult.add(new ServletContextResource(servletContext, currPath));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.filter.<unknown>#doFilter(request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// Lazily initialize the delegate if necessary.\n\t\tFilter delegateToUse = this.delegate;\n\t\tif (delegateToUse == null) {\n\t\t\tsynchronized (this.delegateMonitor) {\n\t\t\t\tdelegateToUse = this.delegate;\n\t\t\t\tif (delegateToUse == null) {\n\t\t\t\t\tWebApplicationContext wac = findWebApplicationContext();\n\t\t\t\t\tif (wac == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No WebApplicationContext found: \" +\n\t\t\t\t\t\t\t\t\"no ContextLoaderListener or DispatcherServlet registered?\");\n\t\t\t\t\t}\n\t\t\t\t\tdelegateToUse = initDelegate(wac);\n\t\t\t\t}\n\t\t\t\tthis.delegate = delegateToUse;\n\t\t\t}\n\t\t}\n\n\t\t// Let the delegate perform the actual doFilter operation.\n\t\tinvokeDelegate(delegateToUse, request, response, filterChain);\n\t}"
  },
  "org.springframework.web.filter.<unknown>#doFilterInternal(request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@code doFilter}, but guaranteed to be\n\t * just invoked once per request within a single request thread.\n\t * See {@link #shouldNotFilterAsyncDispatch()} for details.\n\t * <p>Provides HttpServletRequest and HttpServletResponse arguments instead of the\n\t * default ServletRequest and ServletResponse ones.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected abstract void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException;\n\n\t/**\n\t * Typically an ERROR dispatch happens after the REQUEST dispatch completes,\n\t * and the filter chain starts anew. On some servers however the ERROR\n\t * dispatch may be nested within the REQUEST dispatch, e.g. as a result of\n\t * calling {@code sendError} on the response. In that case we are still in"
  },
  "org.springframework.web.filter.<unknown>#doFilterNestedErrorDispatch(request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Typically an ERROR dispatch happens after the REQUEST dispatch completes,\n\t * and the filter chain starts anew. On some servers however the ERROR\n\t * dispatch may be nested within the REQUEST dispatch, e.g. as a result of\n\t * calling {@code sendError} on the response. In that case we are still in\n\t * the filter chain, on the same thread, but the request and response have\n\t * been switched to the original, unwrapped ones.\n\t * <p>Sub-classes may use this method to filter such nested ERROR dispatches\n\t * and re-apply wrapping on the request or response. {@code ThreadLocal}\n\t * context, if any, should still be active as we are still nested within\n\t * the filter chain.\n\t * @since 5.1.9\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "protected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)",
    "source_code": "\tprotected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain) throws ServletException, IOException {\n\n\t\tfilterChain.doFilter(request, response);\n\t}"
  },
  "org.springframework.web.filter.<unknown>#invokeDelegate(delegate,request,response,filterChain)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the delegate Filter with the given request and response.\n\t * @param delegate the delegate Filter\n\t * @param request the current HTTP request\n\t * @param response the current HTTP response\n\t * @param filterChain the current FilterChain\n\t * @throws ServletException if thrown by the Filter\n\t * @throws IOException if thrown by the Filter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "delegate",
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void invokeDelegate(\n\t\t\tFilter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tdelegate.doFilter(request, response, filterChain);\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#callNextHandlerInChain(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "protected void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tprotected final void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler) {\n\n\t\tNavigationHandler decoratedNavigationHandler = getDecoratedNavigationHandler();\n\n\t\tif (decoratedNavigationHandler instanceof DecoratingNavigationHandler decHandler) {\n\t\t\t// DecoratingNavigationHandler specified through constructor argument:\n\t\t\t// Call it with original NavigationHandler passed in.\n\t\t\tdecHandler.handleNavigation(facesContext, fromAction, outcome, originalNavigationHandler);\n\t\t}\n\t\telse if (decoratedNavigationHandler != null) {\n\t\t\t// Standard NavigationHandler specified through constructor argument:\n\t\t\t// Call it through standard API, without original NavigationHandler passed in.\n\t\t\t// The called handler will not be able to redirect to the original handler.\n\t\t\tdecoratedNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t\telse if (originalNavigationHandler != null) {\n\t\t\t// No NavigationHandler specified through constructor argument:\n\t\t\t// Call original handler, marking the end of this chain.\n\t\t\toriginalNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#handleNavigation(facesContext,fromAction,outcome)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation of the standard JSF {@code handleNavigation} method\n\t * delegates to the overloaded variant, passing in constructor-injected\n\t * NavigationHandler as argument.\n\t * @see #handleNavigation(jakarta.faces.context.FacesContext, String, String, jakarta.faces.application.NavigationHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, String fromAction, String outcome)",
    "source_code": "\tpublic final void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {\n\t\thandleNavigation(facesContext, fromAction, outcome, this.decoratedNavigationHandler);\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#handleNavigation(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Special {@code handleNavigation} variant with explicit NavigationHandler\n\t * argument. Either called directly, by code with an explicit original handler,\n\t * or called from the standard {@code handleNavigation} method, as\n\t * plain JSF-defined NavigationHandler.\n\t * <p>Implementations should invoke {@code callNextHandlerInChain} to\n\t * delegate to the next handler in the chain. This will always call the most\n\t * appropriate next handler (see {@code callNextHandlerInChain} javadoc).\n\t * Alternatively, the decorated NavigationHandler or the passed-in original\n\t * NavigationHandler can also be called directly; however, this is not as\n\t * flexible in terms of reacting to potential positions in the chain.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t * @see #callNextHandlerInChain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tpublic abstract void handleNavigation(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler);\n\n\n\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means"
  },
  "org.springframework.web.jsf.el.<unknown>#getFeatureDescriptors(elContext,base)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Iterator<FeatureDescriptor>",
    "signature": "public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base)",
    "source_code": "\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#getValue(elContext,base,property)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object getValue(ELContext elContext, @Nullable Object base, Object property)",
    "source_code": "\tpublic Object getValue(ELContext elContext, @Nullable Object base, Object property) throws ELException {\n\t\tif (base != null) {\n\t\t\tif (base instanceof WebApplicationContext wac) {\n\t\t\t\tString beanName = property.toString();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Attempting to resolve property '\" + beanName + \"' in root WebApplicationContext\");\n\t\t\t\t}\n\t\t\t\tif (wac.containsBean(beanName)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Successfully resolved property '\" + beanName + \"' in root WebApplicationContext\");\n\t\t\t\t\t}\n\t\t\t\t\telContext.setPropertyResolved(true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn wac.getBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\tthrow new ELException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mimic standard JSF/JSP behavior when base is a Map by returning null.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (WEB_APPLICATION_CONTEXT_VARIABLE_NAME.equals(property)) {\n\t\t\t\telContext.setPropertyResolved(true);\n\t\t\t\treturn getWebApplicationContext(elContext);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#isReadOnly(elContext,base,property)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly(ELContext elContext, Object base, Object property)",
    "source_code": "\tpublic boolean isReadOnly(ELContext elContext, Object base, Object property) throws ELException {\n\t\tif (base instanceof WebApplicationContext) {\n\t\t\telContext.setPropertyResolved(true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#setValue(elContext,base,property,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setValue(ELContext elContext, Object base, Object property, Object value)",
    "source_code": "\tpublic void setValue(ELContext elContext, Object base, Object property, Object value) throws ELException {\n\t}"
  },
  "org.springframework.web.method.<unknown>#assertTargetBean(method,targetBean,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual controller instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). {@code @Controller}'s that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetBean",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "void",
    "signature": "protected void assertTargetBean(Method method, Object targetBean, Object[] args)",
    "source_code": "\tprotected void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString text = \"The mapped handler method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual controller bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the controller requires proxying \" +\n\t\t\t\t\t\"(e.g. due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.<unknown>#findProvidedArgument(parameter,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "Object",
    "signature": "protected Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs)",
    "source_code": "\tprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.<unknown>#formatArgumentError(param,message)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "param",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "String",
    "signature": "protected String formatArgumentError(MethodParameter param, String message)",
    "source_code": "\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}"
  },
  "org.springframework.web.method.<unknown>#formatInvokeError(text,args)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Controller [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded method that uses the ConversionService created at construction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value, UriComponentsBuilder builder,\n\t\t\tMap<String, Object> uriVariables)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value, UriComponentsBuilder builder,\n\t\t\tMap<String, Object> uriVariables) {\n\n\t\tcontributeMethodArgument(parameter, value, builder, uriVariables, this.conversionService);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tfor (Object contributor : this.contributors) {\n\t\t\tif (contributor instanceof UriComponentsContributor ucc) {\n\t\t\t\tif (ucc.supportsParameter(parameter)) {\n\t\t\t\t\tucc.contributeMethodArgument(parameter, value, builder, uriVariables, conversionService);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contributor instanceof HandlerMethodArgumentResolver resolver) {\n\t\t\t\tif (resolver.supportsParameter(parameter)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthentication(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication(String username, String password)",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthenticationCredentials(username,password)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#body(BodyExtractor<T,extractor)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ClientHttpResponse> extractor)",
    "source_code": "\tpublic <T> T body(BodyExtractor<T, ? super ClientHttpResponse> extractor) {\n\t\tT result = extractor.extract(this.response, this.bodyExtractorContext);\n\t\tString description = \"Body from \" + this.requestDescription + \" [DefaultClientResponse]\";\n\t\tif (result instanceof Mono) {\n\t\t\treturn (T) ((Mono<?>) result).checkpoint(description);\n\t\t}\n\t\telse if (result instanceof Flux) {\n\t\t\treturn (T) ((Flux<?>) result).checkpoint(description);\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookie(name,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "DefaultClientResponseBuilder",
    "signature": "public DefaultClientResponseBuilder cookie(String name, String... values)",
    "source_code": "\tpublic DefaultClientResponseBuilder cookie(String name, String... values) {\n\t\tfor (String value : values) {\n\t\t\tgetCookies().add(name, ResponseCookie.from(name, value).build());\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code WebClientResponseException} or an HTTP status specific subclass.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "WebClientResponseException",
    "signature": "public WebClientResponseException create(int statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static WebClientResponseException create(\n\t\t\tint statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(statusCode, statusText, headers, body, charset, null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#create(statusCode,statusText,headers,body,charset,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code WebClientResponseException} or an HTTP status specific subclass.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "WebClientResponseException",
    "signature": "public WebClientResponseException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers,\n\t\t\tbyte[] body, @Nullable Charset charset, @Nullable HttpRequest request)",
    "source_code": "\tpublic static WebClientResponseException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers,\n\t\t\tbyte[] body, @Nullable Charset charset, @Nullable HttpRequest request) {\n\n\t\tif (statusCode instanceof HttpStatus httpStatus) {\n\t\t\tswitch (httpStatus) {\n\t\t\t\tcase BAD_REQUEST:\n\t\t\t\t\treturn new WebClientResponseException.BadRequest(statusText, headers, body, charset, request);\n\t\t\t\tcase UNAUTHORIZED:\n\t\t\t\t\treturn new WebClientResponseException.Unauthorized(statusText, headers, body, charset, request);\n\t\t\t\tcase FORBIDDEN:\n\t\t\t\t\treturn new WebClientResponseException.Forbidden(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_FOUND:\n\t\t\t\t\treturn new WebClientResponseException.NotFound(statusText, headers, body, charset, request);\n\t\t\t\tcase METHOD_NOT_ALLOWED:\n\t\t\t\t\treturn new WebClientResponseException.MethodNotAllowed(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_ACCEPTABLE:\n\t\t\t\t\treturn new WebClientResponseException.NotAcceptable(statusText, headers, body, charset, request);\n\t\t\t\tcase CONFLICT:\n\t\t\t\t\treturn new WebClientResponseException.Conflict(statusText, headers, body, charset, request);\n\t\t\t\tcase GONE:\n\t\t\t\t\treturn new WebClientResponseException.Gone(statusText, headers, body, charset, request);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE:\n\t\t\t\t\treturn new WebClientResponseException.UnsupportedMediaType(statusText, headers, body, charset, request);\n\t\t\t\tcase TOO_MANY_REQUESTS:\n\t\t\t\t\treturn new WebClientResponseException.TooManyRequests(statusText, headers, body, charset, request);\n\t\t\t\tcase UNPROCESSABLE_ENTITY:\n\t\t\t\t\treturn new WebClientResponseException.UnprocessableEntity(statusText, headers, body, charset, request);\n\t\t\t\tcase INTERNAL_SERVER_ERROR:\n\t\t\t\t\treturn new WebClientResponseException.InternalServerError(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_IMPLEMENTED:\n\t\t\t\t\treturn new WebClientResponseException.NotImplemented(statusText, headers, body, charset, request);\n\t\t\t\tcase BAD_GATEWAY:\n\t\t\t\t\treturn new WebClientResponseException.BadGateway(statusText, headers, body, charset, request);\n\t\t\t\tcase SERVICE_UNAVAILABLE:\n\t\t\t\t\treturn new WebClientResponseException.ServiceUnavailable(statusText, headers, body, charset, request);\n\t\t\t\tcase GATEWAY_TIMEOUT:\n\t\t\t\t\treturn new WebClientResponseException.GatewayTimeout(statusText, headers, body, charset, request);\n\t\t\t}\n\t\t}\n\t\treturn new WebClientResponseException(statusCode, statusText, headers, body, charset, request);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#setBodyDecodeFunction(Function<ResolvableType,decoderFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a function to find a decoder the given target type.\n\t * For use with {@link #getResponseBodyAs(Class)}.\n\t * @param decoderFunction the function to find a decoder with\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ResolvableType",
      "decoderFunction"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "void",
    "signature": "public void setBodyDecodeFunction(Function<ResolvableType, ?> decoderFunction)",
    "source_code": "\tpublic void setBodyDecodeFunction(Function<ResolvableType, ?> decoderFunction) {\n\t\tthis.bodyDecodeFunction = decoderFunction;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#statusError(statusPredicate,Function<ClientResponse,exceptionFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function that to create the exception\n\t * @return the filter to generate an error signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction)",
    "source_code": "\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction) {\n\n\t\tAssert.notNull(statusPredicate, \"Predicate must not be null\");\n\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\n\t\treturn ExchangeFilterFunction.ofResponseProcessor(\n\t\t\t\tresponse -> (statusPredicate.test(response.statusCode()) ?\n\t\t\t\t\t\tMono.error(exceptionFunction.apply(response)) : Mono.just(response)));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#attributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void attributes(Map<String, Object> attributes)",
    "source_code": "\tpublic void attributes(Map<String, Object> attributes) {\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyInserter<?,inserter)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyInserter<?",
      "inserter"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter)",
    "source_code": "\tpublic Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter) {\n\t\treturn Mono.just(new BodyInserterResponse<>(\n\t\t\t\tthis.statusCode, this.headers, this.cookies, inserter, this.hints));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(producer,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(Object producer, Class<?> elementClass)",
    "source_code": "\tpublic Mono<ServerResponse> body(Object producer, Class<?> elementClass) {\n\t\treturn initBuilder(producer, BodyInserters.fromProducer(producer, elementClass));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(producer,elementTypeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic Mono<ServerResponse> body(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\treturn initBuilder(producer, BodyInserters.fromProducer(producer, elementTypeRef));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(publisher,elementClass)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> Mono<ServerResponse> body(P publisher, Class<T> elementClass) {\n\t\treturn initBuilder(publisher, BodyInserters.fromPublisher(publisher, elementClass));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(publisher,typeRef)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "typeRef"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(P publisher, ParameterizedTypeReference<T> typeRef)",
    "source_code": "\tpublic <T, P extends Publisher<T>> Mono<ServerResponse> body(P publisher, ParameterizedTypeReference<T> typeRef) {\n\t\treturn initBuilder(publisher, BodyInserters.fromPublisher(publisher, typeRef));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build(BiFunction<ServerWebExchange,ServerResponse.Context,writeFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<ServerWebExchange",
      "ServerResponse.Context",
      "writeFunction"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build(BiFunction<ServerWebExchange, ServerResponse.Context, Mono<Void>> writeFunction)",
    "source_code": "\tpublic Mono<ServerResponse> build(\n\t\t\tBiFunction<ServerWebExchange, ServerResponse.Context, Mono<Void>> writeFunction) {\n\n\t\treturn Mono.just(new WriterFunctionResponse(\n\t\t\t\tthis.statusCode, this.headers, this.cookies, writeFunction));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#render(name,Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> render(String name, Map<String, ?> model)",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Map<String, ?> model) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(model)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#render(name,modelAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "modelAttributes"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> render(String name, Object... modelAttributes)",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Object... modelAttributes) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(modelAttributes)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Mono<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Mono<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#route(predicate,handlerFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "handlerFunction"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction)",
    "source_code": "\tpublic void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {\n\t\tchangeParser(predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#writeTo(exchange,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeTo(ServerWebExchange exchange, Context context)",
    "source_code": "\t\tpublic final Mono<Void> writeTo(ServerWebExchange exchange, Context context) {\n\t\t\twriteStatusAndHeaders(exchange.getResponse());\n\t\t\tInstant lastModified = Instant.ofEpochMilli(headers().getLastModified());\n\t\t\tHttpMethod httpMethod = exchange.getRequest().getMethod();\n\t\t\tif (SAFE_METHODS.contains(httpMethod) && exchange.checkNotModified(headers().getETag(), lastModified)) {\n\t\t\t\treturn exchange.getResponse().setComplete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn writeToInternal(exchange, context);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#writeToInternal(exchange,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context)",
    "source_code": "\t\tprotected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context) {\n\t\t\treturn this.inserter.insert(exchange.getResponse(), new BodyInserter.Context() {\n\t\t\t\t@Override\n\t\t\t\tpublic List<HttpMessageWriter<?>> messageWriters() {\n\t\t\t\t\treturn context.messageWriters();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Optional<ServerHttpRequest> serverRequest() {\n\t\t\t\t\treturn Optional.of(exchange.getRequest());\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Map<String, Object> hints() {\n\t\t\t\t\thints.put(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix());\n\t\t\t\t\treturn hints;\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#lookupHandler(lookupPath,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL lookup path.\n\t * <p>Supports direct matches, e.g. a registered \"/test\" matches \"/test\",\n\t * and various path pattern matches, e.g. a registered \"/t*\" matches\n\t * both \"/test\" and \"/team\". For details, see the PathPattern class.\n\t * @param lookupPath the URL the handler is mapped to\n\t * @param exchange the current exchange\n\t * @return the associated handler instance, or {@code null} if not found\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)",
    "source_code": "\tprotected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.handlerMap.keySet()) {\n\t\t\tif (pattern.matches(lookupPath)) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\n\t\tPathPattern pattern = matches.get(0);\n\t\tPathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath);\n\t\tPathPattern.PathMatchInfo matchInfo = pattern.matchAndExtract(lookupPath);\n\t\tAssert.notNull(matchInfo, \"Expected a match\");\n\n\t\tObject handler = this.handlerMap.get(pattern);\n\n\t\t// Bean name or resolved handler?\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\n\t\tif (this.handlerPredicate != null && !this.handlerPredicate.test(handler, exchange)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvalidateHandler(handler, exchange);\n\n\t\texchange.getAttributes().put(BEST_MATCHING_HANDLER_ATTRIBUTE, handler);\n\t\texchange.getAttributes().put(BEST_MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\texchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);\n\t\texchange.getAttributes().put(URI_TEMPLATE_VARIABLES_ATTRIBUTE, matchInfo.getUriVariables());\n\n\t\treturn handler;\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandler(urlPath,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Parse path pattern\n\t\turlPath = prependLeadingSlash(urlPath);\n\t\tPathPattern pattern = getPathPatternParser().parse(urlPath);\n\t\tif (this.handlerMap.containsKey(pattern)) {\n\t\t\tObject existingHandler = this.handlerMap.get(pattern);\n\t\t\tif (existingHandler != null && existingHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to [\" + urlPath + \"]: \" +\n\t\t\t\t\t\t\"there is already \" + getHandlerDescription(existingHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tif (obtainApplicationContext().isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = obtainApplicationContext().getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\t// Register resolved handler\n\t\tthis.handlerMap.put(pattern, resolvedHandler);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setHandlerPredicate(BiPredicate<Object,handlerPredicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate for extended matching of the handler that was\n\t * matched by URL path. This allows for further narrowing of the mapping by\n\t * checking additional properties of the request. If the predicate returns\n\t * \"false\", it result in a no-match, which allows another\n\t * {@link org.springframework.web.reactive.HandlerMapping} to match or\n\t * result in a 404 (NOT_FOUND) response.\n\t * @param handlerPredicate a bi-predicate to match the candidate handler\n\t * against the current exchange.\n\t * @since 5.3.5\n\t * @see org.springframework.web.reactive.socket.server.support.WebSocketUpgradeHandlerPredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiPredicate<Object",
      "handlerPredicate"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setHandlerPredicate(BiPredicate<Object, ServerWebExchange> handlerPredicate)",
    "source_code": "\tpublic void setHandlerPredicate(BiPredicate<Object, ServerWebExchange> handlerPredicate) {\n\t\tthis.handlerPredicate = (this.handlerPredicate != null ?\n\t\t\t\tthis.handlerPredicate.and(handlerPredicate) : handlerPredicate);\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#validateHandler(handler,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given handler against the current request.\n\t * <p>The default implementation is empty. Can be overridden in subclasses,\n\t * for example to enforce specific preconditions expressed in URL mappings.\n\t * @param handler the handler object to validate\n\t * @param exchange current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "void",
    "signature": "protected void validateHandler(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected void validateHandler(Object handler, ServerWebExchange exchange) {\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#addFixedVersionStrategy(version,pathPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t * will also cofigure automatically a {@code \"/v1.0.0/js/**\"} with {@code \"v1.0.0\"} the\n\t * {@code version} String given as an argument.\n\t * @param version a version string\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see FixedVersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns) {\n\t\tList<String> patternsList = Arrays.asList(pathPatterns);\n\t\tList<String> prefixedPatterns = new ArrayList<>(pathPatterns.length);\n\t\tString versionPrefix = \"/\" + version;\n\t\tfor (String pattern : patternsList) {\n\t\t\tprefixedPatterns.add(pattern);\n\t\t\tif (!pattern.startsWith(versionPrefix) && !patternsList.contains(versionPrefix + pattern)) {\n\t\t\t\tprefixedPatterns.add(versionPrefix + pattern);\n\t\t\t}\n\t\t}\n\t\treturn addVersionStrategy(new FixedVersionStrategy(version), StringUtils.toStringArray(prefixedPatterns));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#checkResource(resource,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resources exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getAllowedLocations() != null) {\n\t\t\tfor (Resource current : getAllowedLocations()) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractLink(index,endChar,content,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "endChar",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "int",
    "signature": "protected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result) {\n\t\t\tint start = index + 1;\n\t\t\tint end = content.indexOf(endChar, start);\n\t\t\tresult.add(new ContentChunkInfo(start, end, true));\n\t\t\treturn end + 1;\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,linksToAdd)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked after a keyword match, after whitespace has been removed, and when\n\t\t * the next char is neither a single nor double quote.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content,\n\t\t\t\tSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected abstract int extractUnquotedLink(int position, String content,\n\t\t\t\tSet<ContentChunkInfo> linksToAdd);\n\n\t}\n\n\n\tprivate static class ImportLinkParser extends AbstractLinkParser {"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(position - 1, ')', content, result);\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getForUriString(uriString,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Get the public resource URL for the given URI string.\n\t * <p>The URI string is expected to be a path and if it contains a query or\n\t * fragment those will be preserved in the resulting public resource URL.\n\t * @param uriString the URI string to transform\n\t * @param exchange the current exchange\n\t * @return the resolved public resource URL path, or empty if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriString",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Mono<String>",
    "signature": "public Mono<String> getForUriString(String uriString, ServerWebExchange exchange)",
    "source_code": "\tpublic final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tint queryIndex = getQueryIndex(uriString);\n\t\tString lookupPath = uriString.substring(0, queryIndex);\n\t\tString query = uriString.substring(queryIndex);\n\t\tPathContainer parsedLookupPath = PathContainer.parsePath(lookupPath);\n\n\t\treturn resolveResourceUrl(exchange, parsedLookupPath).map(resolvedPath ->\n\t\t\t\trequest.getPath().contextPath().value() + resolvedPath + query);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getResource(resourcePath,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or empty {@link Mono} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Mono<Resource> getResource(String resourcePath, Resource location) {\n\t\ttry {\n\t\t\tif (!(location instanceof UrlResource)) {\n\t\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t\t}\n\t\t\tResource resource = location.createRelative(resourcePath);\n\t\t\tif (resource.isReadable()) {\n\t\t\t\tif (checkResource(resource, location)) {\n\t\t\t\t\treturn Mono.just(resource);\n\t\t\t\t}\n\t\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource.getURL() + \"\\\" is neither under the \" +\n\t\t\t\t\t\t\t\t\t\"current location \\\"\" + location.getURL() + \"\\\" nor under any of the \" +\n\t\t\t\t\t\t\t\t\t\"allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tString error = \"Skip location [\" + location + \"] due to error\";\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(error, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(error + \": \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#parse(content,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, '\\'', content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, '\"', content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractUnquotedLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#registerHandlers(Map<String,handlerMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure resource handler mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. If this property is used,\n\t * auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void registerHandlers(Map<String, ResourceWebHandler> handlerMap)",
    "source_code": "\tpublic void registerHandlers(Map<String, ResourceWebHandler> handlerMap) {\n\t\tthis.handlerMap.clear();\n\t\thandlerMap.forEach((rawPattern, resourceWebHandler) -> {\n\t\t\trawPattern = prependLeadingSlash(rawPattern);\n\t\t\tPathPattern pattern = PathPatternParser.defaultInstance.parse(rawPattern);\n\t\t\tthis.handlerMap.put(pattern, resourceWebHandler);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, locations);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(path,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String path, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\treturn getResource(path, locations).map(resource -> path);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveUrlPath(resourceUrlPath, locations)\n\t\t\t\t.flatMap(baseUrl -> {\n\t\t\t\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\t\t\t\tVersionStrategy strategy = getStrategyForPath(resourceUrlPath);\n\t\t\t\t\t\tif (strategy == null) {\n\t\t\t\t\t\t\treturn Mono.just(baseUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chain.resolveResource(null, baseUrl, locations)\n\t\t\t\t\t\t\t\t.flatMap(resource -> strategy.getResourceVersion(resource)\n\t\t\t\t\t\t\t\t\t\t.map(version -> strategy.addVersion(baseUrl, version)));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setHeaders(exchange,resource,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set headers on the response. Called for both GET and HEAD requests.\n\t * @param exchange current exchange\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "resource",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "void",
    "signature": "protected void setHeaders(ServerWebExchange exchange, Resource resource, @Nullable MediaType mediaType)",
    "source_code": "\tprotected void setHeaders(ServerWebExchange exchange, Resource resource, @Nullable MediaType mediaType)\n\t\t\tthrows IOException {\n\n\t\tHttpHeaders headers = exchange.getResponse().getHeaders();\n\n\t\tlong length = resource.contentLength();\n\t\theaders.setContentLength(length);\n\n\t\tif (mediaType != null) {\n\t\t\theaders.setContentType(mediaType);\n\t\t}\n\n\t\tif (resource instanceof HttpResource httpResource) {\n\t\t\texchange.getResponse().getHeaders().putAll(httpResource.getResponseHeaders());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setMediaTypes(Map<String,mediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mappings between file extensions extracted from the filename of static\n\t * {@link Resource}s and the media types to use for the response.\n\t * <p>Use of this method is typically not necessary since mappings can be\n\t * also determined via {@link MediaTypeFactory#getMediaType(Resource)}.\n\t * @param mediaTypes media type mappings\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void setMediaTypes(Map<String, MediaType> mediaTypes)",
    "source_code": "\tpublic void setMediaTypes(Map<String, MediaType> mediaTypes) {\n\t\tif (this.mediaTypes == null) {\n\t\t\tthis.mediaTypes = new HashMap<>(mediaTypes.size());\n\t\t}\n\t\tmediaTypes.forEach((ext, type) ->\n\t\t\t\tthis.mediaTypes.put(ext.toLowerCase(Locale.ENGLISH), type));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setStrategyMap(Map<String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and {@code VersionStrategy} as values.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link AntPathMatcher} javadoc.\n\t * @param map a map with URLs as keys and version strategies as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void setStrategyMap(Map<String, VersionStrategy> map)",
    "source_code": "\tpublic void setStrategyMap(Map<String, VersionStrategy> map) {\n\t\tthis.versionStrategyMap.clear();\n\t\tthis.versionStrategyMap.putAll(map);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#transform(exchange,inputResource,transformerChain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "inputResource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Mono<Resource>",
    "signature": "public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain) {\n\n\t\treturn transformerChain.transform(exchange, inputResource)\n\t\t\t\t.flatMap(outputResource -> {\n\t\t\t\t\tString filename = outputResource.getFilename();\n\t\t\t\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\t\t\t\tinputResource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\t\t\t\treturn Mono.just(outputResource);\n\t\t\t\t\t}\n\n\t\t\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\t\t\t\t\tFlux<DataBuffer> flux = DataBufferUtils\n\t\t\t\t\t\t\t.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE);\n\t\t\t\t\treturn DataBufferUtils.join(flux)\n\t\t\t\t\t\t\t.flatMap(dataBuffer -> {\n\t\t\t\t\t\t\t\tCharBuffer charBuffer = DEFAULT_CHARSET.decode(dataBuffer.asByteBuffer());\n\t\t\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t\t\t\tString cssContent = charBuffer.toString();\n\t\t\t\t\t\t\t\treturn transformContent(cssContent, outputResource, transformerChain, exchange);\n\t\t\t\t\t\t\t});\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 663
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compareTo(other,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} to ensure they have conditions with\n\t * content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, ServerWebExchange exchange) {\n\t\tint result = this.patternsCondition.compareTo(other.getPatternsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#createHandlerMethod(handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the HandlerMethod instance.\n\t * @param handler either a bean name or an actual handler instance\n\t * @param method the target method\n\t * @return the created HandlerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tif (handler instanceof String beanName) {\n\t\t\treturn new HandlerMethod(beanName,\n\t\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory(),\n\t\t\t\t\tobtainApplicationContext(),\n\t\t\t\t\tmethod);\n\t\t}\n\t\treturn new HandlerMethod(handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getCorsConfiguration(handler,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tCorsConfiguration corsConfig = super.getCorsConfiguration(handler, exchange);\n\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\tif (handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) {\n\t\t\t\treturn ALLOW_CORS_CONFIG;\n\t\t\t}\n\t\t\tCorsConfiguration methodConfig = this.mappingRegistry.getCorsConfiguration(handlerMethod);\n\t\t\tcorsConfig = (corsConfig != null ? corsConfig.combine(methodConfig) : methodConfig);\n\t\t}\n\t\treturn corsConfig;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a sub-type of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getMatchingMapping(mapping,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param exchange the current exchange\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, ServerWebExchange exchange)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, ServerWebExchange exchange);"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleMatch(mapping,handlerMethod,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a matching mapping is found.\n\t * @param mapping the matching mapping\n\t * @param handlerMethod the matching method\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange) {\n\t\tString lookupPath = exchange.getRequest().getPath().pathWithinApplication().value();\n\t\texchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleNoMatch(mappings,exchange)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param exchange the current exchange\n\t * @return an alternative HandlerMethod or {@code null}\n\t * @throws Exception provides details that can be translated into an error status code\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange) throws Exception {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handlerMethodsInitialized(Map<T,handlerMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after all handler methods have been detected.\n\t * @param handlerMethods a read-only map with handler methods and mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<T",
      "handlerMethods"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods)",
    "source_code": "\tprotected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#initCorsConfiguration(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the CORS configuration for the mapping.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#invoke(exchange,bindingContext,providedArgs)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method for the given exchange.\n\t * @param exchange the current exchange\n\t * @param bindingContext the binding context to use\n\t * @param providedArgs optional list of argument values to match by type\n\t * @return a Mono with a {@link HandlerResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "bindingContext",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> invoke(ServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs)",
    "source_code": "\tpublic Mono<HandlerResult> invoke(\n\t\t\tServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs) {\n\n\t\treturn getMethodArgumentValues(exchange, bindingContext, providedArgs).flatMap(args -> {\n\t\t\tObject value;\n\t\t\ttry {\n\t\t\t\tMethod method = getBridgedMethod();\n\t\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\t\tvalue = CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = method.invoke(getBean(), args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(text, args), ex));\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\treturn Mono.error(ex.getTargetException());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Unlikely to ever get here, but it must be handled...\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(\"Invocation failure\", args), ex));\n\t\t\t}\n\n\t\t\tHttpStatusCode status = getResponseStatus();\n\t\t\tif (status != null) {\n\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t}\n\n\t\t\tMethodParameter returnType = getReturnType();\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(returnType.getParameterType());\n\t\t\tboolean asyncVoid = isAsyncVoidReturnType(returnType, adapter);\n\t\t\tif ((value == null || asyncVoid) && isResponseHandled(args, exchange)) {\n\t\t\t\treturn (asyncVoid ? Mono.from(adapter.toPublisher(value)) : Mono.empty());\n\t\t\t}\n\n\t\t\tHandlerResult result = new HandlerResult(this, value, returnType, bindingContext);\n\t\t\treturn Mono.just(result);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#register(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 522
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping. Invoked at startup for\n\t * each detected handler method.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#registerMapping(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given mapping.\n\t * <p>This method may be invoked at runtime after initialization has completed.\n\t * @param mapping the mapping for the handler method\n\t * @param handler the handler\n\t * @param method the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void registerMapping(T mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(T mapping, Object handler, Method method) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Register \\\"\" + mapping + \"\\\" to \" + method.toGenericString());\n\t\t}\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handle(exchange,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler)",
    "source_code": "\tpublic Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler) {\n\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n\t\tAssert.state(this.methodResolver != null && this.modelInitializer != null, \"Not initialized\");\n\n\t\tInitBinderBindingContext bindingContext = new InitBinderBindingContext(\n\t\t\t\tgetWebBindingInitializer(), this.methodResolver.getInitBinderMethods(handlerMethod));\n\n\t\tInvocableHandlerMethod invocableMethod = this.methodResolver.getRequestMappingMethod(handlerMethod);\n\n\t\tFunction<Throwable, Mono<HandlerResult>> exceptionHandler =\n\t\t\t\tex -> handleException(ex, handlerMethod, bindingContext, exchange);\n\n\t\treturn this.modelInitializer\n\t\t\t\t.initModel(handlerMethod, bindingContext, exchange)\n\t\t\t\t.then(Mono.defer(() -> invocableMethod.invoke(exchange, bindingContext)))\n\t\t\t\t.doOnNext(result -> result.setExceptionHandler(exceptionHandler))\n\t\t\t\t.doOnNext(result -> bindingContext.saveModel())\n\t\t\t\t.onErrorResume(exceptionHandler);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleResult(exchange,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tMono<?> returnValueMono;\n\t\tMethodParameter bodyParameter;\n\t\tReactiveAdapter adapter = getAdapter(result);\n\t\tMethodParameter actualParameter = result.getReturnTypeSource();\n\n\t\tif (adapter != null) {\n\t\t\tAssert.isTrue(!adapter.isMultiValue(), \"Only a single ResponseEntity supported\");\n\t\t\treturnValueMono = Mono.from(adapter.toPublisher(result.getReturnValue()));\n\t\t\tboolean isContinuation = (KotlinDetector.isSuspendingFunction(actualParameter.getMethod()) &&\n\t\t\t\t\t!COROUTINES_FLOW_CLASS_NAME.equals(actualParameter.getParameterType().getName()));\n\t\t\tbodyParameter = (isContinuation ? actualParameter.nested() : actualParameter.nested().nested());\n\t\t}\n\t\telse {\n\t\t\treturnValueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\tbodyParameter = actualParameter.nested();\n\t\t}\n\n\t\treturn returnValueMono.flatMap(returnValue -> {\n\t\t\tHttpEntity<?> httpEntity;\n\t\t\tif (returnValue instanceof HttpEntity) {\n\t\t\t\thttpEntity = (HttpEntity<?>) returnValue;\n\t\t\t}\n\t\t\telse if (returnValue instanceof ErrorResponse response) {\n\t\t\t\thttpEntity = new ResponseEntity<>(response.getBody(), response.getHeaders(), response.getStatusCode());\n\t\t\t}\n\t\t\telse if (returnValue instanceof ProblemDetail detail) {\n\t\t\t\thttpEntity = new ResponseEntity<>(returnValue, HttpHeaders.EMPTY, detail.getStatus());\n\t\t\t}\n\t\t\telse if (returnValue instanceof HttpHeaders) {\n\t\t\t\thttpEntity = new ResponseEntity<>((HttpHeaders) returnValue, HttpStatus.OK);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"HttpEntity or HttpHeaders expected but got: \" + returnValue.getClass());\n\t\t\t}\n\n\t\t\tif (httpEntity.getBody() instanceof ProblemDetail detail) {\n\t\t\t\tif (detail.getInstance() == null) {\n\t\t\t\t\tURI path = URI.create(exchange.getRequest().getPath().value());\n\t\t\t\t\tdetail.setInstance(path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (httpEntity instanceof ResponseEntity<?> responseEntity) {\n\t\t\t\texchange.getResponse().setStatusCode(responseEntity.getStatusCode());\n\t\t\t}\n\n\t\t\tHttpHeaders entityHeaders = httpEntity.getHeaders();\n\t\t\tHttpHeaders responseHeaders = exchange.getResponse().getHeaders();\n\t\t\tif (!entityHeaders.isEmpty()) {\n\t\t\t\tentityHeaders.entrySet().stream()\n\t\t\t\t\t\t.forEach(entry -> responseHeaders.put(entry.getKey(), entry.getValue()));\n\t\t\t}\n\n\t\t\tif (httpEntity.getBody() == null || returnValue instanceof HttpHeaders) {\n\t\t\t\treturn exchange.getResponse().setComplete();\n\t\t\t}\n\n\t\t\tString etag = entityHeaders.getETag();\n\t\t\tInstant lastModified = Instant.ofEpochMilli(entityHeaders.getLastModified());\n\t\t\tHttpMethod httpMethod = exchange.getRequest().getMethod();\n\t\t\tif (SAFE_METHODS.contains(httpMethod) && exchange.checkNotModified(etag, lastModified)) {\n\t\t\t\treturn exchange.getResponse().setComplete();\n\t\t\t}\n\n\t\t\treturn writeBody(httpEntity.getBody(), bodyParameter, actualParameter, exchange);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#changeLocale(locale,timeZone)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified locale and time zone context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale, TimeZone timeZone)",
    "source_code": "\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getBindStatus(path,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the\n\t * \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will\n\t * be resolved (e.g. \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders --\n\t * named keys with braces {@code {}}. For example, send in a relative URL\n\t * {@code foo/{bar}?spam={spam}} and a parameter map {@code {bar=baz,spam=nuts}}\n\t * and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the current web application with an\n\t * absolute path also URL-encoded accordingly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = StringUtils.applyRelativePath(getContextPath() + \"/\", relativeUrl);\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\treturn getExchange().transformUrl(url);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getErrors(name,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name, boolean htmlEscape)",
    "source_code": "\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tif (errors == null) {\n\t\t\terrors = getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (errors instanceof BindException bindException) {\n\t\t\terrors = bindException.getBindingResult();\n\t\t}\n\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t}\n\n\t\tthis.errorsMap.put(name, errors);\n\t\treturn errors;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, this.locale);\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(code, args, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,defaultMessage)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(resolvable,htmlEscape)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(resolvable, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.socket.<unknown>#create(code,reason)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a constant for the given code, or create a new instance if the\n\t * code does not match or there is a reason.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "CloseStatus",
    "signature": "public CloseStatus create(int code, @Nullable String reason)",
    "source_code": "\tpublic static CloseStatus create(int code, @Nullable String reason) {\n\t\tif (!StringUtils.hasText(reason)) {\n\t\t\tswitch (code) {\n\t\t\t\tcase 1000:\n\t\t\t\t\treturn NORMAL;\n\t\t\t\tcase 1001:\n\t\t\t\t\treturn GOING_AWAY;\n\t\t\t\tcase 1002:\n\t\t\t\t\treturn PROTOCOL_ERROR;\n\t\t\t\tcase 1003:\n\t\t\t\t\treturn NOT_ACCEPTABLE;\n\t\t\t\tcase 1005:\n\t\t\t\t\treturn NO_STATUS_CODE;\n\t\t\t\tcase 1006:\n\t\t\t\t\treturn NO_CLOSE_FRAME;\n\t\t\t\tcase 1007:\n\t\t\t\t\treturn BAD_DATA;\n\t\t\t\tcase 1008:\n\t\t\t\t\treturn POLICY_VIOLATION;\n\t\t\t\tcase 1009:\n\t\t\t\t\treturn TOO_BIG_TO_PROCESS;\n\t\t\t\tcase 1010:\n\t\t\t\t\treturn REQUIRED_EXTENSION;\n\t\t\t\tcase 1011:\n\t\t\t\t\treturn SERVER_ERROR;\n\t\t\t\tcase 1012:\n\t\t\t\t\treturn SERVICE_RESTARTED;\n\t\t\t\tcase 1013:\n\t\t\t\t\treturn SERVICE_OVERLOAD;\n\t\t\t}\n\t\t}\n\t\treturn new CloseStatus(code, reason);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onClose(session,reason)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void onClose(Session session, CloseReason reason)",
    "source_code": "\tpublic void onClose(Session session, CloseReason reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tint code = reason.getCloseCode().getCode();\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(code, reason.getReasonPhrase()));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(session,exception)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void onError(Session session, Throwable exception)",
    "source_code": "\tpublic void onError(Session session, Throwable exception) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(exception);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onOpen(session,config)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "config"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void onOpen(Session session, EndpointConfig config)",
    "source_code": "\tpublic void onOpen(Session session, EndpointConfig config) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tAssert.state(this.delegateSession != null, \"No delegate session\");\n\n\t\tsession.addMessageHandler(String.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\t\tsession.addMessageHandler(ByteBuffer.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\t\tsession.addMessageHandler(PongMessage.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getRequestURI() + \" [StandardWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#registerCloseListener(servletContext,applicationContext)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link ServletContextListener} that closes the given\n\t * application context when the servlet context is destroyed.\n\t * @param servletContext the servlet context to listen to\n\t * @param applicationContext the application context that is to be\n\t * closed when {@code servletContext} is destroyed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext",
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "void",
    "signature": "protected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext)",
    "source_code": "\tprotected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext) {\n\t\tif (applicationContext instanceof ConfigurableApplicationContext cac) {\n\t\t\tservletContext.addListener(new ServletContextDestroyedListener(cac));\n\t\t}\n\t}"
  },
  "org.springframework.web.server.handler.<unknown>#handle(exchange,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handle(ServerWebExchange exchange, Throwable ex)",
    "source_code": "\tpublic Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {\n\t\tif (!updateResponse(exchange.getResponse(), ex)) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\n\t\t// Mirrors AbstractHandlerExceptionResolver in spring-webmvc...\n\t\tString logPrefix = exchange.getLogPrefix();\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(logPrefix + formatError(ex, exchange.getRequest()));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(logPrefix + formatError(ex, exchange.getRequest()));\n\t\t}\n\n\t\treturn exchange.getResponse().setComplete();\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#addRequestValue(name,value,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, String value, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue(String name, String value, HttpRequestValues.Builder requestValues);"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method,reactiveRegistry,blockTimeout)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method's return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method",
      "reactiveRegistry",
      "blockTimeout"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(HttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout)",
    "source_code": "\t\tpublic static ResponseFunction create(\n\t\t\t\tHttpClientAdapter client, Method method, ReactiveAdapterRegistry reactiveRegistry,\n\t\t\t\tDuration blockTimeout) {\n\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tReactiveAdapter reactiveAdapter = reactiveRegistry.getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::requestToVoid;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::requestToVoid;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::requestToHeaders;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::requestToBodilessEntity;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = reactiveRegistry.getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter);\n\t\t\t}\n\n\t\t\tboolean blockForOptional = actualType.equals(Optional.class);\n\t\t\treturn new ResponseFunction(responseFunction, reactiveAdapter, blockForOptional, blockTimeout);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create(Method method, Class<?> containingClass) {\n\n\t\t\tHttpExchange annot1 = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange annot2 = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(annot2, \"Expected HttpRequest annotation\");\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(annot1, annot2);\n\t\t\tString url = initUrl(annot1, annot2);\n\t\t\tMediaType contentType = initContentType(annot1, annot2);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(annot1, annot2);\n\n\t\t\treturn new HttpRequestValuesInitializer(httpMethod, url, contentType, acceptableMediaTypes);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#resolve(argument,parameter,requestValues)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tNamedValueInfo info = getNamedValueInfo(parameter);\n\t\tif (info == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Map.class.isAssignableFrom(parameter.getParameterType())) {\n\t\t\tAssert.isInstanceOf(Map.class, argument);\n\t\t\tfor (Map.Entry<String, ?> entry : ((Map<String, ?>) argument).entrySet()) {\n\t\t\t\taddSingleOrMultipleValues(\n\t\t\t\t\t\tentry.getKey(), entry.getValue(), false, null, info.label, info.multiValued,\n\t\t\t\t\t\trequestValues);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\taddSingleOrMultipleValues(\n\t\t\t\t\tinfo.name, argument, info.required, info.defaultValue, info.label, info.multiValued,\n\t\t\t\t\trequestValues);\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#update(name,required,defaultValue)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "required",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "NamedValueInfo",
    "signature": "public NamedValueInfo update(String name, boolean required, @Nullable String defaultValue)",
    "source_code": "\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#addInterceptor(index,interceptor)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given interceptor at the specified index of this chain.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, HandlerInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, HandlerInterceptor interceptor) {\n\t\tthis.interceptorList.add(index, interceptor);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParam(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a request parameter identifying the request for this FlashMap.\n\t * @param name the expected parameter name (skipped if empty)\n\t * @param value the expected value (skipped if empty)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParam(String name, String value)",
    "source_code": "\tpublic FlashMap addTargetRequestParam(String name, String value) {\n\t\tif (StringUtils.hasText(name) && StringUtils.hasText(value)) {\n\t\t\tthis.targetRequestParams.add(name, value);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParams(MultiValueMap<String,params)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide request parameters identifying the request for this FlashMap.\n\t * @param params a Map with the names and values of expected parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tparams.forEach((key, values) -> {\n\t\t\t\tfor (String value : values) {\n\t\t\t\t\taddTargetRequestParam(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#buildRequestAttributes(request,response,previousAttributes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build ServletRequestAttributes for the given request (potentially also\n\t * holding a reference to the response), taking pre-bound attributes\n\t * (and their type) into consideration.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param previousAttributes pre-bound RequestAttributes instance, if any\n\t * @return the ServletRequestAttributes to bind, or {@code null} to preserve\n\t * the previously bound instance (or not binding any, if none bound before)\n\t * @see RequestContextHolder#setRequestAttributes\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "previousAttributes"
    ],
    "position": {
      "column": 1,
      "line": 1049
    },
    "return": "ServletRequestAttributes",
    "signature": "protected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,\n\t\t\t@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes)",
    "source_code": "\tprotected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,\n\t\t\t@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes) {\n\n\t\tif (previousAttributes == null || previousAttributes instanceof ServletRequestAttributes) {\n\t\t\treturn new ServletRequestAttributes(request, response);\n\t\t}\n\t\telse {\n\t\t\treturn null;  // preserve the pre-bound RequestAttributes instance\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doDelete(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate DELETE requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 926
    },
    "return": "void",
    "signature": "protected void doDelete(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doDelete(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doGet(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate GET requests to processRequest/doService.\n\t * <p>Will also be invoked by HttpServlet's default implementation of {@code doHead},\n\t * with a {@code NoBodyResponse} that just captures the content length.\n\t * @see #doService\n\t * @see #doHead\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "void",
    "signature": "protected void doGet(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doOptions(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate OPTIONS requests to {@link #processRequest}, if desired.\n\t * <p>Applies HttpServlet's standard OPTIONS processing otherwise,\n\t * and also if there is still no 'Allow' header set after dispatching.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 939
    },
    "return": "void",
    "signature": "protected void doOptions(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doOptions(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) {\n\t\t\tprocessRequest(request, response);\n\t\t\tif (response.containsHeader(HttpHeaders.ALLOW)) {\n\t\t\t\t// Proper OPTIONS response coming from a handler - we're done.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Use response wrapper in order to always add PATCH to the allowed methods\n\t\tsuper.doOptions(request, new HttpServletResponseWrapper(response) {\n\t\t\t@Override\n\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\tif (HttpHeaders.ALLOW.equals(name)) {\n\t\t\t\t\tvalue = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name();\n\t\t\t\t}\n\t\t\t\tsuper.setHeader(name, value);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPost(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate POST requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 904
    },
    "return": "void",
    "signature": "protected void doPost(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPut(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate PUT requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "void",
    "signature": "protected void doPut(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPut(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doService(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to do the work of request handling,\n\t * receiving a centralized callback for GET, POST, PUT and DELETE.\n\t * <p>The contract is essentially the same as that for the commonly overridden\n\t * {@code doGet} or {@code doPost} methods of HttpServlet.\n\t * <p>This class intercepts calls to ensure that exception handling and\n\t * event publication takes place.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t * @see jakarta.servlet.http.HttpServlet#doGet\n\t * @see jakarta.servlet.http.HttpServlet#doPost\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1176
    },
    "return": "void",
    "signature": "protected void doService(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected abstract void doService(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception;\n\n\n\t/**\n\t * ApplicationListener endpoint that receives events from this servlet's WebApplicationContext\n\t * only, delegating to {@code onApplicationEvent} on the FrameworkServlet instance."
  },
  "org.springframework.web.servlet.<unknown>#doTrace(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate TRACE requests to {@link #processRequest}, if desired.\n\t * <p>Applies HttpServlet's standard TRACE processing otherwise.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 968
    },
    "return": "void",
    "signature": "protected void doTrace(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doTrace(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.dispatchTraceRequest) {\n\t\t\tprocessRequest(request, response);\n\t\t\tif (\"message/http\".equals(response.getContentType())) {\n\t\t\t\t// Proper TRACE response coming from a handler - we're done.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.doTrace(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#postProcess(webRequest,task,concurrentResult)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task",
      "concurrentResult"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult)",
    "source_code": "\t\tpublic <T> void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tresetContextHolders(request, null, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#preProcess(webRequest,task)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 1200
    },
    "return": "void",
    "signature": "public void preProcess(NativeWebRequest webRequest, Callable<T> task)",
    "source_code": "\t\tpublic <T> void preProcess(NativeWebRequest webRequest, Callable<T> task) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tHttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\t\t\t\tinitContextHolders(request, buildLocaleContext(request),\n\t\t\t\t\t\tbuildRequestAttributes(request, response, null));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#processRequest(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * <p>The actual event handling is performed by the abstract\n\t * {@link #doService} template method.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 986
    },
    "return": "void",
    "signature": "protected void processRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContext localeContext = buildLocaleContext(request);\n\n\t\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\t\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n\t\tinitContextHolders(request, localeContext, requestAttributes);\n\n\t\ttry {\n\t\t\tdoService(request, response);\n\t\t}\n\t\tcatch (ServletException | IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new NestedServletException(\"Request processing failed\", ex);\n\t\t}\n\n\t\tfinally {\n\t\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);\n\t\t\tif (requestAttributes != null) {\n\t\t\t\trequestAttributes.requestCompleted();\n\t\t\t}\n\t\t\tlogResult(request, response, failureCause, asyncManager);\n\t\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#service(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Override the parent class implementation in order to intercept PATCH requests.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 873
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tHttpMethod httpMethod = HttpMethod.valueOf(request.getMethod());\n\t\tif (HttpMethod.PATCH.equals(httpMethod)) {\n\t\t\tprocessRequest(request, response);\n\t\t}\n\t\telse {\n\t\t\tsuper.service(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#setHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 953
    },
    "return": "void",
    "signature": "public void setHeader(String name, String value)",
    "source_code": "\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\tif (HttpHeaders.ALLOW.equals(name)) {\n\t\t\t\t\tvalue = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name();\n\t\t\t\t}\n\t\t\t\tsuper.setHeader(name, value);\n\t\t\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#parse(element,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext context)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext context) {\n\t\tObject source = context.extractSource(element);\n\t\tXmlReaderContext readerContext = context.getReaderContext();\n\n\t\tCompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);\n\t\tcontext.pushContainingComponent(compDefinition);\n\n\t\tRuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, context);\n\n\t\tRootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n\t\thandlerMappingDef.setSource(source);\n\t\thandlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerMappingDef.getPropertyValues().add(\"order\", 0);\n\t\thandlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\n\t\tif (element.hasAttribute(\"enable-matrix-variables\")) {\n\t\t\tboolean enableMatrixVariables = Boolean.parseBoolean(element.getAttribute(\"enable-matrix-variables\"));\n\t\t\thandlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n\t\t}\n\n\t\tconfigurePathMatchingProperties(handlerMappingDef, element, context);\n\t\treaderContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);\n\n\t\tRuntimeBeanReference corsRef = MvcNamespaceUtils.registerCorsConfigurations(null, context, source);\n\t\thandlerMappingDef.getPropertyValues().add(\"corsConfigurations\", corsRef);\n\n\t\tRuntimeBeanReference conversionService = getConversionService(element, source, context);\n\t\tRuntimeBeanReference validator = getValidator(element, source, context);\n\t\tRuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);\n\n\t\tRootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);\n\t\tbindingDef.setSource(source);\n\t\tbindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tbindingDef.getPropertyValues().add(\"conversionService\", conversionService);\n\t\tbindingDef.getPropertyValues().add(\"validator\", validator);\n\t\tbindingDef.getPropertyValues().add(\"messageCodesResolver\", messageCodesResolver);\n\n\t\tManagedList<?> messageConverters = getMessageConverters(element, source, context);\n\t\tManagedList<?> argumentResolvers = getArgumentResolvers(element, context);\n\t\tManagedList<?> returnValueHandlers = getReturnValueHandlers(element, context);\n\t\tString asyncTimeout = getAsyncTimeout(element);\n\t\tRuntimeBeanReference asyncExecutor = getAsyncExecutor(element);\n\t\tManagedList<?> callableInterceptors = getInterceptors(element, source, context, \"callable-interceptors\");\n\t\tManagedList<?> deferredResultInterceptors = getInterceptors(element, source, context, \"deferred-result-interceptors\");\n\n\t\tRootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);\n\t\thandlerAdapterDef.setSource(source);\n\t\thandlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerAdapterDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\thandlerAdapterDef.getPropertyValues().add(\"webBindingInitializer\", bindingDef);\n\t\thandlerAdapterDef.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\taddRequestBodyAdvice(handlerAdapterDef);\n\t\taddResponseBodyAdvice(handlerAdapterDef);\n\n\t\tif (element.hasAttribute(\"ignore-default-model-on-redirect\")) {\n\t\t\tBoolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\"ignore-default-model-on-redirect\"));\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n\t\t}\n\t\tif (argumentResolvers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tif (asyncTimeout != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"asyncRequestTimeout\", asyncTimeout);\n\t\t}\n\t\tif (asyncExecutor != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"taskExecutor\", asyncExecutor);\n\t\t}\n\n\t\thandlerAdapterDef.getPropertyValues().add(\"callableInterceptors\", callableInterceptors);\n\t\thandlerAdapterDef.getPropertyValues().add(\"deferredResultInterceptors\", deferredResultInterceptors);\n\t\treaderContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);\n\n\t\tRootBeanDefinition uriContributorDef =\n\t\t\t\tnew RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);\n\t\turiContributorDef.setSource(source);\n\t\turiContributorDef.getPropertyValues().addPropertyValue(\"handlerAdapter\", handlerAdapterDef);\n\t\turiContributorDef.getPropertyValues().addPropertyValue(\"conversionService\", conversionService);\n\t\tString uriContributorName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;\n\t\treaderContext.getRegistry().registerBeanDefinition(uriContributorName, uriContributorDef);\n\n\t\tRootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);\n\t\tcsInterceptorDef.setSource(source);\n\t\tcsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);\n\t\tRootBeanDefinition mappedInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);\n\t\tmappedInterceptorDef.setSource(source);\n\t\tmappedInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);\n\t\tmappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);\n\t\tString mappedInterceptorName = readerContext.registerWithGeneratedName(mappedInterceptorDef);\n\n\t\tRootBeanDefinition methodExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);\n\t\tmethodExceptionResolver.setSource(source);\n\t\tmethodExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"order\", 0);\n\t\taddResponseBodyAdvice(methodExceptionResolver);\n\t\tif (argumentResolvers != null) {\n\t\t\tmethodExceptionResolver.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\tmethodExceptionResolver.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tString methodExResolverName = readerContext.registerWithGeneratedName(methodExceptionResolver);\n\n\t\tRootBeanDefinition statusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);\n\t\tstatusExceptionResolver.setSource(source);\n\t\tstatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tstatusExceptionResolver.getPropertyValues().add(\"order\", 1);\n\t\tString statusExResolverName = readerContext.registerWithGeneratedName(statusExceptionResolver);\n\n\t\tRootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);\n\t\tdefaultExceptionResolver.setSource(source);\n\t\tdefaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tdefaultExceptionResolver.getPropertyValues().add(\"order\", 2);\n\t\tString defaultExResolverName = readerContext.registerWithGeneratedName(defaultExceptionResolver);\n\n\t\tcontext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME));\n\t\tcontext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME));\n\t\tcontext.registerComponent(new BeanComponentDefinition(uriContributorDef, uriContributorName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(mappedInterceptorDef, mappedInterceptorName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(methodExceptionResolver, methodExResolverName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(statusExceptionResolver, statusExResolverName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExResolverName));\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(context, source);\n\n\t\tcontext.popAndRegisterContainingComponent();\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#parse(element,parserContext)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tObject source = parserContext.extractSource(element);\n\n\t\t// Register SimpleUrlHandlerMapping for view controllers\n\t\tBeanDefinition hm = registerHandlerMapping(parserContext, source);\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(parserContext, source);\n\n\t\t// Create view controller bean definition\n\t\tRootBeanDefinition controller = new RootBeanDefinition(ParameterizableViewController.class);\n\t\tcontroller.setSource(source);\n\n\t\tHttpStatusCode statusCode = null;\n\t\tif (element.hasAttribute(\"status-code\")) {\n\t\t\tint statusValue = Integer.parseInt(element.getAttribute(\"status-code\"));\n\t\t\tstatusCode = HttpStatusCode.valueOf(statusValue);\n\t\t}\n\n\t\tString name = element.getLocalName();\n\t\tswitch (name) {\n\t\t\tcase \"view-controller\" -> {\n\t\t\t\tif (element.hasAttribute(\"view-name\")) {\n\t\t\t\t\tcontroller.getPropertyValues().add(\"viewName\", element.getAttribute(\"view-name\"));\n\t\t\t\t}\n\t\t\t\tif (statusCode != null) {\n\t\t\t\t\tcontroller.getPropertyValues().add(\"statusCode\", statusCode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase \"redirect-view-controller\" ->\n\t\t\t\tcontroller.getPropertyValues().add(\"view\", getRedirectView(element, statusCode, source));\n\t\t\tcase \"status-controller\" -> {\n\t\t\t\tcontroller.getPropertyValues().add(\"statusCode\", statusCode);\n\t\t\t\tcontroller.getPropertyValues().add(\"statusOnly\", true);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\t// Should never happen...\n\t\t\t\tthrow new IllegalStateException(\"Unexpected tag name: \" + name);\n\t\t}\n\n\t\tMap<String, BeanDefinition> urlMap = (Map<String, BeanDefinition>) hm.getPropertyValues().get(\"urlMap\");\n\t\tif (urlMap == null) {\n\t\t\turlMap = new ManagedMap<>();\n\t\t\thm.getPropertyValues().add(\"urlMap\", urlMap);\n\t\t}\n\t\turlMap.put(element.getAttribute(\"path\"), controller);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addDateHeader(name,date)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 584
    },
    "return": "void",
    "signature": "public void addDateHeader(String name, long date)",
    "source_code": "\t\tpublic void addDateHeader(String name, long date) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "void",
    "signature": "public void addHeader(String name, String value)",
    "source_code": "\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addIntHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 502
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\t\t\tpublic void addIntHeader(String name, int value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addIntHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#attributes(Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void attributes(Map<String, Object> attributes)",
    "source_code": "\tpublic void attributes(Map<String, Object> attributes) {\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#checkNotModified(lastModified,etag)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified",
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1079
    },
    "return": "Optional<ServerResponse>",
    "signature": "public Optional<ServerResponse> checkNotModified(Instant lastModified, String etag)",
    "source_code": "\t\tpublic Optional<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.request.checkNotModified(lastModified, etag);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#param(name,predicate)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the parameter to test against\n\t * @param predicate the predicate to test against the parameter value\n\t * @return a predicate that matches the given predicate against the parameter of the given name\n\t * @see ServerRequest#param(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate param(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate param(String name, Predicate<String> predicate) {\n\t\treturn new ParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#param(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's parameter of the given name\n\t * has the given value.\n\t * @param name the name of the parameter to test against\n\t * @param value the value of the parameter to test against\n\t * @return a predicate that matches if the parameter has the given value\n\t * @see ServerRequest#param(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate param(String name, String value)",
    "source_code": "\tpublic static RequestPredicate param(String name, String value) {\n\t\treturn new ParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject oldValue = this.servletRequest.getAttribute(key);\n\t\t\tthis.servletRequest.setAttribute(key, value);\n\t\t\treturn oldValue;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Optional<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Optional<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#route(predicate,handlerFunction)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "handlerFunction"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction)",
    "source_code": "\tpublic void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {\n\t\tchangeParser(predicate);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendError(sc,msg)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "msg"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "void",
    "signature": "public void sendError(int sc, String msg)",
    "source_code": "\t\tpublic void sendError(int sc, String msg) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setDateHeader(name,date)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 491
    },
    "return": "void",
    "signature": "public void setDateHeader(String name, long date)",
    "source_code": "\t\tpublic void setDateHeader(String name, long date) {\n\t\t\tthis.headers.setDate(name, date);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "void",
    "signature": "public void setHeader(String name, String value)",
    "source_code": "\t\tpublic void setHeader(String name, String value) {\n\t\t\tthis.headers.set(name, value);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setIntHeader(name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "void",
    "signature": "public void setIntHeader(String name, int value)",
    "source_code": "\t\tpublic void setIntHeader(String name, int value) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setStatus(sc,sm)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "sm"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "void",
    "signature": "public void setStatus(int sc, String sm)",
    "source_code": "\t\tpublic void setStatus(int sc, String sm) {\n\t\t\tthis.status = sc;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#tryWriteEntityWithMessageConverters(entity,request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "entity",
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "protected void tryWriteEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)",
    "source_code": "\t\tprotected void tryWriteEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context) throws ServletException, IOException {\n\t\t\ttry {\n\t\t\t\twriteEntityWithMessageConverters(entity, request, response, context);\n\t\t\t}\n\t\t\tcatch (IOException | ServletException ex) {\n\t\t\t\thandleError(ex, request, response, context);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeEntityWithMessageConverters(entity,request,response,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "entity",
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)",
    "source_code": "\t\tprotected void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)\n\t\t\t\tthrows ServletException, IOException {\n\n\t\t\tServletServerHttpResponse serverResponse = new ServletServerHttpResponse(response);\n\t\t\tMediaType contentType = getContentType(response);\n\t\t\tClass<?> entityClass = entity.getClass();\n\t\t\tType entityType = this.entityType;\n\n\t\t\tif (entityClass != InputStreamResource.class && Resource.class.isAssignableFrom(entityClass)) {\n\t\t\t\tserverResponse.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t\tString rangeHeader = request.getHeader(HttpHeaders.RANGE);\n\t\t\t\tif (rangeHeader != null) {\n\t\t\t\t\tResource resource = (Resource) entity;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tList<HttpRange> httpRanges = HttpRange.parseRanges(rangeHeader);\n\t\t\t\t\t\tserverResponse.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n\t\t\t\t\t\tentity = HttpRange.toResourceRegions(httpRanges, resource);\n\t\t\t\t\t\tentityClass = entity.getClass();\n\t\t\t\t\t\tentityType = RESOURCE_REGION_LIST_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\tserverResponse.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\t\t\tserverResponse.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (HttpMessageConverter<?> messageConverter : context.messageConverters()) {\n\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter genericMessageConverter) {\n\t\t\t\t\tif (genericMessageConverter.canWrite(entityType, entityClass, contentType)) {\n\t\t\t\t\t\tgenericMessageConverter.write(entity, entityType, contentType, serverResponse);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (messageConverter.canWrite(entityClass, contentType)) {\n\t\t\t\t\t((HttpMessageConverter<Object>) messageConverter).write(entity, contentType, serverResponse);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<MediaType> producibleMediaTypes = producibleMediaTypes(context.messageConverters(), entityClass);\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(servletRequest,servletResponse,context)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletRequest",
      "servletResponse",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,\n\t\t\t\tContext context)",
    "source_code": "\t\tprotected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,\n\t\t\t\tContext context) throws ServletException, IOException {\n\n\t\t\tDeferredResult<?> deferredResult = new DeferredResult<>();\n\t\t\tDefaultAsyncServerResponse.writeAsync(servletRequest, servletResponse, deferredResult);\n\n\t\t\tentity().subscribe(new DeferredResultSubscriber(servletRequest, servletResponse, context, deferredResult));\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#afterCompletion(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.interceptor.afterCompletion(request, response, handler, ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#afterConcurrentHandlingStarted(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) {\n\t\tif (this.requestInterceptor instanceof AsyncWebRequestInterceptor asyncInterceptor) {\n\t\t\tDispatcherServletWebRequest webRequest = new DispatcherServletWebRequest(request, response);\n\t\t\tasyncInterceptor.afterConcurrentHandlingStarted(webRequest);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#buildPathExposingHandler(rawHandler,bestMatchingPattern,pathWithinMapping,Map<String,uriTemplateVariables)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a handler object for the given raw handler, exposing the actual\n\t * handler, the {@link #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE}, as well as\n\t * the {@link #URI_TEMPLATE_VARIABLES_ATTRIBUTE} before executing the handler.\n\t * <p>The default implementation builds a {@link HandlerExecutionChain}\n\t * with a special interceptor that exposes the path attribute and URI\n\t * template variables\n\t * @param rawHandler the raw handler to expose\n\t * @param pathWithinMapping the path to expose before executing the handler\n\t * @param uriTemplateVariables the URI template variables, can be {@code null} if no variables found\n\t * @return the final handler object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rawHandler",
      "bestMatchingPattern",
      "pathWithinMapping",
      "Map<String",
      "uriTemplateVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Object",
    "signature": "protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,\n\t\t\tString pathWithinMapping, @Nullable Map<String, String> uriTemplateVariables)",
    "source_code": "\tprotected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,\n\t\t\tString pathWithinMapping, @Nullable Map<String, String> uriTemplateVariables) {\n\n\t\tHandlerExecutionChain chain = new HandlerExecutionChain(rawHandler);\n\t\tchain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));\n\t\tif (!CollectionUtils.isEmpty(uriTemplateVariables)) {\n\t\t\tchain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#compare(match1,match2)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 829
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#createHandlerMethod(handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Create the HandlerMethod instance.\n\t * @param handler either a bean name or an actual handler instance\n\t * @param method the target method\n\t * @return the created HandlerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tif (handler instanceof String beanName) {\n\t\t\treturn new HandlerMethod(beanName,\n\t\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory(),\n\t\t\t\t\tobtainApplicationContext(),\n\t\t\t\t\tmethod);\n\t\t}\n\t\treturn new HandlerMethod(handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveException(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected final ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tHandlerMethod handlerMethod = (handler instanceof HandlerMethod ? (HandlerMethod) handler : null);\n\t\treturn doResolveHandlerMethodException(request, response, handlerMethod, ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveHandlerMethodException(request,response,handlerMethod,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Actually resolve the given exception that got thrown during on handler execution,\n\t * returning a ModelAndView that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolved applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod the executed handler method, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to, or {@code null} for default processing\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex)",
    "source_code": "\tprotected abstract ModelAndView doResolveHandlerMethodException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex);\n\n}"
  },
  "org.springframework.web.servlet.handler.<unknown>#exposePathWithinMapping(bestMatchingPattern,pathWithinMapping,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the path within the current mapping as request attribute.\n\t * @param pathWithinMapping the path within the current mapping\n\t * @param request the request to expose the path to\n\t * @see #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bestMatchingPattern",
      "pathWithinMapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "void",
    "signature": "protected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping,\n\t\t\tHttpServletRequest request)",
    "source_code": "\tprotected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping,\n\t\t\tHttpServletRequest request) {\n\n\t\trequest.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatchingPattern);\n\t\trequest.setAttribute(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#exposeUriTemplateVariables(Map<String,uriTemplateVariables,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the URI templates variables as request attribute.\n\t * @param uriTemplateVariables the URI template variables\n\t * @param request the request to expose the path to\n\t * @see #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "uriTemplateVariables",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "void",
    "signature": "protected void exposeUriTemplateVariables(Map<String, String> uriTemplateVariables, HttpServletRequest request)",
    "source_code": "\tprotected void exposeUriTemplateVariables(Map<String, String> uriTemplateVariables, HttpServletRequest request) {\n\t\trequest.setAttribute(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriTemplateVariables);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getCorsConfiguration(handler,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) {\n\t\tCorsConfiguration corsConfig = super.getCorsConfiguration(handler, request);\n\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\tif (handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) {\n\t\t\t\treturn AbstractHandlerMethodMapping.ALLOW_CORS_CONFIG;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCorsConfiguration corsConfigFromMethod = this.mappingRegistry.getCorsConfiguration(handlerMethod);\n\t\t\t\tcorsConfig = (corsConfig != null ? corsConfig.combine(corsConfigFromMethod) : corsConfigFromMethod);\n\t\t\t}\n\t\t}\n\t\treturn corsConfig;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getCorsHandlerExecutionChain(request,chain,config)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Update the HandlerExecutionChain for CORS-related handling.\n\t * <p>For pre-flight requests, the default implementation replaces the selected\n\t * handler with a simple HttpRequestHandler that invokes the configured\n\t * {@link #setCorsProcessor}.\n\t * <p>For actual requests, the default implementation inserts a\n\t * HandlerInterceptor that makes CORS-related checks and adds CORS headers.\n\t * @param request the current request\n\t * @param chain the handler chain\n\t * @param config the applicable CORS configuration (possibly {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "chain",
      "config"
    ],
    "position": {
      "column": 1,
      "line": 661
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,\n\t\t\tHandlerExecutionChain chain, @Nullable CorsConfiguration config)",
    "source_code": "\tprotected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request,\n\t\t\tHandlerExecutionChain chain, @Nullable CorsConfiguration config) {\n\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\tHandlerInterceptor[] interceptors = chain.getInterceptors();\n\t\t\treturn new HandlerExecutionChain(new PreFlightHandler(config), interceptors);\n\t\t}\n\t\telse {\n\t\t\tchain.addInterceptor(0, new CorsInterceptor(config));\n\t\t\treturn chain;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getHandlerExecutionChain(handler,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link HandlerExecutionChain} for the given handler, including\n\t * applicable interceptors.\n\t * <p>The default implementation builds a standard {@link HandlerExecutionChain}\n\t * with the given handler, the common interceptors of the handler mapping, and any\n\t * {@link MappedInterceptor MappedInterceptors} matching to the current request URL. Interceptors\n\t * are added in the order they were registered. Subclasses may override this\n\t * in order to extend/rearrange the list of interceptors.\n\t * <p><b>NOTE:</b> The passed-in handler object may be a raw handler or a\n\t * pre-built {@link HandlerExecutionChain}. This method should handle those\n\t * two cases explicitly, either building a new {@link HandlerExecutionChain}\n\t * or extending the existing chain.\n\t * <p>For simply adding an interceptor in a custom subclass, consider calling\n\t * {@code super.getHandlerExecutionChain(handler, request)} and invoking\n\t * {@link HandlerExecutionChain#addInterceptor} on the returned chain object.\n\t * @param handler the resolved handler instance (never {@code null})\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain (never {@code null})\n\t * @see #getAdaptedInterceptors()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 602
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n\t\tHandlerExecutionChain chain = (handler instanceof HandlerExecutionChain handlerExecutionChain ?\n\t\t\t\thandlerExecutionChain : new HandlerExecutionChain(handler));\n\n\t\tfor (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n\t\t\tif (interceptor instanceof MappedInterceptor mappedInterceptor) {\n\t\t\t\tif (mappedInterceptor.matches(request)) {\n\t\t\t\t\tchain.addInterceptor(mappedInterceptor.getInterceptor());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchain.addInterceptor(interceptor);\n\t\t\t}\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMappingForMethod(method,handlerType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a sub-type of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMatchingMapping(mapping,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param request the current HTTP servlet request\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, HttpServletRequest request)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, HttpServletRequest request);"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleMatch(mapping,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a matching mapping is found.\n\t * @param mapping the matching mapping\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected void handleMatch(T mapping, String lookupPath, HttpServletRequest request) {\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleNoMatch(mappings,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t * @throws ServletException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request)\n\t\t\tthrows Exception {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleRequest(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 685
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tcorsProcessor.processRequest(this.config, request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handlerMethodsInitialized(Map<T,handlerMethods)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after all handler methods have been detected.\n\t * @param handlerMethods a read-only map with handler methods and mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<T",
      "handlerMethods"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods)",
    "source_code": "\tprotected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {\n\t\t// Total includes detected mappings + explicit registrations via registerMapping\n\t\tint total = handlerMethods.size();\n\t\tif ((logger.isTraceEnabled() && total == 0) || (logger.isDebugEnabled() && total > 0) ) {\n\t\t\tlogger.debug(total + \" mappings in \" + formatMappingName());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initCorsConfiguration(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the CORS configuration for the mapping.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initPatterns(patterns,parser)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "PatternAdapter[]",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when String pattern matching with {@code PathMatcher} is in use.\n\t * @param lookupPath the path to match patterns against\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @see #exposePathWithinMapping\n\t * @see AntPathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(String lookupPath, HttpServletRequest request) throws Exception {\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<String> matchingPatterns = new ArrayList<>();\n\t\tfor (String registeredPattern : this.handlerMap.keySet()) {\n\t\t\tif (getPathMatcher().match(registeredPattern, lookupPath)) {\n\t\t\t\tmatchingPatterns.add(registeredPattern);\n\t\t\t}\n\t\t\telse if (useTrailingSlashMatch()) {\n\t\t\t\tif (!registeredPattern.endsWith(\"/\") && getPathMatcher().match(registeredPattern + \"/\", lookupPath)) {\n\t\t\t\t\tmatchingPatterns.add(registeredPattern + \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString bestMatch = null;\n\t\tComparator<String> patternComparator = getPathMatcher().getPatternComparator(lookupPath);\n\t\tif (!matchingPatterns.isEmpty()) {\n\t\t\tmatchingPatterns.sort(patternComparator);\n\t\t\tif (logger.isTraceEnabled() && matchingPatterns.size() > 1) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matchingPatterns);\n\t\t\t}\n\t\t\tbestMatch = matchingPatterns.get(0);\n\t\t}\n\t\tif (bestMatch != null) {\n\t\t\thandler = this.handlerMap.get(bestMatch);\n\t\t\tif (handler == null) {\n\t\t\t\tif (bestMatch.endsWith(\"/\")) {\n\t\t\t\t\thandler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));\n\t\t\t\t}\n\t\t\t\tif (handler == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Could not find handler for best pattern match [\" + bestMatch + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Bean name or resolved handler?\n\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t\t}\n\t\t\tvalidateHandler(handler, request);\n\t\t\tString pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);\n\n\t\t\t// There might be multiple 'best patterns', let's make sure we have the correct URI template variables\n\t\t\t// for all of them\n\t\t\tMap<String, String> uriTemplateVariables = new LinkedHashMap<>();\n\t\t\tfor (String matchingPattern : matchingPatterns) {\n\t\t\t\tif (patternComparator.compare(bestMatch, matchingPattern) == 0) {\n\t\t\t\t\tMap<String, String> vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);\n\t\t\t\t\tMap<String, String> decodedVars = getUrlPathHelper().decodePathVariables(request, vars);\n\t\t\t\t\turiTemplateVariables.putAll(decodedVars);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled() && uriTemplateVariables.size() > 0) {\n\t\t\t\tlogger.trace(\"URI variables \" + uriTemplateVariables);\n\t\t\t}\n\t\t\treturn buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);\n\t\t}\n\n\t\t// No handler found...\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(path,lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when parsed {@code PathPattern}s are {@link #usesPathPatterns() enabled}.\n\t * @param path the parsed RequestPath\n\t * @param lookupPath the String lookupPath for checking direct hits\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(RequestPath path, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(\n\t\t\tRequestPath path, String lookupPath, HttpServletRequest request) throws Exception {\n\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.pathPatternHandlerMap.keySet()) {\n\t\t\tif (pattern.matches(path.pathWithinApplication())) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\t\tPathPattern pattern = matches.get(0);\n\t\thandler = this.pathPatternHandlerMap.get(pattern);\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\t\tvalidateHandler(handler, request);\n\t\tString pathWithinMapping = pattern.extractPathWithinPattern(path.pathWithinApplication()).value();\n\t\tpathWithinMapping = UrlPathHelper.defaultInstance.removeSemicolonContent(pathWithinMapping);\n\t\treturn buildPathExposingHandler(handler, pattern.getPatternString(), pathWithinMapping, null);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandlerMethod(lookupPath,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the best-matching handler method for the current request.\n\t * If multiple matches are found, the best match is selected.\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t * @return the best-matching handler method, or {@code null} if no match\n\t * @see #handleMatch(Object, String, HttpServletRequest)\n\t * @see #handleNoMatch(Set, String, HttpServletRequest)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n\t\tList<Match> matches = new ArrayList<>();\n\t\tList<T> directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath);\n\t\tif (directPathMatches != null) {\n\t\t\taddMatchingMappings(directPathMatches, matches, request);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\taddMatchingMappings(this.mappingRegistry.getRegistrations().keySet(), matches, request);\n\t\t}\n\t\tif (!matches.isEmpty()) {\n\t\t\tMatch bestMatch = matches.get(0);\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(request));\n\t\t\t\tmatches.sort(comparator);\n\t\t\t\tbestMatch = matches.get(0);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(matches.size() + \" matching mappings: \" + matches);\n\t\t\t\t}\n\t\t\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\t\t\tfor (Match match : matches) {\n\t\t\t\t\t\tif (match.hasCorsConfig()) {\n\t\t\t\t\t\t\treturn PREFLIGHT_AMBIGUOUS_MATCH;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\t\t\tMethod m1 = bestMatch.getHandlerMethod().getMethod();\n\t\t\t\t\t\tMethod m2 = secondBestMatch.getHandlerMethod().getMethod();\n\t\t\t\t\t\tString uri = request.getRequestURI();\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Ambiguous handler methods mapped for '\" + uri + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trequest.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());\n\t\t\thandleMatch(bestMatch.mapping, lookupPath, request);\n\t\t\treturn bestMatch.getHandlerMethod();\n\t\t}\n\t\telse {\n\t\t\treturn handleNoMatch(this.mappingRegistry.getRegistrations().keySet(), lookupPath, request);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#match(path,isPathContainer,pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "isPathContainer",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "boolean",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#match(request,pattern)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.isNull(getPatternParser(), \"This HandlerMapping uses PathPatterns.\");\n\t\tString lookupPath = UrlPathHelper.getResolvedLookupPath(request);\n\t\tif (getPathMatcher().match(pattern, lookupPath)) {\n\t\t\treturn new RequestMatchResult(pattern, lookupPath, getPathMatcher());\n\t\t}\n\t\telse if (useTrailingSlashMatch()) {\n\t\t\tif (!pattern.endsWith(\"/\") && getPathMatcher().match(pattern + \"/\", lookupPath)) {\n\t\t\t\treturn new RequestMatchResult(pattern + \"/\", lookupPath, getPathMatcher());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#matches(lookupPath,pathMatcher)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lookupPath",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postHandle(request,response,handler,modelAndView)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "void",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.interceptor.postHandle(request, response, handler, modelAndView);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#preHandle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn this.interceptor.preHandle(request, response, handler);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#register(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 630
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tString name = null;\n\t\t\t\tif (getNamingStrategy() != null) {\n\t\t\t\t\tname = getNamingStrategy().getName(handlerMethod, mapping);\n\t\t\t\t\taddMappingName(name, handlerMethod);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, name, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPath,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\t\tif (applicationContext.isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = applicationContext.getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\tif (mappedHandler != null) {\n\t\t\tif (mappedHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to URL path [\" + urlPath +\n\t\t\t\t\t\t\"]: There is already \" + getHandlerDescription(mappedHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (urlPath.equals(\"/\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Root mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetRootHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Default mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetDefaultHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handlerMap.put(urlPath, resolvedHandler);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping. Invoked at startup for\n\t * each detected handler method.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerMapping(mapping,handler,method)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given mapping.\n\t * <p>This method may be invoked at runtime after initialization has completed.\n\t * @param mapping the mapping for the handler method\n\t * @param handler the handler\n\t * @param method the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void registerMapping(T mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(T mapping, Object handler, Method method) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Register \\\"\" + mapping + \"\\\" to \" + method.toGenericString());\n\t\t}\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setCorsConfigurations(Map<String,corsConfigurations)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set \"global\" CORS configuration mappings. The first matching URL pattern\n\t * determines the {@code CorsConfiguration} to use which is then further\n\t * {@link CorsConfiguration#combine(CorsConfiguration) combined} with the\n\t * {@code CorsConfiguration} for the selected handler.\n\t * <p>This is mutually exclusive with\n\t * {@link #setCorsConfigurationSource(CorsConfigurationSource)}.\n\t * @since 4.2\n\t * @see #setCorsProcessor(CorsProcessor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tif (CollectionUtils.isEmpty(corsConfigurations)) {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t\treturn;\n\t\t}\n\t\tUrlBasedCorsConfigurationSource source;\n\t\tif (getPatternParser() != null) {\n\t\t\tsource = new UrlBasedCorsConfigurationSource(getPatternParser());\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t}\n\t\telse {\n\t\t\tsource = new UrlBasedCorsConfigurationSource();\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tsource.setPathMatcher(this.pathMatcher);\n\t\t\tsource.setUrlPathHelper(this.urlPathHelper);\n\t\t}\n\t\tsetCorsConfigurationSource(source);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#shouldApplyTo(request,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if the handler is a {@link HandlerMethod} and then delegates to the\n\t * base class implementation of {@code #shouldApplyTo(HttpServletRequest, Object)}\n\t * passing the bean of the {@code HandlerMethod}. Otherwise returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif (handler == null) {\n\t\t\treturn super.shouldApplyTo(request, null);\n\t\t}\n\t\telse if (handler instanceof HandlerMethod handlerMethod) {\n\t\t\thandler = handlerMethod.getBean();\n\t\t\treturn super.shouldApplyTo(request, handler);\n\t\t}\n\t\telse if (hasGlobalExceptionHandlers() && hasHandlerMappings()) {\n\t\t\treturn super.shouldApplyTo(request, handler);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#validateHandler(handler,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given handler against the current request.\n\t * <p>The default implementation is empty. Can be overridden in subclasses,\n\t * for example to enforce specific preconditions expressed in URL mappings.\n\t * @param handler the handler object to validate\n\t * @param request current HTTP request\n\t * @throws Exception if validation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "protected void validateHandler(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected void validateHandler(Object handler, HttpServletRequest request) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#addCacheMapping(cacheControl,paths)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Map specific URL paths to a specific {@link org.springframework.http.CacheControl}.\n\t * <p>Overrides the default cache seconds setting of this interceptor.\n\t * Can specify a empty {@link org.springframework.http.CacheControl} instance\n\t * to exclude a URL path from default caching.\n\t * <p>For pattern syntax see {@link AntPathMatcher} and {@link PathPattern}\n\t * as well as the class-level Javadoc for details for when each is used.\n\t * The syntax is largely the same with {@link PathPattern} more tailored for\n\t * web usage.\n\t * <p><b>NOTE:</b> Path patterns are not supposed to overlap. If a request\n\t * matches several mappings, it is effectively undefined which one will apply\n\t * (due to the lack of key ordering in the underlying {@code java.util.HashMap}).\n\t * @param cacheControl the {@code CacheControl} to use\n\t * @param paths the URL paths that will map to the given {@code CacheControl}\n\t * @since 4.2\n\t * @see #setCacheSeconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheControl",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void addCacheMapping(CacheControl cacheControl, String... paths)",
    "source_code": "\tpublic void addCacheMapping(CacheControl cacheControl, String... paths) {\n\t\tfor (String path : paths) {\n\t\t\tthis.cacheControlMappings.put(this.patternParser.parse(path), cacheControl);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#afterCompletion(request,response,handler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#handleRequestInternal(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView object with the specified view name.\n\t * <p>The content of the {@link RequestContextUtils#getInputFlashMap\n\t * \"input\" FlashMap} is also added to the model.\n\t * @see #getViewName()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tString viewName = getViewName();\n\n\t\tif (getStatusCode() != null) {\n\t\t\tif (getStatusCode().is3xxRedirection()) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, getStatusCode());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.setStatus(getStatusCode().value());\n\t\t\t\tif (getStatusCode().equals(HttpStatus.NO_CONTENT) && viewName == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isStatusOnly()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tModelAndView modelAndView = new ModelAndView();\n\t\tmodelAndView.addAllObjects(RequestContextUtils.getInputFlashMap(request));\n\t\tif (viewName != null) {\n\t\t\tmodelAndView.setViewName(viewName);\n\t\t}\n\t\telse {\n\t\t\tmodelAndView.setView(getView());\n\t\t}\n\t\treturn modelAndView;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#postHandle(request,response,handler,modelAndView)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#preHandle(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tcheckRequest(request);\n\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cacheControlMappings)) {\n\t\t\tCacheControl control = (path instanceof PathContainer pathContainer ?\n\t\t\t\t\tlookupCacheControl(pathContainer) : lookupCacheControl((String) path));\n\t\t\tif (control != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Applying \" + control);\n\t\t\t\t}\n\t\t\t\tapplyCacheControl(response, control);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cacheMappings)) {\n\t\t\tInteger cacheSeconds = (path instanceof PathContainer pathContainer ?\n\t\t\t\t\tlookupCacheSeconds(pathContainer) : lookupCacheSeconds((String) path));\n\t\t\tif (cacheSeconds != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Applying cacheSeconds \" + cacheSeconds);\n\t\t\t\t}\n\t\t\t\tapplyCacheSeconds(response, cacheSeconds);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tprepareResponse(response);\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#compareTo(other,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the\n\t * context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} to ensure they have\n\t * conditions with content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, HttpServletRequest request)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, HttpServletRequest request) {\n\t\tint result;\n\t\t// Automatic vs explicit HTTP HEAD mapping\n\t\tif (HttpMethod.HEAD.matches(request.getMethod())) {\n\t\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tresult = getActivePatternsCondition().compareTo(other.getActivePatternsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\t// Implicit (no method) vs explicit HTTP method mappings\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#afterBodyRead(body,inputMessage,parameter,targetType,converterType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "inputMessage",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object",
    "signature": "public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\tbody = advice.afterBodyRead(body, inputMessage, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyRead(request,parameter,targetType,converterType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "HttpInputMessage",
    "signature": "public HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) throws IOException {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\trequest = advice.beforeBodyRead(request, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyWrite(body,returnType,contentType,converterType,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "returnType",
      "contentType",
      "converterType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "public Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n\t\t\tClass<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n\t\t\tClass<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn processBody(body, returnType, contentType, converterType, request, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 830
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleAsyncRequestTimeoutException(ex,headers,status,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for AsyncRequestTimeoutException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param webRequest the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex, HttpHeaders headers, HttpStatusCode status, WebRequest webRequest)",
    "source_code": "\tprotected ResponseEntity<Object> handleAsyncRequestTimeoutException(\n\t\t\tAsyncRequestTimeoutException ex, HttpHeaders headers, HttpStatusCode status, WebRequest webRequest) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, webRequest);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleBindException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for BindException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleBindException(BindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleBindException(\n\t\t\tBindException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleConversionNotSupported(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for ConversionNotSupportedException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleConversionNotSupported(ConversionNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleConversionNotSupported(\n\t\t\tConversionNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleEmptyBody(body,inputMessage,parameter,targetType,converterType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "inputMessage",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "public Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\tbody = advice.handleEmptyBody(body, inputMessage, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleException(ex,request)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "ResponseEntity<Object>",
    "signature": "public ResponseEntity<Object> handleException(Exception ex, WebRequest request)",
    "source_code": "\tpublic final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {\n\t\tHttpHeaders headers = new HttpHeaders();\n\n\t\t// ErrorResponse exceptions that expose HTTP response details\n\n\t\tif (ex instanceof ErrorResponse errorEx) {\n\t\t\tif (ex instanceof HttpRequestMethodNotSupportedException subEx) {\n\t\t\t\treturn handleHttpRequestMethodNotSupported(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMediaTypeNotSupportedException subEx) {\n\t\t\t\treturn handleHttpMediaTypeNotSupported(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException subEx) {\n\t\t\t\treturn handleHttpMediaTypeNotAcceptable(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof MissingPathVariableException subEx) {\n\t\t\t\treturn handleMissingPathVariable(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof MissingServletRequestParameterException subEx) {\n\t\t\t\treturn handleMissingServletRequestParameter(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof MissingServletRequestPartException subEx) {\n\t\t\t\treturn handleMissingServletRequestPart(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof ServletRequestBindingException subEx) {\n\t\t\t\treturn handleServletRequestBindingException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof MethodArgumentNotValidException subEx) {\n\t\t\t\treturn handleMethodArgumentNotValid(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof NoHandlerFoundException subEx) {\n\t\t\t\treturn handleNoHandlerFoundException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse if (ex instanceof AsyncRequestTimeoutException subEx) {\n\t\t\t\treturn handleAsyncRequestTimeoutException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Another ErrorResponseException\n\t\t\t\treturn handleExceptionInternal(ex, null, errorEx.getHeaders(), errorEx.getStatusCode(), request);\n\t\t\t}\n\t\t}\n\n\t\t// Other, lower level exceptions\n\n\t\tif (ex instanceof ConversionNotSupportedException cnse) {\n\t\t\treturn handleConversionNotSupported(cnse, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof TypeMismatchException tme) {\n\t\t\treturn handleTypeMismatch(tme, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse if (ex instanceof HttpMessageNotReadableException hmnre) {\n\t\t\treturn handleHttpMessageNotReadable(hmnre, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse if (ex instanceof HttpMessageNotWritableException hmnwe) {\n\t\t\treturn handleHttpMessageNotWritable(hmnwe, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof BindException be) {\n\t\t\treturn handleBindException(be, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse {\n\t\t\t// Unknown exception, typically a wrapper with a common MVC exception as cause\n\t\t\t// (since @ExceptionHandler type declarations also match first-level causes):\n\t\t\t// We only deal with top-level MVC exceptions here, so let's rethrow the given\n\t\t\t// exception for further processing through the HandlerExceptionResolver chain.\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleExceptionInternal(ex,body,headers,statusCode,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A single place to customize the response body of all exception types.\n\t * <p>The default implementation sets the {@link WebUtils#ERROR_EXCEPTION_ATTRIBUTE}\n\t * request attribute and creates a {@link ResponseEntity} from the given\n\t * body, headers, and status.\n\t * @param ex the exception\n\t * @param body the body for the response\n\t * @param headers the headers for the response\n\t * @param statusCode the response status\n\t * @param webRequest the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "body",
      "headers",
      "statusCode",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleExceptionInternal(Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest webRequest)",
    "source_code": "\tprotected ResponseEntity<Object> handleExceptionInternal(\n\t\t\tException ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest webRequest) {\n\n\t\tif (webRequest instanceof ServletWebRequest servletWebRequest) {\n\t\t\tHttpServletResponse response = servletWebRequest.getResponse();\n\t\t\tif (response != null && response.isCommitted()) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Ignoring exception, response committed. : \" + ex);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (HttpStatus.INTERNAL_SERVER_ERROR.equals(statusCode)) {\n\t\t\twebRequest.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);\n\t\t}\n\n\t\tif (body == null && ex instanceof ErrorResponse errorResponse) {\n\t\t\tbody = errorResponse.getBody();\n\t\t}\n\n\t\treturn new ResponseEntity<>(body, headers, statusCode);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotAcceptable(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for HttpMediaTypeNotAcceptableException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(\n\t\t\tHttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotSupported(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for HttpMediaTypeNotSupportedException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotSupported(\n\t\t\tHttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMessageNotReadable(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for HttpMessageNotReadableException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMessageNotReadable(HttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMessageNotReadable(\n\t\t\tHttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMessageNotWritable(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for HttpMessageNotWritableException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMessageNotWritable(HttpMessageNotWritableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMessageNotWritable(\n\t\t\tHttpMessageNotWritableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpRequestMethodNotSupported(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for HttpRequestMethodNotSupportedException.\n\t * <p>This method logs a warning, and delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpRequestMethodNotSupported(\n\t\t\tHttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleInternal(request,response,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 786
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tModelAndView mav;\n\t\tcheckRequest(request);\n\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No HttpSession available -> no mutex necessary\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No synchronization on session demanded at all...\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\n\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprepareResponse(response);\n\t\t\t}\n\t\t}\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMethodArgumentNotValid(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for MethodArgumentNotValidException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodArgumentNotValid(\n\t\t\tMethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingPathVariable(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for MissingPathVariableException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingPathVariable(MissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingPathVariable(\n\t\t\tMissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestParameter(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for MissingServletRequestParameterException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestParameter(MissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestParameter(\n\t\t\tMissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestPart(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for MissingServletRequestPartException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestPart(MissingServletRequestPartException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestPart(\n\t\t\tMissingServletRequestPartException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleNoHandlerFoundException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for NoHandlerFoundException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoHandlerFoundException(NoHandlerFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoHandlerFoundException(\n\t\t\tNoHandlerFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 50
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue instanceof View view) {\n\t\t\tmavContainer.setView(view);\n\t\t\tif (view instanceof SmartView && ((SmartView) view).isRedirectView()) {\n\t\t\t\tmavContainer.setRedirectModelScenario(true);\n\t\t\t}\n\t\t}\n\t\telse if (returnValue != null) {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type: \" +\n\t\t\t\t\treturnType.getParameterType().getName() + \" in method: \" + returnType.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleServletRequestBindingException(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for ServletRequestBindingException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleServletRequestBindingException(ServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleServletRequestBindingException(\n\t\t\tServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleTypeMismatch(ex,headers,status,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the response for TypeMismatchException.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return {@code ResponseEntity} or {@code null} if response is committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleTypeMismatch(TypeMismatchException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleTypeMismatch(\n\t\t\tTypeMismatchException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeHandlerMethod(request,response,handlerMethod)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}\n\t * if view resolution is required.\n\t * @since 4.2\n\t * @see #createInvocableHandlerMethod(HandlerMethod)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 852
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tServletWebRequest webRequest = new ServletWebRequest(request, response);\n\t\ttry {\n\t\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n\t\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n\t\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n\t\t\tif (this.argumentResolvers != null) {\n\t\t\t\tinvocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t\t}\n\t\t\tif (this.returnValueHandlers != null) {\n\t\t\t\tinvocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t\t}\n\t\t\tinvocableMethod.setDataBinderFactory(binderFactory);\n\t\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\n\t\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n\t\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\n\t\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n\t\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n\t\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n\t\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\t\tasyncManager.setTaskExecutor(this.taskExecutor);\n\t\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\n\t\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n\t\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\t\tObject result = asyncManager.getConcurrentResult();\n\t\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n\t\t\t\tasyncManager.clearConcurrentResult();\n\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\n\t\t\t\t\treturn \"Resume with async result [\" + formatted + \"]\";\n\t\t\t\t});\n\t\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\n\t\t\t}\n\n\t\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\n\t\t}\n\t\tfinally {\n\t\t\twebRequest.requestCompleted();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#readWithMessageConverters(webRequest,parameter,paramType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "webRequest",
      "parameter",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType)",
    "source_code": "\tprotected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tHttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\tAssert.state(servletRequest != null, \"No HttpServletRequest\");\n\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest);\n\n\t\tObject arg = readWithMessageConverters(inputMessage, parameter, paramType);\n\t\tif (arg == null && checkRequired(parameter)) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Required request body is missing: \" +\n\t\t\t\t\tparameter.getExecutable().toGenericString(), inputMessage);\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Throws MethodArgumentNotValidException if validation fails.\n\t * @throws HttpMessageNotReadableException if {@link RequestBody#required()}\n\t * is {@code true} and there is no body content or if there is no suitable\n\t * converter to read the content with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tObject arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\n\t\tif (binderFactory != null) {\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n\t\t\tif (arg != null) {\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mavContainer != null) {\n\t\t\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t}\n\t\t}\n\n\t\treturn adaptArgumentIfNecessary(arg, parameter);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#send(data,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void send(Object data, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic void send(Object data, @Nullable MediaType mediaType) throws IOException {\n\t\t\tsendInternal(data, mediaType);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#supports(param,type,converterType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "type",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter param, Type type, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter param, Type type, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#supports(returnType,converterType)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addFixedVersionStrategy(version,pathPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t * will also cofigure automatically a {@code \"/v1.0.0/js/**\"} with {@code \"v1.0.0\"} the\n\t * {@code version} String given as an argument.\n\t * @param version a version string\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see FixedVersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns) {\n\t\tList<String> patternsList = Arrays.asList(pathPatterns);\n\t\tList<String> prefixedPatterns = new ArrayList<>(pathPatterns.length);\n\t\tString versionPrefix = \"/\" + version;\n\t\tfor (String pattern : patternsList) {\n\t\t\tprefixedPatterns.add(pattern);\n\t\t\tif (!pattern.startsWith(versionPrefix) && !patternsList.contains(versionPrefix + pattern)) {\n\t\t\t\tprefixedPatterns.add(versionPrefix + pattern);\n\t\t\t}\n\t\t}\n\t\treturn addVersionStrategy(new FixedVersionStrategy(version), StringUtils.toStringArray(prefixedPatterns));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#checkResource(resource,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Perform additional checks on a resolved resource beyond checking whether the\n\t * resources exists and is readable. The default implementation also verifies\n\t * the resource is either under the location relative to which it was found or\n\t * is under one of the {@link #setAllowedLocations allowed locations}.\n\t * @param resource the resource to check\n\t * @param location the location relative to which the resource was found\n\t * @return \"true\" if resource is in a valid location, \"false\" otherwise.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "boolean",
    "signature": "protected boolean checkResource(Resource resource, Resource location)",
    "source_code": "\tprotected boolean checkResource(Resource resource, Resource location) throws IOException {\n\t\tif (isResourceUnderLocation(resource, location)) {\n\t\t\treturn true;\n\t\t}\n\t\tResource[] allowedLocations = getAllowedLocations();\n\t\tif (allowedLocations != null) {\n\t\t\tfor (Resource current : allowedLocations) {\n\t\t\t\tif (isResourceUnderLocation(resource, current)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#extractLink(index,content,linksToAdd)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "int",
    "signature": "protected int extractLink(int index, String content, SortedSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected int extractLink(int index, String content, SortedSet<ContentChunkInfo> linksToAdd) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(index - 1, \")\", content, linksToAdd);\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#extractLink(index,endKey,content,linksToAdd)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "endKey",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "int",
    "signature": "protected int extractLink(int index, String endKey, String content, SortedSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected int extractLink(int index, String endKey, String content, SortedSet<ContentChunkInfo> linksToAdd) {\n\t\t\tint start = index + 1;\n\t\t\tint end = content.indexOf(endKey, start);\n\t\t\tlinksToAdd.add(new ContentChunkInfo(start, end));\n\t\t\treturn end + endKey.length();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getForRequestUrl(request,requestUrl)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * A variation on {@link #getForLookupPath(String)} that accepts a full request\n\t * URL path (i.e. including context and servlet path) and returns the full request\n\t * URL path to expose for public use.\n\t * @param request the current request\n\t * @param requestUrl the request URL path to resolve\n\t * @return the resolved public URL path, or {@code null} if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requestUrl"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "String",
    "signature": "public String getForRequestUrl(HttpServletRequest request, String requestUrl)",
    "source_code": "\tpublic final String getForRequestUrl(HttpServletRequest request, String requestUrl) {\n\t\tint prefixIndex = getLookupPathIndex(request);\n\t\tint suffixIndex = getEndPathIndex(requestUrl);\n\t\tif (prefixIndex >= suffixIndex) {\n\t\t\treturn null;\n\t\t}\n\t\tString prefix = requestUrl.substring(0, prefixIndex);\n\t\tString suffix = requestUrl.substring(suffixIndex);\n\t\tString lookupPath = requestUrl.substring(prefixIndex, suffixIndex);\n\t\tString resolvedLookupPath = getForLookupPath(lookupPath);\n\t\treturn (resolvedLookupPath != null ? prefix + resolvedLookupPath + suffix : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getMediaType(request,resource)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the media type for the given request and the resource matched\n\t * to it. This implementation tries to determine the MediaType using one of\n\t * the following lookups based on the resource filename and its path\n\t * extension:\n\t * <ol>\n\t * <li>{@link jakarta.servlet.ServletContext#getMimeType(String)}\n\t * <li>{@link #getMediaTypes()}\n\t * <li>{@link MediaTypeFactory#getMediaType(String)}\n\t * </ol>\n\t * @param request the current request\n\t * @param resource the resource to check\n\t * @return the corresponding media type, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 780
    },
    "return": "MediaType",
    "signature": "protected MediaType getMediaType(HttpServletRequest request, Resource resource)",
    "source_code": "\tprotected MediaType getMediaType(HttpServletRequest request, Resource resource) {\n\t\tMediaType result = null;\n\t\tString mimeType = request.getServletContext().getMimeType(resource.getFilename());\n\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\tresult = MediaType.parseMediaType(mimeType);\n\t\t}\n\t\tif (result == null || MediaType.APPLICATION_OCTET_STREAM.equals(result)) {\n\t\t\tMediaType mediaType = null;\n\t\t\tString filename = resource.getFilename();\n\t\t\tString ext = StringUtils.getFilenameExtension(filename);\n\t\t\tif (ext != null) {\n\t\t\t\tmediaType = this.mediaTypes.get(ext.toLowerCase(Locale.ENGLISH));\n\t\t\t}\n\t\t\tif (mediaType == null) {\n\t\t\t\tList<MediaType> mediaTypes = MediaTypeFactory.getMediaTypes(filename);\n\t\t\t\tif (!CollectionUtils.isEmpty(mediaTypes)) {\n\t\t\t\t\tmediaType = mediaTypes.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mediaType != null) {\n\t\t\t\tresult = mediaType;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getResource(resourcePath,location)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Find the resource under the given location.\n\t * <p>The default implementation checks if there is a readable\n\t * {@code Resource} for the given path relative to the location.\n\t * @param resourcePath the path to the resource\n\t * @param location the location to check\n\t * @return the resource, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "location"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "Resource",
    "signature": "protected Resource getResource(String resourcePath, Resource location)",
    "source_code": "\tprotected Resource getResource(String resourcePath, Resource location) throws IOException {\n\t\tResource resource = location.createRelative(resourcePath);\n\t\tif (resource.isReadable()) {\n\t\t\tif (checkResource(resource, location)) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tResource[] allowed = getAllowedLocations();\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Resource path \\\"\" + resourcePath + \"\\\" was successfully resolved \" +\n\t\t\t\t\t\t\t\t\"but resource \\\"\" + resource.getURL() + \"\\\" is neither under \" +\n\t\t\t\t\t\t\t\t\"the current location \\\"\" + location.getURL() + \"\\\" nor under any of \" +\n\t\t\t\t\t\t\t\t\"the allowed locations \" + (allowed != null ? Arrays.asList(allowed) : \"[]\"), -1, true));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#handleRequest(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Processes a resource request.\n\t * <p>Checks for the existence of the requested resource in the configured list of locations.\n\t * If the resource does not exist, a {@code 404} response will be returned to the client.\n\t * If the resource exists, the request will be checked for the presence of the\n\t * {@code Last-Modified} header, and its value will be compared against the last-modified\n\t * timestamp of the given resource, returning a {@code 304} status code if the\n\t * {@code Last-Modified} value  is greater. If the resource is newer than the\n\t * {@code Last-Modified} value, or the header is not present, the content resource\n\t * of the resource will be written to the response with caching headers\n\t * set to expire one year in the future.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 552
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// For very general mappings (e.g. \"/\") we need to check 404 first\n\t\tResource resource = getResource(request);\n\t\tif (resource == null) {\n\t\t\tlogger.debug(\"Resource not found\");\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\tresponse.setHeader(HttpHeaders.ALLOW, getAllowHeader());\n\t\t\treturn;\n\t\t}\n\n\t\t// Supported methods and required session\n\t\tcheckRequest(request);\n\n\t\t// Header phase\n\t\tif (isUseLastModified() && new ServletWebRequest(request, response).checkNotModified(resource.lastModified())) {\n\t\t\tlogger.trace(\"Resource not modified\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Apply cache settings, if any\n\t\tprepareResponse(response);\n\n\t\t// Check the media type for the resource\n\t\tMediaType mediaType = getMediaType(request, resource);\n\t\tsetHeaders(response, resource, mediaType);\n\n\t\t// Content phase\n\t\tServletServerHttpResponse outputMessage = new ServletServerHttpResponse(response);\n\t\tif (request.getHeader(HttpHeaders.RANGE) == null) {\n\t\t\tAssert.state(this.resourceHttpMessageConverter != null, \"Not initialized\");\n\n\t\t\tif (HttpMethod.HEAD.matches(request.getMethod())) {\n\t\t\t\tthis.resourceHttpMessageConverter.addDefaultHeaders(outputMessage, resource, mediaType);\n\t\t\t\toutputMessage.flush();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.resourceHttpMessageConverter.write(resource, mediaType, outputMessage);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.resourceRegionHttpMessageConverter != null, \"Not initialized\");\n\t\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(request);\n\t\t\ttry {\n\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\t\t\t\tthis.resourceRegionHttpMessageConverter.write(\n\t\t\t\t\t\tHttpRange.toResourceRegions(httpRanges, resource), mediaType, outputMessage);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tresponse.setHeader(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#parse(content,result)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, \"'\", content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, \"\\\"\", content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveResourceInternal(request,requestPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "Resource",
    "signature": "protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn getResource(requestPath, request, locations);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourcePath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourcePath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourcePath, List<? extends Resource> locations,\n\t\t\tResourceResolverChain chain) {\n\n\t\treturn (StringUtils.hasText(resourcePath) &&\n\t\t\t\tgetResource(resourcePath, null, locations) != null ? resourcePath : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\tString baseUrl = chain.resolveUrlPath(resourceUrlPath, locations);\n\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\tVersionStrategy versionStrategy = getStrategyForPath(resourceUrlPath);\n\t\t\tif (versionStrategy == null) {\n\t\t\t\treturn baseUrl;\n\t\t\t}\n\t\t\tResource resource = chain.resolveResource(null, baseUrl, locations);\n\t\t\tAssert.state(resource != null, \"Unresolvable resource\");\n\t\t\tString version = versionStrategy.getResourceVersion(resource);\n\t\t\treturn versionStrategy.addVersion(baseUrl, version);\n\t\t}\n\t\treturn baseUrl;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHandlerMap(Map<String,handlerMap)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure the resource mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. However if this property is\n\t * used, the auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap)",
    "source_code": "\tpublic void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap) {\n\t\tif (handlerMap != null) {\n\t\t\tthis.handlerMap.clear();\n\t\t\tthis.handlerMap.putAll(handlerMap);\n\t\t\tthis.autodetect = false;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHeaders(response,resource,mediaType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set headers on the given servlet response.\n\t * Called for GET requests as well as HEAD requests.\n\t * @param response current servlet response\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t * @throws IOException in case of errors while setting the headers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "resource",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 814
    },
    "return": "void",
    "signature": "protected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)",
    "source_code": "\tprotected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)\n\t\t\tthrows IOException {\n\n\t\tif (mediaType != null) {\n\t\t\tresponse.setContentType(mediaType.toString());\n\t\t}\n\n\t\tif (resource instanceof HttpResource httpResource) {\n\t\t\tHttpHeaders resourceHeaders = httpResource.getResponseHeaders();\n\t\t\tresourceHeaders.forEach((headerName, headerValues) -> {\n\t\t\t\tboolean first = true;\n\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tresponse.setHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresponse.addHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tresponse.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setLocationCharsets(Map<Resource,locationCharsets)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure charsets associated with locations. If a static resource is found\n\t * under a {@link org.springframework.core.io.UrlResource URL resource}\n\t * location the charset is used to encode the relative path\n\t * <p><strong>Note:</strong> the charset is used only if the\n\t * {@link #setUrlPathHelper urlPathHelper} property is also configured and\n\t * its {@code urlDecode} property is set to true.\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Resource",
      "locationCharsets"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void setLocationCharsets(Map<Resource, Charset> locationCharsets)",
    "source_code": "\tpublic void setLocationCharsets(Map<Resource, Charset> locationCharsets) {\n\t\tthis.locationCharsets.clear();\n\t\tthis.locationCharsets.putAll(locationCharsets);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setMediaTypes(Map<String,mediaTypes)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add mappings between file extensions, extracted from the filename of a\n\t * static {@link Resource}, and corresponding media type to set on the\n\t * response.\n\t * <p>Use of this method is typically not necessary since mappings are\n\t * otherwise determined via\n\t * {@link jakarta.servlet.ServletContext#getMimeType(String)} or via\n\t * {@link MediaTypeFactory#getMediaType(Resource)}.\n\t * @param mediaTypes media type mappings\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "void",
    "signature": "public void setMediaTypes(Map<String, MediaType> mediaTypes)",
    "source_code": "\tpublic void setMediaTypes(Map<String, MediaType> mediaTypes) {\n\t\tmediaTypes.forEach((ext, mediaType) ->\n\t\t\t\tthis.mediaTypes.put(ext.toLowerCase(Locale.ENGLISH), mediaType));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setStrategyMap(Map<String,map)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and {@code VersionStrategy} as values.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param map a map with URLs as keys and version strategies as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void setStrategyMap(Map<String, VersionStrategy> map)",
    "source_code": "\tpublic void setStrategyMap(Map<String, VersionStrategy> map) {\n\t\tthis.versionStrategyMap.clear();\n\t\tthis.versionStrategyMap.putAll(map);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#transform(request,resource,transformerChain)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "resource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Resource",
    "signature": "public Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)\n\t\t\tthrows IOException {\n\n\t\tresource = transformerChain.transform(request, resource);\n\n\t\tString filename = resource.getFilename();\n\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\tresource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tbyte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream());\n\t\tString content = new String(bytes, DEFAULT_CHARSET);\n\n\t\tSortedSet<ContentChunkInfo> links = new TreeSet<>();\n\t\tfor (LinkParser parser : this.linkParsers) {\n\t\t\tparser.parse(content, links);\n\t\t}\n\n\t\tif (links.isEmpty()) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tint index = 0;\n\t\tStringWriter writer = new StringWriter();\n\t\tfor (ContentChunkInfo linkContentChunkInfo : links) {\n\t\t\twriter.write(content.substring(index, linkContentChunkInfo.getStart()));\n\t\t\tString link = content.substring(linkContentChunkInfo.getStart(), linkContentChunkInfo.getEnd());\n\t\t\tString newLink = null;\n\t\t\tif (!hasScheme(link)) {\n\t\t\t\tString absolutePath = toAbsolutePath(link, request);\n\t\t\t\tnewLink = resolveUrlPath(absolutePath, request, resource, transformerChain);\n\t\t\t}\n\t\t\twriter.write(newLink != null ? newLink : link);\n\t\t\tindex = linkContentChunkInfo.getEnd();\n\t\t}\n\t\twriter.write(content.substring(index));\n\n\t\treturn new TransformedResource(resource, writer.toString().getBytes(DEFAULT_CHARSET));\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#isSelected(bindStatus,candidateValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the supplied candidate value is equal to the value bound to\n\t * the supplied {@link BindStatus}. Equality in this case differs from standard Java equality and\n\t * is described in more detail <a href=\"#equality-contract\">here</a>.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindStatus",
      "candidateValue"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue)",
    "source_code": "\tpublic static boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue) {\n\t\t// Check obvious equality matches with the candidate first,\n\t\t// both with the rendered value and with the original value.\n\t\tObject boundValue = bindStatus.getValue();\n\t\tif (ObjectUtils.nullSafeEquals(boundValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tObject actualValue = bindStatus.getActualValue();\n\t\tif (actualValue != null && actualValue != boundValue &&\n\t\t\t\tObjectUtils.nullSafeEquals(actualValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (actualValue != null) {\n\t\t\tboundValue = actualValue;\n\t\t}\n\t\telse if (boundValue == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Non-null value but no obvious equality with the candidate value:\n\t\t// go into more exhaustive comparisons.\n\t\tboolean selected = false;\n\t\tif (candidateValue != null) {\n\t\t\tif (boundValue.getClass().isArray()) {\n\t\t\t\tselected = collectionCompare(CollectionUtils.arrayToList(boundValue), candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Collection<?> collection) {\n\t\t\t\tselected = collectionCompare(collection, candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Map<?, ?> map) {\n\t\t\t\tselected = mapCompare(map, candidateValue, bindStatus);\n\t\t\t}\n\t\t}\n\t\tif (!selected) {\n\t\t\tselected = exhaustiveCompare(boundValue, candidateValue, bindStatus.getEditor(), null);\n\t\t}\n\t\treturn selected;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#render(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "void",
    "signature": "public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n\t\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#resolveViewName(viewName,locale)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic View resolveViewName(String viewName, Locale locale) throws Exception {\n\t\tRequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n\t\tAssert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\");\n\t\tList<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n\t\tif (requestedMediaTypes != null) {\n\t\t\tList<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n\t\t\tView bestView = getBestView(candidateViews, requestedMediaTypes, attrs);\n\t\t\tif (bestView != null) {\n\t\t\t\treturn bestView;\n\t\t\t}\n\t\t}\n\n\t\tString mediaTypeInfo = logger.isDebugEnabled() && requestedMediaTypes != null ?\n\t\t\t\t\" given \" + requestedMediaTypes.toString() : \"\";\n\n\t\tif (this.useNotAcceptableStatusCode) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using 406 NOT_ACCEPTABLE\" + mediaTypeInfo);\n\t\t\t}\n\t\t\treturn NOT_ACCEPTABLE_VIEW;\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"View remains unresolved\" + mediaTypeInfo);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#filterAndWrapModel(Map<String,model,request)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Filter and optionally wrap the model in {@link MappingJacksonValue} container.\n\t * @param model the model, as passed on to {@link #renderMergedOutputModel}\n\t * @param request current HTTP request\n\t * @return the wrapped or unwrapped value to be rendered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "Object",
    "signature": "protected Object filterAndWrapModel(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected Object filterAndWrapModel(Map<String, Object> model, HttpServletRequest request) {\n\t\tObject value = filterModel(model);\n\t\tClass<?> serializationView = (Class<?>) model.get(JsonView.class.getName());\n\t\tFilterProvider filters = (FilterProvider) model.get(FilterProvider.class.getName());\n\t\tif (serializationView != null || filters != null) {\n\t\t\tMappingJacksonValue container = new MappingJacksonValue(value);\n\t\t\tif (serializationView != null) {\n\t\t\t\tcontainer.setSerializationView(serializationView);\n\t\t\t}\n\t\t\tif (filters != null) {\n\t\t\t\tcontainer.setFilters(filters);\n\t\t\t}\n\t\t\tvalue = container;\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#filterModel(Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Filter out undesired attributes from the given model.\n\t * The return value can be either another {@link Map} or a single value object.\n\t * @param model the model, as passed on to {@link #renderMergedOutputModel}\n\t * @return the value to be rendered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Object",
    "signature": "protected Object filterModel(Map<String, Object> model)",
    "source_code": "\tprotected abstract Object filterModel(Map<String, Object> model);"
  },
  "org.springframework.web.servlet.view.json.<unknown>#prepareResponse(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setCharacterEncoding(this.encoding.getJavaName());\n\t\tif (this.disableCaching) {\n\t\t\tresponse.addHeader(\"Cache-Control\", \"no-store\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\tByteArrayOutputStream temporaryStream = null;\n\t\tOutputStream stream;\n\n\t\tif (this.updateContentLength) {\n\t\t\ttemporaryStream = createTemporaryOutputStream();\n\t\t\tstream = temporaryStream;\n\t\t}\n\t\telse {\n\t\t\tstream = response.getOutputStream();\n\t\t}\n\n\t\tObject value = filterAndWrapModel(model, request);\n\t\twriteContent(stream, value);\n\n\t\tif (temporaryStream != null) {\n\t\t\twriteToResponse(response, temporaryStream);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writeContent(stream,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write the actual JSON content to the stream.\n\t * @param stream the output stream to use\n\t * @param object the value to be rendered, as returned from {@link #filterModel}\n\t * @throws IOException if writing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "stream",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void writeContent(OutputStream stream, Object object)",
    "source_code": "\tprotected void writeContent(OutputStream stream, Object object) throws IOException {\n\t\ttry (JsonGenerator generator = this.objectMapper.getFactory().createGenerator(stream, this.encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\n\t\t\tif (value instanceof MappingJacksonValue container) {\n\t\t\t\tvalue = container.getValue();\n\t\t\t\tserializationView = container.getSerializationView();\n\t\t\t\tfilters = container.getFilters();\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tthis.objectMapper.writerWithView(serializationView) : this.objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writePrefix(generator,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write a prefix before the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "protected void writePrefix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writeSuffix(generator,object)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Write a suffix after the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "void",
    "signature": "protected void writeSuffix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writeSuffix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.web.servlet.view.script.<unknown>#prepareResponse(request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsuper.prepareResponse(request, response);\n\n\t\tsetResponseContentType(request, response);\n\t\tif (this.charset != null) {\n\t\t\tresponse.setCharacterEncoding(this.charset.name());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.script.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\ttry {\n\t\t\tScriptEngine engine = getEngine();\n\t\t\tString url = getUrl();\n\t\t\tAssert.state(url != null, \"'url' not set\");\n\t\t\tString template = getTemplate(url);\n\n\t\t\tFunction<String, String> templateLoader = path -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn getTemplate(path);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tLocale locale = RequestContextUtils.getLocale(request);\n\t\t\tRenderingContext context = new RenderingContext(obtainApplicationContext(), locale, templateLoader, url);\n\n\t\t\tObject html;\n\t\t\tif (this.renderFunction == null) {\n\t\t\t\tSimpleBindings bindings = new SimpleBindings();\n\t\t\t\tbindings.putAll(model);\n\t\t\t\tmodel.put(\"renderingContext\", context);\n\t\t\t\thtml = engine.eval(template, bindings);\n\t\t\t}\n\t\t\telse if (this.renderObject != null) {\n\t\t\t\tObject thiz = engine.eval(this.renderObject);\n\t\t\t\thtml = ((Invocable) engine).invokeMethod(thiz, this.renderFunction, template, model, context);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thtml = ((Invocable) engine).invokeFunction(this.renderFunction, template, model, context);\n\t\t\t}\n\n\t\t\tresponse.getWriter().write(String.valueOf(html));\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ServletException(\"Failed to render script template\", new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureResponse(Map<String,model,response,transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link HttpServletResponse}.\n\t * <p>The default implementation of this method sets the\n\t * {@link HttpServletResponse#setContentType content type} and\n\t * {@link HttpServletResponse#setCharacterEncoding encoding}\n\t * from the \"media-type\" and \"encoding\" output properties\n\t * specified in the {@link Transformer}.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "protected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer)",
    "source_code": "\tprotected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer) {\n\t\tString contentType = getContentType();\n\t\tString mediaType = transformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n\t\tString encoding = transformer.getOutputProperty(OutputKeys.ENCODING);\n\t\tif (StringUtils.hasText(mediaType)) {\n\t\t\tcontentType = mediaType;\n\t\t}\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\t// Only apply encoding if content type is specified but does not contain charset clause already.\n\t\t\tif (contentType != null && !contentType.toLowerCase().contains(WebUtils.CONTENT_TYPE_CHARSET_PREFIX)) {\n\t\t\t\tcontentType = contentType + WebUtils.CONTENT_TYPE_CHARSET_PREFIX + encoding;\n\t\t\t}\n\t\t}\n\t\tresponse.setContentType(contentType);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureTransformer(Map<String,model,response,transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link Transformer} instance.\n\t * <p>The default implementation copies parameters from the model into the\n\t * Transformer's {@link Transformer#setParameter parameter set}.\n\t * This implementation also copies the {@link #setOutputProperties output properties}\n\t * into the {@link Transformer} {@link Transformer#setOutputProperty output properties}.\n\t * Indentation properties are set as well.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t * @see #copyModelParameters(Map, Transformer)\n\t * @see #copyOutputProperties(Transformer)\n\t * @see #configureIndentation(Transformer)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer)",
    "source_code": "\tprotected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer) {\n\n\t\tcopyModelParameters(model, transformer);\n\t\tcopyOutputProperties(transformer);\n\t\tconfigureIndentation(transformer);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#copyModelParameters(Map<String,model,transformer)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all entries from the supplied Map into the\n\t * {@link Transformer#setParameter(String, Object) parameter set}\n\t * of the supplied {@link Transformer}.\n\t * @param model merged output Map (never {@code null})\n\t * @param transformer the target transformer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "void",
    "signature": "protected void copyModelParameters(Map<String, Object> model, Transformer transformer)",
    "source_code": "\tprotected final void copyModelParameters(Map<String, Object> model, Transformer transformer) {\n\t\tmodel.forEach(transformer::setParameter);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#locateSource(Map<String,model)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * <p>Locate the {@link Source} object in the supplied model,\n\t * converting objects as required.\n\t * The default implementation first attempts to look under the configured\n\t * {@link #setSourceKey source key}, if any, before attempting to locate\n\t * an object of {@link #getSourceTypes() supported type}.\n\t * @param model the merged model Map\n\t * @return the XSLT Source object (or {@code null} if none found)\n\t * @throws Exception if an error occurred during locating the source\n\t * @see #setSourceKey\n\t * @see #convertSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Source",
    "signature": "protected Source locateSource(Map<String, Object> model)",
    "source_code": "\tprotected Source locateSource(Map<String, Object> model) throws Exception {\n\t\tif (this.sourceKey != null) {\n\t\t\treturn convertSource(model.get(this.sourceKey));\n\t\t}\n\t\tObject source = CollectionUtils.findValueOfType(model.values(), getSourceTypes());\n\t\treturn (source != null ? convertSource(source) : null);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(\n\t\t\tMap<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tTemplates templates = this.cachedTemplates;\n\t\tif (templates == null) {\n\t\t\ttemplates = loadTemplates();\n\t\t}\n\n\t\tTransformer transformer = createTransformer(templates);\n\t\tconfigureTransformer(model, response, transformer);\n\t\tconfigureResponse(model, response, transformer);\n\t\tSource source = null;\n\t\ttry {\n\t\t\tsource = locateSource(model);\n\t\t\tif (source == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to locate Source object in model: \" + model);\n\t\t\t}\n\t\t\ttransformer.transform(source, createResult(response));\n\t\t}\n\t\tfinally {\n\t\t\tcloseSourceIfNecessary(source);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.<unknown>#add(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName  the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.add(headerName, headerValue);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#put(key,value)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putAll(String,m)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "m"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> m)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> m) {\n\t\tthis.headers.putAll(m);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#set(headerName,headerValue)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName  the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.set(headerName, headerValue);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#setAll(Map<String,values)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#afterHandshake(request,response,wsHandler,ex)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex)",
    "source_code": "\tpublic void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex) {\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#beforeHandshake(request,response,wsHandler,Map<String,attributes)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tpublic boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {\n\n\t\tHttpSession session = getSession(request);\n\t\tif (session != null) {\n\t\t\tif (isCopyHttpSessionId()) {\n\t\t\t\tattributes.put(HTTP_SESSION_ID_ATTR_NAME, session.getId());\n\t\t\t}\n\t\t\tEnumeration<String> names = session.getAttributeNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tif (isCopyAllAttributes() || getAttributeNames().contains(name)) {\n\t\t\t\t\tattributes.put(name, session.getAttribute(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#doHandshake(handler,headers,url)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "headers",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "ListenableFuture<WebSocketSession>",
    "signature": "public ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url)",
    "source_code": "\tpublic final ListenableFuture<WebSocketSession> doHandshake(\n\t\t\tWebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url) {\n\n\t\tAssert.notNull(handler, \"WebSocketHandler is required\");\n\t\tAssert.notNull(url, \"URL is required\");\n\n\t\tString scheme = url.getScheme();\n\t\tif (!supportedProtocols.contains(scheme)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scheme: '\" + scheme + \"'\");\n\t\t}\n\n\t\tSettableListenableFuture<WebSocketSession> connectFuture = new SettableListenableFuture<>();\n\t\ttry {\n\t\t\tSockJsUrlInfo sockJsUrlInfo = new SockJsUrlInfo(url);\n\t\t\tServerInfo serverInfo = getServerInfo(sockJsUrlInfo, getHttpRequestHeaders(headers));\n\t\t\tcreateRequest(sockJsUrlInfo, headers, serverInfo).connect(handler, connectFuture);\n\t\t}\n\t\tcatch (Exception exception) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Initial SockJS \\\"Info\\\" request to server failed, url=\" + url, exception);\n\t\t\t}\n\t\t\tconnectFuture.setException(exception);\n\t\t}\n\t\treturn connectFuture;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#doHandshake(handler,uriTemplate,uriVars)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "uriTemplate",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "ListenableFuture<WebSocketSession>",
    "signature": "public ListenableFuture<WebSocketSession> doHandshake(WebSocketHandler handler, String uriTemplate, Object... uriVars)",
    "source_code": "\tpublic ListenableFuture<WebSocketSession> doHandshake(\n\t\t\tWebSocketHandler handler, String uriTemplate, Object... uriVars) {\n\n\t\tAssert.notNull(uriTemplate, \"uriTemplate must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().toUri();\n\t\treturn doHandshake(handler, null, uri);\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.<unknown>#closeFrame(code,reason)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "SockJsFrame",
    "signature": "public SockJsFrame closeFrame(int code, @Nullable String reason)",
    "source_code": "\tpublic static SockJsFrame closeFrame(int code, @Nullable String reason) {\n\t\treturn new SockJsFrame(\"c[\" + code + \",\\\"\" + (reason != null ? reason : \"\") + \"\\\"]\");\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.<unknown>#messageFrame(codec,messages)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "messages"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "SockJsFrame",
    "signature": "public SockJsFrame messageFrame(SockJsMessageCodec codec, String... messages)",
    "source_code": "\tpublic static SockJsFrame messageFrame(SockJsMessageCodec codec, String... messages) {\n\t\tString encoded = codec.encode(messages);\n\t\treturn new SockJsFrame(encoded);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#handleRawWebSocketRequest(request,response,handler)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler)",
    "source_code": "\tprotected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler) throws IOException {\n\n\t\tTransportHandler transportHandler = this.handlers.get(TransportType.WEBSOCKET);\n\t\tif (!(transportHandler instanceof HandshakeHandler)) {\n\t\t\tlogger.error(\"No handler configured for raw WebSocket messages\");\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t((HandshakeHandler) transportHandler).doHandshake(request, response, handler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\"Uncaught failure for request \" + request.getURI(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#handleTransportRequest(request,response,handler,sessionId,transport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, String sessionId, String transport)",
    "source_code": "\tprotected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, String sessionId, String transport) throws SockJsException {\n\n\t\tTransportType transportType = TransportType.fromValue(transport);\n\t\tif (transportType == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Unknown transport type for \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tTransportHandler transportHandler = this.handlers.get(transportType);\n\t\tif (transportHandler == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"No TransportHandler for \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tSockJsException failure = null;\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler);\n\n\t\ttry {\n\t\t\tHttpMethod supportedMethod = transportType.getHttpMethod();\n\t\t\tif (supportedMethod != request.getMethod()) {\n\t\t\t\tif (request.getMethod() == HttpMethod.OPTIONS && transportType.supportsCors()) {\n\t\t\t\t\tif (checkOrigin(request, response, HttpMethod.OPTIONS, supportedMethod)) {\n\t\t\t\t\t\tresponse.setStatusCode(HttpStatus.NO_CONTENT);\n\t\t\t\t\t\taddCacheHeaders(response);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (transportType.supportsCors()) {\n\t\t\t\t\tsendMethodNotAllowed(response, supportedMethod, HttpMethod.OPTIONS);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsendMethodNotAllowed(response, supportedMethod);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSockJsSession session = this.sessions.get(sessionId);\n\t\t\tboolean isNewSession = false;\n\t\t\tif (session == null) {\n\t\t\t\tif (transportHandler instanceof SockJsSessionFactory) {\n\t\t\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tSockJsSessionFactory sessionFactory = (SockJsSessionFactory) transportHandler;\n\t\t\t\t\tsession = createSockJsSession(sessionId, sessionFactory, handler, attributes);\n\t\t\t\t\tisNewSession = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Session not found, sessionId=\" + sessionId +\n\t\t\t\t\t\t\t\t\". The session may have been closed \" +\n\t\t\t\t\t\t\t\t\"(e.g. missed heart-beat) while a message was coming in.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrincipal principal = session.getPrincipal();\n\t\t\t\tif (principal != null && !principal.equals(request.getPrincipal())) {\n\t\t\t\t\tlogger.debug(\"The user for the session does not match the user for the request.\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!transportHandler.checkSessionType(session)) {\n\t\t\t\t\tlogger.debug(\"Session type does not match the transport type for the request.\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (transportType.sendsNoCacheInstruction()) {\n\t\t\t\taddNoCacheHeaders(response);\n\t\t\t}\n\t\t\tif (transportType.supportsCors() && !checkOrigin(request, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttransportHandler.handleRequest(request, response, handler, session);\n\n\t\t\tif (isNewSession && response instanceof ServletServerHttpResponse servletResponse) {\n\t\t\t\tint status = servletResponse.getServletResponse().getStatus();\n\t\t\t\tif (HttpStatusCode.valueOf(status).is4xxClientError()) {\n\t\t\t\t\tthis.sessions.remove(sessionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (SockJsException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new SockJsException(\"Uncaught failure for request \" + request.getURI(), sessionId, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#validateRequest(serverId,sessionId,transport)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!super.validateRequest(serverId, sessionId, transport)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!getAllowedOrigins().isEmpty() && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t!getAllowedOriginPatterns().isEmpty()) {\n\t\t\tTransportType transportType = TransportType.fromValue(transport);\n\t\t\tif (transportType == null || !transportType.supportsOrigin()) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Origin check enabled but transport '\" + transport + \"' does not support it.\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#tryCloseWithSockJsTransportError(error,closeStatus)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Close due to error arising from SockJS transport handling.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "void",
    "signature": "public void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus)",
    "source_code": "\tpublic void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing due to transport error for \" + this);\n\t\t}\n\t\ttry {\n\t\t\tdelegateError(error);\n\t\t}\n\t\tcatch (Throwable delegateException) {\n\t\t\t// Ignore\n\t\t\tlogger.debug(\"Exception from error handling delegate\", delegateException);\n\t\t}\n\t\ttry {\n\t\t\tclose(closeStatus);\n\t\t}\n\t\tcatch (Throwable closeException) {\n\t\t\tlogger.debug(\"Failure while closing \" + this, closeException);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#apply(source,type)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 776
    },
    "return": "String",
    "signature": "public String apply(String source, Type type)",
    "source_code": "\t\tpublic String apply(String source, Type type) {\n\t\t\t// URI variable only?\n\t\t\tif (isUriVariable(source)) {\n\t\t\t\treturn source;\n\t\t\t}\n\t\t\t// Literal template only?\n\t\t\tif (source.indexOf('{') == -1) {\n\t\t\t\treturn encodeUriComponent(source, this.charset, type);\n\t\t\t}\n\t\t\tint level = 0;\n\t\t\tclear(this.currentLiteral);\n\t\t\tclear(this.currentVariable);\n\t\t\tclear(this.output);\n\t\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\t\tchar c = source.charAt(i);\n\t\t\t\tif (c == ':' && level == 1) {\n\t\t\t\t\tthis.variableWithNameAndRegex = true;\n\t\t\t\t}\n\t\t\t\tif (c == '{') {\n\t\t\t\t\tlevel++;\n\t\t\t\t\tif (level == 1) {\n\t\t\t\t\t\tappend(this.currentLiteral, true, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == '}' && level > 0) {\n\t\t\t\t\tlevel--;\n\t\t\t\t\tthis.currentVariable.append('}');\n\t\t\t\t\tif (level == 0) {\n\t\t\t\t\t\tboolean encode = !isUriVariable(this.currentVariable);\n\t\t\t\t\t\tappend(this.currentVariable, encode, type);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.variableWithNameAndRegex) {\n\t\t\t\t\t\tappend(this.currentVariable, true, type);\n\t\t\t\t\t\tlevel = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (level > 0) {\n\t\t\t\t\tthis.currentVariable.append(c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentLiteral.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 0) {\n\t\t\t\tthis.currentLiteral.append(this.currentVariable);\n\t\t\t}\n\t\t\tappend(this.currentLiteral, true, type);\n\t\t\treturn this.output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#encode(BiFunction<String,Type,encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<String",
      "Type",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1043
    },
    "return": "PathComponent",
    "signature": "public PathComponent encode(BiFunction<String, Type, String> encoder)",
    "source_code": "\t\tpublic PathComponent encode(BiFunction<String, Type, String> encoder) {\n\t\t\tList<PathComponent> encodedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\tencodedComponents.add(pathComponent.encode(encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(encodedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#expand(uriVariables,encoder)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1059
    },
    "return": "PathComponent",
    "signature": "public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder)",
    "source_code": "\t\tpublic PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {\n\t\t\tList<PathComponent> expandedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\texpandedComponents.add(pathComponent.expand(uriVariables, encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(expandedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#exposeErrorRequestAttributes(request,ex,servletName)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the Servlet spec's error attributes as {@link jakarta.servlet.http.HttpServletRequest}\n\t * attributes under the keys defined in the Servlet 2.3 specification, for error pages that\n\t * are rendered directly rather than through the Servlet container's error page resolution:\n\t * {@code jakarta.servlet.error.status_code},\n\t * {@code jakarta.servlet.error.exception_type},\n\t * {@code jakarta.servlet.error.message},\n\t * {@code jakarta.servlet.error.exception},\n\t * {@code jakarta.servlet.error.request_uri},\n\t * {@code jakarta.servlet.error.servlet_name}.\n\t * <p>Does not override values if already present, to respect attribute values\n\t * that have been exposed explicitly before.\n\t * <p>Exposes status code 200 by default. Set the \"jakarta.servlet.error.status_code\"\n\t * attribute explicitly (before or after) in order to expose a different status code.\n\t * @param request current servlet request\n\t * @param ex the exception encountered\n\t * @param servletName the name of the offending servlet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "ex",
      "servletName"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "public void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,\n\t\t\t@Nullable String servletName)",
    "source_code": "\tpublic static void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,\n\t\t\t@Nullable String servletName) {\n\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_STATUS_CODE_ATTRIBUTE, HttpServletResponse.SC_OK);\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_TYPE_ATTRIBUTE, ex.getClass());\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_MESSAGE_ATTRIBUTE, ex.getMessage());\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_ATTRIBUTE, ex);\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_REQUEST_URI_ATTRIBUTE, request.getRequestURI());\n\t\tif (servletName != null) {\n\t\t\texposeRequestAttributeIfNotPresent(request, ERROR_SERVLET_NAME_ATTRIBUTE, servletName);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(Map<String,parameters,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>This method will try to obtain a parameter value using the\n\t * following algorithm:\n\t * <ol>\n\t * <li>Try to get the parameter value using just the given <i>logical</i> name.\n\t * This handles parameters of the form <tt>logicalName = value</tt>. For normal\n\t * parameters, e.g. submitted using a hidden HTML form field, this will return\n\t * the requested value.</li>\n\t * <li>Try to obtain the parameter value from the parameter name, where the\n\t * parameter name in the request is of the form <tt>logicalName_value = xyz</tt>\n\t * with \"_\" being the configured delimiter. This deals with parameter values\n\t * submitted using an HTML form submit button.</li>\n\t * <li>If the value obtained in the previous step has a \".x\" or \".y\" suffix,\n\t * remove that. This handles cases where the value was submitted using an\n\t * HTML form image button. In this case the parameter in the request would\n\t * actually be of the form <tt>logicalName_value.x = 123</tt>. </li>\n\t * </ol>\n\t * @param parameters the available parameter map\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "parameters",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "String",
    "signature": "public String findParameterValue(Map<String, ?> parameters, String name)",
    "source_code": "\tpublic static String findParameterValue(Map<String, ?> parameters, String name) {\n\t\t// First try to get it as a normal name=value parameter\n\t\tObject value = parameters.get(name);\n\t\tif (value instanceof String[] values) {\n\t\t\treturn (values.length > 0 ? values[0] : null);\n\t\t}\n\t\telse if (value != null) {\n\t\t\treturn value.toString();\n\t\t}\n\t\t// If no value yet, try to get it as a name_value=xyz parameter\n\t\tString prefix = name + \"_\";\n\t\tfor (String paramName : parameters.keySet()) {\n\t\t\tif (paramName.startsWith(prefix)) {\n\t\t\t\t// Support images buttons, which would submit parameters as name_value.x=123\n\t\t\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\t\t\tif (paramName.endsWith(suffix)) {\n\t\t\t\t\t\treturn paramName.substring(prefix.length(), paramName.length() - suffix.length());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn paramName.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\t// We couldn't find the parameter value...\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(request,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>See {@link #findParameterValue(java.util.Map, String)}\n\t * for a description of the lookup algorithm.\n\t * @param request current HTTP request\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 622
    },
    "return": "String",
    "signature": "public String findParameterValue(ServletRequest request, String name)",
    "source_code": "\tpublic static String findParameterValue(ServletRequest request, String name) {\n\t\treturn findParameterValue(request.getParameterMap(), name);\n\t}"
  },
  "org.springframework.web.util.<unknown>#getCookie(request,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the first cookie with the given name. Note that multiple\n\t * cookies can have the same name but different paths or domains.\n\t * @param request current servlet request\n\t * @param name cookie name\n\t * @return the first cookie with the given name, or {@code null} if none is found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "Cookie",
    "signature": "public Cookie getCookie(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Cookie getCookie(HttpServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tCookie[] cookies = request.getCookies();\n\t\tif (cookies != null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tif (name.equals(cookie.getName())) {\n\t\t\t\t\treturn cookie;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeRequest(request,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate request object of the specified type, if available,\n\t * unwrapping the given request as far as necessary.\n\t * @param request the servlet request to introspect\n\t * @param requiredType the desired type of request object\n\t * @return the matching request object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "T",
    "signature": "public T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(request)) {\n\t\t\t\treturn (T) request;\n\t\t\t}\n\t\t\telse if (request instanceof ServletRequestWrapper wrapper) {\n\t\t\t\treturn getNativeRequest(wrapper.getRequest(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeResponse(response,requiredType)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate response object of the specified type, if available,\n\t * unwrapping the given response as far as necessary.\n\t * @param response the servlet response to introspect\n\t * @param requiredType the desired type of response object\n\t * @return the matching response object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "T",
    "signature": "public T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(response)) {\n\t\t\t\treturn (T) response;\n\t\t\t}\n\t\t\telse if (response instanceof ServletResponseWrapper wrapper) {\n\t\t\t\treturn getNativeResponse(wrapper.getResponse(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getParametersStartingWith(request,prefix)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map containing all parameters with the given prefix.\n\t * Maps single values to String and multiple values to String array.\n\t * <p>For example, with a prefix of \"spring_\", \"spring_param1\" and\n\t * \"spring_param2\" result in a Map with \"param1\" and \"param2\" as keys.\n\t * @param request the HTTP request in which to look for parameters\n\t * @param prefix the beginning of parameter names\n\t * (if this is null or the empty string, all parameters will match)\n\t * @return map containing request parameters <b>without the prefix</b>,\n\t * containing either a String or a String array as values\n\t * @see jakarta.servlet.ServletRequest#getParameterNames\n\t * @see jakarta.servlet.ServletRequest#getParameterValues\n\t * @see jakarta.servlet.ServletRequest#getParameterMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "Object>",
    "signature": "public Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix)",
    "source_code": "\tpublic static Map<String, Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tEnumeration<String> paramNames = request.getParameterNames();\n\t\tMap<String, Object> params = new TreeMap<>();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\twhile (paramNames != null && paramNames.hasMoreElements()) {\n\t\t\tString paramName = paramNames.nextElement();\n\t\t\tif (prefix.isEmpty() || paramName.startsWith(prefix)) {\n\t\t\t\tString unprefixed = paramName.substring(prefix.length());\n\t\t\t\tString[] values = request.getParameterValues(paramName);\n\t\t\t\tif (values == null || values.length == 0) {\n\t\t\t\t\t// Do nothing, no values found at all.\n\t\t\t\t}\n\t\t\t\telse if (values.length > 1) {\n\t\t\t\t\tparams.put(unprefixed, values);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparams.put(unprefixed, values[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRealPath(servletContext,path)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Return the real path of the given path within the web application,\n\t * as provided by the servlet container.\n\t * <p>Prepends a slash if the path does not already start with a slash,\n\t * and throws a FileNotFoundException if the path cannot be resolved to\n\t * a resource (in contrast to ServletContext's {@code getRealPath},\n\t * which returns null).\n\t * @param servletContext the servlet context of the web application\n\t * @param path the path within the web application\n\t * @return the corresponding real path\n\t * @throws FileNotFoundException if the path cannot be resolved to a resource\n\t * @see jakarta.servlet.ServletContext#getRealPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "path"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "String",
    "signature": "public String getRealPath(ServletContext servletContext, String path)",
    "source_code": "\tpublic static String getRealPath(ServletContext servletContext, String path) throws FileNotFoundException {\n\t\tAssert.notNull(servletContext, \"ServletContext must not be null\");\n\t\t// Interpret location as relative to the web application root directory.\n\t\tif (!path.startsWith(\"/\")) {\n\t\t\tpath = \"/\" + path;\n\t\t}\n\t\tString realPath = servletContext.getRealPath(path);\n\t\tif (realPath == null) {\n\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\"ServletContext resource [\" + path + \"] cannot be resolved to absolute file path - \" +\n\t\t\t\t\t\"web application archive not expanded?\");\n\t\t}\n\t\treturn realPath;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRequiredSessionAttribute(request,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for a session attribute of the given name.\n\t * Throws an exception if there is no session or if the session has no such\n\t * attribute. Does not create a new session if none has existed before!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @return the value of the session attribute, or {@code null} if not found\n\t * @throws IllegalStateException if the session attribute could not be found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Object",
    "signature": "public Object getRequiredSessionAttribute(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Object getRequiredSessionAttribute(HttpServletRequest request, String name)\n\t\t\tthrows IllegalStateException {\n\n\t\tObject attr = getSessionAttribute(request, name);\n\t\tif (attr == null) {\n\t\t\tthrow new IllegalStateException(\"No session attribute '\" + name + \"' found\");\n\t\t}\n\t\treturn attr;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getSessionAttribute(request,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for a session attribute of the given name.\n\t * Returns null if there is no session or if the session has no such attribute.\n\t * Does not create a new session if none has existed before!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @return the value of the session attribute, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "Object",
    "signature": "public Object getSessionAttribute(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Object getSessionAttribute(HttpServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tHttpSession session = request.getSession(false);\n\t\treturn (session != null ? session.getAttribute(name) : null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#hasSubmitParameter(request,name)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a specific input type=\"submit\" parameter was sent in the request,\n\t * either via a button (directly with name) or via an image (name + \".x\" or\n\t * name + \".y\").\n\t * @param request current HTTP request\n\t * @param name the name of the parameter\n\t * @return if the parameter was sent\n\t * @see #SUBMIT_IMAGE_SUFFIXES\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "boolean",
    "signature": "public boolean hasSubmitParameter(ServletRequest request, String name)",
    "source_code": "\tpublic static boolean hasSubmitParameter(ServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tif (request.getParameter(name) != null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\tif (request.getParameter(name + suffix) != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.util.<unknown>#isValidOrigin(request,allowedOrigins)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request origin against a list of allowed origins.\n\t * A list containing \"*\" means that all origins are allowed.\n\t * An empty list means only same origin is allowed.\n\t *\n\t * <p><strong>Note:</strong> as of 5.1 this method ignores\n\t * {@code \"Forwarded\"} and {@code \"X-Forwarded-*\"} headers that specify the\n\t * client-originated address. Consider using the {@code ForwardedHeaderFilter}\n\t * to extract and use, or to discard such headers.\n\t * @return {@code true} if the request origin is valid, {@code false} otherwise\n\t * @since 4.1.5\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454: The Web Origin Concept</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "allowedOrigins"
    ],
    "position": {
      "column": 1,
      "line": 764
    },
    "return": "boolean",
    "signature": "public boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins)",
    "source_code": "\tpublic static boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(allowedOrigins, \"Allowed origins must not be null\");\n\n\t\tString origin = request.getHeaders().getOrigin();\n\t\tif (origin == null || allowedOrigins.contains(\"*\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (CollectionUtils.isEmpty(allowedOrigins)) {\n\t\t\treturn isSameOrigin(request);\n\t\t}\n\t\telse {\n\t\t\treturn allowedOrigins.contains(origin);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#setSessionAttribute(request,name,value)": {
    "change": "added",
    "deprecated": false,
    "doc": "\t/**\n\t * Set the session attribute with the given name to the given value.\n\t * Removes the session attribute if value is null, if a session existed at all.\n\t * Does not create a new session if not necessary!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @param value the value of the session attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "void",
    "signature": "public void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tif (value != null) {\n\t\t\trequest.getSession().setAttribute(name, value);\n\t\t}\n\t\telse {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsession.removeAttribute(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#set(key,value,MultiValueMap<String,parameters)": {
    "change": "added",
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "MultiValueMap<String",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 689
    },
    "return": "void",
    "signature": "public void set(String key, String value, MultiValueMap<String,String> parameters)",
    "source_code": "\t\tpublic void set(String key, String value, MultiValueMap<String,String> parameters) {\n\t\t\tif (this.extractedUriVariables == null) {\n\t\t\t\tthis.extractedUriVariables = new HashMap<>();\n\t\t\t}\n\t\t\tthis.extractedUriVariables.put(key, value);\n\n\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\tif (this.extractedMatrixVariables == null) {\n\t\t\t\t\tthis.extractedMatrixVariables = new HashMap<>();\n\t\t\t\t}\n\t\t\t\tthis.extractedMatrixVariables.put(key, CollectionUtils.unmodifiableMultiValueMap(parameters));\n\t\t\t}\n\t\t}"
  }
}