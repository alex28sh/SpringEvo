{
  "org.apache.commons.logging.<unknown>#debug(message,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "void",
    "signature": "public void debug(Object message, Throwable exception)",
    "source_code": "\t\tpublic void debug(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#error(message,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "void",
    "signature": "public void error(Object message, Throwable exception)",
    "source_code": "\t\tpublic void error(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.SEVERE, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#fatal(message,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void fatal(Object message, Throwable exception)",
    "source_code": "\t\tpublic void fatal(Object message, Throwable exception) {\n\t\t\terror(message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#info(message,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void info(Object message, Throwable exception)",
    "source_code": "\t\tpublic void info(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.INFO, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#trace(message,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 596
    },
    "return": "void",
    "signature": "public void trace(Object message, Throwable exception)",
    "source_code": "\t\tpublic void trace(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.FINEST, message, exception);\n\t\t}"
  },
  "org.apache.commons.logging.<unknown>#warn(message,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 566
    },
    "return": "void",
    "signature": "public void warn(Object message, Throwable exception)",
    "source_code": "\t\tpublic void warn(Object message, Throwable exception) {\n\t\t\tlog(java.util.logging.Level.WARNING, message, exception);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#argBinding(jp,jpMatch,returnValue,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Take the arguments at the method execution join point and output a set of arguments\n\t * to the advice method.\n\t * @param jp the current JoinPoint\n\t * @param jpMatch the join point match that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the empty array if there are no arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "Object[]",
    "signature": "protected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable ex) {\n\n\t\tcalculateArgumentBindings();\n\n\t\t// AMC start\n\t\tObject[] adviceInvocationArgs = new Object[this.parameterTypes.length];\n\t\tint numBound = 0;\n\n\t\tif (this.joinPointArgumentIndex != -1) {\n\t\t\tadviceInvocationArgs[this.joinPointArgumentIndex] = jp;\n\t\t\tnumBound++;\n\t\t}\n\t\telse if (this.joinPointStaticPartArgumentIndex != -1) {\n\t\t\tadviceInvocationArgs[this.joinPointStaticPartArgumentIndex] = jp.getStaticPart();\n\t\t\tnumBound++;\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(this.argumentBindings)) {\n\t\t\t// binding from pointcut match\n\t\t\tif (jpMatch != null) {\n\t\t\t\tPointcutParameter[] parameterBindings = jpMatch.getParameterBindings();\n\t\t\t\tfor (PointcutParameter parameter : parameterBindings) {\n\t\t\t\t\tString name = parameter.getName();\n\t\t\t\t\tInteger index = this.argumentBindings.get(name);\n\t\t\t\t\tadviceInvocationArgs[index] = parameter.getBinding();\n\t\t\t\t\tnumBound++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// binding from returning clause\n\t\t\tif (this.returningName != null) {\n\t\t\t\tInteger index = this.argumentBindings.get(this.returningName);\n\t\t\t\tadviceInvocationArgs[index] = returnValue;\n\t\t\t\tnumBound++;\n\t\t\t}\n\t\t\t// binding from thrown exception\n\t\t\tif (this.throwingName != null) {\n\t\t\t\tInteger index = this.argumentBindings.get(this.throwingName);\n\t\t\t\tadviceInvocationArgs[index] = ex;\n\t\t\t\tnumBound++;\n\t\t\t}\n\t\t}\n\n\t\tif (numBound != this.parameterTypes.length) {\n\t\t\tthrow new IllegalStateException(\"Required to bind \" + this.parameterTypes.length +\n\t\t\t\t\t\" arguments, but only bound \" + numBound + \" (JoinPointMatch \" +\n\t\t\t\t\t(jpMatch == null ? \"was NOT\" : \"WAS\") + \" bound in invocation)\");\n\t\t}\n\n\t\treturn adviceInvocationArgs;\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#couldMatchJoinPointsInType(someClass,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "someClass",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 634
    },
    "return": "boolean",
    "signature": "public boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context)",
    "source_code": "\t\tpublic boolean couldMatchJoinPointsInType(Class someClass, MatchingContext context) {\n\t\t\treturn (contextMatch(someClass) == FuzzyBoolean.YES);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jp,jpMatch,returnValue,t)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jp",
      "jpMatch",
      "returnValue",
      "t"
    ],
    "position": {
      "column": 1,
      "line": 625
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t)",
    "source_code": "\tprotected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable t) throws Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#invokeAdviceMethod(jpMatch,returnValue,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the advice method.\n\t * @param jpMatch the JoinPointMatch that matched this execution join point\n\t * @param returnValue the return value from the method execution (may be null)\n\t * @param ex the exception thrown by the method execution (may be null)\n\t * @return the invocation result\n\t * @throws Throwable in case of invocation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jpMatch",
      "returnValue",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 617
    },
    "return": "Object",
    "signature": "protected Object invokeAdviceMethod(@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)",
    "source_code": "\tprotected Object invokeAdviceMethod(\n\t\t\t@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)\n\t\t\tthrows Throwable {\n\n\t\treturn invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 712
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn !this.adviceMethod.equals(method);\n\t\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Bind Spring AOP proxy to AspectJ \"this\" and Spring AOP target to AspectJ target,\n\t\t// consistent with return of MethodInvocationProceedingJoinPoint\n\t\tProxyMethodInvocation pmi = null;\n\t\tObject targetObject = null;\n\t\tObject thisObject = null;\n\t\ttry {\n\t\t\tMethodInvocation curr = ExposeInvocationInterceptor.currentInvocation();\n\t\t\tif (curr.getMethod() == method) {\n\t\t\t\ttargetObject = curr.getThis();\n\t\t\t\tif (!(curr instanceof ProxyMethodInvocation currPmi)) {\n\t\t\t\t\tthrow new IllegalStateException(\"MethodInvocation is not a Spring ProxyMethodInvocation: \" + curr);\n\t\t\t\t}\n\t\t\t\tpmi = currPmi;\n\t\t\t\tthisObject = pmi.getProxy();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\t// No current invocation...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not access current invocation - matching with limited context: \" + ex);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tJoinPointMatch joinPointMatch = shadowMatch.matchesJoinPoint(thisObject, targetObject, args);\n\n\t\t\t/*\n\t\t\t * Do a final check to see if any this(TYPE) kind of residue match. For\n\t\t\t * this purpose, we use the original method's (proxy method's) shadow to\n\t\t\t * ensure that 'this' is correctly checked against. Without this check,\n\t\t\t * we get incorrect match on this(TYPE) where TYPE matches the target\n\t\t\t * type but not 'this' (as would be the case of JDK dynamic proxies).\n\t\t\t * <p>See SPR-2979 for the original bug.\n\t\t\t */\n\t\t\tif (pmi != null && thisObject != null) {  // there is a current invocation\n\t\t\t\tRuntimeTestWalker originalMethodResidueTest = getRuntimeTestWalker(getShadowMatch(method, method));\n\t\t\t\tif (!originalMethodResidueTest.testThisInstanceOfResidue(thisObject.getClass())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (joinPointMatch.matches()) {\n\t\t\t\t\tbindParameters(pmi, joinPointMatch);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn joinPointMatch.matches();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to evaluate join point for arguments \" + Arrays.toString(args) +\n\t\t\t\t\t\t\" - falling back to non-match\", ex);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matches(method,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);\n\n\t\t// Special handling for this, target, @this, @target, @annotation\n\t\t// in Spring - we can optimize since we know we have exactly this class,\n\t\t// and there will never be matching subclass at runtime.\n\t\tif (shadowMatch.alwaysMatches()) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (shadowMatch.neverMatches()) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// the maybe case\n\t\t\tif (hasIntroductions) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// A match test returned maybe - if there are any subtype sensitive variables\n\t\t\t// involved in the test (this, target, at_this, at_target, at_annotation) then\n\t\t\t// we say this is not a match as in Spring there will never be a different\n\t\t\t// runtime subtype.\n\t\t\tRuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);\n\t\t\treturn (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.<unknown>#matchesJoinPoint(thisObject,targetObject,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "thisObject",
      "targetObject",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 707
    },
    "return": "JoinPointMatch",
    "signature": "public JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args)",
    "source_code": "\t\tpublic JoinPointMatch matchesJoinPoint(Object thisObject, Object targetObject, Object[] args) {\n\t\t\ttry {\n\t\t\t\treturn this.primary.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t\tcatch (ReflectionWorldException ex) {\n\t\t\t\treturn this.other.matchesJoinPoint(thisObject, targetObject, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tReflectionHints reflectionHints = generationContext.getRuntimeHints().reflection();\n\t\t\tfor (Advisor advisor : this.advisors) {\n\t\t\t\tif (advisor.getAdvice() instanceof AbstractAspectJAdvice aspectJAdvice) {\n\t\t\t\t\treflectionHints.registerMethod(aspectJAdvice.getAspectJAdviceMethod(), ExecutableMode.INVOKE);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#getAdvice(candidateAdviceMethod,expressionPointcut,aspectInstanceFactory,declarationOrder,aspectName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdviceMethod",
      "expressionPointcut",
      "aspectInstanceFactory",
      "declarationOrder",
      "aspectName"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "Advice",
    "signature": "public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n\t\t\tMetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName)",
    "source_code": "\tpublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n\t\t\tMetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n\t\tClass<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n\t\tvalidate(candidateAspectClass);\n\n\t\tAspectJAnnotation aspectJAnnotation =\n\t\t\t\tAbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n\t\tif (aspectJAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If we get here, we know we have an AspectJ method.\n\t\t// Check that it's an AspectJ-annotated class\n\t\tif (!isAspect(candidateAspectClass)) {\n\t\t\tthrow new AopConfigException(\"Advice must be declared inside an aspect type: \" +\n\t\t\t\t\t\"Offending method '\" + candidateAdviceMethod + \"' in class [\" +\n\t\t\t\t\tcandidateAspectClass.getName() + \"]\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found AspectJ method: \" + candidateAdviceMethod);\n\t\t}\n\n\t\tAbstractAspectJAdvice springAdvice;\n\n\t\tswitch (aspectJAnnotation.getAnnotationType()) {\n\t\t\tcase AtPointcut -> {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\");\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tcase AtAround -> springAdvice = new AspectJAroundAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtBefore -> springAdvice = new AspectJMethodBeforeAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtAfter -> springAdvice = new AspectJAfterAdvice(\n\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\tcase AtAfterReturning -> {\n\t\t\t\tspringAdvice = new AspectJAfterReturningAdvice(\n\t\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\t\tAfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();\n\t\t\t\tif (StringUtils.hasText(afterReturningAnnotation.returning())) {\n\t\t\t\t\tspringAdvice.setReturningName(afterReturningAnnotation.returning());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase AtAfterThrowing -> {\n\t\t\t\tspringAdvice = new AspectJAfterThrowingAdvice(\n\t\t\t\t\t\tcandidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n\t\t\t\tAfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();\n\t\t\t\tif (StringUtils.hasText(afterThrowingAnnotation.throwing())) {\n\t\t\t\t\tspringAdvice.setThrowingName(afterThrowingAnnotation.throwing());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault -> throw new UnsupportedOperationException(\n\t\t\t\t\t\"Unsupported advice type on method: \" + candidateAdviceMethod);\n\t\t}\n\n\t\t// Now to configure the advice...\n\t\tspringAdvice.setAspectName(aspectName);\n\t\tspringAdvice.setDeclarationOrder(declarationOrder);\n\t\tString[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);\n\t\tif (argNames != null) {\n\t\t\tspringAdvice.setArgumentNamesFromStringArray(argNames);\n\t\t}\n\t\tspringAdvice.calculateArgumentBindings();\n\n\t\treturn springAdvice;\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#getAdvisor(candidateAdviceMethod,aspectInstanceFactory,declarationOrderInAspect,aspectName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdviceMethod",
      "aspectInstanceFactory",
      "declarationOrderInAspect",
      "aspectName"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "Advisor",
    "signature": "public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n\t\t\tint declarationOrderInAspect, String aspectName)",
    "source_code": "\tpublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n\t\t\tint declarationOrderInAspect, String aspectName) {\n\n\t\tvalidate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\n\t\tAspectJExpressionPointcut expressionPointcut = getPointcut(\n\t\t\t\tcandidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\t\tif (expressionPointcut == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n\t\t\t\t\tthis, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n\t\t}\n\t\tcatch (IllegalArgumentException | IllegalStateException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Ignoring incompatible advice method: \" + candidateAdviceMethod, ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\t// We're either instantiated and matching on declared pointcut,\n\t\t\t// or uninstantiated matching on either pointcut...\n\t\t\treturn (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass)) ||\n\t\t\t\t\tthis.preInstantiationPointcut.getMethodMatcher().matches(method, targetClass);\n\t\t}"
  },
  "org.springframework.aop.aspectj.annotation.<unknown>#matches(method,targetClass,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\t\t// This can match only on declared pointcut.\n\t\t\treturn (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass, args));\n\t\t}"
  },
  "org.springframework.aop.aspectj.autoproxy.<unknown>#shouldSkip(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "boolean",
    "signature": "protected boolean shouldSkip(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n\t\t// TODO: Consider optimization by caching the list of the aspect names\n\t\tList<Advisor> candidateAdvisors = findCandidateAdvisors();\n\t\tfor (Advisor advisor : candidateAdvisors) {\n\t\t\tif (advisor instanceof AspectJPointcutAdvisor pointcutAdvisor &&\n\t\t\t\t\tpointcutAdvisor.getAspectName().equals(beanName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.shouldSkip(beanClass, beanName);\n\t}"
  },
  "org.springframework.aop.config.<unknown>#decorate(node,definition,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tboolean proxyTargetClass = true;\n\t\tif (node instanceof Element ele && ele.hasAttribute(PROXY_TARGET_CLASS)) {\n\t\t\tproxyTargetClass = Boolean.parseBoolean(ele.getAttribute(PROXY_TARGET_CLASS));\n\t\t}\n\n\t\t// Register the original bean definition as it will be referenced by the scoped proxy\n\t\t// and is relevant for tooling (validation, navigation).\n\t\tBeanDefinitionHolder holder =\n\t\t\t\tScopedProxyUtils.createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass);\n\t\tString targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName());\n\t\tparserContext.getReaderContext().fireComponentRegistered(\n\t\t\t\tnew BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName));\n\t\treturn holder;\n\t}"
  },
  "org.springframework.aop.config.<unknown>#decorate(node,definitionHolder,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definitionHolder",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definitionHolder, ParserContext parserContext)",
    "source_code": "\tpublic final BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definitionHolder, ParserContext parserContext) {\n\t\tBeanDefinitionRegistry registry = parserContext.getRegistry();\n\n\t\t// get the root bean name - will be the name of the generated proxy factory bean\n\t\tString existingBeanName = definitionHolder.getBeanName();\n\t\tBeanDefinition targetDefinition = definitionHolder.getBeanDefinition();\n\t\tBeanDefinitionHolder targetHolder = new BeanDefinitionHolder(targetDefinition, existingBeanName + \".TARGET\");\n\n\t\t// delegate to subclass for interceptor definition\n\t\tBeanDefinition interceptorDefinition = createInterceptorDefinition(node);\n\n\t\t// generate name and register the interceptor\n\t\tString interceptorName = existingBeanName + '.' + getInterceptorNameSuffix(interceptorDefinition);\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(\n\t\t\t\tnew BeanDefinitionHolder(interceptorDefinition, interceptorName), registry);\n\n\t\tBeanDefinitionHolder result = definitionHolder;\n\n\t\tif (!isProxyFactoryBeanDefinition(targetDefinition)) {\n\t\t\t// create the proxy definition\n\t\t\tRootBeanDefinition proxyDefinition = new RootBeanDefinition();\n\t\t\t// create proxy factory bean definition\n\t\t\tproxyDefinition.setBeanClass(ProxyFactoryBean.class);\n\t\t\tproxyDefinition.setScope(targetDefinition.getScope());\n\t\t\tproxyDefinition.setLazyInit(targetDefinition.isLazyInit());\n\t\t\t// set the target\n\t\t\tproxyDefinition.setDecoratedDefinition(targetHolder);\n\t\t\tproxyDefinition.getPropertyValues().add(\"target\", targetHolder);\n\t\t\t// create the interceptor names list\n\t\t\tproxyDefinition.getPropertyValues().add(\"interceptorNames\", new ManagedList<>());\n\t\t\t// copy autowire settings from original bean definition.\n\t\t\tproxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());\n\t\t\tproxyDefinition.setPrimary(targetDefinition.isPrimary());\n\t\t\tif (targetDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\t\tproxyDefinition.copyQualifiersFrom(abd);\n\t\t\t}\n\t\t\t// wrap it in a BeanDefinitionHolder with bean name\n\t\t\tresult = new BeanDefinitionHolder(proxyDefinition, existingBeanName);\n\t\t}\n\n\t\taddInterceptorNameToList(interceptorName, result.getBeanDefinition());\n\t\treturn result;\n\t}"
  },
  "org.springframework.aop.config.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tCompositeComponentDefinition compositeDef =\n\t\t\t\tnew CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));\n\t\tparserContext.pushContainingComponent(compositeDef);\n\n\t\tconfigureAutoProxyCreator(parserContext, element);\n\n\t\tList<Element> childElts = DomUtils.getChildElements(element);\n\t\tfor (Element elt: childElts) {\n\t\t\tString localName = parserContext.getDelegate().getLocalName(elt);\n\t\t\tswitch (localName) {\n\t\t\t\tcase POINTCUT -> parsePointcut(elt, parserContext);\n\t\t\t\tcase ADVISOR -> parseAdvisor(elt, parserContext);\n\t\t\t\tcase ASPECT -> parseAspect(elt, parserContext);\n\t\t\t}\n\t\t}\n\n\t\tparserContext.popAndRegisterContainingComponent();\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvice(pos,advice)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Cannot add introductions this way unless the advice implements IntroductionInfo.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advice"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "void",
    "signature": "public void addAdvice(int pos, Advice advice)",
    "source_code": "\tpublic void addAdvice(int pos, Advice advice) throws AopConfigException {\n\t\tAssert.notNull(advice, \"Advice must not be null\");\n\t\tif (advice instanceof IntroductionInfo introductionInfo) {\n\t\t\t// We don't need an IntroductionAdvisor for this kind of introduction:\n\t\t\t// It's fully self-describing.\n\t\t\taddAdvisor(pos, new DefaultIntroductionAdvisor(advice, introductionInfo));\n\t\t}\n\t\telse if (advice instanceof DynamicIntroductionAdvice) {\n\t\t\t// We need an IntroductionAdvisor for this kind of introduction.\n\t\t\tthrow new AopConfigException(\"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor\");\n\t\t}\n\t\telse {\n\t\t\taddAdvisor(pos, new DefaultPointcutAdvisor(advice));\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#addAdvisor(pos,advisor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pos",
      "advisor"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "public void addAdvisor(int pos, Advisor advisor)",
    "source_code": "\tpublic void addAdvisor(int pos, Advisor advisor) throws AopConfigException {\n\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t}\n\t\taddAdvisorInternal(pos, advisor);\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#copyConfigurationFrom(other,targetSource,advisors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the AOP configuration from the given {@link AdvisedSupport} object,\n\t * but allow substitution of a fresh {@link TargetSource} and a given interceptor chain.\n\t * @param other the {@code AdvisedSupport} object to take proxy configuration from\n\t * @param targetSource the new TargetSource\n\t * @param advisors the Advisors for the chain\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "other",
      "targetSource",
      "advisors"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "void",
    "signature": "protected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors)",
    "source_code": "\tprotected void copyConfigurationFrom(AdvisedSupport other, TargetSource targetSource, List<Advisor> advisors) {\n\t\tcopyFrom(other);\n\t\tthis.targetSource = targetSource;\n\t\tthis.advisorChainFactory = other.advisorChainFactory;\n\t\tthis.interfaces = new ArrayList<>(other.interfaces);\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof IntroductionAdvisor introductionAdvisor) {\n\t\t\t\tvalidateIntroductionAdvisor(introductionAdvisor);\n\t\t\t}\n\t\t\tAssert.notNull(advisor, \"Advisor must not be null\");\n\t\t\tthis.advisors.add(advisor);\n\t\t}\n\t\tadviceChanged();\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#createProxyClassAndInstance(enhancer,callbacks)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "enhancer",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "Object",
    "signature": "protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks)",
    "source_code": "\tprotected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {\n\t\tenhancer.setInterceptDuringConstruction(false);\n\t\tenhancer.setCallbacks(callbacks);\n\t\treturn (this.constructorArgs != null && this.constructorArgTypes != null ?\n\t\t\t\tenhancer.create(this.constructorArgTypes, this.constructorArgs) :\n\t\t\t\tenhancer.create());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsAdvisors(a,b)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the advisors behind the given AdvisedSupport objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "boolean",
    "signature": "public boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsAdvisors(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn a.getAdvisorCount() == b.getAdvisorCount() && Arrays.equals(a.getAdvisors(), b.getAdvisors());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsInProxy(a,b)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the proxies behind the given AdvisedSupport objects.\n\t * Not the same as equality of the AdvisedSupport objects:\n\t * rather, equality of interfaces, advisors and target sources.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "boolean",
    "signature": "public boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsInProxy(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn (a == b ||\n\t\t\t\t(equalsProxiedInterfaces(a, b) && equalsAdvisors(a, b) && a.getTargetSource().equals(b.getTargetSource())));\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#equalsProxiedInterfaces(a,b)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check equality of the proxied interfaces behind the given AdvisedSupport objects.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "boolean",
    "signature": "public boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b)",
    "source_code": "\tpublic static boolean equalsProxiedInterfaces(AdvisedSupport a, AdvisedSupport b) {\n\t\treturn Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#getInterceptorsAndDynamicInterceptionAdvice(config,method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "config",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "List<Object>",
    "signature": "public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\tAdvised config, Method method, @Nullable Class<?> targetClass) {\n\n\t\t// This is somewhat tricky... We have to process introductions first,\n\t\t// but we need to preserve order in the ultimate list.\n\t\tAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\n\t\tAdvisor[] advisors = config.getAdvisors();\n\t\tList<Object> interceptorList = new ArrayList<>(advisors.length);\n\t\tClass<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\n\t\tBoolean hasIntroductions = null;\n\n\t\tfor (Advisor advisor : advisors) {\n\t\t\tif (advisor instanceof PointcutAdvisor pointcutAdvisor) {\n\t\t\t\t// Add it conditionally.\n\t\t\t\tif (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\n\t\t\t\t\tMethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n\t\t\t\t\tboolean match;\n\t\t\t\t\tif (mm instanceof IntroductionAwareMethodMatcher iamm) {\n\t\t\t\t\t\tif (hasIntroductions == null) {\n\t\t\t\t\t\t\thasIntroductions = hasMatchingIntroductions(advisors, actualClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = iamm.matches(method, actualClass, hasIntroductions);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = mm.matches(method, actualClass);\n\t\t\t\t\t}\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tMethodInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\t\t\tif (mm.isRuntime()) {\n\t\t\t\t\t\t\t// Creating a new object instance in the getInterceptors() method\n\t\t\t\t\t\t\t// isn't a problem as we normally cache created chains.\n\t\t\t\t\t\t\tfor (MethodInterceptor interceptor : interceptors) {\n\t\t\t\t\t\t\t\tinterceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (advisor instanceof IntroductionAdvisor ia) {\n\t\t\t\tif (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\n\t\t\t\t\tInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInterceptor[] interceptors = registry.getInterceptors(advisor);\n\t\t\t\tinterceptorList.addAll(Arrays.asList(interceptors));\n\t\t\t}\n\t\t}\n\n\t\treturn interceptorList;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#getInterceptorsAndDynamicInterceptionAdvice(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects\n\t * for the given method, based on this configuration.\n\t * @param method the proxied method\n\t * @param targetClass the target class\n\t * @return a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 513
    },
    "return": "List<Object>",
    "signature": "public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass) {\n\t\tList<Object> cachedInterceptors;\n\t\tif (this.methodCache != null) {\n\t\t\t// Method-specific cache for method-specific pointcuts\n\t\t\tMethodCacheKey cacheKey = new MethodCacheKey(method);\n\t\t\tcachedInterceptors = this.methodCache.get(cacheKey);\n\t\t\tif (cachedInterceptors == null) {\n\t\t\t\tcachedInterceptors = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\t\tthis, method, targetClass);\n\t\t\t\tthis.methodCache.put(cacheKey, cachedInterceptors);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Shared cache since there are no method-specific advisors (see below).\n\t\t\tcachedInterceptors = this.cachedInterceptors;\n\t\t\tif (cachedInterceptors == null) {\n\t\t\t\tcachedInterceptors = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\t\tthis, method, targetClass);\n\t\t\t\tthis.cachedInterceptors = cachedInterceptors;\n\t\t\t}\n\t\t}\n\t\treturn cachedInterceptors;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#intercept(proxy,method,args,methodProxy)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args",
      "methodProxy"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "Object",
    "signature": "public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)",
    "source_code": "\t\tpublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n\t\t\tObject oldProxy = null;\n\t\t\tboolean setProxyContext = false;\n\t\t\tObject target = null;\n\t\t\tTargetSource targetSource = this.advised.getTargetSource();\n\t\t\ttry {\n\t\t\t\tif (this.advised.exposeProxy) {\n\t\t\t\t\t// Make invocation available if necessary.\n\t\t\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\t\t\tsetProxyContext = true;\n\t\t\t\t}\n\t\t\t\t// Get as late as possible to minimize the time we \"own\" the target, in case it comes from a pool...\n\t\t\t\ttarget = targetSource.getTarget();\n\t\t\t\tClass<?> targetClass = (target != null ? target.getClass() : null);\n\t\t\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\t\t\t\tObject retVal;\n\t\t\t\t// Check whether we only have one InvokerInterceptor: that is,\n\t\t\t\t// no real advice, but just reflective invocation of the target.\n\t\t\t\tif (chain.isEmpty()) {\n\t\t\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly.\n\t\t\t\t\t// Note that the final invoker must be an InvokerInterceptor, so we know\n\t\t\t\t\t// it does nothing but a reflective operation on the target, and no hot\n\t\t\t\t\t// swapping or fancy proxying.\n\t\t\t\t\tObject[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n\t\t\t\t\tretVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We need to create a method invocation...\n\t\t\t\t\tretVal = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain).proceed();\n\t\t\t\t}\n\t\t\t\treturn processReturnType(proxy, target, method, args, retVal);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t\t}\n\t\t\t\tif (setProxyContext) {\n\t\t\t\t\t// Restore old proxy.\n\t\t\t\t\tAopContext.setCurrentProxy(oldProxy);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aop.framework.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Implementation of {@code InvocationHandler.invoke}.\n\t * <p>Callers will see exactly the exception thrown by the target,\n\t * unless a hook method throws an exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tObject oldProxy = null;\n\t\tboolean setProxyContext = false;\n\n\t\tTargetSource targetSource = this.advised.targetSource;\n\t\tObject target = null;\n\n\t\ttry {\n\t\t\tif (!this.cache.equalsDefined && AopUtils.isEqualsMethod(method)) {\n\t\t\t\t// The target does not implement the equals(Object) method itself.\n\t\t\t\treturn equals(args[0]);\n\t\t\t}\n\t\t\telse if (!this.cache.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n\t\t\t\t// The target does not implement the hashCode() method itself.\n\t\t\t\treturn hashCode();\n\t\t\t}\n\t\t\telse if (method.getDeclaringClass() == DecoratingProxy.class) {\n\t\t\t\t// There is only getDecoratedClass() declared -> dispatch to proxy config.\n\t\t\t\treturn AopProxyUtils.ultimateTargetClass(this.advised);\n\t\t\t}\n\t\t\telse if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n\t\t\t\t\tmethod.getDeclaringClass().isAssignableFrom(Advised.class)) {\n\t\t\t\t// Service invocations on ProxyConfig with the proxy config...\n\t\t\t\treturn AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n\t\t\t}\n\n\t\t\tObject retVal;\n\n\t\t\tif (this.advised.exposeProxy) {\n\t\t\t\t// Make invocation available if necessary.\n\t\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\t\tsetProxyContext = true;\n\t\t\t}\n\n\t\t\t// Get as late as possible to minimize the time we \"own\" the target,\n\t\t\t// in case it comes from a pool.\n\t\t\ttarget = targetSource.getTarget();\n\t\t\tClass<?> targetClass = (target != null ? target.getClass() : null);\n\n\t\t\t// Get the interception chain for this method.\n\t\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n\t\t\t// Check whether we have any advice. If we don't, we can fall back on direct\n\t\t\t// reflective invocation of the target, and avoid creating a MethodInvocation.\n\t\t\tif (chain.isEmpty()) {\n\t\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly\n\t\t\t\t// Note that the final invoker must be an InvokerInterceptor so we know it does\n\t\t\t\t// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n\t\t\t\tObject[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n\t\t\t\tretVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We need to create a method invocation...\n\t\t\t\tMethodInvocation invocation =\n\t\t\t\t\t\tnew ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n\t\t\t\t// Proceed to the joinpoint through the interceptor chain.\n\t\t\t\tretVal = invocation.proceed();\n\t\t\t}\n\n\t\t\t// Massage return value if necessary.\n\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\tif (retVal != null && retVal == target &&\n\t\t\t\t\treturnType != Object.class && returnType.isInstance(proxy) &&\n\t\t\t\t\t!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n\t\t\t\t// Special case: it returned \"this\" and the return type of the method\n\t\t\t\t// is type-compatible. Note that we can't help if the target sets\n\t\t\t\t// a reference to itself in another returned object.\n\t\t\t\tretVal = proxy;\n\t\t\t}\n\t\t\telse if (retVal == null && returnType != void.class && returnType.isPrimitive()) {\n\t\t\t\tthrow new AopInvocationException(\n\t\t\t\t\t\t\"Null return value from advice does not match primitive return type for: \" + method);\n\t\t\t}\n\t\t\tif (coroutinesReactorPresent && KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\treturn COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()) ?\n\t\t\t\t\t\tCoroutinesUtils.asFlow(retVal) : CoroutinesUtils.awaitSingleOrNull(retVal, args[args.length - 1]);\n\t\t\t}\n\t\t\treturn retVal;\n\t\t}\n\t\tfinally {\n\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\t// Must have come from TargetSource.\n\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t}\n\t\t\tif (setProxyContext) {\n\t\t\t\t// Restore old proxy.\n\t\t\t\tAopContext.setCurrentProxy(oldProxy);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#isEligible(bean,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean is eligible for advising with this\n\t * post-processor's {@link Advisor}.\n\t * <p>Delegates to {@link #isEligible(Class)} for target class checking.\n\t * Can be overridden, for example, to specifically exclude certain beans by name.\n\t * <p>Note: Only called for regular bean instances but not for existing\n\t * proxy instances which implement {@link Advised} and allow for adding\n\t * the local {@link Advisor} to the existing proxy's {@link Advisor} chain.\n\t * For the latter, {@link #isEligible(Class)} is being called directly,\n\t * with the actual target class behind the existing proxy (as determined\n\t * by {@link AopUtils#getTargetClass(Object)}).\n\t * @param bean the bean instance\n\t * @param beanName the name of the bean\n\t * @see #isEligible(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "boolean",
    "signature": "protected boolean isEligible(Object bean, String beanName)",
    "source_code": "\tprotected boolean isEligible(Object bean, String beanName) {\n\t\treturn isEligible(bean.getClass());\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (this.advisor == null || bean instanceof AopInfrastructureBean) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tif (bean instanceof Advised advised) {\n\t\t\tif (!advised.isFrozen() && isEligible(AopUtils.getTargetClass(bean))) {\n\t\t\t\t// Add our local Advisor to the existing proxy's Advisor chain.\n\t\t\t\tif (this.beforeExistingAdvisors) {\n\t\t\t\t\tadvised.addAdvisor(0, this.advisor);\n\t\t\t\t}\n\t\t\t\telse if (advised.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE &&\n\t\t\t\t\t\tadvised.getAdvisorCount() > 0) {\n\t\t\t\t\t// No target, leave last Advisor in place and add new Advisor right before.\n\t\t\t\t\tadvised.addAdvisor(advised.getAdvisorCount() - 1, this.advisor);\n\t\t\t\t\treturn bean;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadvised.addAdvisor(this.advisor);\n\t\t\t\t}\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\n\t\tif (isEligible(bean, beanName)) {\n\t\t\tProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);\n\t\t\tif (!proxyFactory.isProxyTargetClass()) {\n\t\t\t\tevaluateProxyInterfaces(bean.getClass(), proxyFactory);\n\t\t\t}\n\t\t\tproxyFactory.addAdvisor(this.advisor);\n\t\t\tcustomizeProxyFactory(proxyFactory);\n\n\t\t\t// Use original ClassLoader if bean class not locally loaded in overriding class loader\n\t\t\tClassLoader classLoader = getProxyClassLoader();\n\t\t\tif (classLoader instanceof SmartClassLoader smartClassLoader &&\n\t\t\t\t\tclassLoader != bean.getClass().getClassLoader()) {\n\t\t\t\tclassLoader = smartClassLoader.getOriginalClassLoader();\n\t\t\t}\n\t\t\treturn proxyFactory.getProxy(classLoader);\n\t\t}\n\n\t\t// No proxy needed.\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#prepareProxyFactory(bean,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a {@link ProxyFactory} for the given bean.\n\t * <p>Subclasses may customize the handling of the target instance and in\n\t * particular the exposure of the target class. The default introspection\n\t * of interfaces for non-target-class proxies and the configured advisor\n\t * will be applied afterwards; {@link #customizeProxyFactory} allows for\n\t * late customizations of those parts right before proxy creation.\n\t * @param bean the bean instance to create a proxy for\n\t * @param beanName the corresponding bean name\n\t * @return the ProxyFactory, initialized with this processor's\n\t * {@link ProxyConfig} settings and the specified bean\n\t * @since 4.2.3\n\t * @see #customizeProxyFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "ProxyFactory",
    "signature": "protected ProxyFactory prepareProxyFactory(Object bean, String beanName)",
    "source_code": "\tprotected ProxyFactory prepareProxyFactory(Object bean, String beanName) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.copyFrom(this);\n\t\tproxyFactory.setTarget(bean);\n\t\treturn proxyFactory;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#replaceAdvisor(a,b)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "boolean",
    "signature": "public boolean replaceAdvisor(Advisor a, Advisor b)",
    "source_code": "\tpublic boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException {\n\t\tAssert.notNull(a, \"Advisor a must not be null\");\n\t\tAssert.notNull(b, \"Advisor b must not be null\");\n\t\tint index = indexOf(a);\n\t\tif (index == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tremoveAdvisor(index);\n\t\taddAdvisor(index, b);\n\t\treturn true;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#setConstructorArguments(constructorArgs,constructorArgTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set constructor arguments to use for creating the proxy.\n\t * @param constructorArgs the constructor argument values\n\t * @param constructorArgTypes the constructor argument types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructorArgs",
      "constructorArgTypes"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes)",
    "source_code": "\tpublic void setConstructorArguments(@Nullable Object[] constructorArgs, @Nullable Class<?>[] constructorArgTypes) {\n\t\tif (constructorArgs == null || constructorArgTypes == null) {\n\t\t\tthrow new IllegalArgumentException(\"Both 'constructorArgs' and 'constructorArgTypes' need to be specified\");\n\t\t}\n\t\tif (constructorArgs.length != constructorArgTypes.length) {\n\t\t\tthrow new IllegalArgumentException(\"Number of 'constructorArgs' (\" + constructorArgs.length +\n\t\t\t\t\t\") must match number of 'constructorArgTypes' (\" + constructorArgTypes.length + \")\");\n\t\t}\n\t\tthis.constructorArgs = constructorArgs;\n\t\tthis.constructorArgTypes = constructorArgTypes;\n\t}"
  },
  "org.springframework.aop.framework.<unknown>#setUserAttribute(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "void",
    "signature": "public void setUserAttribute(String key, @Nullable Object value)",
    "source_code": "\tpublic void setUserAttribute(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\tif (this.userAttributes == null) {\n\t\t\t\tthis.userAttributes = new HashMap<>();\n\t\t\t}\n\t\t\tthis.userAttributes.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tif (this.userAttributes != null) {\n\t\t\t\tthis.userAttributes.remove(key);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.adapter.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AdvisorAdapter advisorAdapter) {\n\t\t\tthis.advisorAdapterRegistry.registerAdvisorAdapter(advisorAdapter);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.adapter.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#buildAdvisors(beanName,specificInterceptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the advisors for the given bean, including the specific interceptors\n\t * as well as the common interceptor, all adapted to the Advisor interface.\n\t * @param beanName the name of the bean\n\t * @param specificInterceptors the set of interceptors that is\n\t * specific to this bean (may be empty, but not null)\n\t * @return the list of Advisors for the given bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "specificInterceptors"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "Advisor[]",
    "signature": "protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors)",
    "source_code": "\tprotected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {\n\t\t// Handle prototypes correctly...\n\t\tAdvisor[] commonInterceptors = resolveInterceptorNames();\n\n\t\tList<Object> allInterceptors = new ArrayList<>();\n\t\tif (specificInterceptors != null) {\n\t\t\tif (specificInterceptors.length > 0) {\n\t\t\t\t// specificInterceptors may equal PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n\t\t\t\tallInterceptors.addAll(Arrays.asList(specificInterceptors));\n\t\t\t}\n\t\t\tif (commonInterceptors.length > 0) {\n\t\t\t\tif (this.applyCommonInterceptorsFirst) {\n\t\t\t\t\tallInterceptors.addAll(0, Arrays.asList(commonInterceptors));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tallInterceptors.addAll(Arrays.asList(commonInterceptors));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tint nrOfCommonInterceptors = commonInterceptors.length;\n\t\t\tint nrOfSpecificInterceptors = (specificInterceptors != null ? specificInterceptors.length : 0);\n\t\t\tlogger.trace(\"Creating implicit proxy for bean '\" + beanName + \"' with \" + nrOfCommonInterceptors +\n\t\t\t\t\t\" common interceptors and \" + nrOfSpecificInterceptors + \" specific interceptors\");\n\t\t}\n\n\t\tAdvisor[] advisors = new Advisor[allInterceptors.size()];\n\t\tfor (int i = 0; i < allInterceptors.size(); i++) {\n\t\t\tadvisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));\n\t\t}\n\t\treturn advisors;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#createProxy(beanClass,beanName,specificInterceptors,targetSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an AOP proxy for the given bean.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @param specificInterceptors the set of interceptors that is\n\t * specific to this bean (may be empty, but not null)\n\t * @param targetSource the TargetSource for the proxy,\n\t * already pre-configured to access the bean\n\t * @return the AOP proxy for the bean\n\t * @see #buildAdvisors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "specificInterceptors",
      "targetSource"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "protected Object createProxy(Class<?> beanClass, @Nullable String beanName,\n\t\t\t@Nullable Object[] specificInterceptors, TargetSource targetSource)",
    "source_code": "\tprotected Object createProxy(Class<?> beanClass, @Nullable String beanName,\n\t\t\t@Nullable Object[] specificInterceptors, TargetSource targetSource) {\n\n\t\treturn buildProxy(beanClass, beanName, specificInterceptors, targetSource, false);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#findAdvisorsThatCanApply(candidateAdvisors,beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Search the given candidate Advisors to find all Advisors that\n\t * can apply to the specified bean.\n\t * @param candidateAdvisors the candidate Advisors\n\t * @param beanClass the target's bean class\n\t * @param beanName the target's bean name\n\t * @return the List of applicable Advisors\n\t * @see ProxyCreationContext#getCurrentProxiedBeanName()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "candidateAdvisors",
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "List<Advisor>",
    "signature": "protected List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName)",
    "source_code": "\tprotected List<Advisor> findAdvisorsThatCanApply(\n\t\t\tList<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n\n\t\tProxyCreationContext.setCurrentProxiedBeanName(beanName);\n\t\ttry {\n\t\t\treturn AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n\t\t}\n\t\tfinally {\n\t\t\tProxyCreationContext.setCurrentProxiedBeanName(null);\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#findEligibleAdvisors(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find all eligible Advisors for auto-proxying this class.\n\t * @param beanClass the clazz to find advisors for\n\t * @param beanName the name of the currently proxied bean\n\t * @return the empty List, not {@code null},\n\t * if there are no pointcuts or interceptors\n\t * @see #findCandidateAdvisors\n\t * @see #sortAdvisors\n\t * @see #extendAdvisors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "List<Advisor>",
    "signature": "protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n\t\tList<Advisor> candidateAdvisors = findCandidateAdvisors();\n\t\tList<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n\t\textendAdvisors(eligibleAdvisors);\n\t\tif (!eligibleAdvisors.isEmpty()) {\n\t\t\ttry {\n\t\t\t\teligibleAdvisors = sortAdvisors(eligibleAdvisors);\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tthrow new AopConfigException(\"Advisor sorting failed with unexpected bean creation, probably due \" +\n\t\t\t\t\t\t\"to custom use of the Ordered interface. Consider using the @Order annotation instead.\", ex);\n\t\t\t}\n\t\t}\n\t\treturn eligibleAdvisors;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getAdvicesAndAdvisorsForBean(beanClass,beanName,customTargetSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the given bean is to be proxied, what additional\n\t * advices (for example, AOP Alliance interceptors) and advisors to apply.\n\t * @param beanClass the class of the bean to advise\n\t * @param beanName the name of the bean\n\t * @param customTargetSource the TargetSource returned by the\n\t * {@link #getCustomTargetSource} method: may be ignored.\n\t * Will be {@code null} if no custom target source is in use.\n\t * @return an array of additional interceptors for the particular bean;\n\t * or an empty array if no additional interceptors but just the common ones;\n\t * or {@code null} if no proxy at all, not even with the common interceptors.\n\t * See constants DO_NOT_PROXY and PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS.\n\t * @throws BeansException in case of errors\n\t * @see #DO_NOT_PROXY\n\t * @see #PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "customTargetSource"
    ],
    "position": {
      "column": 1,
      "line": 637
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource)",
    "source_code": "\tprotected abstract Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName,\n\t\t\t@Nullable TargetSource customTargetSource) throws BeansException;\n\n}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getAdvicesAndAdvisorsForBean(beanClass,beanName,targetSource)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName",
      "targetSource"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Object[]",
    "signature": "protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, @Nullable TargetSource targetSource)",
    "source_code": "\tprotected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, @Nullable TargetSource targetSource) {\n\n\t\tList<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n\t\tif (advisors.isEmpty()) {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t\treturn advisors.toArray();\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getCacheKey(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a cache key for the given bean class and bean name.\n\t * <p>Note: As of 4.2.3, this implementation does not return a concatenated\n\t * class/name String anymore but rather the most efficient cache key possible:\n\t * a plain bean name, prepended with {@link BeanFactory#FACTORY_BEAN_PREFIX}\n\t * in case of a {@code FactoryBean}; or if no bean name specified, then the\n\t * given bean {@code Class} as-is.\n\t * @param beanClass the bean class\n\t * @param beanName the bean name\n\t * @return the cache key for the given class and name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Class<?> beanClass, @Nullable String beanName)",
    "source_code": "\tprotected Object getCacheKey(Class<?> beanClass, @Nullable String beanName) {\n\t\tif (StringUtils.hasLength(beanName)) {\n\t\t\treturn (FactoryBean.class.isAssignableFrom(beanClass) ?\n\t\t\t\t\tBeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);\n\t\t}\n\t\telse {\n\t\t\treturn beanClass;\n\t\t}\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getCustomTargetSource(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a target source for bean instances. Uses any TargetSourceCreators if set.\n\t * Returns {@code null} if no custom TargetSource should be used.\n\t * <p>This implementation uses the \"customTargetSourceCreators\" property.\n\t * Subclasses can override this method to use a different mechanism.\n\t * @param beanClass the class of the bean to create a TargetSource for\n\t * @param beanName the name of the bean\n\t * @return a TargetSource for this bean\n\t * @see #setCustomTargetSourceCreators\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "TargetSource",
    "signature": "protected TargetSource getCustomTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected TargetSource getCustomTargetSource(Class<?> beanClass, String beanName) {\n\t\t// We can't create fancy target sources for directly registered singletons.\n\t\tif (this.customTargetSourceCreators != null &&\n\t\t\t\tthis.beanFactory != null && this.beanFactory.containsBean(beanName)) {\n\t\t\tfor (TargetSourceCreator tsc : this.customTargetSourceCreators) {\n\t\t\t\tTargetSource ts = tsc.getTargetSource(beanClass, beanName);\n\t\t\t\tif (ts != null) {\n\t\t\t\t\t// Found a matching TargetSource.\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"TargetSourceCreator [\" + tsc +\n\t\t\t\t\t\t\t\t\"] found custom TargetSource for bean with name '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\treturn ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No custom TargetSource found.\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#getEarlyBeanReference(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Object",
    "signature": "public Object getEarlyBeanReference(Object bean, String beanName)",
    "source_code": "\tpublic Object getEarlyBeanReference(Object bean, String beanName) {\n\t\tObject cacheKey = getCacheKey(bean.getClass(), beanName);\n\t\tthis.earlyBeanReferences.put(cacheKey, bean);\n\t\treturn wrapIfNecessary(bean, beanName, cacheKey);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#isEligible(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "boolean",
    "signature": "protected boolean isEligible(Object bean, String beanName)",
    "source_code": "\tprotected boolean isEligible(Object bean, String beanName) {\n\t\treturn (!AutoProxyUtils.isOriginalInstance(beanName, bean.getClass()) &&\n\t\t\t\tsuper.isEligible(bean, beanName));\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a proxy with the configured interceptors if the bean is\n\t * identified as one to proxy by the subclass.\n\t * @see #getAdvicesAndAdvisorsForBean\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(@Nullable Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {\n\t\tif (bean != null) {\n\t\t\tObject cacheKey = getCacheKey(bean.getClass(), beanName);\n\t\t\tif (this.earlyBeanReferences.remove(cacheKey) != bean) {\n\t\t\t\treturn wrapIfNecessary(bean, beanName, cacheKey);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tObject cacheKey = getCacheKey(beanClass, beanName);\n\n\t\tif (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {\n\t\t\tif (this.advisedBeans.containsKey(cacheKey)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {\n\t\t\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Create proxy here if we have a custom TargetSource.\n\t\t// Suppresses unnecessary default instantiation of the target bean:\n\t\t// The TargetSource will handle target instances in a custom fashion.\n\t\tTargetSource targetSource = getCustomTargetSource(beanClass, beanName);\n\t\tif (targetSource != null) {\n\t\t\tif (StringUtils.hasLength(beanName)) {\n\t\t\t\tthis.targetSourcedBeans.add(beanName);\n\t\t\t}\n\t\t\tObject[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);\n\t\t\tObject proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\treturn pvs;  // skip postProcessPropertyValues\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#prepareProxyFactory(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "ProxyFactory",
    "signature": "protected ProxyFactory prepareProxyFactory(Object bean, String beanName)",
    "source_code": "\tprotected ProxyFactory prepareProxyFactory(Object bean, String beanName) {\n\t\tif (this.beanFactory != null) {\n\t\t\tAutoProxyUtils.exposeTargetClass(this.beanFactory, beanName, bean.getClass());\n\t\t}\n\n\t\tProxyFactory proxyFactory = super.prepareProxyFactory(bean, beanName);\n\t\tif (!proxyFactory.isProxyTargetClass() && this.beanFactory != null &&\n\t\t\t\tAutoProxyUtils.shouldProxyTargetClass(this.beanFactory, beanName)) {\n\t\t\tproxyFactory.setProxyTargetClass(true);\n\t\t}\n\t\treturn proxyFactory;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#shouldProxyTargetClass(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean should be proxied with its target class rather than its interfaces.\n\t * <p>Checks the {@link AutoProxyUtils#PRESERVE_TARGET_CLASS_ATTRIBUTE \"preserveTargetClass\" attribute}\n\t * of the corresponding bean definition.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @return whether the given bean should be proxied with its target class\n\t * @see AutoProxyUtils#shouldProxyTargetClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "boolean",
    "signature": "protected boolean shouldProxyTargetClass(Class<?> beanClass, @Nullable String beanName)",
    "source_code": "\tprotected boolean shouldProxyTargetClass(Class<?> beanClass, @Nullable String beanName) {\n\t\treturn (this.beanFactory instanceof ConfigurableListableBeanFactory clbf &&\n\t\t\t\tAutoProxyUtils.shouldProxyTargetClass(clbf, beanName));\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#shouldSkip(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses should override this method to return {@code true} if the\n\t * given bean should not be considered for auto-proxying by this post-processor.\n\t * <p>Sometimes we need to be able to avoid this happening, for example, if it will lead to\n\t * a circular reference or if the existing target instance needs to be preserved.\n\t * This implementation returns {@code false} unless the bean name indicates an\n\t * \"original instance\" according to {@code AutowireCapableBeanFactory} conventions.\n\t * @param beanClass the class of the bean\n\t * @param beanName the name of the bean\n\t * @return whether to skip the given bean\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#ORIGINAL_INSTANCE_SUFFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "boolean",
    "signature": "protected boolean shouldSkip(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected boolean shouldSkip(Class<?> beanClass, String beanName) {\n\t\treturn AutoProxyUtils.isOriginalInstance(beanName, beanClass);\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.<unknown>#wrapIfNecessary(bean,beanName,cacheKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.\n\t * @param bean the raw bean instance\n\t * @param beanName the name of the bean\n\t * @param cacheKey the cache key for metadata access\n\t * @return a proxy wrapping the bean, or the raw bean instance as-is\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName",
      "cacheKey"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "Object",
    "signature": "protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey)",
    "source_code": "\tprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n\t\tif (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {\n\t\t\treturn bean;\n\t\t}\n\t\tif (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n\t\t\treturn bean;\n\t\t}\n\t\tif (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n\t\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\t\treturn bean;\n\t\t}\n\n\t\t// Create proxy if we have advice.\n\t\tObject[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n\t\tif (specificInterceptors != DO_NOT_PROXY) {\n\t\t\tthis.advisedBeans.put(cacheKey, Boolean.TRUE);\n\t\t\tObject proxy = createProxy(\n\t\t\t\t\tbean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n\t\t\tthis.proxyTypes.put(cacheKey, proxy.getClass());\n\t\t\treturn proxy;\n\t\t}\n\n\t\tthis.advisedBeans.put(cacheKey, Boolean.FALSE);\n\t\treturn bean;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.target.<unknown>#createBeanFactoryBasedTargetSource(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "AbstractBeanFactoryBasedTargetSource",
    "signature": "protected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(\n\t\t\tClass<?> beanClass, String beanName) {\n\n\t\tif (getBeanFactory() instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\tBeanDefinition definition = clbf.getBeanDefinition(beanName);\n\t\t\tif (definition.isLazyInit()) {\n\t\t\t\treturn new LazyInitTargetSource();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.aop.framework.autoproxy.target.<unknown>#getTargetSource(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "TargetSource",
    "signature": "public TargetSource getTargetSource(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic final TargetSource getTargetSource(Class<?> beanClass, String beanName) {\n\t\tAbstractBeanFactoryBasedTargetSource targetSource =\n\t\t\t\tcreateBeanFactoryBasedTargetSource(beanClass, beanName);\n\t\tif (targetSource == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Configuring AbstractBeanFactoryBasedTargetSource: \" + targetSource);\n\t\t}\n\n\t\tDefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName);\n\n\t\t// We need to override just this bean definition, as it may reference other beans\n\t\t// and we're happy to take the parent's definition for those.\n\t\t// Always use prototype scope if demanded.\n\t\tBeanDefinition bd = getConfigurableBeanFactory().getMergedBeanDefinition(beanName);\n\t\tGenericBeanDefinition bdCopy = new GenericBeanDefinition(bd);\n\t\tif (isPrototypeBased()) {\n\t\t\tbdCopy.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t}\n\t\tinternalBeanFactory.registerBeanDefinition(beanName, bdCopy);\n\n\t\t// Complete configuring the PrototypeTargetSource.\n\t\ttargetSource.setTargetBeanName(beanName);\n\t\ttargetSource.setBeanFactory(internalBeanFactory);\n\n\t\treturn targetSource;\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#configure(defaultExecutor,exceptionHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this aspect with the given executor and exception handler suppliers,\n\t * applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultExecutor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<Executor> defaultExecutor,\n\t\t\t@Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tpublic void configure(@Nullable Supplier<Executor> defaultExecutor,\n\t\t\t@Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tthis.defaultExecutor = new SingletonSupplier<>(defaultExecutor, () -> getDefaultExecutor(this.beanFactory));\n\t\tthis.exceptionHandler = new SingletonSupplier<>(exceptionHandler, SimpleAsyncUncaughtExceptionHandler::new);\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#doSubmit(task,executor,returnType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate for actually executing the given task with the chosen executor.\n\t * @param task the task to execute\n\t * @param executor the chosen executor\n\t * @param returnType the declared return type (potentially a {@link Future} variant)\n\t * @return the execution result (potentially a corresponding {@link Future} handle)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "executor",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "Object",
    "signature": "protected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType)",
    "source_code": "\tprotected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType) {\n\t\tif (CompletableFuture.class.isAssignableFrom(returnType)) {\n\t\t\treturn executor.submitCompletable(task);\n\t\t}\n\t\telse if (org.springframework.util.concurrent.ListenableFuture.class.isAssignableFrom(returnType)) {\n\t\t\treturn ((org.springframework.core.task.AsyncListenableTaskExecutor) executor).submitListenable(task);\n\t\t}\n\t\telse if (Future.class.isAssignableFrom(returnType)) {\n\t\t\treturn executor.submit(task);\n\t\t}\n\t\telse if (void.class == returnType || \"kotlin.Unit\".equals(returnType.getName())) {\n\t\t\texecutor.submit(task);\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Invalid return type for async method (only Future and void supported): \" + returnType);\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#findQualifiedExecutor(beanFactory,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a target executor for the given qualifier.\n\t * @param qualifier the qualifier to resolve\n\t * @return the target executor, or {@code null} if none available\n\t * @since 4.2.6\n\t * @see #getExecutorQualifier(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Executor",
    "signature": "protected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier)",
    "source_code": "\tprotected Executor findQualifiedExecutor(@Nullable BeanFactory beanFactory, String qualifier) {\n\t\tif (beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\"BeanFactory must be set on \" + getClass().getSimpleName() +\n\t\t\t\t\t\" to access qualified executor '\" + qualifier + \"'\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, Executor.class, qualifier);\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#handleError(ex,method,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handles a fatal error thrown while asynchronously invoking the specified\n\t * {@link Method}.\n\t * <p>If the return type of the method is a {@link Future} object, the original\n\t * exception can be propagated by just throwing it at the higher level. However,\n\t * for all other cases, the exception will not be transmitted back to the client.\n\t * In that later case, the current {@link AsyncUncaughtExceptionHandler} will be\n\t * used to manage such exception.\n\t * @param ex the exception to handle\n\t * @param method the method that was invoked\n\t * @param params the parameters used to invoke the method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "method",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "protected void handleError(Throwable ex, Method method, Object... params)",
    "source_code": "\tprotected void handleError(Throwable ex, Method method, Object... params) throws Exception {\n\t\tif (Future.class.isAssignableFrom(method.getReturnType())) {\n\t\t\tReflectionUtils.rethrowException(ex);\n\t\t}\n\t\telse {\n\t\t\t// Could not transmit the exception to the caller with default executor\n\t\t\ttry {\n\t\t\t\tthis.exceptionHandler.obtain().handleUncaughtException(ex, method, params);\n\t\t\t}\n\t\t\tcatch (Throwable ex2) {\n\t\t\t\tlogger.warn(\"Exception handler for async method '\" + method.toGenericString() +\n\t\t\t\t\t\t\"' threw unexpected exception itself\", ex2);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#invokeUnderTrace(invocation,logger)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Writes a log message before the invocation based on the value of {@code enterMessage}.\n\t * If the invocation succeeds, then a log message is written on exit based on the value\n\t * {@code exitMessage}. If an exception occurs during invocation, then a message is\n\t * written based on the value of {@code exceptionMessage}.\n\t * @see #setEnterMessage\n\t * @see #setExitMessage\n\t * @see #setExceptionMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "logger"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "Object",
    "signature": "protected Object invokeUnderTrace(MethodInvocation invocation, Log logger)",
    "source_code": "\tprotected Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable {\n\t\tString name = ClassUtils.getQualifiedMethodName(invocation.getMethod());\n\t\tStopWatch stopWatch = new StopWatch(name);\n\t\tObject returnValue = null;\n\t\tboolean exitThroughException = false;\n\t\ttry {\n\t\t\tstopWatch.start(name);\n\t\t\twriteToLog(logger,\n\t\t\t\t\treplacePlaceholders(this.enterMessage, invocation, null, null, -1));\n\t\t\treturnValue = invocation.proceed();\n\t\t\treturn returnValue;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\tstopWatch.stop();\n\t\t\t}\n\t\t\texitThroughException = true;\n\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\tthis.exceptionMessage, invocation, null, ex, stopWatch.getTotalTimeMillis()), ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (!exitThroughException) {\n\t\t\t\tif (stopWatch.isRunning()) {\n\t\t\t\t\tstopWatch.stop();\n\t\t\t\t}\n\t\t\t\twriteToLog(logger, replacePlaceholders(\n\t\t\t\t\t\tthis.exitMessage, invocation, returnValue, null, stopWatch.getTotalTimeMillis()));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.aop.interceptor.<unknown>#replacePlaceholders(message,methodInvocation,returnValue,throwable,invocationTime)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace the placeholders in the given message with the supplied values,\n\t * or values derived from those supplied.\n\t * @param message the message template containing the placeholders to be replaced\n\t * @param methodInvocation the {@code MethodInvocation} being logged.\n\t * Used to derive values for all placeholders except {@code $[exception]}\n\t * and {@code $[returnValue]}.\n\t * @param returnValue any value returned by the invocation.\n\t * Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.\n\t * @param throwable any {@code Throwable} raised during the invocation.\n\t * The value of {@code Throwable.toString()} is replaced for the\n\t * {@code $[exception]} placeholder. May be {@code null}.\n\t * @param invocationTime the value to write in place of the\n\t * {@code $[invocationTime]} placeholder\n\t * @return the formatted output to write to the log\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "methodInvocation",
      "returnValue",
      "throwable",
      "invocationTime"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "String",
    "signature": "protected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime)",
    "source_code": "\tprotected String replacePlaceholders(String message, MethodInvocation methodInvocation,\n\t\t\t@Nullable Object returnValue, @Nullable Throwable throwable, long invocationTime) {\n\n\t\tObject target = methodInvocation.getThis();\n\t\tAssert.state(target != null, \"Target must not be null\");\n\n\t\tStringBuilder output = new StringBuilder();\n\t\tMatcher matcher = PATTERN.matcher(message);\n\t\twhile (matcher.find()) {\n\t\t\tString match = matcher.group();\n\t\t\tswitch (match) {\n\t\t\t\tcase PLACEHOLDER_METHOD_NAME -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(methodInvocation.getMethod().getName()));\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_NAME -> {\n\t\t\t\t\tString className = getClassForLogging(target).getName();\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(className));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_TARGET_CLASS_SHORT_NAME -> {\n\t\t\t\t\tString shortName = ClassUtils.getShortName(getClassForLogging(target));\n\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(shortName));\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_ARGUMENTS -> matcher.appendReplacement(output,\n\t\t\t\t\t\tMatcher.quoteReplacement(StringUtils.arrayToCommaDelimitedString(methodInvocation.getArguments())));\n\t\t\t\tcase PLACEHOLDER_ARGUMENT_TYPES -> appendArgumentTypes(methodInvocation, matcher, output);\n\t\t\t\tcase PLACEHOLDER_RETURN_VALUE -> appendReturnValue(methodInvocation, matcher, output, returnValue);\n\t\t\t\tcase PLACEHOLDER_EXCEPTION -> {\n\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\tmatcher.appendReplacement(output, Matcher.quoteReplacement(throwable.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase PLACEHOLDER_INVOCATION_TIME -> matcher.appendReplacement(output, Long.toString(invocationTime));\n\t\t\t\tdefault -> {\n\t\t\t\t\t// Should not happen since placeholders are checked earlier.\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown placeholder [\" + match + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatcher.appendTail(output);\n\n\t\treturn output.toString();\n\t}"
  },
  "org.springframework.aop.scope.<unknown>#createScopedProxy(definition,registry,proxyTargetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a scoped proxy for the supplied target bean, registering the target\n\t * bean with an internal name and setting 'targetBeanName' on the scoped proxy.\n\t * @param definition the original bean definition\n\t * @param registry the bean definition registry\n\t * @param proxyTargetClass whether to create a target class proxy\n\t * @return the scoped proxy definition\n\t * @see #getTargetBeanName(String)\n\t * @see #getOriginalBeanName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition",
      "registry",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition,\n\t\t\tBeanDefinitionRegistry registry, boolean proxyTargetClass)",
    "source_code": "\tpublic static BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition,\n\t\t\tBeanDefinitionRegistry registry, boolean proxyTargetClass) {\n\n\t\tString originalBeanName = definition.getBeanName();\n\t\tBeanDefinition targetDefinition = definition.getBeanDefinition();\n\t\tString targetBeanName = getTargetBeanName(originalBeanName);\n\n\t\t// Create a scoped proxy definition for the original bean name,\n\t\t// \"hiding\" the target bean in an internal target definition.\n\t\tRootBeanDefinition proxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\tproxyDefinition.setDecoratedDefinition(new BeanDefinitionHolder(targetDefinition, targetBeanName));\n\t\tproxyDefinition.setOriginatingBeanDefinition(targetDefinition);\n\t\tproxyDefinition.setSource(definition.getSource());\n\t\tproxyDefinition.setRole(targetDefinition.getRole());\n\n\t\tproxyDefinition.getPropertyValues().add(\"targetBeanName\", targetBeanName);\n\t\tif (proxyTargetClass) {\n\t\t\ttargetDefinition.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedProxyFactoryBean's \"proxyTargetClass\" default is TRUE, so we don't need to set it explicitly here.\n\t\t}\n\t\telse {\n\t\t\tproxyDefinition.getPropertyValues().add(\"proxyTargetClass\", Boolean.FALSE);\n\t\t}\n\n\t\t// Copy autowire settings from original bean definition.\n\t\tproxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());\n\t\tproxyDefinition.setPrimary(targetDefinition.isPrimary());\n\t\tif (targetDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\tproxyDefinition.copyQualifiersFrom(abd);\n\t\t}\n\n\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\ttargetDefinition.setAutowireCandidate(false);\n\t\ttargetDefinition.setPrimary(false);\n\n\t\t// Register the target bean as separate bean in the factory.\n\t\tregistry.registerBeanDefinition(targetBeanName, targetDefinition);\n\n\t\t// Return the scoped proxy definition as primary bean definition\n\t\t// (potentially an inner bean).\n\t\treturn new BeanDefinitionHolder(proxyDefinition, originalBeanName, definition.getAliases());\n\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(\n\t\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\n\t\t\tGeneratedMethod generatedMethod = beanRegistrationCode.getMethods()\n\t\t\t\t\t.add(\"getScopedProxyInstance\", method -> {\n\t\t\t\t\t\tmethod.addJavadoc(\"Create the scoped proxy bean instance for '$L'.\",\n\t\t\t\t\t\t\t\tthis.registeredBean.getBeanName());\n\t\t\t\t\t\tmethod.addModifiers(Modifier.PRIVATE, Modifier.STATIC);\n\t\t\t\t\t\tmethod.returns(ScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"$T factory = new $T()\",\n\t\t\t\t\t\t\t\tScopedProxyFactoryBean.class, ScopedProxyFactoryBean.class);\n\t\t\t\t\t\tmethod.addStatement(\"factory.setTargetBeanName($S)\", this.targetBeanName);\n\t\t\t\t\t\tmethod.addStatement(\"factory.setBeanFactory($L.getBeanFactory())\",\n\t\t\t\t\t\t\t\tREGISTERED_BEAN_PARAMETER_NAME);\n\t\t\t\t\t\tmethod.addStatement(\"return factory\");\n\t\t\t\t\t});\n\t\t\treturn CodeBlock.of(\"$T.of($L)\", InstanceSupplier.class,\n\t\t\t\t\tgeneratedMethod.toMethodReference().toCodeBlock());\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateNewBeanDefinitionCode(generationContext,beanType,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanType",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode) {\n\n\t\t\treturn super.generateNewBeanDefinitionCode(generationContext,\n\t\t\t\t\tthis.targetBeanDefinition.getResolvableType(), beanRegistrationCode);\n\t\t}"
  },
  "org.springframework.aop.scope.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter)",
    "source_code": "\t\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(\n\t\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter) {\n\n\t\t\tRootBeanDefinition processedBeanDefinition = new RootBeanDefinition(beanDefinition);\n\t\t\tprocessedBeanDefinition.setTargetType(this.targetBeanDefinition.getResolvableType());\n\t\t\tprocessedBeanDefinition.getPropertyValues().removePropertyValue(\"targetBeanName\");\n\t\t\treturn super.generateSetBeanDefinitionPropertiesCode(generationContext,\n\t\t\t\t\tbeanRegistrationCode, processedBeanDefinition, attributeFilter);\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(advisor,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given advisor apply at all on the given class?\n\t * This is an important test as it can be used to optimize\n\t * out an advisor for a class.\n\t * @param advisor the advisor to check\n\t * @param targetClass class we're testing\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advisor",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "boolean",
    "signature": "public boolean canApply(Advisor advisor, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Advisor advisor, Class<?> targetClass) {\n\t\treturn canApply(advisor, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(advisor,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given advisor apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize out an advisor for a class.\n\t * This version also takes into account introductions (for IntroductionAwareMethodMatchers).\n\t * @param advisor the advisor to check\n\t * @param targetClass class we're testing\n\t * @param hasIntroductions whether the advisor chain for this bean includes\n\t * any introductions\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "advisor",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "boolean",
    "signature": "public boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n\t\tif (advisor instanceof IntroductionAdvisor ia) {\n\t\t\treturn ia.getClassFilter().matches(targetClass);\n\t\t}\n\t\telse if (advisor instanceof PointcutAdvisor pca) {\n\t\t\treturn canApply(pca.getPointcut(), targetClass, hasIntroductions);\n\t\t}\n\t\telse {\n\t\t\t// It doesn't have a pointcut so we assume it applies.\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass) {\n\t\treturn canApply(pc, targetClass, false);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#canApply(pc,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Can the given pointcut apply at all on the given class?\n\t * <p>This is an important test as it can be used to optimize\n\t * out a pointcut for a class.\n\t * @param pc the static or dynamic pointcut to check\n\t * @param targetClass the class to test\n\t * @param hasIntroductions whether the advisor chain\n\t * for this bean includes any introductions\n\t * @return whether the pointcut can apply on any method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pc",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "boolean",
    "signature": "public boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n\t\tAssert.notNull(pc, \"Pointcut must not be null\");\n\t\tif (!pc.getClassFilter().matches(targetClass)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMethodMatcher methodMatcher = pc.getMethodMatcher();\n\t\tif (methodMatcher == MethodMatcher.TRUE) {\n\t\t\t// No need to iterate the methods if we're matching any method anyway...\n\t\t\treturn true;\n\t\t}\n\n\t\tIntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n\t\tif (methodMatcher instanceof IntroductionAwareMethodMatcher iamm) {\n\t\t\tintroductionAwareMethodMatcher = iamm;\n\t\t}\n\n\t\tSet<Class<?>> classes = new LinkedHashSet<>();\n\t\tif (!Proxy.isProxyClass(targetClass)) {\n\t\t\tclasses.add(ClassUtils.getUserClass(targetClass));\n\t\t}\n\t\tclasses.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tMethod[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (introductionAwareMethodMatcher != null ?\n\t\t\t\t\t\tintroductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :\n\t\t\t\t\t\tmethodMatcher.matches(method, targetClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#findAdvisorsThatCanApply(candidateAdvisors,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the sublist of the {@code candidateAdvisors} list\n\t * that is applicable to the given class.\n\t * @param candidateAdvisors the Advisors to evaluate\n\t * @param clazz the target class\n\t * @return sublist of Advisors that can apply to an object of the given class\n\t * (may be the incoming List as-is)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidateAdvisors",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "List<Advisor>",
    "signature": "public List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz)",
    "source_code": "\tpublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n\t\tif (candidateAdvisors.isEmpty()) {\n\t\t\treturn candidateAdvisors;\n\t\t}\n\t\tList<Advisor> eligibleAdvisors = new ArrayList<>();\n\t\tfor (Advisor candidate : candidateAdvisors) {\n\t\t\tif (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n\t\t\t\teligibleAdvisors.add(candidate);\n\t\t\t}\n\t\t}\n\t\tboolean hasIntroductions = !eligibleAdvisors.isEmpty();\n\t\tfor (Advisor candidate : candidateAdvisors) {\n\t\t\tif (candidate instanceof IntroductionAdvisor) {\n\t\t\t\t// already processed\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (canApply(candidate, clazz, hasIntroductions)) {\n\t\t\t\teligibleAdvisors.add(candidate);\n\t\t\t}\n\t\t}\n\t\treturn eligibleAdvisors;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#getMostSpecificMethod(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current AOP invocation, find the corresponding target method if there\n\t * is one. For example, the method may be {@code IFoo.bar()} and the target class\n\t * may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},\n\t * this method resolves bridge methods in order to retrieve attributes from\n\t * the <i>original</i> method definition.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see org.springframework.util.ClassUtils#getMostSpecificMethod\n\t * @see org.springframework.core.BridgeMethodResolver#getMostSpecificMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Method",
    "signature": "public Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> specificTargetClass = (targetClass != null ? ClassUtils.getUserClass(targetClass) : null);\n\t\treturn BridgeMethodResolver.getMostSpecificMethod(method, specificTargetClass);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#intersection(cf1,cf2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all classes that <i>both</i> of the given ClassFilters match.\n\t * @param cf1 the first ClassFilter\n\t * @param cf2 the second ClassFilter\n\t * @return a distinct ClassFilter that matches all classes that both\n\t * of the given ClassFilter match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf1",
      "cf2"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter intersection(ClassFilter cf1, ClassFilter cf2)",
    "source_code": "\tpublic static ClassFilter intersection(ClassFilter cf1, ClassFilter cf2) {\n\t\tAssert.notNull(cf1, \"First ClassFilter must not be null\");\n\t\tAssert.notNull(cf2, \"Second ClassFilter must not be null\");\n\t\treturn new IntersectionClassFilter(new ClassFilter[] {cf1, cf2});\n\t}"
  },
  "org.springframework.aop.support.<unknown>#intersection(mm1,mm2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>both</i> of the given MethodMatchers match.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that both\n\t * of the given MethodMatchers match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher intersection(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher intersection(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew IntersectionIntroductionAwareMethodMatcher(mm1, mm2) : new IntersectionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#invokeJoinpointUsingReflection(target,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given target via reflection, as part of an AOP method invocation.\n\t * @param target the target object\n\t * @param method the method to invoke\n\t * @param args the arguments for the method\n\t * @return the invocation result, if any\n\t * @throws Throwable if thrown by the target method\n\t * @throws org.springframework.aop.AopInvocationException in case of a reflection error\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "Object",
    "signature": "public Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)",
    "source_code": "\tpublic static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\n\t\t// Use reflection to invoke the method.\n\t\ttry {\n\t\t\tMethod originalMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\tReflectionUtils.makeAccessible(originalMethod);\n\t\t\treturn (coroutinesReactorPresent && KotlinDetector.isSuspendingFunction(originalMethod) ?\n\t\t\t\t\tKotlinDelegate.invokeSuspendingFunction(originalMethod, target, args) : originalMethod.invoke(target, args));\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Invoked method threw a checked exception.\n\t\t\t// We must rethrow it. The client won't see the interceptor.\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new AopInvocationException(\"AOP configuration seems to be invalid: tried calling method [\" +\n\t\t\t\t\tmethod + \"] on target [\" + target + \"]\", ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new AopInvocationException(\"Could not access method [\" + method + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.aop.support.<unknown>#invokeSuspendingFunction(method,target,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "Object",
    "signature": "public Object invokeSuspendingFunction(Method method, @Nullable Object target, Object... args)",
    "source_code": "\t\tpublic static Object invokeSuspendingFunction(Method method, @Nullable Object target, Object... args) {\n\t\t\tContinuation<?> continuation = (Continuation<?>) args[args.length -1];\n\t\t\tAssert.state(continuation != null, \"No Continuation available\");\n\t\t\tCoroutineContext context = continuation.getContext().minusKey(Job.Key);\n\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(context, method, target, args);\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#isMatch(methodName,mappedNamePattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the mapped name pattern.\n\t * <p>The default implementation checks for {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} matches, as well as direct equality.\n\t * <p>Can be overridden in subclasses.\n\t * @param methodName the method name to check\n\t * @param mappedNamePattern the method name pattern\n\t * @return {@code true} if the method name matches the pattern\n\t * @see PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedNamePattern)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedNamePattern) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedNamePattern, methodName);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#isMatch(methodName,methodNamePattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the method name pattern.\n\t * <p>This method is invoked by {@link #isMatch(String, int)}.\n\t * <p>The default implementation checks for direct equality as well as\n\t * {@code xxx*}, {@code *xxx}, {@code *xxx*}, and {@code xxx*yyy} matches.\n\t * <p>Can be overridden in subclasses &mdash; for example, to support a\n\t * different style of simple pattern matching.\n\t * @param methodName the method name to check\n\t * @param methodNamePattern the method name pattern\n\t * @return {@code true} if the method name matches the pattern\n\t * @since 6.1\n\t * @see #isMatch(String, int)\n\t * @see PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "methodNamePattern"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String methodNamePattern)",
    "source_code": "\tprotected boolean isMatch(String methodName, String methodNamePattern) {\n\t\treturn (methodName.equals(methodNamePattern) ||\n\t\t\t\tPatternMatchUtils.simpleMatch(methodNamePattern, methodName));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#isMatch(methodName,patternIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given method name matches the method name pattern at the\n\t * specified index.\n\t * <p>This method is invoked by {@link #matches(Method, Class, Object...)}.\n\t * <p>The default implementation retrieves the method name pattern from\n\t * {@link #methodNamePatterns} and delegates to {@link #isMatch(String, String)}.\n\t * <p>Can be overridden in subclasses &mdash; for example, to support\n\t * regular expressions.\n\t * @param methodName the method name to check\n\t * @param patternIndex the index of the method name pattern\n\t * @return {@code true} if the method name matches the pattern at the specified\n\t * index\n\t * @since 6.1\n\t * @see #methodNamePatterns\n\t * @see #isMatch(String, String)\n\t * @see #matches(Method, Class, Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, int patternIndex)",
    "source_code": "\tprotected boolean isMatch(String methodName, int patternIndex) {\n\t\tString methodNamePattern = this.methodNamePatterns.get(patternIndex);\n\t\treturn isMatch(methodName, methodNamePattern);\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\t\treturn !this.original.matches(method, targetClass);\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, Object... args)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, Object... args) {\n\t\t\treturn !this.original.matches(method, targetClass, args);\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(method,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\t\tpublic boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\t\treturn (MethodMatchers.matches(this.mm1, method, targetClass, hasIntroductions) &&\n\t\t\t\t\tMethodMatchers.matches(this.mm2, method, targetClass, hasIntroductions));\n\t\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(mm,method,targetClass,hasIntroductions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given MethodMatcher to the given Method, supporting an\n\t * {@link org.springframework.aop.IntroductionAwareMethodMatcher}\n\t * (if applicable).\n\t * @param mm the MethodMatcher to apply (may be an IntroductionAwareMethodMatcher)\n\t * @param method the candidate method\n\t * @param targetClass the target class\n\t * @param hasIntroductions {@code true} if the object on whose behalf we are\n\t * asking is the subject on one or more introductions; {@code false} otherwise\n\t * @return whether this method matches statically\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm",
      "method",
      "targetClass",
      "hasIntroductions"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "public boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions)",
    "source_code": "\tpublic static boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions) {\n\t\tAssert.notNull(mm, \"MethodMatcher must not be null\");\n\t\treturn (mm instanceof IntroductionAwareMethodMatcher iamm ?\n\t\t\t\tiamm.matches(method, targetClass, hasIntroductions) :\n\t\t\t\tmm.matches(method, targetClass));\n\t}"
  },
  "org.springframework.aop.support.<unknown>#matches(pattern,patternIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Does the pattern at the given index match the given String?\n\t * @param pattern the {@code String} pattern to match\n\t * @param patternIndex index of pattern (starting from 0)\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pattern",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "boolean",
    "signature": "protected boolean matches(String pattern, int patternIndex)",
    "source_code": "\tprotected abstract boolean matches(String pattern, int patternIndex);"
  },
  "org.springframework.aop.support.<unknown>#matchesExclusion(pattern,patternIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Does the exclusion pattern at the given index match the given String?\n\t * @param pattern the {@code String} pattern to match\n\t * @param patternIndex index of pattern (starting from 0)\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pattern",
      "patternIndex"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "boolean",
    "signature": "protected boolean matchesExclusion(String pattern, int patternIndex)",
    "source_code": "\tprotected abstract boolean matchesExclusion(String pattern, int patternIndex);"
  },
  "org.springframework.aop.support.<unknown>#selectInvocableMethod(method,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Select an invocable method on the target type: either the given method itself\n\t * if actually exposed on the target type, or otherwise a corresponding method\n\t * on one of the target type's interfaces or on the target type itself.\n\t * @param method the method to check\n\t * @param targetType the target type to search methods on (typically an AOP proxy)\n\t * @return a corresponding invocable method on the target type\n\t * @throws IllegalStateException if the given method is not invocable on the given\n\t * target type (typically due to a proxy mismatch)\n\t * @since 4.3\n\t * @see MethodIntrospector#selectInvocableMethod(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "Method",
    "signature": "public Method selectInvocableMethod(Method method, @Nullable Class<?> targetType)",
    "source_code": "\tpublic static Method selectInvocableMethod(Method method, @Nullable Class<?> targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn method;\n\t\t}\n\t\tMethod methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType);\n\t\tif (Modifier.isPrivate(methodToUse.getModifiers()) && !Modifier.isStatic(methodToUse.getModifiers()) &&\n\t\t\t\tSpringProxy.class.isAssignableFrom(targetType)) {\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"Need to invoke method '%s' found on proxy for target class '%s' but cannot \" +\n\t\t\t\t\t\"be delegated to target bean. Switch its visibility to package or protected.\",\n\t\t\t\t\tmethod.getName(), method.getDeclaringClass().getSimpleName()));\n\t\t}\n\t\treturn methodToUse;\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(cf1,cf2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all classes that <i>either</i> (or both) of the given ClassFilters matches.\n\t * @param cf1 the first ClassFilter\n\t * @param cf2 the second ClassFilter\n\t * @return a distinct ClassFilter that matches all classes that either\n\t * of the given ClassFilter matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf1",
      "cf2"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ClassFilter",
    "signature": "public ClassFilter union(ClassFilter cf1, ClassFilter cf2)",
    "source_code": "\tpublic static ClassFilter union(ClassFilter cf1, ClassFilter cf2) {\n\t\tAssert.notNull(cf1, \"First ClassFilter must not be null\");\n\t\tAssert.notNull(cf2, \"Second ClassFilter must not be null\");\n\t\treturn new UnionClassFilter(new ClassFilter[] {cf1, cf2});\n\t}"
  },
  "org.springframework.aop.support.<unknown>#union(mm1,mm2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match all methods that <i>either</i> (or both) of the given MethodMatchers matches.\n\t * @param mm1 the first MethodMatcher\n\t * @param mm2 the second MethodMatcher\n\t * @return a distinct MethodMatcher that matches all methods that either\n\t * of the given MethodMatchers matches\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mm1",
      "mm2"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "MethodMatcher",
    "signature": "public MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2)",
    "source_code": "\tpublic static MethodMatcher union(MethodMatcher mm1, MethodMatcher mm2) {\n\t\treturn (mm1 instanceof IntroductionAwareMethodMatcher || mm2 instanceof IntroductionAwareMethodMatcher ?\n\t\t\t\tnew UnionIntroductionAwareMethodMatcher(mm1, mm2) : new UnionMethodMatcher(mm1, mm2));\n\t}"
  },
  "org.springframework.aop.support.annotation.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\tif (matchesMethod(method)) {\n\t\t\treturn true;\n\t\t}\n\t\t// Proxy classes never have annotations on their redeclared methods.\n\t\tif (Proxy.isProxyClass(targetClass)) {\n\t\t\treturn false;\n\t\t}\n\t\t// The method may be on an interface, so let's check on the target class as well.\n\t\tMethod specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\t\treturn (specificMethod != method && matchesMethod(specificMethod));\n\t}"
  },
  "org.springframework.aop.target.<unknown>#forClass(targetClass,isStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an EmptyTargetSource for the given target Class.\n\t * @param targetClass the target Class (may be {@code null})\n\t * @param isStatic whether the TargetSource should be marked as static\n\t * @see #getTargetClass()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetClass",
      "isStatic"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "EmptyTargetSource",
    "signature": "public EmptyTargetSource forClass(@Nullable Class<?> targetClass, boolean isStatic)",
    "source_code": "\tpublic static EmptyTargetSource forClass(@Nullable Class<?> targetClass, boolean isStatic) {\n\t\treturn (targetClass == null && isStatic ? INSTANCE : new EmptyTargetSource(targetClass, isStatic));\n\t}"
  },
  "org.springframework.aot.agent.<unknown>#transform(classLoader,className,classBeingRedefined,protectionDomain,classfileBuffer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "className",
      "classBeingRedefined",
      "protectionDomain",
      "classfileBuffer"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "byte[]",
    "signature": "public byte[] transform(@Nullable ClassLoader classLoader, String className, Class<?> classBeingRedefined,\n\t\t\tProtectionDomain protectionDomain, byte[] classfileBuffer)",
    "source_code": "\tpublic byte[] transform(@Nullable ClassLoader classLoader, String className, Class<?> classBeingRedefined,\n\t\t\tProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\n\t\tif (isTransformationCandidate(classLoader, className)) {\n\t\t\treturn attemptClassTransformation(classfileBuffer);\n\t\t}\n\t\treturn classfileBuffer;\n\t}"
  },
  "org.springframework.aot.agent.<unknown>#visitInvokeDynamicInsn(name,descriptor,bootstrapMethodHandle,bootstrapMethodArguments)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor",
      "bootstrapMethodHandle",
      "bootstrapMethodArguments"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments)",
    "source_code": "\t\tpublic void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n\t\t\tfor (int i = 0; i < bootstrapMethodArguments.length; i++) {\n\t\t\t\tif (bootstrapMethodArguments[i] instanceof Handle argumentHandle) {\n\t\t\t\t\tif (shouldRecordMethodCall(argumentHandle.getOwner(), argumentHandle.getName())) {\n\t\t\t\t\t\tString instrumentedMethodName = rewriteMethodName(argumentHandle.getOwner(), argumentHandle.getName());\n\t\t\t\t\t\tString newDescriptor = rewriteDescriptor(argumentHandle.getTag(), argumentHandle.getOwner(), argumentHandle.getName(), argumentHandle.getDesc());\n\t\t\t\t\t\tbootstrapMethodArguments[i] = new Handle(H_INVOKESTATIC, INSTRUMENTED_CLASS, instrumentedMethodName, newDescriptor, false);\n\t\t\t\t\t\tisTransformed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n\t\t}"
  },
  "org.springframework.aot.agent.<unknown>#visitMethod(access,name,descriptor,signature,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "descriptor",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n\t\tMethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n\t\treturn new InvocationsRecorderMethodVisitor(mv);\n\t}"
  },
  "org.springframework.aot.agent.<unknown>#visitMethodInsn(opcode,owner,name,descriptor,isInterface)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "opcode",
      "owner",
      "name",
      "descriptor",
      "isInterface"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface)",
    "source_code": "\t\tpublic void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n\t\t\tif (isOpcodeSupported(opcode) && shouldRecordMethodCall(owner, name)) {\n\t\t\t\tString instrumentedMethodName = rewriteMethodName(owner, name);\n\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, INSTRUMENTED_CLASS, instrumentedMethodName,\n\t\t\t\t\t\trewriteDescriptor(opcode, owner, name, descriptor), false);\n\t\t\t\tisTransformed = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuper.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#addArguments(code,argumentCodeGenerator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the code for the method arguments using the specified\n\t * {@link ArgumentCodeGenerator} if necessary.\n\t * @param code the code builder to use to add method arguments\n\t * @param argumentCodeGenerator the code generator to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "argumentCodeGenerator"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "protected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator)",
    "source_code": "\tprotected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator) {\n\t\tList<CodeBlock> arguments = new ArrayList<>();\n\t\tTypeName[] argumentTypes = this.method.parameters.stream()\n\t\t\t\t.map(parameter -> parameter.type).toArray(TypeName[]::new);\n\t\tfor (int i = 0; i < argumentTypes.length; i++) {\n\t\t\tTypeName argumentType = argumentTypes[i];\n\t\t\tCodeBlock argumentCode = argumentCodeGenerator.generateCode(argumentType);\n\t\t\tif (argumentCode == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not generate code for \" + this\n\t\t\t\t\t\t+ \": parameter \" + i + \" of type \" + argumentType + \" is not supported\");\n\t\t\t}\n\t\t\targuments.add(argumentCode);\n\t\t}\n\t\tcode.add(CodeBlock.join(arguments, \", \"));\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#copy(content,override)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "content",
      "override"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void copy(InputStreamSource content, boolean override)",
    "source_code": "\t\tprotected void copy(InputStreamSource content, boolean override) {\n\t\t\tif (override) {\n\t\t\t\tcopy(content, StandardCopyOption.REPLACE_EXISTING);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcopy(content);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#generateCode(codeGenerator,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codeGenerator",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value)",
    "source_code": "\t\tpublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\n\t\t\tif (value.getClass().isArray()) {\n\t\t\t\tStream<CodeBlock> elements = Arrays.stream(ObjectUtils.toObjectArray(value))\n\t\t\t\t\t\t.map(codeGenerator::generateCode);\n\t\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\t\tcode.add(\"new $T {\", value.getClass());\n\t\t\t\tcode.add(elements.collect(CodeBlock.joining(\", \")));\n\t\t\t\tcode.add(\"}\");\n\t\t\t\treturn code.build();\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#generateCode(valueCodeGenerator,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueCodeGenerator",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value)",
    "source_code": "\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (value instanceof Map<?, ?> map) {\n\t\t\t\tif (map.isEmpty()) {\n\t\t\t\t\treturn EMPTY_RESULT;\n\t\t\t\t}\n\t\t\t\treturn generateMapCode(valueCodeGenerator, map);\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#generateCollectionCode(valueCodeGenerator,collection)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection)",
    "source_code": "\t\tprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection) {\n\t\t\tif (collection instanceof LinkedHashSet) {\n\t\t\t\treturn CodeBlock.of(\"new $T($L)\", LinkedHashSet.class,\n\t\t\t\t\t\tgenerateCollectionOf(valueCodeGenerator, collection, List.class));\n\t\t\t}\n\t\t\treturn super.generateCollectionCode(valueCodeGenerator,\n\t\t\t\t\torderForCodeConsistency(collection));\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#generateCollectionOf(valueCodeGenerator,collection,collectionType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "collection",
      "collectionType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator,\n\t\t\t\tCollection<?> collection, Class<?> collectionType)",
    "source_code": "\t\tprotected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator,\n\t\t\t\tCollection<?> collection, Class<?> collectionType) {\n\t\t\tBuilder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T.of(\", collectionType);\n\t\t\tIterator<?> iterator = collection.iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject element = iterator.next();\n\t\t\t\tcode.add(\"$L\", valueCodeGenerator.generateCode(element));\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#generateMapCode(valueCodeGenerator,Map<?,map)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Generate the code for a non-empty {@link Map}.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param map the value to generate\n\t\t * @return the code that represents the specified map or {@code null} if\n\t\t * the specified map is not supported.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map)",
    "source_code": "\t\tprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\n\t\t\tmap = orderForCodeConsistency(map);\n\t\t\tboolean useOfEntries = map.size() > 10;\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\n\t\t\tIterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tEntry<?, ?> entry = iterator.next();\n\t\t\t\tCodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\n\t\t\t\tCodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\n\t\t\t\tif (!useOfEntries) {\n\t\t\t\t\tcode.add(\"$L, $L\", keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcode.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tcode.add(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.add(\")\");\n\t\t\treturn code.build();\n\t\t}"
  },
  "org.springframework.aot.generate.<unknown>#handleFile(kind,path,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "kind",
      "path",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler)",
    "source_code": "\tpublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\n\t\tFileSystemFileHandler fileHandler = new FileSystemFileHandler(toPath(kind, path));\n\t\thandler.accept(fileHandler);\n\t}"
  },
  "org.springframework.aot.generate.<unknown>#toInvokeCodeBlock(argumentCodeGenerator,targetClassName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argumentCodeGenerator",
      "targetClassName"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator,\n\t\t\t@Nullable ClassName targetClassName)",
    "source_code": "\tpublic CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator,\n\t\t\t@Nullable ClassName targetClassName) {\n\n\t\tString methodName = this.method.name;\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tif (isStatic()) {\n\t\t\tAssert.state(this.declaringClass != null, \"Static method reference must define a declaring class\");\n\t\t\tif (this.declaringClass.equals(targetClassName)) {\n\t\t\t\tcode.add(\"$L\", methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode.add(\"$T.$L\", this.declaringClass, methodName);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.declaringClass != null && !this.declaringClass.equals(targetClassName)) {\n\t\t\t\tcode.add(instantiateDeclaringClass(this.declaringClass));\n\t\t\t}\n\t\t\tcode.add(\"$L\", methodName);\n\t\t}\n\t\tcode.add(\"(\");\n\t\taddArguments(code, argumentCodeGenerator);\n\t\tcode.add(\")\");\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerComponentHints(hints,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "void",
    "signature": "public void registerComponentHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\t\tpublic static void registerComponentHints(ReflectionHints hints, Class<?> type) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\n\t\t\tif (kClass.isData()) {\n\t\t\t\tfor (Method method : type.getMethods()) {\n\t\t\t\t\tString methodName = method.getName();\n\t\t\t\t\tif (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\n\t\t\t\t\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerPatternIfPresent(classLoader,location,resourceHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a pattern if the given {@code location} is available on the\n\t * classpath. This delegates to {@link ClassLoader#getResource(String)}\n\t * which validates directories as well. The location is not included in\n\t * the hint.\n\t * @param classLoader the classloader to use\n\t * @param location a '/'-separated path name that should exist\n\t * @param resourceHint a builder to customize the resource pattern\n\t * @return {@code this}, to facilitate method chaining\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "location",
      "resourceHint"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "ResourceHints",
    "signature": "public ResourceHints registerPatternIfPresent(@Nullable ClassLoader classLoader, String location,\n\t\t\tConsumer<ResourcePatternHints.Builder> resourceHint)",
    "source_code": "\tpublic ResourceHints registerPatternIfPresent(@Nullable ClassLoader classLoader, String location,\n\t\t\tConsumer<ResourcePatternHints.Builder> resourceHint) {\n\t\tClassLoader classLoaderToUse = (classLoader != null ? classLoader : getClass().getClassLoader());\n\t\tif (classLoaderToUse.getResource(location) != null) {\n\t\t\tregisterPattern(resourceHint);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerReflectionHints(hints,types)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the necessary reflection hints to bind the specified types.\n\t * @param hints the hints instance to use\n\t * @param types the types to register\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, Type... types)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, Type... types) {\n\t\tSet<Type> seen = new HashSet<>();\n\t\tfor (Type type : types) {\n\t\t\tregisterReflectionHints(hints, seen, type);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#registerResourceBundle(baseName,resourceHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register that the resource bundle with the specified base name should\n\t * be made available at runtime.\n\t * @param baseName the base name of the resource bundle\n\t * @param resourceHint a builder to further customize the resource bundle\n\t * @return {@code this}, to facilitate method chaining\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseName",
      "resourceHint"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ResourceHints",
    "signature": "public ResourceHints registerResourceBundle(String baseName, @Nullable Consumer<ResourceBundleHint.Builder> resourceHint)",
    "source_code": "\tpublic ResourceHints registerResourceBundle(String baseName, @Nullable Consumer<ResourceBundleHint.Builder> resourceHint) {\n\t\tResourceBundleHint.Builder builder = new ResourceBundleHint.Builder(baseName);\n\t\tif (resourceHint != null) {\n\t\t\tresourceHint.accept(builder);\n\t\t}\n\t\tthis.resourceBundleHints.add(builder.build());\n\t\treturn this;\n\t}"
  },
  "org.springframework.aot.hint.<unknown>#withConstructor(parameterTypes,mode)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Register the need for reflection on the constructor with the specified\n\t\t * parameter types, using the specified {@link ExecutableMode}.\n\t\t * @param parameterTypes the parameter types of the constructor\n\t\t * @param mode the requested mode\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Builder",
    "signature": "public Builder withConstructor(List<TypeReference> parameterTypes, ExecutableMode mode)",
    "source_code": "\t\tpublic Builder withConstructor(List<TypeReference> parameterTypes, ExecutableMode mode) {\n\t\t\treturn withConstructor(parameterTypes, ExecutableHint.builtWith(mode));\n\t\t}"
  },
  "org.springframework.aot.hint.<unknown>#withMethod(name,parameterTypes,mode)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Register the need for reflection on the method with the specified name\n\t\t * and parameter types, using the specified {@link ExecutableMode}.\n\t\t * @param name the name of the method\n\t\t * @param parameterTypes the parameter types of the constructor\n\t\t * @param mode the requested mode\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Builder",
    "signature": "public Builder withMethod(String name, List<TypeReference> parameterTypes, ExecutableMode mode)",
    "source_code": "\t\tpublic Builder withMethod(String name, List<TypeReference> parameterTypes, ExecutableMode mode) {\n\t\t\treturn withMethod(name, parameterTypes, ExecutableHint.builtWith(mode));\n\t\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#ReflectionRegistration(classes,memberCategories)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classes",
      "memberCategories"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "record",
    "signature": "protected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories)",
    "source_code": "\tprotected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories) {}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#parse(element,annotation)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "ReflectionRegistration",
    "signature": "protected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation)",
    "source_code": "\tprotected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\n\t\tList<Class<?>> allClassNames = new ArrayList<>();\n\t\tallClassNames.addAll(Arrays.asList(annotation.classes()));\n\t\tallClassNames.addAll(Arrays.stream(annotation.classNames())\n\t\t\t\t.map(this::loadClass).filter(Objects::nonNull).toList());\n\t\tif (allClassNames.isEmpty()) {\n\t\t\tif (element instanceof Class<?> clazz) {\n\t\t\t\tallClassNames.add(clazz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"At least one class must be specified, \"\n\t\t\t\t\t\t+ \"could not detect target from '\" + element + \"'\");\n\t\t\t}\n\t\t}\n\t\treturn new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]),\n\t\t\t\tannotation.memberCategories());\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerConstructorHint(hints,constructor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Constructor}.\n\t * @param hints the reflection hints instance to use\n\t * @param constructor the constructor to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "constructor"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void registerConstructorHint(ReflectionHints hints, Constructor<?> constructor)",
    "source_code": "\tprotected void registerConstructorHint(ReflectionHints hints, Constructor<?> constructor) {\n\t\thints.registerConstructor(constructor, ExecutableMode.INVOKE);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerFieldHint(hints,field)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Field}.\n\t * @param hints the reflection hints instance to use\n\t * @param field the field to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "protected void registerFieldHint(ReflectionHints hints, Field field)",
    "source_code": "\tprotected void registerFieldHint(ReflectionHints hints, Field field) {\n\t\thints.registerField(field);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerMethodHint(hints,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Method}.\n\t * @param hints the reflection hints instance to use\n\t * @param method the method to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "protected void registerMethodHint(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHint(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHint(hints, type);\n\t\t}\n\t\telse if (element instanceof Constructor<?> constructor) {\n\t\t\tregisterConstructorHint(hints, constructor);\n\t\t}\n\t\telse if (element instanceof Field field) {\n\t\t\tregisterFieldHint(hints, field);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHint(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerReflectionHints(hints,registration)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "registration"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration)",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\n\t\tfor (Class<?> target : registration.classes) {\n\t\t\tregisterReflectionHints(hints, target, registration.memberCategories);\n\t\t}\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerReflectionHints(hints,target,memberCategories)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "target",
      "memberCategories"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "protected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories)",
    "source_code": "\tprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\n\t\thints.registerType(target, type -> type.withMembers(memberCategories));\n\t}"
  },
  "org.springframework.aot.hint.annotation.<unknown>#registerTypeHint(hints,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register {@link ReflectionHints} against the specified {@link Class}.\n\t * @param hints the reflection hints instance to use\n\t * @param type the class to process\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void registerTypeHint(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHint(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.aot.hint.predicate.<unknown>#forResource(type,resourceName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a predicate that checks whether a resource hint is registered for the given\n\t * resource name, located in the given type's package.\n\t * <p>For example, {@code forResource(org.example.MyClass, \"myResource.txt\")}\n\t * will match against {@code \"org/example/myResource.txt\"}.\n\t * <p>If the given resource name is an absolute path (i.e., starts with a\n\t * leading slash), the supplied type will be ignored. For example,\n\t * {@code forResource(org.example.MyClass, \"/myResource.txt\")} will match against\n\t * {@code \"myResource.txt\"}.\n\t * @param type the type's package where to look for the resource\n\t * @param resourceName the resource name\n\t * @return the {@link RuntimeHints} predicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "resourceName"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Predicate<RuntimeHints>",
    "signature": "public Predicate<RuntimeHints> forResource(TypeReference type, String resourceName)",
    "source_code": "\tpublic Predicate<RuntimeHints> forResource(TypeReference type, String resourceName) {\n\t\tString absoluteName = resolveAbsoluteResourceName(type, resourceName);\n\t\treturn forResource(absoluteName);\n\t}"
  },
  "org.springframework.aot.hint.support.<unknown>#registerHints(hints,classLoader)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Register resource hints for the current state of this builder. For each\n\t\t * classpath location that resolves against the {@code ClassLoader}, files\n\t\t * with the configured file prefixes and extensions are registered.\n\t\t * @param hints the hints contributed so far for the deployment unit\n\t\t * @param classLoader the classloader, or {@code null} if even the system\n\t\t * ClassLoader isn't accessible\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "void",
    "signature": "public void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader)",
    "source_code": "\t\tpublic void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\n\t\t\tbuild().registerHints(hints, classLoader);\n\t\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(chars,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "chars",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "public void write(char[] chars, int offset, int length)",
    "source_code": "\t\tpublic void write(char[] chars, int offset, int length) {\n\t\t\ttry {\n\t\t\t\tif (this.prependIndent) {\n\t\t\t\t\tthis.out.write(this.currentIndent.toCharArray(), 0, this.currentIndent.length());\n\t\t\t\t\tthis.prependIndent = false;\n\t\t\t\t}\n\t\t\t\tthis.out.write(chars, offset, length);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.aot.nativex.<unknown>#write(writer,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "writer",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void write(BasicJsonWriter writer, ResourceHints hints)",
    "source_code": "\tpublic void write(BasicJsonWriter writer, ResourceHints hints) {\n\t\tMap<String, Object> attributes = new LinkedHashMap<>();\n\t\taddIfNotEmpty(attributes, \"resources\", toAttributes(hints));\n\t\thandleResourceBundles(attributes, hints.resourceBundleHints());\n\t\twriter.writeObject(attributes);\n\t}"
  },
  "org.springframework.aot.nativex.<unknown>#writeObject(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write an object with the specified attributes. Each attribute is\n\t * written according to its value type:\n\t * <ul>\n\t * <li>Map: write the value as a nested object</li>\n\t * <li>List: write the value as a nested array</li>\n\t * <li>Otherwise, write a single value</li>\n\t * </ul>\n\t * @param attributes the attributes of the object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void writeObject(Map<String, Object> attributes)",
    "source_code": "\tpublic void writeObject(Map<String, Object> attributes) {\n\t\twriteObject(attributes, true);\n\t}"
  },
  "org.springframework.beans.<unknown>#add(propertyName,propertyValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a PropertyValue object, replacing any existing one for the\n\t * corresponding property or getting merged with it (if applicable).\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue)",
    "source_code": "\tpublic MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValue(propertyName,propertyValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Overloaded version of {@code addPropertyValue} that takes\n\t * a property name and a property value.\n\t * <p>Note: we recommend using the more concise and chaining-capable variant\n\t * {@link #add(String, Object)}.\n\t * @param propertyName name of the property\n\t * @param propertyValue value of the property\n\t * @see #addPropertyValue(PropertyValue)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "propertyValue"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void addPropertyValue(String propertyName, Object propertyValue)",
    "source_code": "\tpublic void addPropertyValue(String propertyName, Object propertyValue) {\n\t\taddPropertyValue(new PropertyValue(propertyName, propertyValue));\n\t}"
  },
  "org.springframework.beans.<unknown>#addPropertyValues(Map<?,other)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add all property values from the given Map.\n\t * @param other a Map with property values keyed by property name,\n\t * which must be a String\n\t * @return this in order to allow for adding multiple property values in a chain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "other"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "MutablePropertyValues",
    "signature": "public MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other)",
    "source_code": "\tpublic MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other) {\n\t\tif (other != null) {\n\t\t\tother.forEach((attrName, attrValue) -> addPropertyValue(\n\t\t\t\t\tnew PropertyValue(attrName.toString(), attrValue)));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.<unknown>#compare(desc1,desc2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "int",
    "signature": "public int compare(PropertyDescriptor desc1, PropertyDescriptor desc2)",
    "source_code": "\t\tpublic int compare(PropertyDescriptor desc1, PropertyDescriptor desc2) {\n\t\t\treturn desc1.getName().compareTo(desc2.getName());\n\t\t}"
  },
  "org.springframework.beans.<unknown>#convertForProperty(propertyName,oldValue,newValue,td)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "td"
    ],
    "position": {
      "column": 1,
      "line": 605
    },
    "return": "Object",
    "signature": "protected Object convertForProperty(String propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)",
    "source_code": "\tprotected Object convertForProperty(\n\t\t\tString propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn convertIfNecessary(propertyName, oldValue, newValue, td.getType(), td);\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,\n\t\t\tObject newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {\n\n\t\treturn convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType));\n\t}"
  },
  "org.springframework.beans.<unknown>#convertIfNecessary(propertyName,oldValue,newValue,requiredType,typeDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the value to the required type (if necessary from a String),\n\t * for the specified property.\n\t * @param propertyName name of the property\n\t * @param oldValue the previous value, if available (may be {@code null})\n\t * @param newValue the proposed new value\n\t * @param requiredType the type we must convert to\n\t * (or {@code null} if not known, for example in case of a collection element)\n\t * @param typeDescriptor the descriptor for the target property or field\n\t * @return the new value, possibly the result of type conversion\n\t * @throws IllegalArgumentException if type conversion failed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "oldValue",
      "newValue",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx = null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n\t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx = ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue = newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType)) {\n\t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc != null) {\n\t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n\t\t\t\t\tif (convertedValue instanceof String text) {\n\t\t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray(text);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (editor == null && String.class != elementType) {\n\t\t\t\t\t\t\teditor = findDefaultEditor(elementType.arrayType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor == null) {\n\t\t\t\teditor = findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion = false;\n\n\t\tif (requiredType != null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue != null) {\n\t\t\t\tif (Object.class == requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String text &&\n\t\t\t\t\t\t\tEnum.class.isAssignableFrom(requiredType.componentType())) {\n\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray(text);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.componentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue.getClass().isArray()) {\n\t\t\t\t\tif (Collection.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\t\tconvertedValue = convertToTypedCollection(CollectionUtils.arrayToList(convertedValue),\n\t\t\t\t\t\t\t\tpropertyName, requiredType, typeDescriptor);\n\t\t\t\t\t\tstandardConversion = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (Array.getLength(convertedValue) == 1) {\n\t\t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n\t\t\t\t\t\tstandardConversion = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection<?> coll) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue = convertToTypedCollection(coll, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map<?, ?> map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue = convertToTypedMap(map, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String text && !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue = text.trim();\n\t\t\t\t\tif (requiredType.isEnum() && trimmedValue.isEmpty()) {\n\t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number num && Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(num, (Class<Number>) requiredType);\n\t\t\t\t\tstandardConversion = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue == null\n\t\t\t\tif (requiredType == Optional.class) {\n\t\t\t\t\tconvertedValue = Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx != null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService != null && typeDescriptor != null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn't produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append('\\'');\n\t\t\t\tif (propertyName != null) {\n\t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append('\\'');\n\t\t\t\t}\n\t\t\t\tif (editor != null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append('\\'');\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx != null) {\n\t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the target bean.\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects.\n\t * <p>The following table provides a non-exhaustive set of examples of source\n\t * and target property types that can be copied as well as source and target\n\t * property types that cannot be copied.\n\t * <table border=\"1\">\n\t * <tr><th>source property type</th><th>target property type</th><th>copy supported</th></tr>\n\t * <tr><td>{@code Integer}</td><td>{@code Integer}</td><td>yes</td></tr>\n\t * <tr><td>{@code Integer}</td><td>{@code Number}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<Integer>}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<?>}</td><td>{@code List<?>}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<?>}</td><td>yes</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<? extends Number>}</td><td>yes</td></tr>\n\t * <tr><td>{@code String}</td><td>{@code Integer}</td><td>no</td></tr>\n\t * <tr><td>{@code Number}</td><td>{@code Integer}</td><td>no</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<Long>}</td><td>no</td></tr>\n\t * <tr><td>{@code List<Integer>}</td><td>{@code List<Number>}</td><td>no</td></tr>\n\t * </table>\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target) throws BeansException {\n\t\tcopyProperties(source, target, null, (String[]) null);\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target,editable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the given target bean,\n\t * only setting properties defined in the given \"editable\" class (or interface).\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects. See the\n\t * documentation for {@link #copyProperties(Object, Object)} for details.\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @param editable the class (or interface) to restrict property setting to\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target",
      "editable"
    ],
    "position": {
      "column": 1,
      "line": 765
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target, Class<?> editable)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {\n\t\tcopyProperties(source, target, editable, (String[]) null);\n\t}"
  },
  "org.springframework.beans.<unknown>#copyProperties(source,target,ignoreProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the property values of the given source bean into the given target bean,\n\t * ignoring the given \"ignoreProperties\".\n\t * <p>Note: The source and target classes do not have to match or even be derived\n\t * from each other, as long as the properties match. Any bean properties that the\n\t * source bean exposes but the target bean does not will silently be ignored.\n\t * <p>This is just a convenience method. For more complex transfer needs,\n\t * consider using a full {@link BeanWrapper}.\n\t * <p>As of Spring Framework 5.3, this method honors generic type information\n\t * when matching properties in the source and target objects. See the\n\t * documentation for {@link #copyProperties(Object, Object)} for details.\n\t * @param source the source bean\n\t * @param target the target bean\n\t * @param ignoreProperties array of property names to ignore\n\t * @throws BeansException if the copying failed\n\t * @see BeanWrapper\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "target",
      "ignoreProperties"
    ],
    "position": {
      "column": 1,
      "line": 786
    },
    "return": "void",
    "signature": "public void copyProperties(Object source, Object target, String... ignoreProperties)",
    "source_code": "\tpublic static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {\n\t\tcopyProperties(source, target, null, ignoreProperties);\n\t}"
  },
  "org.springframework.beans.<unknown>#findDeclaredMethod(clazz,methodName,paramTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and the given parameter types,\n\t * declared on the given class or one of its superclasses. Will return a public,\n\t * protected, package access, or private method.\n\t * <p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @param paramTypes the parameter types of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @see Class#getDeclaredMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)",
    "source_code": "\tpublic static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\ttry {\n\t\t\treturn clazz.getDeclaredMethod(methodName, paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\treturn findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#findDeclaredMethodWithMinimalParameters(clazz,methodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none),\n\t * declared on the given class or one of its superclasses. Will return a public,\n\t * protected, package access, or private method.\n\t * <p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t * @see Class#getDeclaredMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName);\n\t\tif (targetMethod == null && clazz.getSuperclass() != null) {\n\t\t\ttargetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethod(clazz,methodName,paramTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and the given parameter types,\n\t * declared on the given class or one of its superclasses. Prefers public methods,\n\t * but will return a protected, package access, or private method too.\n\t * <p>Checks {@code Class.getMethod} first, falling back to\n\t * {@code findDeclaredMethod}. This allows to find public methods\n\t * without issues even in environments with restricted Java security settings.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @param paramTypes the parameter types of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @see Class#getMethod\n\t * @see #findDeclaredMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "Method",
    "signature": "public Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)",
    "source_code": "\tpublic static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\ttry {\n\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn findDeclaredMethod(clazz, methodName, paramTypes);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethodWithMinimalParameters(clazz,methodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none),\n\t * declared on the given class or one of its superclasses. Prefers public methods,\n\t * but will return a protected, package access, or private method too.\n\t * <p>Checks {@code Class.getMethods} first, falling back to\n\t * {@code findDeclaredMethodWithMinimalParameters}. This allows for finding public\n\t * methods without issues even in environments with restricted Java security settings.\n\t * @param clazz the class to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t * @see Class#getMethods\n\t * @see #findDeclaredMethodWithMinimalParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "Method",
    "signature": "public Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)",
    "source_code": "\tpublic static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName);\n\t\tif (targetMethod == null) {\n\t\t\ttargetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName);\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#findMethodWithMinimalParameters(methods,methodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a method with the given method name and minimal parameters (best case: none)\n\t * in the given list of methods.\n\t * @param methods the methods to check\n\t * @param methodName the name of the method to find\n\t * @return the Method object, or {@code null} if not found\n\t * @throws IllegalArgumentException if methods of the given name were found but\n\t * could not be resolved to a unique method with minimal parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methods",
      "methodName"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "Method",
    "signature": "public Method findMethodWithMinimalParameters(Method[] methods, String methodName)",
    "source_code": "\tpublic static Method findMethodWithMinimalParameters(Method[] methods, String methodName)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tMethod targetMethod = null;\n\t\tint numMethodsFoundWithCurrentMinimumArgs = 0;\n\t\tfor (Method method : methods) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\tint numParams = method.getParameterCount();\n\t\t\t\tif (targetMethod == null || numParams < targetMethod.getParameterCount()) {\n\t\t\t\t\ttargetMethod = method;\n\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs = 1;\n\t\t\t\t}\n\t\t\t\telse if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {\n\t\t\t\t\tif (targetMethod.isBridge()) {\n\t\t\t\t\t\t// Prefer regular method over bridge...\n\t\t\t\t\t\ttargetMethod = method;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Additional candidate with same length\n\t\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (numMethodsFoundWithCurrentMinimumArgs > 1) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot resolve method '\" + methodName +\n\t\t\t\t\t\"' to a unique method. Attempted to resolve to overloaded method with \" +\n\t\t\t\t\t\"the least number of parameters but there were \" +\n\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs + \" candidates.\");\n\t\t}\n\t\treturn targetMethod;\n\t}"
  },
  "org.springframework.beans.<unknown>#findPropertyForMethod(method,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a JavaBeans {@code PropertyDescriptor} for the given method,\n\t * with the method either being the read method or the write method for\n\t * that bean property.\n\t * @param method the method to find a corresponding PropertyDescriptor for\n\t * @param clazz the (most specific) class to introspect for descriptors\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t * @since 3.2.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "PropertyDescriptor",
    "signature": "public PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz)",
    "source_code": "\tpublic static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tPropertyDescriptor[] pds = getPropertyDescriptors(clazz);\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.<unknown>#getFinalPath(pa,nestedPath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the last component of the path. Also works if not nested.\n\t * @param pa property accessor to work on\n\t * @param nestedPath property path we know is nested\n\t * @return last component of the path (the property on the target bean)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "pa",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 813
    },
    "return": "String",
    "signature": "protected String getFinalPath(AbstractNestablePropertyAccessor pa, String nestedPath)",
    "source_code": "\tprotected String getFinalPath(AbstractNestablePropertyAccessor pa, String nestedPath) {\n\t\tif (pa == this) {\n\t\t\treturn nestedPath;\n\t\t}\n\t\treturn nestedPath.substring(PropertyAccessorUtils.getLastNestedPropertySeparatorIndex(nestedPath) + 1);\n\t}"
  },
  "org.springframework.beans.<unknown>#getPropertyDescriptor(clazz,propertyName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the JavaBeans {@code PropertyDescriptors} for the given property.\n\t * @param clazz the Class to retrieve the PropertyDescriptor for\n\t * @param propertyName the name of the property\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "PropertyDescriptor",
    "signature": "public PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)",
    "source_code": "\tpublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) throws BeansException {\n\t\treturn CachedIntrospectionResults.forClass(clazz).getPropertyDescriptor(propertyName);\n\t}"
  },
  "org.springframework.beans.<unknown>#instantiateClass(clazz,assignableTo)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate a class using its no-arg constructor and return the new instance\n\t * as the specified assignable type.\n\t * <p>Useful in cases where the type of the class to instantiate (clazz) is not\n\t * available, but the type desired (assignableTo) is known.\n\t * <p>Note that this method tries to set the constructor accessible if given a\n\t * non-accessible (that is, non-public) constructor.\n\t * @param clazz class to instantiate\n\t * @param assignableTo type that clazz must be assignableTo\n\t * @return the new instance\n\t * @throws BeanInstantiationException if the bean cannot be instantiated\n\t * @see Constructor#newInstance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "assignableTo"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "T",
    "signature": "public T instantiateClass(Class<?> clazz, Class<T> assignableTo)",
    "source_code": "\tpublic static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {\n\t\tAssert.isAssignable(assignableTo, clazz);\n\t\treturn (T) instantiateClass(clazz);\n\t}"
  },
  "org.springframework.beans.<unknown>#instantiateClass(ctor,args)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Instantiate a Kotlin class using the provided constructor.\n\t\t * @param ctor the constructor of the Kotlin class to instantiate\n\t\t * @param args the constructor arguments to apply\n\t\t * (use {@code null} for unspecified parameter if needed)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "T",
    "signature": "public T instantiateClass(Constructor<T> ctor, Object... args)",
    "source_code": "\t\tpublic static <T> T instantiateClass(Constructor<T> ctor, Object... args)\n\t\t\t\tthrows IllegalAccessException, InvocationTargetException, InstantiationException {\n\n\t\t\tKFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor);\n\t\t\tif (kotlinConstructor == null) {\n\t\t\t\treturn ctor.newInstance(args);\n\t\t\t}\n\n\t\t\tif ((!Modifier.isPublic(ctor.getModifiers()) || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers()))) {\n\t\t\t\tKCallablesJvm.setAccessible(kotlinConstructor, true);\n\t\t\t}\n\n\t\t\tList<KParameter> parameters = kotlinConstructor.getParameters();\n\n\t\t\tAssert.isTrue(args.length <= parameters.size(),\n\t\t\t\t\t\"Number of provided arguments must be less than or equal to the number of constructor parameters\");\n\t\t\tif (parameters.isEmpty()) {\n\t\t\t\treturn kotlinConstructor.call();\n\t\t\t}\n\t\t\tMap<KParameter, Object> argParameters = CollectionUtils.newHashMap(parameters.size());\n\t\t\tfor (int i = 0 ; i < args.length ; i++) {\n\t\t\t\tif (!(parameters.get(i).isOptional() && args[i] == null)) {\n\t\t\t\t\targParameters.put(parameters.get(i), args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn kotlinConstructor.callBy(argParameters);\n\t\t}"
  },
  "org.springframework.beans.<unknown>#matchesProperty(registeredPath,propertyPath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given registered path matches the given property path,\n\t * either indicating the property itself or an indexed element of the property.\n\t * @param propertyPath the property path (typically without index)\n\t * @param registeredPath the registered path (potentially with index)\n\t * @return whether the paths match\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredPath",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "boolean",
    "signature": "public boolean matchesProperty(String registeredPath, String propertyPath)",
    "source_code": "\tpublic static boolean matchesProperty(String registeredPath, String propertyPath) {\n\t\tif (!registeredPath.startsWith(propertyPath)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (registeredPath.length() == propertyPath.length()) {\n\t\t\treturn true;\n\t\t}\n\t\tif (registeredPath.charAt(propertyPath.length()) != PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (registeredPath.indexOf(PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR, propertyPath.length() + 1) ==\n\t\t\t\tregisteredPath.length() - 1);\n\t}"
  },
  "org.springframework.beans.<unknown>#newNestedPropertyAccessor(object,nestedPath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new nested property accessor instance.\n\t * Can be overridden in subclasses to create a PropertyAccessor subclass.\n\t * @param object the object wrapped by this PropertyAccessor\n\t * @param nestedPath the nested path of the object\n\t * @return the nested PropertyAccessor instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "nestedPath"
    ],
    "position": {
      "column": 1,
      "line": 760
    },
    "return": "AbstractNestablePropertyAccessor",
    "signature": "protected AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath)",
    "source_code": "\tprotected abstract AbstractNestablePropertyAccessor newNestedPropertyAccessor(Object object, String nestedPath);"
  },
  "org.springframework.beans.<unknown>#resolveSignature(signature,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a method signature in the form {@code methodName[([arg_list])]},\n\t * where {@code arg_list} is an optional, comma-separated list of fully-qualified\n\t * type names, and attempts to resolve that signature against the supplied {@code Class}.\n\t * <p>When not supplying an argument list ({@code methodName}) the method whose name\n\t * matches and has the least number of parameters will be returned. When supplying an\n\t * argument type list, only the method whose name and argument types match will be returned.\n\t * <p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>\n\t * resolved in the same way. The signature {@code methodName} means the method called\n\t * {@code methodName} with the least number of arguments, whereas {@code methodName()}\n\t * means the method called {@code methodName} with exactly 0 arguments.\n\t * <p>If no method can be found, then {@code null} is returned.\n\t * @param signature the method signature as String representation\n\t * @param clazz the class to resolve the method signature against\n\t * @return the resolved Method\n\t * @see #findMethod\n\t * @see #findMethodWithMinimalParameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "signature",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "Method",
    "signature": "public Method resolveSignature(String signature, Class<?> clazz)",
    "source_code": "\tpublic static Method resolveSignature(String signature, Class<?> clazz) {\n\t\tAssert.hasText(signature, \"'signature' must not be empty\");\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tint startParen = signature.indexOf('(');\n\t\tint endParen = signature.indexOf(')');\n\t\tif (startParen > -1 && endParen == -1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid method signature '\" + signature +\n\t\t\t\t\t\"': expected closing ')' for args list\");\n\t\t}\n\t\telse if (startParen == -1 && endParen > -1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid method signature '\" + signature +\n\t\t\t\t\t\"': expected opening '(' for args list\");\n\t\t}\n\t\telse if (startParen == -1) {\n\t\t\treturn findMethodWithMinimalParameters(clazz, signature);\n\t\t}\n\t\telse {\n\t\t\tString methodName = signature.substring(0, startParen);\n\t\t\tString[] parameterTypeNames =\n\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen));\n\t\t\tClass<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];\n\t\t\tfor (int i = 0; i < parameterTypeNames.length; i++) {\n\t\t\t\tString parameterTypeName = parameterTypeNames[i].trim();\n\t\t\t\ttry {\n\t\t\t\t\tparameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid method signature: unable to resolve type [\" +\n\t\t\t\t\t\t\tparameterTypeName + \"] for argument \" + i + \". Root cause: \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn findMethod(clazz, methodName, parameterTypes);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValue(propertyName,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually set a property value.\n\t * @param propertyName name of the property to set value of\n\t * @param value the new value\n\t * @throws InvalidPropertyException if there is no such property or\n\t * if the property isn't writable\n\t * @throws PropertyAccessException if the property was valid but the\n\t * accessor method failed or a type mismatch occurred\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void setPropertyValue(String propertyName, @Nullable Object value)",
    "source_code": "\tpublic abstract void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException;"
  },
  "org.springframework.beans.<unknown>#setPropertyValue(tokens,pv)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tokens",
      "pv"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv)",
    "source_code": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tif (tokens.keys != null) {\n\t\t\tprocessKeyedProperty(tokens, pv);\n\t\t}\n\t\telse {\n\t\t\tprocessLocalProperty(tokens, pv);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValueAt(pv,i)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Modify a PropertyValue object held in this object.\n\t * Indexed from 0.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pv",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "void",
    "signature": "public void setPropertyValueAt(PropertyValue pv, int i)",
    "source_code": "\tpublic void setPropertyValueAt(PropertyValue pv, int i) {\n\t\tthis.propertyValueList.set(i, pv);\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(Map<?,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void setPropertyValues(Map<?, ?> map)",
    "source_code": "\tpublic void setPropertyValues(Map<?, ?> map) throws BeansException {\n\t\tsetPropertyValues(new MutablePropertyValues(map));\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(pvs,ignoreUnknown)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "ignoreUnknown"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown)",
    "source_code": "\tpublic void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown) throws BeansException {\n\t\tsetPropertyValues(pvs, ignoreUnknown, false);\n\t}"
  },
  "org.springframework.beans.<unknown>#setPropertyValues(pvs,ignoreUnknown,ignoreInvalid)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "ignoreUnknown",
      "ignoreInvalid"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)",
    "source_code": "\tpublic void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)\n\t\t\tthrows BeansException {\n\n\t\tList<PropertyAccessException> propertyAccessExceptions = null;\n\t\tList<PropertyValue> propertyValues = (pvs instanceof MutablePropertyValues mpvs ?\n\t\t\t\tmpvs.getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));\n\n\t\tif (ignoreUnknown) {\n\t\t\tthis.suppressNotWritablePropertyException = true;\n\t\t}\n\t\ttry {\n\t\t\tfor (PropertyValue pv : propertyValues) {\n\t\t\t\t// setPropertyValue may throw any BeansException, which won't be caught\n\t\t\t\t// here, if there is a critical failure such as no matching field.\n\t\t\t\t// We can attempt to deal only with less serious exceptions.\n\t\t\t\ttry {\n\t\t\t\t\tsetPropertyValue(pv);\n\t\t\t\t}\n\t\t\t\tcatch (NotWritablePropertyException ex) {\n\t\t\t\t\tif (!ignoreUnknown) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, just ignore it and continue...\n\t\t\t\t}\n\t\t\t\tcatch (NullValueInNestedPathException ex) {\n\t\t\t\t\tif (!ignoreInvalid) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, just ignore it and continue...\n\t\t\t\t}\n\t\t\t\tcatch (PropertyAccessException ex) {\n\t\t\t\t\tif (propertyAccessExceptions == null) {\n\t\t\t\t\t\tpropertyAccessExceptions = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tpropertyAccessExceptions.add(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (ignoreUnknown) {\n\t\t\t\tthis.suppressNotWritablePropertyException = false;\n\t\t\t}\n\t\t}\n\n\t\t// If we encountered individual exceptions, throw the composite exception.\n\t\tif (propertyAccessExceptions != null) {\n\t\t\tPropertyAccessException[] paeArray = propertyAccessExceptions.toArray(new PropertyAccessException[0]);\n\t\t\tthrow new PropertyBatchUpdateException(paeArray);\n\t\t}\n\t}"
  },
  "org.springframework.beans.<unknown>#setWrappedInstance(object,nestedPath,rootObject)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Switch the target object, replacing the cached introspection results only\n\t * if the class of the new object is different to that of the replaced object.\n\t * @param object the new target object\n\t * @param nestedPath the nested path of the object\n\t * @param rootObject the root object at the top of the path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "nestedPath",
      "rootObject"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject)",
    "source_code": "\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tthis.wrappedObject = ObjectUtils.unwrapOptional(object);\n\t\tAssert.notNull(this.wrappedObject, \"Target object must not be null\");\n\t\tthis.nestedPath = (nestedPath != null ? nestedPath : \"\");\n\t\tthis.rootObject = (!this.nestedPath.isEmpty() ? rootObject : this.wrappedObject);\n\t\tthis.nestedPropertyAccessors = null;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForAnnotationIncludingAncestors(lbf,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names whose {@code Class} has the supplied {@link Annotation}\n\t * type, including those defined in ancestor factories, without creating any bean\n\t * instances yet. Will return unique names in case of overridden bean definitions.\n\t * @param lbf the bean factory\n\t * @param annotationType the type of annotation to look for\n\t * @return the array of matching bean names, or an empty array if none\n\t * @since 5.0\n\t * @see ListableBeanFactory#getBeanNamesForAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForAnnotationIncludingAncestors(ListableBeanFactory lbf, Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static String[] beanNamesForAnnotationIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<? extends Annotation> annotationType) {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForAnnotation(annotationType);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForAnnotationIncludingAncestors(pbf, annotationType);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForTypeIncludingAncestors(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names for the given type, including those defined in ancestor\n\t * factories. Will return unique names in case of overridden bean definitions.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanNamesForTypeIncludingAncestors} automatically\n\t * includes prototypes and FactoryBeans.\n\t * @param lbf the bean factory\n\t * @param type the type that beans must match (as a {@code Class})\n\t * @return the array of matching bean names, or an empty array if none\n\t * @see ListableBeanFactory#getBeanNamesForType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type)",
    "source_code": "\tpublic static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForType(type);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForTypeIncludingAncestors(pbf, type);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanNamesForTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all bean names for the given type, including those defined in ancestor\n\t * factories. Will return unique names in case of overridden bean definitions.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @param type the type that beans must match\n\t * @return the array of matching bean names, or an empty array if none\n\t * @see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "String[]",
    "signature": "public String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static String[] beanNamesForTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tString[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tString[] parentResult = beanNamesForTypeIncludingAncestors(\n\t\t\t\t\t\tpbf, type, includeNonSingletons, allowEagerInit);\n\t\t\t\tresult = mergeNamesWithParent(result, parentResult, hbf);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanOfType} automatically includes\n\t * prototypes and FactoryBeans.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 467
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfType(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, not looking in ancestor\n\t * factories. Useful convenience method when we expect a single bean and\n\t * don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\"\n\t * flag is set, which means that FactoryBeans will get initialized. If the\n\t * object created by the FactoryBean doesn't match, the raw FactoryBean itself\n\t * will be matched against the type. If \"allowEagerInit\" is not set,\n\t * only raw FactoryBeans will be checked (which doesn't require initialization\n\t * of each FactoryBean).\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "T",
    "signature": "public T beanOfType(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfType(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfTypeIncludingAncestors(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, also picking up beans\n\t * defined in ancestor bean factories if the current bean factory is a\n\t * HierarchicalBeanFactory. Useful convenience method when we expect a\n\t * single bean and don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p>This version of {@code beanOfTypeIncludingAncestors} automatically includes\n\t * prototypes and FactoryBeans.\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "T",
    "signature": "public T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beanOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a single bean of the given type or subtypes, also picking up beans\n\t * defined in ancestor bean factories if the current bean factory is a\n\t * HierarchicalBeanFactory. Useful convenience method when we expect a\n\t * single bean and don't care about the bean name.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the matching bean instance\n\t * @throws NoSuchBeanDefinitionException if no bean of the given type was found\n\t * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found\n\t * @throws BeansException if the bean could not be created\n\t * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "T",
    "signature": "public T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> T beanOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tMap<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit);\n\t\treturn uniqueBean(type, beansOfType);\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans\n\t * will get initialized. If the object created by the FactoryBean doesn't match,\n\t * the raw FactoryBean itself will be matched against the type.\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.<unknown>#beansOfTypeIncludingAncestors(lbf,type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return all beans of the given type or subtypes, also picking up beans defined in\n\t * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.\n\t * The returned Map will only contain beans of this type.\n\t * <p>Does consider objects created by FactoryBeans if the \"allowEagerInit\" flag is set,\n\t * which means that FactoryBeans will get initialized. If the object created by the\n\t * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the\n\t * type. If \"allowEagerInit\" is not set, only raw FactoryBeans will be checked\n\t * (which doesn't require initialization of each FactoryBean).\n\t * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,\n\t * i.e. such beans will be returned from the lowest factory that they are being found in,\n\t * hiding corresponding beans in ancestor factories.</b> This feature allows for\n\t * 'replacing' beans by explicitly choosing the same bean name in a child factory;\n\t * the bean in the ancestor factory won't be visible then, not even for by-type lookups.\n\t * @param lbf the bean factory\n\t * @param type type of bean to match\n\t * @param includeNonSingletons whether to include prototype or scoped beans too\n\t * or just singletons (also applies to FactoryBeans)\n\t * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and\n\t * <i>objects created by FactoryBeans</i> (or by factory methods with a\n\t * \"factory-bean\" reference) for the type check. Note that FactoryBeans need to be\n\t * eagerly initialized to determine their type: So be aware that passing in \"true\"\n\t * for this flag will initialize FactoryBeans and \"factory-bean\" references.\n\t * @return the Map of matching bean instances, or an empty Map if none\n\t * @throws BeansException if a bean could not be created\n\t * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lbf",
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "T>",
    "signature": "public T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic static <T> Map<String, T> beansOfTypeIncludingAncestors(\n\t\t\tListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(lbf, \"ListableBeanFactory must not be null\");\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tresult.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit));\n\t\tif (lbf instanceof HierarchicalBeanFactory hbf) {\n\t\t\tif (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {\n\t\t\t\tMap<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type, includeNonSingletons, allowEagerInit);\n\t\t\t\tparentResult.forEach((beanName, beanInstance) -> {\n\t\t\t\t\tif (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {\n\t\t\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 975
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"Autowiring\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Autowiring for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generateMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply the autowiring.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tCodeWarnings codeWarnings = new CodeWarnings();\n\t\t\t\tcodeWarnings.detectDeprecation(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(codeWarnings,\n\t\t\t\t\t\tgeneratedClass.getName(), generationContext.getRuntimeHints()));\n\t\t\t\tcodeWarnings.suppress(method);\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generateMethod.toMethodReference());\n\n\t\t\tif (this.candidateResolver != null) {\n\t\t\t\tregisterHints(generationContext.getRuntimeHints());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifier(bdHolder,annotation,typeConverter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotation against the candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotation",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "boolean",
    "signature": "protected boolean checkQualifier(BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter)",
    "source_code": "\tprotected boolean checkQualifier(\n\t\t\tBeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter) {\n\n\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\tRootBeanDefinition bd = (RootBeanDefinition) bdHolder.getBeanDefinition();\n\n\t\tAutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());\n\t\tif (qualifier == null) {\n\t\t\tqualifier = bd.getQualifier(ClassUtils.getShortName(type));\n\t\t}\n\t\tif (qualifier == null) {\n\t\t\t// First, check annotation on qualified element, if any\n\t\t\tAnnotation targetAnnotation = getQualifiedElementAnnotation(bd, type);\n\t\t\t// Then, check annotation on factory method, if applicable\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(bd, type);\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);\n\t\t\t\tif (dbd != null) {\n\t\t\t\t\ttargetAnnotation = getFactoryMethodAnnotation(dbd, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation == null) {\n\t\t\t\tBeanFactory beanFactory = getBeanFactory();\n\t\t\t\t// Look for matching annotation on the target class\n\t\t\t\tif (beanFactory != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> beanType = beanFactory.getType(bdHolder.getBeanName());\n\t\t\t\t\t\tif (beanType != null) {\n\t\t\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t// Not the usual case - simply forget about the type check...\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (targetAnnotation == null && bd.hasBeanClass()) {\n\t\t\t\t\ttargetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targetAnnotation != null && targetAnnotation.equals(annotation)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);\n\t\tif (attributes.isEmpty() && qualifier == null) {\n\t\t\t// If no attributes, the qualifier must be present\n\t\t\treturn false;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t\t\tString attributeName = entry.getKey();\n\t\t\tObject expectedValue = entry.getValue();\n\t\t\tObject actualValue = null;\n\t\t\t// Check qualifier first\n\t\t\tif (qualifier != null) {\n\t\t\t\tactualValue = qualifier.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null) {\n\t\t\t\t// Fall back on bean definition attribute\n\t\t\t\tactualValue = bd.getAttribute(attributeName);\n\t\t\t}\n\t\t\tif (actualValue == null && attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &&\n\t\t\t\t\texpectedValue instanceof String name && bdHolder.matchesName(name)) {\n\t\t\t\t// Finally, check bean name (or alias) match\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (actualValue == null && qualifier != null) {\n\t\t\t\t// Fall back on default, but only if the qualifier is present\n\t\t\t\tactualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);\n\t\t\t}\n\t\t\tif (actualValue != null) {\n\t\t\t\tactualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());\n\t\t\t}\n\t\t\tif (!ObjectUtils.nullSafeEquals(expectedValue, actualValue)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#checkQualifiers(bdHolder,annotationsToSearch)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given qualifier annotations against the candidate bean definition.\n\t * @return {@code false} if a qualifier has been found but not matched,\n\t * {@code true} if a qualifier has been found and matched,\n\t * {@code null} if no qualifier has been found at all\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "annotationsToSearch"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Boolean",
    "signature": "protected Boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)",
    "source_code": "\tprotected Boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {\n\t\tboolean qualifierFound = false;\n\t\tif (!ObjectUtils.isEmpty(annotationsToSearch)) {\n\t\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\t\tfor (Annotation annotation : annotationsToSearch) {\n\t\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\t\tif (isPlainJavaAnnotation(type)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean checkMeta = true;\n\t\t\t\tboolean fallbackToMeta = false;\n\t\t\t\tif (isQualifier(type)) {\n\t\t\t\t\tqualifierFound = true;\n\t\t\t\t\tif (!checkQualifier(bdHolder, annotation, typeConverter)) {\n\t\t\t\t\t\tfallbackToMeta = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcheckMeta = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (checkMeta) {\n\t\t\t\t\tboolean foundMeta = false;\n\t\t\t\t\tfor (Annotation metaAnn : type.getAnnotations()) {\n\t\t\t\t\t\tClass<? extends Annotation> metaType = metaAnn.annotationType();\n\t\t\t\t\t\tif (isPlainJavaAnnotation(metaType)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isQualifier(metaType)) {\n\t\t\t\t\t\t\tqualifierFound = true;\n\t\t\t\t\t\t\tfoundMeta = true;\n\t\t\t\t\t\t\t// Only accept fallback match if @Qualifier annotation has a value...\n\t\t\t\t\t\t\t// Otherwise, it is just a marker for a custom qualifier annotation.\n\t\t\t\t\t\t\tif ((fallbackToMeta && ObjectUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||\n\t\t\t\t\t\t\t\t\t!checkQualifier(bdHolder, metaAnn, typeConverter)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fallbackToMeta && !foundMeta) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (qualifierFound ? true : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#forElements(elements,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@code InjectionMetadata} instance, possibly for empty elements.\n\t * @param elements the elements to inject (possibly empty)\n\t * @param clazz the target class\n\t * @return a new {@link #InjectionMetadata(Class, Collection)} instance\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elements",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "InjectionMetadata",
    "signature": "public InjectionMetadata forElements(Collection<InjectedElement> elements, Class<?> clazz)",
    "source_code": "\tpublic static InjectionMetadata forElements(Collection<InjectedElement> elements, Class<?> clazz) {\n\t\treturn (elements.isEmpty() ? new InjectionMetadata(clazz, Collections.emptyList()) :\n\t\t\t\tnew InjectionMetadata(clazz, elements));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getFactoryMethodAnnotation(bd,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 346
    },
    "return": "Annotation",
    "signature": "protected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getFactoryMethodAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tMethod resolvedFactoryMethod = bd.getResolvedFactoryMethod();\n\t\treturn (resolvedFactoryMethod != null ? AnnotationUtils.getAnnotation(resolvedFactoryMethod, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getQualifiedElementAnnotation(bd,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "Annotation",
    "signature": "protected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type)",
    "source_code": "\tprotected Annotation getQualifiedElementAnnotation(RootBeanDefinition bd, Class<? extends Annotation> type) {\n\t\tAnnotatedElement qualifiedElement = bd.getQualifiedElement();\n\t\treturn (qualifiedElement != null ? AnnotationUtils.getAnnotation(qualifiedElement, type) : null);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Either this or {@link #inject} needs to be overridden.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(bean,beanName,pvs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "void",
    "signature": "protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\t\tprotected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\t\tif (!shouldInject(pvs)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMethod method = (Method) this.member;\n\t\t\tObject[] arguments;\n\t\t\tif (this.cached) {\n\t\t\t\ttry {\n\t\t\t\t\targuments = resolveCachedArguments(beanName, this.cachedMethodArguments);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t// Unexpected target bean mismatch for cached argument -> re-resolve\n\t\t\t\t\tthis.cached = false;\n\t\t\t\t\tlogger.debug(\"Failed to resolve cached argument\", ex);\n\t\t\t\t\targuments = resolveMethodArguments(method, bean, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\targuments = resolveMethodArguments(method, bean, beanName);\n\t\t\t}\n\t\t\tif (arguments != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(bean, arguments);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,beanName,pvs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)",
    "source_code": "\tpublic void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n\t\tCollection<InjectedElement> checkedElements = this.checkedElements;\n\t\tCollection<InjectedElement> elementsToIterate =\n\t\t\t\t(checkedElements != null ? checkedElements : this.injectedElements);\n\t\tif (!elementsToIterate.isEmpty()) {\n\t\t\tfor (InjectedElement element : elementsToIterate) {\n\t\t\t\telement.inject(target, beanName, pvs);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#inject(target,requestingBeanName,pvs)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Either this or {@link #getResourceToInject} needs to be overridden.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)",
    "source_code": "\t\tprotected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)\n\t\t\t\tthrows Throwable {\n\n\t\t\tif (!shouldInject(pvs)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isField) {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tfield.set(target, getResourceToInject(target, requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = (Method) this.member;\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(target, getResourceToInject(target, requestingBeanName));\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#invokeDestroyMethods(target,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "void",
    "signature": "public void invokeDestroyMethods(Object target, String beanName)",
    "source_code": "\t\tpublic void invokeDestroyMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleMethod> checkedDestroyMethods = this.checkedDestroyMethods;\n\t\t\tCollection<LifecycleMethod> destroyMethodsToUse =\n\t\t\t\t\t(checkedDestroyMethods != null ? checkedDestroyMethods : this.destroyMethods);\n\t\t\tif (!destroyMethodsToUse.isEmpty()) {\n\t\t\t\tfor (LifecycleMethod lifecycleMethod : destroyMethodsToUse) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking destroy method on bean '\" + beanName + \"': \" + lifecycleMethod.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\tlifecycleMethod.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#invokeInitMethods(target,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "void",
    "signature": "public void invokeInitMethods(Object target, String beanName)",
    "source_code": "\t\tpublic void invokeInitMethods(Object target, String beanName) throws Throwable {\n\t\t\tCollection<LifecycleMethod> checkedInitMethods = this.checkedInitMethods;\n\t\t\tCollection<LifecycleMethod> initMethodsToIterate =\n\t\t\t\t\t(checkedInitMethods != null ? checkedInitMethods : this.initMethods);\n\t\t\tif (!initMethodsToIterate.isEmpty()) {\n\t\t\t\tfor (LifecycleMethod lifecycleMethod : initMethodsToIterate) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Invoking init method on bean '\" + beanName + \"': \" + lifecycleMethod.getMethod());\n\t\t\t\t\t}\n\t\t\t\t\tlifecycleMethod.invoke(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the provided bean definition is an autowire candidate.\n\t * <p>To be considered a candidate the bean's <em>autowire-candidate</em>\n\t * attribute must not have been set to 'false'. Also, if an annotation on\n\t * the field or parameter to be autowired is recognized by this bean factory\n\t * as a <em>qualifier</em>, the bean must 'match' against the annotation as\n\t * well as any attributes it may contain. The bean definition must contain\n\t * the same qualifier or match by meta attributes. A \"value\" attribute will\n\t * fall back to match against the bean name or an alias if a qualifier or\n\t * attribute does not match.\n\t * @see Qualifier\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tif (!super.isAutowireCandidate(bdHolder, descriptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tBoolean checked = checkQualifiers(bdHolder, descriptor.getAnnotations());\n\t\tif (checked != Boolean.FALSE) {\n\t\t\tMethodParameter methodParam = descriptor.getMethodParameter();\n\t\t\tif (methodParam != null) {\n\t\t\t\tMethod method = methodParam.getMethod();\n\t\t\t\tif (method == null || void.class == method.getReturnType()) {\n\t\t\t\t\tBoolean methodChecked = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());\n\t\t\t\t\tif (methodChecked != null && checked == null) {\n\t\t\t\t\t\tchecked = methodChecked;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (checked == Boolean.TRUE ||\n\t\t\t\t(checked == null && ((RootBeanDefinition) bdHolder.getBeanDefinition()).isDefaultCandidate()));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#isQualifierMatch(qualifier,beanName,beanFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the named bean declares a qualifier of the given name.\n\t * @param qualifier the qualifier to match\n\t * @param beanName the name of the candidate bean\n\t * @param beanFactory the factory from which to retrieve the named bean\n\t * @return {@code true} if either the bean definition (in the XML case)\n\t * or the bean's factory method (in the {@code @Bean} case) defines a matching\n\t * qualifier value (through {@code <qualifier>} or {@code @Qualifier})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifier",
      "beanName",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "boolean",
    "signature": "public boolean isQualifierMatch(Predicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory)",
    "source_code": "\tpublic static boolean isQualifierMatch(\n\t\t\tPredicate<String> qualifier, String beanName, @Nullable BeanFactory beanFactory) {\n\n\t\t// Try quick bean name or alias match first...\n\t\tif (qualifier.test(beanName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (beanFactory != null) {\n\t\t\tfor (String alias : beanFactory.getAliases(beanName)) {\n\t\t\t\tif (qualifier.test(alias)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tClass<?> beanType = beanFactory.getType(beanName);\n\t\t\t\tif (beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\t\t\tBeanDefinition bd = cbf.getMergedBeanDefinition(beanName);\n\t\t\t\t\t// Explicit qualifier metadata on bean definition? (typically in XML definition)\n\t\t\t\t\tif (bd instanceof AbstractBeanDefinition abd) {\n\t\t\t\t\t\tAutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName());\n\t\t\t\t\t\tif (candidate != null) {\n\t\t\t\t\t\t\tObject value = candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY);\n\t\t\t\t\t\t\tif (value != null && qualifier.test(value.toString())) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Corresponding qualifier on factory method? (typically in configuration class)\n\t\t\t\t\tif (bd instanceof RootBeanDefinition rbd) {\n\t\t\t\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\t\t\t\tif (factoryMethod != null) {\n\t\t\t\t\t\t\tQualifier targetAnnotation = AnnotationUtils.getAnnotation(factoryMethod, Qualifier.class);\n\t\t\t\t\t\t\tif (targetAnnotation != null) {\n\t\t\t\t\t\t\t\treturn qualifier.test(targetAnnotation.value());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Corresponding qualifier on bean implementation class? (for custom user types)\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\tQualifier targetAnnotation = AnnotationUtils.getAnnotation(beanType, Qualifier.class);\n\t\t\t\t\tif (targetAnnotation != null) {\n\t\t\t\t\t\treturn qualifier.test(targetAnnotation.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore - can't compare qualifiers for a manually registered singleton object\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#needsRefresh(metadata,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given injection metadata needs to be refreshed.\n\t * @param metadata the existing metadata instance\n\t * @param clazz the current target class\n\t * @return {@code true} indicating a refresh, {@code false} otherwise\n\t * @see #needsRefresh(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "boolean",
    "signature": "public boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz)",
    "source_code": "\tpublic static boolean needsRefresh(@Nullable InjectionMetadata metadata, Class<?> clazz) {\n\t\treturn (metadata == null || metadata.needsRefresh(clazz));\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\t\ttry {\n\t\t\tmetadata.invokeDestroyMethods(bean, beanName);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tString msg = \"Destroy method on bean with name '\" + beanName + \"' threw an exception\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, ex.getTargetException());\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(msg + \": \" + ex.getTargetException());\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to invoke destroy method on bean with name '\" + beanName + \"'\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 216
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tLifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n\t\ttry {\n\t\t\tmetadata.invokeInitMethods(bean, beanName);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Invocation of init method failed\", ex.getTargetException());\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Failed to invoke init method\", ex);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanClass, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanClass, String beanName) {\n\t\tfindLifecycleMetadata(beanDefinition, beanClass);\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\t// Register externally managed config members on bean definition.\n\t\tfindInjectionMetadata(beanName, beanType, beanDefinition);\n\n\t\t// Use opportunity to clear caches which are not needed after singleton instantiation.\n\t\t// The injectionMetadataCache itself is left intact since it cannot be reliably\n\t\t// reconstructed in terms of externally managed config members otherwise.\n\t\tif (beanDefinition.isSingleton()) {\n\t\t\tthis.candidateConstructorsCache.remove(beanType);\n\t\t\t// With actual lookup overrides, keep it intact along with bean definition.\n\t\t\tif (!beanDefinition.hasMethodOverrides()) {\n\t\t\t\tthis.lookupMethodsChecked.remove(beanName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#qualifiedBeanOfType(beanFactory,beanType,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a\n\t * qualifier (for example, via {@code <qualifier>} or {@code @Qualifier}) matching the given\n\t * qualifier, or having a bean name matching the given qualifier.\n\t * @param beanFactory the factory to get the target bean from (also searching ancestors)\n\t * @param beanType the type of bean to retrieve\n\t * @param qualifier the qualifier for selecting between multiple bean matches\n\t * @return the matching bean of type {@code T} (never {@code null})\n\t * @throws NoUniqueBeanDefinitionException if multiple matching beans of type {@code T} found\n\t * @throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found\n\t * @throws BeansException if the bean could not be created\n\t * @see BeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanType",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "T",
    "signature": "public T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)",
    "source_code": "\tpublic static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)\n\t\t\tthrows BeansException {\n\n\t\tAssert.notNull(beanFactory, \"BeanFactory must not be null\");\n\n\t\tif (beanFactory instanceof ListableBeanFactory lbf) {\n\t\t\t// Full qualifier matching supported.\n\t\t\treturn qualifiedBeanOfType(lbf, beanType, qualifier);\n\t\t}\n\t\telse if (beanFactory.containsBean(qualifier)) {\n\t\t\t// Fallback: target bean at least found by bean name.\n\t\t\treturn beanFactory.getBean(qualifier, beanType);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchBeanDefinitionException(qualifier, \"No matching \" + beanType.getSimpleName() +\n\t\t\t\t\t\" bean found for bean name '\" + qualifier +\n\t\t\t\t\t\"'! (Note: Qualifier matching not supported because given \" +\n\t\t\t\t\t\"BeanFactory does not implement ConfigurableListableBeanFactory.)\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.annotation.<unknown>#qualifiedBeansOfType(beanFactory,beanType,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve all beans of type {@code T} from the given {@code BeanFactory} declaring a\n\t * qualifier (for example, via {@code <qualifier>} or {@code @Qualifier}) matching the given\n\t * qualifier, or having a bean name matching the given qualifier.\n\t * @param beanFactory the factory to get the target beans from (also searching ancestors)\n\t * @param beanType the type of beans to retrieve\n\t * @param qualifier the qualifier for selecting among all type matches\n\t * @return the matching beans of type {@code T}\n\t * @throws BeansException if any of the matching beans could not be created\n\t * @since 5.1.1\n\t * @see BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanType",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "T>",
    "signature": "public T> qualifiedBeansOfType(ListableBeanFactory beanFactory, Class<T> beanType, String qualifier)",
    "source_code": "\tpublic static <T> Map<String, T> qualifiedBeansOfType(\n\t\t\tListableBeanFactory beanFactory, Class<T> beanType, String qualifier) throws BeansException {\n\n\t\tString[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanType);\n\t\tMap<String, T> result = new LinkedHashMap<>(4);\n\t\tfor (String beanName : candidateBeans) {\n\t\t\tif (isQualifierMatch(qualifier::equals, beanName, beanFactory)) {\n\t\t\t\tresult.put(beanName, beanFactory.getBean(beanName, beanType));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext,\n\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\tpublic void applyTo(GenerationContext generationContext,\n\t\t\tBeanFactoryInitializationCode beanFactoryInitializationCode) {\n\n\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t.addForFeature(\"BeanFactoryRegistrations\", type -> {\n\t\t\t\t\ttype.addJavadoc(\"Register bean definitions for the bean factory.\");\n\t\t\t\t\ttype.addModifiers(Modifier.PUBLIC);\n\t\t\t\t});\n\t\tBeanRegistrationsCodeGenerator codeGenerator = new BeanRegistrationsCodeGenerator(generatedClass);\n\t\tGeneratedMethod generatedBeanDefinitionsMethod = new BeanDefinitionsRegistrationGenerator(\n\t\t\t\tgenerationContext, codeGenerator, this.registrations).generateRegisterBeanDefinitionsMethod();\n\t\tbeanFactoryInitializationCode.addInitializer(generatedBeanDefinitionsMethod.toMethodReference());\n\t\tGeneratedMethod generatedAliasesMethod = codeGenerator.getMethods().add(\"registerAliases\",\n\t\t\t\tthis::generateRegisterAliasesMethod);\n\t\tbeanFactoryInitializationCode.addInitializer(generatedAliasesMethod.toMethodReference());\n\t\tgenerateRegisterHints(generationContext.getRuntimeHints(), this.registrations);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#factoriesAndBeans(springFactoriesLoader,beanFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link Loader} that will obtain AOT services from the given\n\t * {@link SpringFactoriesLoader} and {@link ListableBeanFactory}.\n\t * @param springFactoriesLoader the spring factories loader\n\t * @param beanFactory the bean factory\n\t * @return a new {@link Loader} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "springFactoriesLoader",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Loader",
    "signature": "public Loader factoriesAndBeans(SpringFactoriesLoader springFactoriesLoader, ListableBeanFactory beanFactory)",
    "source_code": "\tpublic static Loader factoriesAndBeans(SpringFactoriesLoader springFactoriesLoader, ListableBeanFactory beanFactory) {\n\t\tAssert.notNull(beanFactory, \"'beanFactory' must not be null\");\n\t\tAssert.notNull(springFactoriesLoader, \"'springFactoriesLoader' must not be null\");\n\t\treturn new Loader(springFactoriesLoader, beanFactory);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#forFactoryMethod(declaringClass,methodName,parameterTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link BeanInstanceSupplier} that\n\t * resolves arguments for the specified factory method.\n\t * @param <T> the type of instance supplied\n\t * @param declaringClass the class that declares the factory method\n\t * @param methodName the factory method name\n\t * @param parameterTypes the factory method parameter types\n\t * @return a new {@link BeanInstanceSupplier} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "declaringClass",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> forFactoryMethod(Class<?> declaringClass, String methodName, Class<?>... parameterTypes)",
    "source_code": "\tpublic static <T> BeanInstanceSupplier<T> forFactoryMethod(\n\t\t\tClass<?> declaringClass, String methodName, Class<?>... parameterTypes) {\n\n\t\tAssert.notNull(declaringClass, \"'declaringClass' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\tAssert.notNull(parameterTypes, \"'parameterTypes' must not be null\");\n\t\tAssert.noNullElements(parameterTypes, \"'parameterTypes' must not contain null elements\");\n\t\treturn new BeanInstanceSupplier<>(\n\t\t\t\tnew FactoryMethodLookup(declaringClass, methodName, parameterTypes),\n\t\t\t\tnull, null, null);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex) {\n\t\treturn generateCode(parameterTypes, startIndex, \"args\");\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(parameterTypes,startIndex,variableName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "startIndex",
      "variableName"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex, String variableName)",
    "source_code": "\tpublic CodeBlock generateCode(Class<?>[] parameterTypes, int startIndex, String variableName) {\n\t\tAssert.notNull(parameterTypes, \"'parameterTypes' must not be null\");\n\t\tAssert.notNull(variableName, \"'variableName' must not be null\");\n\t\tboolean ambiguous = isAmbiguous();\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tfor (int i = startIndex; i < parameterTypes.length; i++) {\n\t\t\tcode.add(i > startIndex ? \", \" : \"\");\n\t\t\tif (!ambiguous) {\n\t\t\t\tcode.add(\"$L.get($L)\", variableName, i - startIndex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode.add(\"$L.get($L, $T.class)\", variableName, i - startIndex, parameterTypes[i]);\n\t\t\t}\n\t\t}\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(registeredBean,constructorOrFactoryMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param constructorOrFactoryMethod the executable to use to create the bean\n\t * @return the generated code\n\t * @deprecated in favor of {@link #generateCode(RegisteredBean, InstantiationDescriptor)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod)",
    "source_code": "\tpublic CodeBlock generateCode(RegisteredBean registeredBean, Executable constructorOrFactoryMethod) {\n\t\treturn generateCode(registeredBean, new InstantiationDescriptor(\n\t\t\t\tconstructorOrFactoryMethod, constructorOrFactoryMethod.getDeclaringClass()));\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(registeredBean,instantiationDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate the instance supplier code.\n\t * @param registeredBean the bean to handle\n\t * @param instantiationDescriptor the executable to use to create the bean\n\t * @return the generated code\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registeredBean",
      "instantiationDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(RegisteredBean registeredBean, InstantiationDescriptor instantiationDescriptor)",
    "source_code": "\tpublic CodeBlock generateCode(RegisteredBean registeredBean, InstantiationDescriptor instantiationDescriptor) {\n\t\tExecutable constructorOrFactoryMethod = instantiationDescriptor.executable();\n\t\tregisterRuntimeHintsIfNecessary(registeredBean, constructorOrFactoryMethod);\n\t\tif (constructorOrFactoryMethod instanceof Constructor<?> constructor) {\n\t\t\treturn generateCodeForConstructor(registeredBean, constructor);\n\t\t}\n\t\tif (constructorOrFactoryMethod instanceof Method method && !KotlinDetector.isSuspendingFunction(method)) {\n\t\t\treturn generateCodeForFactoryMethod(registeredBean, method, instantiationDescriptor.targetClass());\n\t\t}\n\t\tthrow new AotBeanProcessingException(registeredBean, \"no suitable constructor or factory method found\");\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateCode(valueCodeGenerator,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "valueCodeGenerator",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value)",
    "source_code": "\t\tpublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\n\t\t\tif (value instanceof TypedStringValue typedStringValue) {\n\t\t\t\treturn generateTypeStringValueCode(valueCodeGenerator, typedStringValue);\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\tpublic CodeBlock generateInstanceSupplierCode(\n\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\tboolean allowDirectSupplierShortcut) {\n\n\t\tif (hasInstanceSupplier()) {\n\t\t\tthrow new AotBeanProcessingException(this.registeredBean, \"instance supplier is not supported\");\n\t\t}\n\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\tbeanRegistrationCode.getClassName(), beanRegistrationCode.getMethods(), allowDirectSupplierShortcut)\n\t\t\t\t.generateCode(this.registeredBean, this.instantiationDescriptor.get());\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateMapCode(valueCodeGenerator,Map<?,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "valueCodeGenerator",
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map)",
    "source_code": "\t\tprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\n\t\t\tGeneratedMethods generatedMethods = valueCodeGenerator.getGeneratedMethods();\n\t\t\tif (map instanceof LinkedHashMap<?, ?> && generatedMethods != null) {\n\t\t\t\treturn generateLinkedHashMapCode(valueCodeGenerator, generatedMethods, map);\n\t\t\t}\n\t\t\treturn super.generateMapCode(valueCodeGenerator, map);\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateNewBeanDefinitionCode(generationContext,beanType,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanType",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\tpublic CodeBlock generateNewBeanDefinitionCode(GenerationContext generationContext,\n\t\t\tResolvableType beanType, BeanRegistrationCode beanRegistrationCode) {\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tRootBeanDefinition mbd = this.registeredBean.getMergedBeanDefinition();\n\t\tClass<?> beanClass = (mbd.hasBeanClass() ? mbd.getBeanClass() : null);\n\t\tCodeBlock beanClassCode = generateBeanClassCode(\n\t\t\t\tbeanRegistrationCode.getClassName().packageName(),\n\t\t\t\t(beanClass != null ? beanClass : beanType.toClass()));\n\t\tcode.addStatement(\"$T $L = new $T($L)\", RootBeanDefinition.class,\n\t\t\t\tBEAN_DEFINITION_VARIABLE, RootBeanDefinition.class, beanClassCode);\n\t\tif (targetTypeNecessary(beanType, beanClass)) {\n\t\t\tcode.addStatement(\"$L.setTargetType($L)\", BEAN_DEFINITION_VARIABLE, generateBeanTypeCode(beanType));\n\t\t}\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateReturnCode(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateReturnCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\tpublic CodeBlock generateReturnCode(\n\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tcode.addStatement(\"return $L\", BEAN_DEFINITION_VARIABLE);\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter)",
    "source_code": "\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(\n\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter) {\n\n\t\tLoader loader = AotServices.factories(this.registeredBean.getBeanFactory().getBeanClassLoader());\n\t\tList<Delegate> additionalDelegates = loader.load(Delegate.class).asList();\n\n\t\treturn new BeanDefinitionPropertiesCodeGenerator(\n\t\t\t\tgenerationContext.getRuntimeHints(), attributeFilter,\n\t\t\t\tbeanRegistrationCode.getMethods(), additionalDelegates,\n\t\t\t\t(name, value) -> generateValueCode(generationContext, name, value))\n\t\t\t\t.generateCode(beanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateSetBeanInstanceSupplierCode(generationContext,beanRegistrationCode,instanceSupplierCode,postProcessors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "instanceSupplierCode",
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanInstanceSupplierCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\tCodeBlock instanceSupplierCode, List<MethodReference> postProcessors)",
    "source_code": "\tpublic CodeBlock generateSetBeanInstanceSupplierCode(\n\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\tCodeBlock instanceSupplierCode, List<MethodReference> postProcessors) {\n\n\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\tif (postProcessors.isEmpty()) {\n\t\t\tcode.addStatement(\"$L.setInstanceSupplier($L)\", BEAN_DEFINITION_VARIABLE, instanceSupplierCode);\n\t\t\treturn code.build();\n\t\t}\n\t\tcode.addStatement(\"$T $L = $L\",\n\t\t\t\tParameterizedTypeName.get(InstanceSupplier.class, this.registeredBean.getBeanClass()),\n\t\t\t\tINSTANCE_SUPPLIER_VARIABLE, instanceSupplierCode);\n\t\tfor (MethodReference postProcessor : postProcessors) {\n\t\t\tcode.addStatement(\"$L = $L.andThen($L)\", INSTANCE_SUPPLIER_VARIABLE,\n\t\t\t\t\tINSTANCE_SUPPLIER_VARIABLE, postProcessor.toCodeBlock());\n\t\t}\n\t\tcode.addStatement(\"$L.setInstanceSupplier($L)\", BEAN_DEFINITION_VARIABLE,\n\t\t\t\tINSTANCE_SUPPLIER_VARIABLE);\n\t\treturn code.build();\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#generateValueCode(generationContext,name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generationContext",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "CodeBlock",
    "signature": "protected CodeBlock generateValueCode(GenerationContext generationContext, String name, Object value)",
    "source_code": "\tprotected CodeBlock generateValueCode(GenerationContext generationContext, String name, Object value) {\n\t\tRegisteredBean innerRegisteredBean = getInnerRegisteredBean(value);\n\t\tif (innerRegisteredBean != null) {\n\t\t\tBeanDefinitionMethodGenerator methodGenerator = this.beanDefinitionMethodGeneratorFactory\n\t\t\t\t\t.getBeanDefinitionMethodGenerator(innerRegisteredBean, name);\n\t\t\tAssert.state(methodGenerator != null, \"Unexpected filtering of inner-bean\");\n\t\t\tMethodReference generatedMethod = methodGenerator\n\t\t\t\t\t.generateBeanDefinitionMethod(generationContext, this.beanRegistrationsCode);\n\t\t\treturn generatedMethod.toInvokeCodeBlock(ArgumentCodeGenerator.none());\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#registerRuntimeHints(runtimeHints,executable)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "executable"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "void",
    "signature": "public void registerRuntimeHints(RuntimeHints runtimeHints, Executable executable)",
    "source_code": "\t\tpublic void registerRuntimeHints(RuntimeHints runtimeHints, Executable executable) {\n\t\t\tClass<?>[] parameterTypes = executable.getParameterTypes();\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, i);\n\t\t\t\tDependencyDescriptor dependencyDescriptor = new DependencyDescriptor(methodParam, true);\n\t\t\t\tregisterProxyIfNecessary(runtimeHints, dependencyDescriptor);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#withGenerator(ThrowingBiFunction<RegisteredBean,AutowiredArguments,generator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses the specified\n\t * {@code generator} bi-function to instantiate the underlying bean.\n\t * @param generator a {@link ThrowingBiFunction} that uses the\n\t * {@link RegisteredBean} and resolved {@link AutowiredArguments} to\n\t * instantiate the underlying bean\n\t * @return a new {@link BeanInstanceSupplier} instance with the specified generator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ThrowingBiFunction<RegisteredBean",
      "AutowiredArguments",
      "generator"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingBiFunction<RegisteredBean, AutowiredArguments, T> generator)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withGenerator(ThrowingBiFunction<RegisteredBean, AutowiredArguments, T> generator) {\n\t\tAssert.notNull(generator, \"'generator' must not be null\");\n\t\treturn new BeanInstanceSupplier<>(this.lookup, null, generator, this.shortcutBeanNames);\n\t}"
  },
  "org.springframework.beans.factory.aot.<unknown>#withGenerator(ThrowingFunction<RegisteredBean,generator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new {@link BeanInstanceSupplier} instance that uses the specified\n\t * {@code generator} function to instantiate the underlying bean.\n\t * @param generator a {@link ThrowingFunction} that uses the\n\t * {@link RegisteredBean} to instantiate the underlying bean\n\t * @return a new {@link BeanInstanceSupplier} instance with the specified generator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ThrowingFunction<RegisteredBean",
      "generator"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "BeanInstanceSupplier<T>",
    "signature": "public BeanInstanceSupplier<T> withGenerator(ThrowingFunction<RegisteredBean, T> generator)",
    "source_code": "\tpublic BeanInstanceSupplier<T> withGenerator(ThrowingFunction<RegisteredBean, T> generator) {\n\t\tAssert.notNull(generator, \"'generator' must not be null\");\n\t\treturn new BeanInstanceSupplier<>(this.lookup, generator, null, this.shortcutBeanNames);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addGenericArgumentValue(value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a generic argument value to be matched by type.\n\t * <p>Note: A single generic argument value will just be used once,\n\t * rather than matched multiple times.\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void addGenericArgumentValue(Object value, String type)",
    "source_code": "\tpublic void addGenericArgumentValue(Object value, String type) {\n\t\tthis.genericArgumentValues.add(new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,newValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param newValue the argument value in the form of a ValueHolder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, ValueHolder newValue)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, ValueHolder newValue) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tAssert.notNull(newValue, \"ValueHolder must not be null\");\n\t\taddOrMergeIndexedArgumentValue(index, newValue);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param value the argument value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, @Nullable Object value)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, @Nullable Object value) {\n\t\taddIndexedArgumentValue(index, new ValueHolder(value));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addIndexedArgumentValue(index,value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param value the argument value\n\t * @param type the type of the constructor argument\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void addIndexedArgumentValue(int index, @Nullable Object value, String type)",
    "source_code": "\tpublic void addIndexedArgumentValue(int index, @Nullable Object value, String type) {\n\t\taddIndexedArgumentValue(index, new ValueHolder(value, type));\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#addScope(scopeName,scope)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given scope to this configurer's map of scopes.\n\t * @param scopeName the name of the scope\n\t * @param scope the scope implementation\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void addScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void addScope(String scopeName, Scope scope) {\n\t\tif (this.scopes == null) {\n\t\t\tthis.scopes = new LinkedHashMap<>(1);\n\t\t}\n\t\tthis.scopes.put(scopeName, scope);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#createServiceLocatorException(exceptionConstructor,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a service locator exception for the given cause.\n\t * Only called in case of a custom service locator exception.\n\t * <p>The default implementation can handle all variations of\n\t * message and exception arguments.\n\t * @param exceptionConstructor the constructor to use\n\t * @param cause the cause of the service lookup failure\n\t * @return the service locator exception to throw\n\t * @see #setServiceLocatorExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exceptionConstructor",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Exception",
    "signature": "protected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause)",
    "source_code": "\tprotected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause) {\n\t\tClass<?>[] paramTypes = exceptionConstructor.getParameterTypes();\n\t\tObject[] args = new Object[paramTypes.length];\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (String.class == paramTypes[i]) {\n\t\t\t\targs[i] = cause.getMessage();\n\t\t\t}\n\t\t\telse if (paramTypes[i].isInstance(cause)) {\n\t\t\t\targs[i] = cause;\n\t\t\t}\n\t\t}\n\t\treturn BeanUtils.instantiateClass(exceptionConstructor, args);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType) {\n\t\treturn getArgumentValue(index, requiredType, null, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match\n\t * @param requiredName the parameter name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName) {\n\t\treturn getArgumentValue(index, requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getArgumentValue(index,requiredType,requiredName,usedValueHolders)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for an argument value that either corresponds to the given index\n\t * in the constructor argument list or generically matches by type.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the parameter type to match (can be {@code null}\n\t * to find an untyped argument value)\n\t * @param requiredName the parameter name to match (can be {@code null}\n\t * to find an unnamed argument value, or empty String to match any name)\n\t * @param usedValueHolders a Set of ValueHolder objects that have already\n\t * been used in the current resolution process and should therefore not\n\t * be returned again (allowing to return the next generic argument match\n\t * in case of multiple generic argument values of the same type)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName",
      "usedValueHolders"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType,\n\t\t\t@Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders)",
    "source_code": "\tpublic ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType,\n\t\t\t@Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders) {\n\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tValueHolder valueHolder = getIndexedArgumentValue(index, requiredType, requiredName);\n\t\tif (valueHolder == null) {\n\t\t\tvalueHolder = getGenericArgumentValue(requiredType, requiredName, usedValueHolders);\n\t\t}\n\t\treturn valueHolder;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getFlattenedMap(Map<String,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a flattened version of the given map, recursively following any nested Map\n\t * or Collection values. Entries from the resulting map retain the same order as the\n\t * source. When called with the Map from a {@link MatchCallback} the result will\n\t * contain the same values as the {@link MatchCallback} Properties.\n\t * @param source the source map\n\t * @return a flattened map\n\t * @since 4.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "Object>",
    "signature": "protected Object> getFlattenedMap(Map<String, Object> source)",
    "source_code": "\tprotected final Map<String, Object> getFlattenedMap(Map<String, Object> source) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tbuildFlattenedMap(result, source, null);\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getGenericArgumentValue(requiredType,requiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for a generic argument value that matches the given type.\n\t * @param requiredType the type to match\n\t * @param requiredName the name to match\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName)",
    "source_code": "\tpublic ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName) {\n\t\treturn getGenericArgumentValue(requiredType, requiredName, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getGenericArgumentValue(requiredType,requiredName,usedValueHolders)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for the next generic argument value that matches the given type,\n\t * ignoring argument values that have already been used in the current\n\t * resolution process.\n\t * @param requiredType the type to match (can be {@code null} to find\n\t * an arbitrary next generic argument value)\n\t * @param requiredName the name to match (can be {@code null} to not\n\t * match argument values by name, or empty String to match any name)\n\t * @param usedValueHolders a Set of ValueHolder objects that have already been used\n\t * in the current resolution process and should therefore not be returned again\n\t * @return the ValueHolder for the argument, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "requiredName",
      "usedValueHolders"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName,\n\t\t\t@Nullable Set<ValueHolder> usedValueHolders)",
    "source_code": "\tpublic ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName,\n\t\t\t@Nullable Set<ValueHolder> usedValueHolders) {\n\n\t\tfor (ValueHolder valueHolder : this.genericArgumentValues) {\n\t\t\tif (usedValueHolders != null && usedValueHolders.contains(valueHolder)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (valueHolder.getName() != null && (requiredName == null ||\n\t\t\t\t\t(!requiredName.isEmpty() && !requiredName.equals(valueHolder.getName())))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (valueHolder.getType() != null && (requiredType == null ||\n\t\t\t\t\t!ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (requiredType != null && valueHolder.getType() == null && valueHolder.getName() == null &&\n\t\t\t\t\t!ClassUtils.isAssignableValue(requiredType, valueHolder.getValue())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn valueHolder;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getIndexedArgumentValue(index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the type to match (can be {@code null} to match\n\t * untyped values only)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType)",
    "source_code": "\tpublic ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType) {\n\t\treturn getIndexedArgumentValue(index, requiredType, null);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getIndexedArgumentValue(index,requiredType,requiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get argument value for the given index in the constructor argument list.\n\t * @param index the index in the constructor argument list\n\t * @param requiredType the type to match (can be {@code null} to match\n\t * untyped values only)\n\t * @param requiredName the type to match (can be {@code null} to match\n\t * unnamed values only, or empty String to match any name)\n\t * @return the ValueHolder for the argument, or {@code null} if none set\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "requiredType",
      "requiredName"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "ValueHolder",
    "signature": "public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName)",
    "source_code": "\tpublic ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName) {\n\t\tAssert.isTrue(index >= 0, \"Index must not be negative\");\n\t\tValueHolder valueHolder = this.indexedArgumentValues.get(index);\n\t\tif (valueHolder != null &&\n\t\t\t\t(valueHolder.getType() == null || (requiredType != null &&\n\t\t\t\t\t\tClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) &&\n\t\t\t\t(valueHolder.getName() == null || (requiredName != null &&\n\t\t\t\t\t\t(requiredName.isEmpty() || requiredName.equals(valueHolder.getName()))))) {\n\t\t\treturn valueHolder;\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#getMostSpecific(a,b)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Compare two {@link MatchStatus} items, returning the most specific status.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "a",
      "b"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "MatchStatus",
    "signature": "public MatchStatus getMostSpecific(MatchStatus a, MatchStatus b)",
    "source_code": "\t\tpublic static MatchStatus getMostSpecific(MatchStatus a, MatchStatus b) {\n\t\t\treturn (a.ordinal() < b.ordinal() ? a : b);\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\t// Use hashCode of service locator proxy.\n\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"Service locator: \" + serviceLocatorInterface;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn invokeServiceLocatorMethod(method, args);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#resolveCandidate(beanName,requiredType,beanFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified bean name, as a candidate result of the matching\n\t * algorithm for this dependency, to a bean instance from the given factory.\n\t * <p>The default implementation calls {@link BeanFactory#getBean(String)}.\n\t * Subclasses may provide additional arguments or other customizations.\n\t * @param beanName the bean name, as a candidate result for this dependency\n\t * @param requiredType the expected type of the bean (as an assertion)\n\t * @param beanFactory the associated factory\n\t * @return the bean instance (never {@code null})\n\t * @throws BeansException if the bean could not be obtained\n\t * @since 4.3.2\n\t * @see BeanFactory#getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)\n\t\t\tthrows BeansException {\n\n\t\treturn beanFactory.getBean(beanName);\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#resolveNotUnique(type,Map<String,matchingBeans)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the specified not-unique scenario: by default,\n\t * throwing a {@link NoUniqueBeanDefinitionException}.\n\t * <p>Subclasses may override this to select one of the instances or\n\t * to opt out with no result at all through returning {@code null}.\n\t * @param type the requested bean type\n\t * @param matchingBeans a map of bean names and corresponding bean\n\t * instances which have been pre-selected for the given type\n\t * (qualifiers etc already applied)\n\t * @return a bean instance to proceed with, or {@code null} for none\n\t * @throws BeansException in case of the not-unique scenario being fatal\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) throws BeansException {\n\t\tthrow new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#setScopes(Map<String,scopes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the custom scopes that are to be registered.\n\t * <p>The keys indicate the scope names (of type String); each value\n\t * is expected to be the corresponding custom {@link Scope} instance\n\t * or class name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "scopes"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void setScopes(Map<String, Object> scopes)",
    "source_code": "\tpublic void setScopes(Map<String, Object> scopes) {\n\t\tthis.scopes = scopes;\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#visitIndexedArgumentValues(Map<Integer,ias)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<Integer",
      "ias"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "protected void visitIndexedArgumentValues(Map<Integer, ConstructorArgumentValues.ValueHolder> ias)",
    "source_code": "\tprotected void visitIndexedArgumentValues(Map<Integer, ConstructorArgumentValues.ValueHolder> ias) {\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : ias.values()) {\n\t\t\tObject newVal = resolveValue(valueHolder.getValue());\n\t\t\tif (!ObjectUtils.nullSafeEquals(newVal, valueHolder.getValue())) {\n\t\t\t\tvalueHolder.setValue(newVal);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.config.<unknown>#visitMap(Map<?,mapVal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "mapVal"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "protected void visitMap(Map<?, ?> mapVal)",
    "source_code": "\tprotected void visitMap(Map<?, ?> mapVal) {\n\t\tMap newContent = new LinkedHashMap();\n\t\tboolean entriesModified = false;\n\t\tfor (Map.Entry entry : mapVal.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tint keyHash = (key != null ? key.hashCode() : 0);\n\t\t\tObject newKey = resolveValue(key);\n\t\t\tint newKeyHash = (newKey != null ? newKey.hashCode() : 0);\n\t\t\tObject val = entry.getValue();\n\t\t\tObject newVal = resolveValue(val);\n\t\t\tnewContent.put(newKey, newVal);\n\t\t\tentriesModified = entriesModified || (newVal != val || newKey != key || newKeyHash != keyHash);\n\t\t}\n\t\tif (entriesModified) {\n\t\t\tmapVal.clear();\n\t\t\tmapVal.putAll(newContent);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#applyPropertyToBeanDefinition(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "void",
    "signature": "protected void applyPropertyToBeanDefinition(String name, Object value)",
    "source_code": "\tprotected void applyPropertyToBeanDefinition(String name, Object value) {\n\t\tif (value instanceof GString) {\n\t\t\tvalue = value.toString();\n\t\t}\n\t\tif (addDeferredProperty(name, value)) {\n\t\t\treturn;\n\t\t}\n\t\telse if (value instanceof Closure<?> callable) {\n\t\t\tGroovyBeanDefinitionWrapper current = this.currentBeanDefinition;\n\t\t\ttry {\n\t\t\t\tClass<?> parameterType = callable.getParameterTypes()[0];\n\t\t\t\tif (Object.class == parameterType) {\n\t\t\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(\"\");\n\t\t\t\t\tcallable.call(this.currentBeanDefinition);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, parameterType);\n\t\t\t\t\tcallable.call((Object) null);\n\t\t\t\t}\n\n\t\t\t\tvalue = this.currentBeanDefinition.getBeanDefinition();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.currentBeanDefinition = current;\n\t\t\t}\n\t\t}\n\t\tAssert.state(this.currentBeanDefinition != null, \"No current bean definition set\");\n\t\tthis.currentBeanDefinition.addProperty(name, value);\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#bean(type,Object...args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Define an inner bean definition.\n\t * @param type the bean type\n\t * @param args the constructors arguments and closure configurer\n\t * @return the bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Object...args"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition bean(Class<?> type, Object...args)",
    "source_code": "\tpublic AbstractBeanDefinition bean(Class<?> type, Object...args) {\n\t\tGroovyBeanDefinitionWrapper current = this.currentBeanDefinition;\n\t\ttry {\n\t\t\tClosure<?> callable = null;\n\t\t\tCollection<Object> constructorArgs = null;\n\t\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\t\tint index = args.length;\n\t\t\t\tObject lastArg = args[index - 1];\n\t\t\t\tif (lastArg instanceof Closure<?> closure) {\n\t\t\t\t\tcallable = closure;\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\tconstructorArgs = resolveConstructorArguments(args, 0, index);\n\t\t\t}\n\t\t\tthis.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, type, constructorArgs);\n\t\t\tif (callable != null) {\n\t\t\t\tcallable.call(this.currentBeanDefinition);\n\t\t\t}\n\t\t\treturn this.currentBeanDefinition.getBeanDefinition();\n\t\t}\n\t\tfinally {\n\t\t\tthis.currentBeanDefinition = current;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,arg)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This method overrides method invocation to create beans for each method name that\n\t * takes a class argument.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "arg"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object arg)",
    "source_code": "\tpublic Object invokeMethod(String name, Object arg) {\n\t\tObject[] args = (Object[])arg;\n\t\tif (\"beans\".equals(name) && args.length == 1 && args[0] instanceof Closure<?> closure) {\n\t\t\treturn beans(closure);\n\t\t}\n\t\telse if (\"ref\".equals(name)) {\n\t\t\tString refName;\n\t\t\tif (args[0] == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Argument to ref() is not a valid bean or was not found\");\n\t\t\t}\n\t\t\tif (args[0] instanceof RuntimeBeanReference runtimeBeanReference) {\n\t\t\t\trefName = runtimeBeanReference.getBeanName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\trefName = args[0].toString();\n\t\t\t}\n\t\t\tboolean parentRef = false;\n\t\t\tif (args.length > 1 && args[1] instanceof Boolean bool) {\n\t\t\t\tparentRef = bool;\n\t\t\t}\n\t\t\treturn new RuntimeBeanReference(refName, parentRef);\n\t\t}\n\t\telse if (this.namespaces.containsKey(name) && args.length > 0 && args[0] instanceof Closure) {\n\t\t\tGroovyDynamicElementReader reader = createDynamicElementReader(name);\n\t\t\treader.invokeMethod(\"doCall\", args);\n\t\t}\n\t\telse if (args.length > 0 && args[0] instanceof Closure) {\n\t\t\t// abstract bean definition\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\telse if (args.length > 0 &&\n\t\t\t\t(args[0] instanceof Class || args[0] instanceof RuntimeBeanReference || args[0] instanceof Map)) {\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\telse if (args.length > 1 && args[args.length -1] instanceof Closure) {\n\t\t\treturn invokeBeanDefiningMethod(name, args);\n\t\t}\n\t\tMetaClass mc = DefaultGroovyMethods.getMetaClass(getRegistry());\n\t\tif (!mc.respondsTo(getRegistry(), name, args).isEmpty()){\n\t\t\treturn mc.invokeMethod(getRegistry(), name, args);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 843
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\t\t\tpublic Object invokeMethod(String name, Object args) {\n\t\t\t\treturn InvokerHelper.invokeMethod(this.propertyValue, name, args);\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#invokeMethod(name,obj)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object obj)",
    "source_code": "\tpublic Object invokeMethod(String name, Object obj) {\n\t\tObject[] args = (Object[]) obj;\n\t\tif (name.equals(\"doCall\")) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tClosure<Object> callable = (Closure<Object>) args[0];\n\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\tcallable.setDelegate(this);\n\t\t\tObject result = callable.call();\n\n\t\t\tif (this.callAfterInvocation) {\n\t\t\t\tafterInvocation();\n\t\t\t\tthis.callAfterInvocation = false;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tStreamingMarkupBuilder builder = new StreamingMarkupBuilder();\n\t\t\tString myNamespace = this.rootNamespace;\n\t\t\tMap<String, String> myNamespaces = this.xmlNamespaces;\n\n\t\t\t@SuppressWarnings(\"serial\")\n\t\t\tClosure<Object> callable = new Closure<>(this) {\n\t\t\t\t@Override\n\t\t\t\tpublic Object call(Object... arguments) {\n\t\t\t\t\t((GroovyObject) getProperty(\"mkp\")).invokeMethod(\"declareNamespace\", new Object[] {myNamespaces});\n\t\t\t\t\tint len = args.length;\n\t\t\t\t\tif (len > 0 && args[len-1] instanceof Closure<?> callable) {\n\t\t\t\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\t\t\t\tcallable.setDelegate(builder);\n\t\t\t\t\t}\n\t\t\t\t\treturn ((GroovyObject) ((GroovyObject) getDelegate()).getProperty(myNamespace)).invokeMethod(name, args);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcallable.setResolveStrategy(Closure.DELEGATE_FIRST);\n\t\t\tcallable.setDelegate(builder);\n\t\t\tWritable writable = (Writable) builder.bind(callable);\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\ttry {\n\t\t\t\twritable.writeTo(sw);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\n\t\t\tElement element = this.delegate.getReaderContext().readDocumentFromString(sw.toString()).getDocumentElement();\n\t\t\tthis.delegate.initDefaults(element);\n\t\t\tif (this.decorating) {\n\t\t\t\tBeanDefinitionHolder holder = this.beanDefinition.getBeanDefinitionHolder();\n\t\t\t\tholder = this.delegate.decorateIfRequired(element, holder, null);\n\t\t\t\tthis.beanDefinition.setBeanDefinitionHolder(holder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBeanDefinition beanDefinition = this.delegate.parseCustomElement(element);\n\t\t\t\tif (beanDefinition != null) {\n\t\t\t\t\tthis.beanDefinition.setBeanDefinition((AbstractBeanDefinition) beanDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.callAfterInvocation) {\n\t\t\t\tafterInvocation();\n\t\t\t\tthis.callAfterInvocation = false;\n\t\t\t}\n\t\t\treturn element;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#resolveConstructorArguments(args,start,end)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "start",
      "end"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "List<Object>",
    "signature": "protected List<Object> resolveConstructorArguments(Object[] args, int start, int end)",
    "source_code": "\tprotected List<Object> resolveConstructorArguments(Object[] args, int start, int end) {\n\t\tObject[] constructorArgs = Arrays.copyOfRange(args, start, end);\n\t\tfor (int i = 0; i < constructorArgs.length; i++) {\n\t\t\tif (constructorArgs[i] instanceof GString) {\n\t\t\t\tconstructorArgs[i] = constructorArgs[i].toString();\n\t\t\t}\n\t\t\telse if (constructorArgs[i] instanceof List<?> list) {\n\t\t\t\tconstructorArgs[i] = manageListIfNecessary(list);\n\t\t\t}\n\t\t\telse if (constructorArgs[i] instanceof Map<?, ?> map){\n\t\t\t\tconstructorArgs[i] = manageMapIfNecessary(map);\n\t\t\t}\n\t\t}\n\t\treturn List.of(constructorArgs);\n\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setProperty(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 853
    },
    "return": "void",
    "signature": "public void setProperty(String name, Object value)",
    "source_code": "\t\t\tpublic void setProperty(String name, Object value) {\n\t\t\t\tInvokerHelper.setProperty(this.propertyValue, name, value);\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setProperty(property,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 797
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\t\tpublic void setProperty(String property, Object newValue) {\n\t\t\tif (!addDeferredProperty(property, newValue)) {\n\t\t\t\tthis.beanDefinition.getBeanDefinition().getPropertyValues().add(property, newValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#setVariable(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "public void setVariable(String name, Object value)",
    "source_code": "\t\t\tpublic void setVariable(String name, Object value) {\n\t\t\t\tif (currentBeanDefinition != null) {\n\t\t\t\t\tapplyPropertyToBeanDefinition(name, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsuper.setVariable(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.beans.factory.groovy.<unknown>#xmlns(Map<String,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Define a Spring XML namespace definition to use.\n\t * @param definition the namespace definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void xmlns(Map<String, String> definition)",
    "source_code": "\tpublic void xmlns(Map<String, String> definition) {\n\t\tif (!definition.isEmpty()) {\n\t\t\tfor (Map.Entry<String,String> entry : definition.entrySet()) {\n\t\t\t\tString namespace = entry.getKey();\n\t\t\t\tString uri = entry.getValue();\n\t\t\t\tif (uri == null) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Namespace definition must supply a non-null URI\");\n\t\t\t\t}\n\t\t\t\tNamespaceHandler namespaceHandler =\n\t\t\t\t\t\tthis.groovyDslXmlBeanDefinitionReader.getNamespaceHandlerResolver().resolve(uri);\n\t\t\t\tif (namespaceHandler == null) {\n\t\t\t\t\tthrow new BeanDefinitionParsingException(new Problem(\"No namespace handler found for URI: \" + uri,\n\t\t\t\t\t\t\tnew Location(new DescriptiveResource((\"Groovy\")))));\n\t\t\t\t}\n\t\t\t\tthis.namespaces.put(namespace, uri);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#InstantiationDescriptor(executable,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Descriptor for how a bean should be instantiated. While the {@code targetClass}\n\t * is usually the declaring class of the {@code executable} (in case of a constructor\n\t * or a locally declared factory method), there are cases where retaining the actual\n\t * concrete class is necessary (for example, for an inherited factory method).\n\t * @since 6.1.7\n\t * @param executable the {@link Executable} ({@link java.lang.reflect.Constructor}\n\t * or {@link java.lang.reflect.Method}) to invoke\n\t * @param targetClass the target {@link Class} of the executable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 275
    },
    "return": "record",
    "signature": "public record InstantiationDescriptor(Executable executable, Class<?> targetClass)",
    "source_code": "\tpublic record InstantiationDescriptor(Executable executable, Class<?> targetClass) {\n\n\t\tpublic InstantiationDescriptor(Executable executable) {\n\t\t\tthis(executable, executable.getDeclaringClass());\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#add(index,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 2008
    },
    "return": "void",
    "signature": "public void add(int index, BeanPostProcessor element)",
    "source_code": "\t\tpublic void add(int index, BeanPostProcessor element) {\n\t\t\tsuper.add(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addAll(index,c)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 2057
    },
    "return": "boolean",
    "signature": "public boolean addAll(int index, Collection<? extends BeanPostProcessor> c)",
    "source_code": "\t\tpublic boolean addAll(int index, Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(index, c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#addBean(name,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new singleton bean.\n\t * <p>Will overwrite any existing instance for the given name.\n\t * @param name the name of the bean\n\t * @param bean the bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beans.put(name, bean);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessAfterInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPostProcessorsBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply InstantiationAwareBeanPostProcessors to the specified bean definition\n\t * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.\n\t * <p>Any returned object will be used as the bean instead of actually instantiating\n\t * the target bean. A {@code null} return value from the post-processor will\n\t * result in the target bean being instantiated.\n\t * @param beanClass the class of the bean to be instantiated\n\t * @param beanName the name of the bean\n\t * @return the bean object to use instead of a default instance of the target bean, or {@code null}\n\t * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1142
    },
    "return": "Object",
    "signature": "protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tprotected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\tObject result = bp.postProcessBeforeInstantiation(beanClass, beanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tapplyPropertyValues(beanName, bd, bw, bd.getPropertyValues());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyMergedBeanDefinitionPostProcessors(mbd,beanType,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,\n\t * invoking their {@code postProcessMergedBeanDefinition} methods.\n\t * @param mbd the merged bean definition for the bean\n\t * @param beanType the actual type of the managed bean instance\n\t * @param beanName the name of the bean\n\t * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "void",
    "signature": "protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName)",
    "source_code": "\tprotected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#applyPropertyValues(beanName,mbd,bw,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given property values, resolving any runtime references\n\t * to other beans in this bean factory. Must use deep copy, so we\n\t * don't permanently modify this property.\n\t * @param beanName the bean name passed for better exception information\n\t * @param mbd the merged bean definition\n\t * @param bw the BeanWrapper wrapping the target object\n\t * @param pvs the new property values\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1651
    },
    "return": "void",
    "signature": "protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)",
    "source_code": "\tprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n\t\tif (pvs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMutablePropertyValues mpvs = null;\n\t\tList<PropertyValue> original;\n\n\t\tif (pvs instanceof MutablePropertyValues _mpvs) {\n\t\t\tmpvs = _mpvs;\n\t\t\tif (mpvs.isConverted()) {\n\t\t\t\t// Shortcut: use the pre-converted values as-is.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValues(mpvs);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginal = mpvs.getPropertyValueList();\n\t\t}\n\t\telse {\n\t\t\toriginal = Arrays.asList(pvs.getPropertyValues());\n\t\t}\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\t\tBeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n\t\t// Create a deep copy, resolving any references for values.\n\t\tList<PropertyValue> deepCopy = new ArrayList<>(original.size());\n\t\tboolean resolveNecessary = false;\n\t\tfor (PropertyValue pv : original) {\n\t\t\tif (pv.isConverted()) {\n\t\t\t\tdeepCopy.add(pv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString propertyName = pv.getName();\n\t\t\t\tObject originalValue = pv.getValue();\n\t\t\t\tif (originalValue == AutowiredPropertyMarker.INSTANCE) {\n\t\t\t\t\tMethod writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();\n\t\t\t\t\tif (writeMethod == null) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Autowire marker for property without write method: \" + pv);\n\t\t\t\t\t}\n\t\t\t\t\toriginalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);\n\t\t\t\t}\n\t\t\t\tObject resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n\t\t\t\tObject convertedValue = resolvedValue;\n\t\t\t\tboolean convertible = isConvertibleProperty(propertyName, bw);\n\t\t\t\tif (convertible) {\n\t\t\t\t\tconvertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n\t\t\t\t}\n\t\t\t\t// Possibly store converted value in merged bean definition,\n\t\t\t\t// in order to avoid re-conversion for every created bean instance.\n\t\t\t\tif (resolvedValue == originalValue) {\n\t\t\t\t\tif (convertible) {\n\t\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse if (convertible && originalValue instanceof TypedStringValue typedStringValue &&\n\t\t\t\t\t\t!typedStringValue.isDynamic() &&\n\t\t\t\t\t\t!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveNecessary = true;\n\t\t\t\t\tdeepCopy.add(new PropertyValue(pv, convertedValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mpvs != null && !resolveNecessary) {\n\t\t\tmpvs.setConverted();\n\t\t}\n\n\t\t// Set our (possibly massaged) deep copy.\n\t\ttry {\n\t\t\tbw.setPropertyValues(new MutablePropertyValues(deepCopy));\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tif (bd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR) {\n\t\t\treturn autowireConstructor(beanClass.getName(), bd, null, null).getWrappedInstance();\n\t\t}\n\t\telse {\n\t\t\tObject bean = getInstantiationStrategy().instantiate(bd, null, this);\n\t\t\tpopulateBean(beanClass.getName(), bd, new BeanWrapperImpl(bean));\n\t\t\treturn bean;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException {\n\n\t\tif (autowireMode == AUTOWIRE_CONSTRUCTOR) {\n\t\t\tthrow new IllegalArgumentException(\"AUTOWIRE_CONSTRUCTOR not supported for existing bean instance\");\n\t\t}\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd =\n\t\t\t\tnew RootBeanDefinition(ClassUtils.getUserClass(existingBean), autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireByName(beanName,mbd,bw,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Fill in any missing property values with references to\n\t * other beans in this factory if autowire is set to \"byName\".\n\t * @param beanName the name of the bean we're wiring up.\n\t * Useful for debugging messages; not used functionally.\n\t * @param mbd bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1463
    },
    "return": "void",
    "signature": "protected void autowireByName(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)",
    "source_code": "\tprotected void autowireByName(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\tif (containsBean(propertyName)) {\n\t\t\t\tObject bean = getBean(propertyName);\n\t\t\t\tpvs.add(propertyName, bean);\n\t\t\t\tregisterDependentBean(propertyName, beanName);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireByType(beanName,mbd,bw,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract method defining \"autowire by type\" (bean properties by type) behavior.\n\t * <p>This is like PicoContainer default, in which there must be exactly one bean\n\t * of the property type in the bean factory. This makes bean factories simple to\n\t * configure for small namespaces, but doesn't work as well as standard Spring\n\t * behavior for bigger applications.\n\t * @param beanName the name of the bean to autowire by type\n\t * @param mbd the merged bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1497
    },
    "return": "void",
    "signature": "protected void autowireByType(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)",
    "source_code": "\tprotected void autowireByType(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(propertyNames.length * 2);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\ttry {\n\t\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\t\t// Don't try autowiring by type for type Object: never makes sense,\n\t\t\t\t// even if it technically is an unsatisfied, non-simple property.\n\t\t\t\tif (Object.class != pd.getPropertyType()) {\n\t\t\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t\t// Do not allow eager init for type matching in case of a prioritized post-processor.\n\t\t\t\t\tboolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);\n\t\t\t\t\tDependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n\t\t\t\t\tObject autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n\t\t\t\t\tif (autowiredArgument != null) {\n\t\t\t\t\t\tpvs.add(propertyName, autowiredArgument);\n\t\t\t\t\t}\n\t\t\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\t\t\tregisterDependentBean(autowiredBeanName, beanName);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" +\n\t\t\t\t\t\t\t\t\tpropertyName + \"' to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tautowiredBeanNames.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireConstructor(beanName,mbd,chosenCtors,explicitArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param chosenCtors chosen candidate constructors (or {@code null} if none)\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (-> use constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "mbd",
      "chosenCtors",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "BeanWrapper",
    "signature": "public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n\t\t\t@Nullable Constructor<?>[] chosenCtors, @Nullable Object[] explicitArgs)",
    "source_code": "\tpublic BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,\n\t\t\t@Nullable Constructor<?>[] chosenCtors, @Nullable Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tConstructor<?> constructorToUse = null;\n\t\tArgumentsHolder argsHolderToUse = null;\n\t\tObject[] argsToUse = null;\n\n\t\tif (explicitArgs != null) {\n\t\t\targsToUse = explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve = null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse != null && mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached constructor...\n\t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse == null) {\n\t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve != null) {\n\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (constructorToUse == null || argsToUse == null) {\n\t\t\t// Take specified constructors, if any.\n\t\t\tConstructor<?>[] candidates = chosenCtors;\n\t\t\tif (candidates == null) {\n\t\t\t\tClass<?> beanClass = mbd.getBeanClass();\n\t\t\t\ttry {\n\t\t\t\t\tcandidates = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\tbeanClass.getDeclaredConstructors() : beanClass.getConstructors());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Resolution of declared constructors on bean Class [\" + beanClass.getName() +\n\t\t\t\t\t\t\t\"] from ClassLoader [\" + beanClass.getClassLoader() + \"] failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (candidates.length == 1 && explicitArgs == null && !mbd.hasConstructorArgumentValues()) {\n\t\t\t\tConstructor<?> uniqueCandidate = candidates[0];\n\t\t\t\tif (uniqueCandidate.getParameterCount() == 0) {\n\t\t\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;\n\t\t\t\t\t\tmbd.constructorArgumentsResolved = true;\n\t\t\t\t\t\tmbd.resolvedConstructorArguments = EMPTY_ARGS;\n\t\t\t\t\t}\n\t\t\t\t\tbw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));\n\t\t\t\t\treturn bw;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Need to resolve the constructor.\n\t\t\tboolean autowiring = (chosenCtors != null ||\n\t\t\t\t\tmbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);\n\t\t\tConstructorArgumentValues resolvedValues = null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs != null) {\n\t\t\t\tminNrOfArgs = explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tAutowireUtils.sortConstructors(candidates);\n\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n\t\t\tSet<Constructor<?>> ambiguousConstructors = null;\n\t\t\tDeque<UnsatisfiedDependencyException> causes = null;\n\n\t\t\tfor (Constructor<?> candidate : candidates) {\n\t\t\t\tint parameterCount = candidate.getParameterCount();\n\n\t\t\t\tif (constructorToUse != null && argsToUse != null && argsToUse.length > parameterCount) {\n\t\t\t\t\t// Already found greedy constructor that can be satisfied ->\n\t\t\t\t\t// do not look any further, there are only less greedy constructors left.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parameterCount < minNrOfArgs) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tArgumentsHolder argsHolder;\n\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\tif (resolvedValues != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString[] paramNames = null;\n\t\t\t\t\t\tif (resolvedValues.containsNamedArgument()) {\n\t\t\t\t\t\t\tparamNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);\n\t\t\t\t\t\t\tif (paramNames == null) {\n\t\t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\t\tif (pnd != null) {\n\t\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,\n\t\t\t\t\t\t\t\tgetUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring constructor [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Swallow and try next constructor.\n\t\t\t\t\t\tif (causes == null) {\n\t\t\t\t\t\t\tcauses = new ArrayDeque<>(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n\t\t\t\t\tif (parameterCount != explicitArgs.length) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n\t\t\t\t}\n\n\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n\t\t\t\t\tconstructorToUse = candidate;\n\t\t\t\t\targsHolderToUse = argsHolder;\n\t\t\t\t\targsToUse = argsHolder.arguments;\n\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n\t\t\t\t\tambiguousConstructors = null;\n\t\t\t\t}\n\t\t\t\telse if (constructorToUse != null && typeDiffWeight == minTypeDiffWeight) {\n\t\t\t\t\tif (ambiguousConstructors == null) {\n\t\t\t\t\t\tambiguousConstructors = new LinkedHashSet<>();\n\t\t\t\t\t\tambiguousConstructors.add(constructorToUse);\n\t\t\t\t\t}\n\t\t\t\t\tambiguousConstructors.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constructorToUse == null) {\n\t\t\t\tif (causes != null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Could not resolve matching constructor on bean class [\" + mbd.getBeanClassName() + \"] \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities. \" +\n\t\t\t\t\t\t\"You should also check the consistency of arguments when mixing indexed and named arguments, \" +\n\t\t\t\t\t\t\"especially in case of bean definition inheritance)\");\n\t\t\t}\n\t\t\telse if (ambiguousConstructors != null && !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous constructor matches found on bean class [\" + mbd.getBeanClassName() + \"] \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousConstructors);\n\t\t\t}\n\n\t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, constructorToUse);\n\t\t\t}\n\t\t}\n\n\t\tAssert.state(argsToUse != null, \"Unresolved constructor arguments\");\n\t\tbw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));\n\t\treturn bw;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#autowireConstructor(beanName,mbd,ctors,explicitArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "ctors",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1368
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#await(destroyMethod,returnValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destroyMethod",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "boolean",
    "signature": "public boolean await(Method destroyMethod, Object returnValue)",
    "source_code": "\t\tpublic boolean await(Method destroyMethod, Object returnValue) throws InterruptedException {\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(returnValue.getClass());\n\t\t\tif (adapter != null) {\n\t\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\t\tadapter.toPublisher(returnValue).subscribe(new DestroyMethodSubscriber(destroyMethod, latch));\n\t\t\t\tlatch.await();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkDependencies(beanName,mbd,pds,pvs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a dependency check that all properties exposed have been set,\n\t * if desired. Dependency checks can be objects (collaborating beans),\n\t * simple (primitives and String), or all (both).\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param pds the relevant property descriptors for the target bean\n\t * @param pvs the property values to be applied to the bean\n\t * @see #isExcludedFromDependencyCheck(java.beans.PropertyDescriptor)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "pds",
      "pvs"
    ],
    "position": {
      "column": 1,
      "line": 1623
    },
    "return": "void",
    "signature": "protected void checkDependencies(String beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)",
    "source_code": "\tprotected void checkDependencies(\n\t\t\tString beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)\n\t\t\tthrows UnsatisfiedDependencyException {\n\n\t\tint dependencyCheck = mbd.getDependencyCheck();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && (pvs == null || !pvs.contains(pd.getName()))) {\n\t\t\t\tboolean isSimple = BeanUtils.isSimpleProperty(pd.getPropertyType());\n\t\t\t\tboolean unsatisfied = (dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_ALL) ||\n\t\t\t\t\t\t(isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLE) ||\n\t\t\t\t\t\t(!isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\tif (unsatisfied) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, pd.getName(),\n\t\t\t\t\t\t\t\"Set this property value or disable dependency checking for this bean.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkForAliasCircle(name,alias)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Also checks for an alias overriding a bean definition of the same name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 1339
    },
    "return": "void",
    "signature": "protected void checkForAliasCircle(String name, String alias)",
    "source_code": "\tprotected void checkForAliasCircle(String name, String alias) {\n\t\tsuper.checkForAliasCircle(name, alias);\n\t\tif (!isBeanDefinitionOverridable(alias) && containsBeanDefinition(alias)) {\n\t\t\tthrow new IllegalStateException(\"Cannot register alias '\" + alias +\n\t\t\t\t\t\"' for name '\" + name + \"': Alias would override bean definition '\" + alias + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkGenericTypeMatch(bdHolder,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Match the given dependency type with its generic type information against the given\n\t * candidate bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "protected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tprotected boolean checkGenericTypeMatch(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tResolvableType dependencyType = descriptor.getResolvableType();\n\t\tif (dependencyType.getType() instanceof Class) {\n\t\t\t// No generic type -> we know it's a Class type-match, so no need to check again.\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvableType targetType = null;\n\t\tboolean cacheType = false;\n\t\tRootBeanDefinition rbd = null;\n\t\tif (bdHolder.getBeanDefinition() instanceof RootBeanDefinition rootBeanDef) {\n\t\t\trbd = rootBeanDef;\n\t\t}\n\t\tif (rbd != null) {\n\t\t\ttargetType = rbd.targetType;\n\t\t\tif (targetType == null) {\n\t\t\t\tcacheType = true;\n\t\t\t\t// First, check factory method return type, if applicable\n\t\t\t\ttargetType = getReturnTypeForFactoryMethod(rbd, descriptor);\n\t\t\t\tif (targetType == null) {\n\t\t\t\t\tRootBeanDefinition dbd = getResolvedDecoratedDefinition(rbd);\n\t\t\t\t\tif (dbd != null) {\n\t\t\t\t\t\ttargetType = dbd.targetType;\n\t\t\t\t\t\tif (targetType == null) {\n\t\t\t\t\t\t\ttargetType = getReturnTypeForFactoryMethod(dbd, descriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\t// Regular case: straight bean instance, with BeanFactory available.\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tClass<?> beanType = this.beanFactory.getType(bdHolder.getBeanName());\n\t\t\t\tif (beanType != null) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanType));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Fallback: no BeanFactory set, or no type resolvable through it\n\t\t\t// -> best-effort match against the target class if applicable.\n\t\t\tif (targetType == null && rbd != null && rbd.hasBeanClass() && rbd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = rbd.getBeanClass();\n\t\t\t\tif (!FactoryBean.class.isAssignableFrom(beanClass)) {\n\t\t\t\t\ttargetType = ResolvableType.forClass(ClassUtils.getUserClass(beanClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (targetType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (cacheType) {\n\t\t\trbd.targetType = targetType;\n\t\t}\n\n\t\t// Pre-declared target type: In case of a generic FactoryBean type,\n\t\t// unwrap nested generic type when matching a non-FactoryBean type.\n\t\tClass<?> targetClass = targetType.resolve();\n\t\tif (targetClass != null && FactoryBean.class.isAssignableFrom(targetClass)) {\n\t\t\tClass<?> classToMatch = dependencyType.resolve();\n\t\t\tif (classToMatch != null && !FactoryBean.class.isAssignableFrom(classToMatch) &&\n\t\t\t\t\t!classToMatch.isAssignableFrom(targetClass)) {\n\t\t\t\ttargetType = targetType.getGeneric();\n\t\t\t\tif (descriptor.fallbackMatchAllowed()) {\n\t\t\t\t\t// Matching the Class-based type determination for FactoryBean\n\t\t\t\t\t// objects in the lazy-determination getType code path above.\n\t\t\t\t\ttargetType = ResolvableType.forClass(targetType.resolve());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (descriptor.fallbackMatchAllowed()) {\n\t\t\t// Fallback matches allow unresolvable generics, for example, plain HashMap to Map<String,String>;\n\t\t\t// and pragmatically also java.util.Properties to any Map (since despite formally being a\n\t\t\t// Map<Object,Object>, java.util.Properties is usually perceived as a Map<String,String>).\n\t\t\tif (targetType.hasUnresolvableGenerics()) {\n\t\t\t\treturn dependencyType.isAssignableFromResolvedPart(targetType);\n\t\t\t}\n\t\t\telse if (targetType.resolve() == Properties.class) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Full check for complex generic type match...\n\t\treturn dependencyType.isAssignableFrom(targetType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#checkMergedBeanDefinition(mbd,beanName,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "beanName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 985
    },
    "return": "void",
    "signature": "protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)",
    "source_code": "\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {\n\t\tsuper.checkMergedBeanDefinition(mbd, beanName, args);\n\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for background \" +\n\t\t\t\t\t\t\"initialization but requested in mainline thread - declare ObjectProvider \" +\n\t\t\t\t\t\t\"or lazy injection point in dependent mainline beans\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Bean intended to be initialized in main bootstrap thread\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for mainline initialization \" +\n\t\t\t\t\t\t\"but requested in background thread - enforce early instantiation in mainline thread \" +\n\t\t\t\t\t\t\"through depends-on '\" + beanName + \"' declaration for dependent background beans\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#configureBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\tpublic Object configureBean(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition mbd = getMergedBeanDefinition(beanName);\n\t\tRootBeanDefinition bd = null;\n\t\tif (mbd instanceof RootBeanDefinition rbd) {\n\t\t\tbd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition());\n\t\t}\n\t\tif (bd == null) {\n\t\t\tbd = new RootBeanDefinition(mbd);\n\t\t}\n\t\tif (!bd.isPrototype()) {\n\t\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\t\tbd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader());\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(beanName, bd, bw);\n\t\treturn initializeBean(beanName, existingBean, bd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\treturn createBean(beanClass.getName(), bd, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBean(beanName,mbd,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean instance for the given merged bean definition (and arguments).\n\t * The bean definition will already have been merged with the parent definition\n\t * in case of a child definition.\n\t * <p>All bean retrieval methods delegate to this method for actual bean creation.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1981
    },
    "return": "Object",
    "signature": "protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException;\n\n\n\t/**\n\t * CopyOnWriteArrayList which resets the beanPostProcessorCache field on modification.\n\t *\n\t * @since 5.3\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate class BeanPostProcessorCacheAwareList extends CopyOnWriteArrayList<BeanPostProcessor> {\n\n\t\t@Override\n\t\tpublic BeanPostProcessor set(int index, BeanPostProcessor element) {\n\t\t\tBeanPostProcessor result = super.set(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(BeanPostProcessor o) {\n\t\t\tboolean success = super.add(o);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, BeanPostProcessor element) {\n\t\t\tsuper.add(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t}\n\n\t\t@Override\n\t\tpublic BeanPostProcessor remove(int index) {\n\t\t\tBeanPostProcessor result = super.remove(index);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tboolean success = super.remove(o);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean success = super.removeAll(c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tboolean success = super.retainAll(c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends BeanPostProcessor> c) {\n\t\t\tboolean success = super.addAll(index, c);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeIf(Predicate<? super BeanPostProcessor> filter) {\n\t\t\tboolean success = super.removeIf(filter);\n\t\t\tif (success) {\n\t\t\t\tresetBeanPostProcessorCache();\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\n\t\t@Override\n\t\tpublic void replaceAll(UnaryOperator<BeanPostProcessor> operator) {\n\t\t\tsuper.replaceAll(operator);\n\t\t\tresetBeanPostProcessorCache();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createBeanInstance(beanName,mbd,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n\t * factory method, constructor autowiring, or simple instantiation.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a BeanWrapper for the new instance\n\t * @see #obtainFromSupplier\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t * @see #instantiateBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1164
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n\t\t// Make sure bean class is actually resolved at this point.\n\t\tClass<?> beanClass = resolveBeanClass(mbd, beanName);\n\n\t\tif (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n\t\t}\n\n\t\tif (args == null) {\n\t\t\tSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\n\t\t\tif (instanceSupplier != null) {\n\t\t\t\treturn obtainFromSupplier(instanceSupplier, beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t\t}\n\n\t\t// Shortcut when re-creating the same bean...\n\t\tboolean resolved = false;\n\t\tboolean autowireNecessary = false;\n\t\tif (args == null) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (resolved) {\n\t\t\tif (autowireNecessary) {\n\t\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn instantiateBean(beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\t// Candidate constructors for autowiring?\n\t\tConstructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\t\tif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n\t\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t\t}\n\n\t\t// Preferred constructors for default construction?\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n\n\t\t// No special handling: simply use no-arg constructor.\n\t\treturn instantiateBean(beanName, mbd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#createDependencyProvider(descriptor,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 2487
    },
    "return": "Object",
    "signature": "public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName)",
    "source_code": "\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\treturn new Jsr330Provider(descriptor, beanName);\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#destroyBean(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Destroy the given bean instance (usually a prototype instance\n\t * obtained from this factory) according to the given bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bean the bean instance to destroy\n\t * @param mbd the merged bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1241
    },
    "return": "void",
    "signature": "protected void destroyBean(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void destroyBean(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tnew DisposableBeanAdapter(\n\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware).destroy();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#destroyBean(beanName,beanInstance)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 1230
    },
    "return": "void",
    "signature": "public void destroyBean(String beanName, Object beanInstance)",
    "source_code": "\tpublic void destroyBean(String beanName, Object beanInstance) {\n\t\tdestroyBean(beanName, beanInstance, getMergedLocalBeanDefinition(beanName));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determineAutowireCandidate(Map<String,candidates,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the autowire candidate in the given set of beans.\n\t * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).\n\t * @param candidates a Map of candidate names and candidate instances\n\t * that match the required type, as returned by {@link #findAutowireCandidates}\n\t * @param descriptor the target dependency to match against\n\t * @return the name of the autowire candidate, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 1902
    },
    "return": "String",
    "signature": "protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor)",
    "source_code": "\tprotected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {\n\t\tClass<?> requiredType = descriptor.getDependencyType();\n\t\t// Step 1: check primary candidate\n\t\tString primaryCandidate = determinePrimaryCandidate(candidates, requiredType);\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\t\t// Step 2a: match bean name against declared dependency name\n\t\tString dependencyName = descriptor.getDependencyName();\n\t\tif (dependencyName != null) {\n\t\t\tfor (String beanName : candidates.keySet()) {\n\t\t\t\tif (matchesBeanName(beanName, dependencyName)) {\n\t\t\t\t\treturn beanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Step 2b: match bean name against qualifier-suggested name\n\t\tString suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);\n\t\tif (suggestedName != null) {\n\t\t\tfor (String beanName : candidates.keySet()) {\n\t\t\t\tif (matchesBeanName(beanName, suggestedName)) {\n\t\t\t\t\treturn beanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Step 3: check highest priority candidate\n\t\tString priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);\n\t\tif (priorityCandidate != null) {\n\t\t\treturn priorityCandidate;\n\t\t}\n\t\t// Step 4: pick directly registered dependency\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) {\n\t\t\t\treturn candidateName;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determineHighestPriorityCandidate(Map<String,candidates,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the candidate with the highest priority in the given set of beans.\n\t * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related\n\t * {@link org.springframework.core.Ordered} interface, the lowest value has\n\t * the highest priority.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the candidate with the highest priority,\n\t * or {@code null} if none found\n\t * @throws NoUniqueBeanDefinitionException if multiple beans are detected with\n\t * the same highest priority value\n\t * @see #getPriority(Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 2004
    },
    "return": "String",
    "signature": "protected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType)",
    "source_code": "\tprotected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString highestPriorityBeanName = null;\n\t\tInteger highestPriority = null;\n\t\tboolean highestPriorityConflictDetected = false;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null) {\n\t\t\t\tInteger candidatePriority = getPriority(beanInstance);\n\t\t\t\tif (candidatePriority != null) {\n\t\t\t\t\tif (highestPriority != null) {\n\t\t\t\t\t\tif (candidatePriority.equals(highestPriority)) {\n\t\t\t\t\t\t\thighestPriorityConflictDetected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (candidatePriority < highestPriority) {\n\t\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t\t\thighestPriorityConflictDetected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (highestPriorityConflictDetected) {\n\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\"Multiple beans found with the same highest priority (\" + highestPriority +\n\t\t\t\t\t\") among candidates: \" + candidates.keySet());\n\n\t\t}\n\t\treturn highestPriorityBeanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#determinePrimaryCandidate(Map<String,candidates,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the primary candidate in the given set of beans.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see #isPrimary(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "candidates",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1952
    },
    "return": "String",
    "signature": "protected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType)",
    "source_code": "\tprotected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n\t\t\t\t\tif (candidateLocal == primaryLocal) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidates.keySet());\n\t\t\t\t\t}\n\t\t\t\t\telse if (candidateLocal) {\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidates.keySet()) {\n\t\t\t\tif (!isFallback(candidateBeanName)) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doCreateBean(beanName,mbd,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually create the specified bean. Pre-creation processing has already happened\n\t * at this point, for example, checking {@code postProcessBeforeInstantiation} callbacks.\n\t * <p>Differentiates between default bean instantiation, use of a\n\t * factory method, and autowiring a constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t * @see #instantiateBean\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "Object",
    "signature": "protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)",
    "source_code": "\tprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\tObject bean = instanceWrapper.getWrappedInstance();\n\t\tClass<?> beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.markAsPostProcessed();\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {\n\t\t\t\tthrow bce;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = CollectionUtils.newLinkedHashSet(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doGetBean(name,requiredType,args,typeCheckOnly)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @param typeCheckOnly whether the instance is obtained for a type check,\n\t * not for actual use\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "requiredType",
      "args",
      "typeCheckOnly"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "T",
    "signature": "protected T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)",
    "source_code": "\tprotected <T> T doGetBean(\n\t\t\tString name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)\n\t\t\tthrows BeansException {\n\n\t\tString beanName = transformedBeanName(name);\n\t\tObject beanInstance;\n\n\t\t// Eagerly check singleton cache for manually registered singletons.\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\tif (sharedInstance != null && args == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\tlogger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n\t\t\t\t\t\t\t\"' that is not fully initialized yet - a consequence of a circular reference\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t\t}\n\n\t\telse {\n\t\t\t// Fail if we're already creating this bean instance:\n\t\t\t// We're assumably within a circular reference.\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// Check if bean definition exists in this factory.\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// Not found -> check parent.\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory abf) {\n\t\t\t\t\treturn abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t}\n\t\t\t\telse if (args != null) {\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t}\n\t\t\t\telse if (requiredType != null) {\n\t\t\t\t\t// No args -> delegate to standard getBean method.\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\tStartupStep beanCreation = this.applicationStartup.start(\"spring.beans.instantiate\")\n\t\t\t\t\t.tag(\"beanName\", name);\n\t\t\ttry {\n\t\t\t\tif (requiredType != null) {\n\t\t\t\t\tbeanCreation.tag(\"beanType\", requiredType::toString);\n\t\t\t\t}\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\t\t\t\tif (requiredType != null) {\n\t\t\t\t\t\t\t\t// Wrap exception with current bean metadata but only if specifically\n\t\t\t\t\t\t\t\t// requested (indicated by required type), not for depends-on cascades.\n\t\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\t\"Failed to initialize dependency '\" + ex.getBeanName() + \"' of \" +\n\t\t\t\t\t\t\t\t\t\t\t\trequiredType.getSimpleName() + \" bean '\" + beanName + \"': \" +\n\t\t\t\t\t\t\t\t\t\t\t\tex.getMessage(), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create bean instance.\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t// It's a prototype -> create a new instance.\n\t\t\t\t\tObject prototypeInstance = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tbeanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\tif (!StringUtils.hasLength(scopeName)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No scope name defined for bean '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbeanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t\tthrow new ScopeNotActiveException(beanName, scopeName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tbeanCreation.tag(\"exception\", ex.getClass().toString());\n\t\t\t\tbeanCreation.tag(\"message\", String.valueOf(ex.getMessage()));\n\t\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tbeanCreation.end();\n\t\t\t\tif (!isCacheBeanMetadata()) {\n\t\t\t\t\tclearMergedBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn adaptBeanInstance(name, beanInstance, requiredType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#doResolveDependency(descriptor,beanName,autowiredBeanNames,typeConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "beanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 1519
    },
    "return": "Object",
    "signature": "public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\t// Step 1: pre-resolved shortcut for single bean match, for example, from @Autowired\n\t\t\tObject shortcut = descriptor.resolveShortcut(this);\n\t\t\tif (shortcut != null) {\n\t\t\t\treturn shortcut;\n\t\t\t}\n\n\t\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\t\t// Step 2: pre-defined value or expression, for example, from @Value\n\t\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof String strValue) {\n\t\t\t\t\tString resolvedValue = resolveEmbeddedValue(strValue);\n\t\t\t\t\tBeanDefinition bd = (beanName != null && containsBean(beanName) ?\n\t\t\t\t\t\t\tgetMergedBeanDefinition(beanName) : null);\n\t\t\t\t\tvalue = evaluateBeanDefinitionString(resolvedValue, bd);\n\t\t\t\t}\n\t\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\t\ttry {\n\t\t\t\t\treturn converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t\t// A custom TypeConverter which does not support TypeDescriptor resolution...\n\t\t\t\t\treturn (descriptor.getField() != null ?\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getField()) :\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 3: shortcut for declared dependency name or qualifier-suggested name matching target bean name\n\t\t\tif (descriptor.usesStandardBeanLookup()) {\n\t\t\t\tString dependencyName = descriptor.getDependencyName();\n\t\t\t\tif (dependencyName == null || !containsBean(dependencyName)) {\n\t\t\t\t\tString suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);\n\t\t\t\t\tdependencyName = (suggestedName != null && containsBean(suggestedName) ? suggestedName : null);\n\t\t\t\t}\n\t\t\t\tif (dependencyName != null) {\n\t\t\t\t\tdependencyName = canonicalName(dependencyName);  // dependency name can be alias of target name\n\t\t\t\t\tif (isTypeMatch(dependencyName, type) && isAutowireCandidate(dependencyName, descriptor) &&\n\t\t\t\t\t\t\t!isFallback(dependencyName) && !hasPrimaryConflict(dependencyName, type) &&\n\t\t\t\t\t\t\t!isSelfReference(beanName, dependencyName)) {\n\t\t\t\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\t\t\t\tautowiredBeanNames.add(dependencyName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject dependencyBean = getBean(dependencyName);\n\t\t\t\t\t\treturn resolveInstance(dependencyBean, descriptor, type, dependencyName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 4a: multiple beans as stream / array / standard collection / plain map\n\t\t\tObject multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tif (multipleBeans != null) {\n\t\t\t\treturn multipleBeans;\n\t\t\t}\n\t\t\t// Step 4b: direct bean matches, possibly direct beans of type Collection / Map\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\t// Step 4c (fallback): custom Collection / Map declarations for collecting multiple beans\n\t\t\t\tmultipleBeans = resolveMultipleBeansFallback(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\tif (multipleBeans != null) {\n\t\t\t\t\treturn multipleBeans;\n\t\t\t\t}\n\t\t\t\t// Raise exception if nothing found for required injection point\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString autowiredBeanName;\n\t\t\tObject instanceCandidate;\n\n\t\t\t// Step 5: determine single candidate\n\t\t\tif (matchingBeans.size() > 1) {\n\t\t\t\tautowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n\t\t\t\tif (autowiredBeanName == null) {\n\t\t\t\t\tif (isRequired(descriptor) || !indicatesArrayCollectionOrMap(type)) {\n\t\t\t\t\t\t// Raise exception if no clear match found for required injection point\n\t\t\t\t\t\treturn descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// In case of an optional Collection/Map, silently ignore a non-unique case:\n\t\t\t\t\t\t// possibly it was meant to be an empty collection of multiple regular beans\n\t\t\t\t\t\t// (before 4.3 in particular when we didn't even look for collection beans).\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinstanceCandidate = matchingBeans.get(autowiredBeanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have exactly one match.\n\t\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n\t\t\t\tautowiredBeanName = entry.getKey();\n\t\t\t\tinstanceCandidate = entry.getValue();\n\t\t\t}\n\n\t\t\t// Step 6: validate single result\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.add(autowiredBeanName);\n\t\t\t}\n\t\t\tif (instanceCandidate instanceof Class) {\n\t\t\t\tinstanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);\n\t\t\t}\n\t\t\treturn resolveInstance(instanceCandidate, descriptor, type, autowiredBeanName);\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluate(candidate,paramCount)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "candidate",
      "paramCount"
    ],
    "position": {
      "column": 1,
      "line": 1405
    },
    "return": "String[]",
    "signature": "public String[] evaluate(Constructor<?> candidate, int paramCount)",
    "source_code": "\t\tpublic static String[] evaluate(Constructor<?> candidate, int paramCount) {\n\t\t\tConstructorProperties cp = candidate.getAnnotation(ConstructorProperties.class);\n\t\t\tif (cp != null) {\n\t\t\t\tString[] names = cp.value();\n\t\t\t\tif (names.length != paramCount) {\n\t\t\t\t\tthrow new IllegalStateException(\"Constructor annotated with @ConstructorProperties but not \" +\n\t\t\t\t\t\t\t\"corresponding to actual number of parameters (\" + paramCount + \"): \" + candidate);\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#evaluateBeanDefinitionString(value,beanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the given String as contained in a bean definition,\n\t * potentially resolving it as an expression.\n\t * @param value the value to check\n\t * @param beanDefinition the bean definition that the value comes from\n\t * @return the resolved value\n\t * @see #setBeanExpressionResolver\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 1632
    },
    "return": "Object",
    "signature": "protected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition)",
    "source_code": "\tprotected Object evaluateBeanDefinitionString(@Nullable String value, @Nullable BeanDefinition beanDefinition) {\n\t\tif (this.beanExpressionResolver == null) {\n\t\t\treturn value;\n\t\t}\n\n\t\tScope scope = null;\n\t\tif (beanDefinition != null) {\n\t\t\tString scopeName = beanDefinition.getScope();\n\t\t\tif (scopeName != null) {\n\t\t\t\tscope = getRegisteredScope(scopeName);\n\t\t\t}\n\t\t}\n\t\treturn this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#filterPropertyDescriptorsForDependencyCheck(bw,cache)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @param cache whether to cache filtered PropertyDescriptors for the given bean Class\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t * @see #filterPropertyDescriptorsForDependencyCheck(org.springframework.beans.BeanWrapper)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bw",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 1569
    },
    "return": "PropertyDescriptor[]",
    "signature": "protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache)",
    "source_code": "\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache) {\n\t\tPropertyDescriptor[] filtered = this.filteredPropertyDescriptorsCache.get(bw.getWrappedClass());\n\t\tif (filtered == null) {\n\t\t\tfiltered = filterPropertyDescriptorsForDependencyCheck(bw);\n\t\t\tif (cache) {\n\t\t\t\tPropertyDescriptor[] existing =\n\t\t\t\t\t\tthis.filteredPropertyDescriptorsCache.putIfAbsent(bw.getWrappedClass(), filtered);\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tfiltered = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 800
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tSet<A> annotations = new LinkedHashSet<>();\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotations.from(beanType, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, for example, in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotations.from(beanClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotations.from(factoryMethod, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 753
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findAnnotationOnBean(beanName, annotationType, true);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 761
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\tMergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\tif (annotation.isPresent()) {\n\t\t\t\treturn annotation.synthesize();\n\t\t\t}\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, for example, in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\t\tMergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\tMergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#findAutowireCandidates(beanName,requiredType,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find bean instances that match the required type.\n\t * Called during autowiring for the specified bean.\n\t * @param beanName the name of the bean that is about to be wired\n\t * @param requiredType the actual type of bean to look for\n\t * (may be an array component type or collection element type)\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @return a Map of candidate names and candidate instances that match\n\t * the required type (never {@code null})\n\t * @throws BeansException in case of errors\n\t * @see #autowireByType\n\t * @see #autowireConstructor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "requiredType",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 1823
    },
    "return": "Object>",
    "signature": "protected Object> findAutowireCandidates(@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor)",
    "source_code": "\tprotected Map<String, Object> findAutowireCandidates(\n\t\t\t@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {\n\n\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tthis, requiredType, true, descriptor.isEager());\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\tfor (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {\n\t\t\tClass<?> autowiringType = classObjectEntry.getKey();\n\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n\t\t\t\tObject autowiringValue = classObjectEntry.getValue();\n\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (String candidate : candidateNames) {\n\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n\t\tif (result.isEmpty()) {\n\t\t\tboolean multiple = indicatesArrayCollectionOrMap(requiredType);\n\t\t\t// Consider fallback matches if the first pass failed to find anything...\n\t\t\tDependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();\n\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&\n\t\t\t\t\t\t(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {\n\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isEmpty() && !multiple) {\n\t\t\t\t// Consider self references as a final pass...\n\t\t\t\t// but in the case of a dependency collection, not the very same bean itself.\n\t\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t\tif (isSelfReference(beanName, candidate) &&\n\t\t\t\t\t\t\t(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&\n\t\t\t\t\t\t\tisAutowireCandidate(candidate, fallbackDescriptor)) {\n\t\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn doGetBean(name, null, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn doGetBean(name, requiredType, null, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(name,requiredType,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\n\t * @param requiredType the required type of the bean to retrieve\n\t * @param args arguments to use when creating a bean instance using explicit arguments\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "T",
    "signature": "public T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n\t\t\tthrows BeansException {\n\n\t\treturn doGetBean(name, requiredType, args, false);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBean(requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tObject resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);\n\t\tif (resolved == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t\treturn (T) resolved;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tif (!isConfigurationFrozen() || type == null || !allowEagerInit) {\n\t\t\treturn doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);\n\t\t}\n\t\tMap<Class<?>, String[]> cache =\n\t\t\t\t(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);\n\t\tString[] resolvedBeanNames = cache.get(type);\n\t\tif (resolvedBeanNames != null) {\n\t\t\treturn resolvedBeanNames;\n\t\t}\n\t\tresolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);\n\t\tif (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {\n\t\t\tcache.put(type, resolvedBeanNames);\n\t\t}\n\t\treturn resolvedBeanNames;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new BeanObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, null, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, args, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, false);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfAvailable();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, true);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfUnique();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForTypedStream(requiredType, allowEagerInit))\n\t\t\t\t\t\t.map(name -> (T) getBean(name))\n\t\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\tString[] beanNames = getBeanNamesForTypedStream(requiredType, allowEagerInit);\n\t\t\t\tif (beanNames.length == 0) {\n\t\t\t\t\treturn Stream.empty();\n\t\t\t\t}\n\t\t\t\tMap<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\t\tfor (String beanName : beanNames) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, (T) beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStream<T> stream = matchingBeans.values().stream();\n\t\t\t\treturn stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(\n\t\t\t@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {\n\n\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tMap<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\ttry {\n\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\tresult.put(beanName, (T) beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\tString exBeanName = bce.getBeanName();\n\t\t\t\t\tif (exBeanName != null && isCurrentlyInCreation(exBeanName)) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring match to currently created bean '\" + exBeanName + \"': \" +\n\t\t\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getEarlyBeanReference(beanName,mbd,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a reference for early access to the specified bean,\n\t * typically for the purpose of resolving a circular reference.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param bean the raw bean instance\n\t * @return the object to expose as bean reference\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 969
    },
    "return": "Object",
    "signature": "protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean)",
    "source_code": "\tprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\texposedObject = bp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getMergedBeanDefinition(beanName,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a RootBeanDefinition for the given top-level bean, by merging with\n\t * the parent if the given bean's definition is a child bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bd the original bean definition (Root/ChildBeanDefinition)\n\t * @return a (potentially merged) RootBeanDefinition for the given bean\n\t * @throws BeanDefinitionStoreException in case of an invalid bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1372
    },
    "return": "RootBeanDefinition",
    "signature": "protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)",
    "source_code": "\tprotected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\treturn getMergedBeanDefinition(beanName, bd, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getMergedBeanDefinition(beanName,bd,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a RootBeanDefinition for the given bean, by merging with the\n\t * parent if the given bean's definition is a child bean definition.\n\t * @param beanName the name of the bean definition\n\t * @param bd the original bean definition (Root/ChildBeanDefinition)\n\t * @param containingBd the containing bean definition in case of inner bean,\n\t * or {@code null} in case of a top-level bean\n\t * @return a (potentially merged) RootBeanDefinition for the given bean\n\t * @throws BeanDefinitionStoreException in case of an invalid bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bd",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1388
    },
    "return": "RootBeanDefinition",
    "signature": "protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)",
    "source_code": "\tprotected RootBeanDefinition getMergedBeanDefinition(\n\t\t\tString beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tsynchronized (this.mergedBeanDefinitions) {\n\t\t\tRootBeanDefinition mbd = null;\n\t\t\tRootBeanDefinition previous = null;\n\n\t\t\t// Check with full lock now in order to enforce the same merged instance.\n\t\t\tif (containingBd == null) {\n\t\t\t\tmbd = this.mergedBeanDefinitions.get(beanName);\n\t\t\t}\n\n\t\t\tif (mbd == null || mbd.stale) {\n\t\t\t\tprevious = mbd;\n\t\t\t\tif (bd.getParentName() == null) {\n\t\t\t\t\t// Use copy of given root bean definition.\n\t\t\t\t\tif (bd instanceof RootBeanDefinition rootBeanDef) {\n\t\t\t\t\t\tmbd = rootBeanDef.cloneBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmbd = new RootBeanDefinition(bd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Child bean definition: needs to be merged with parent.\n\t\t\t\t\tBeanDefinition pbd;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString parentBeanName = transformedBeanName(bd.getParentName());\n\t\t\t\t\t\tif (!beanName.equals(parentBeanName)) {\n\t\t\t\t\t\t\tpbd = getMergedBeanDefinition(parentBeanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (getParentBeanFactory() instanceof ConfigurableBeanFactory parent) {\n\t\t\t\t\t\t\t\tpbd = parent.getMergedBeanDefinition(parentBeanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(parentBeanName,\n\t\t\t\t\t\t\t\t\t\t\"Parent name '\" + parentBeanName + \"' is equal to bean name '\" + beanName +\n\t\t\t\t\t\t\t\t\t\t\t\t\"': cannot be resolved without a ConfigurableBeanFactory parent\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Could not resolve parent bean definition '\" + bd.getParentName() + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\t// Deep copy with overridden values.\n\t\t\t\t\tmbd = new RootBeanDefinition(pbd);\n\t\t\t\t\tmbd.overrideFrom(bd);\n\t\t\t\t}\n\n\t\t\t\t// Set default singleton scope, if not configured before.\n\t\t\t\tif (!StringUtils.hasLength(mbd.getScope())) {\n\t\t\t\t\tmbd.setScope(SCOPE_SINGLETON);\n\t\t\t\t}\n\n\t\t\t\t// A bean contained in a non-singleton bean cannot be a singleton itself.\n\t\t\t\t// Let's correct this on the fly here, since this might be the result of\n\t\t\t\t// parent-child merging for the outer bean, in which case the original inner bean\n\t\t\t\t// definition will not have inherited the merged outer bean's singleton status.\n\t\t\t\tif (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {\n\t\t\t\t\tmbd.setScope(containingBd.getScope());\n\t\t\t\t}\n\n\t\t\t\t// Cache the merged bean definition for the time being\n\t\t\t\t// (it might still get re-merged later on in order to pick up metadata changes)\n\t\t\t\tif (containingBd == null && (isCacheBeanMetadata() || isBeanEligibleForMetadataCaching(beanName))) {\n\t\t\t\t\tthis.mergedBeanDefinitions.put(beanName, mbd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (previous != null) {\n\t\t\t\tcopyRelevantMergedBeanDefinitionCaches(previous, mbd);\n\t\t\t}\n\t\t\treturn mbd;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectForBeanInstance(beanInstance,name,beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the object for the given bean instance, either the bean\n\t * instance itself or its created object in case of a FactoryBean.\n\t * @param beanInstance the shared bean instance\n\t * @param name the name that may include factory dereference prefix\n\t * @param beanName the canonical bean name\n\t * @param mbd the merged bean definition\n\t * @return the object to expose for the bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanInstance",
      "name",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1825
    },
    "return": "Object",
    "signature": "protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object getObjectForBeanInstance(\n\t\t\tObject beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {\n\n\t\t// Don't let calling code try to dereference the factory if the bean isn't a factory.\n\t\tif (BeanFactoryUtils.isFactoryDereference(name)) {\n\t\t\tif (beanInstance instanceof NullBean) {\n\t\t\t\treturn beanInstance;\n\t\t\t}\n\t\t\tif (!(beanInstance instanceof FactoryBean)) {\n\t\t\t\tthrow new BeanIsNotAFactoryException(beanName, beanInstance.getClass());\n\t\t\t}\n\t\t\tif (mbd != null) {\n\t\t\t\tmbd.isFactoryBean = true;\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\n\t\t// Now we have the bean instance, which may be a normal bean or a FactoryBean.\n\t\t// If it's a FactoryBean, we use it to create a bean instance, unless the\n\t\t// caller actually wants a reference to the factory.\n\t\tif (!(beanInstance instanceof FactoryBean<?> factoryBean)) {\n\t\t\treturn beanInstance;\n\t\t}\n\n\t\tObject object = null;\n\t\tif (mbd != null) {\n\t\t\tmbd.isFactoryBean = true;\n\t\t}\n\t\telse {\n\t\t\tobject = getCachedObjectForFactoryBean(beanName);\n\t\t}\n\t\tif (object == null) {\n\t\t\t// Return bean instance from factory.\n\t\t\t// Caches object obtained from FactoryBean if it is a singleton.\n\t\t\tif (mbd == null && containsBeanDefinition(beanName)) {\n\t\t\t\tmbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t}\n\t\t\tboolean synthetic = (mbd != null && mbd.isSynthetic());\n\t\t\tobject = getObjectFromFactoryBean(factoryBean, beanName, !synthetic);\n\t\t}\n\t\treturn object;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getObjectFromFactoryBean(factory,beanName,shouldPostProcess)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an object to expose from the given FactoryBean.\n\t * @param factory the FactoryBean instance\n\t * @param beanName the name of the bean\n\t * @param shouldPostProcess whether the bean is subject to post-processing\n\t * @return the object obtained from the FactoryBean\n\t * @throws BeanCreationException if FactoryBean object creation failed\n\t * @see org.springframework.beans.factory.FactoryBean#getObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "beanName",
      "shouldPostProcess"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Object",
    "signature": "protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess)",
    "source_code": "\tprotected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n\t\tif (factory.isSingleton() && containsSingleton(beanName)) {\n\t\t\tObject object = this.factoryBeanObjectCache.get(beanName);\n\t\t\tif (object == null) {\n\t\t\t\tobject = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\t\t// Only post-process and store if not put there already during getObject() call above\n\t\t\t\t// (for example, because of circular reference processing triggered by custom getBean calls)\n\t\t\t\tObject alreadyThere = this.factoryBeanObjectCache.get(beanName);\n\t\t\t\tif (alreadyThere != null) {\n\t\t\t\t\tobject = alreadyThere;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (shouldPostProcess) {\n\t\t\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\t\t\t// Temporarily return non-post-processed object, not storing it yet\n\t\t\t\t\t\t\treturn object;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\t\"Post-processing of FactoryBean's singleton object failed\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (containsSingleton(beanName)) {\n\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t\telse {\n\t\t\tObject object = doGetObjectFromFactoryBean(factory, beanName);\n\t\t\tif (shouldPostProcess) {\n\t\t\t\ttry {\n\t\t\t\t\tobject = postProcessObjectFromFactoryBean(object, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getReturnTypeForFactoryMethod(rbd,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rbd",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor)",
    "source_code": "\tprotected ResolvableType getReturnTypeForFactoryMethod(RootBeanDefinition rbd, DependencyDescriptor descriptor) {\n\t\t// Should typically be set for any kind of factory method, since the BeanFactory\n\t\t// pre-resolves them before reaching out to the AutowireCandidateResolver...\n\t\tResolvableType returnType = rbd.factoryMethodReturnType;\n\t\tif (returnType == null) {\n\t\t\tMethod factoryMethod = rbd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\treturnType = ResolvableType.forMethodReturnType(factoryMethod);\n\t\t\t}\n\t\t}\n\t\tif (returnType != null) {\n\t\t\tClass<?> resolvedClass = returnType.resolve();\n\t\t\tif (resolvedClass != null && descriptor.getDependencyType().isAssignableFrom(resolvedClass)) {\n\t\t\t\t// Only use factory method metadata if the return type is actually expressive enough\n\t\t\t\t// for our dependency. Otherwise, the returned instance type may have matched instead\n\t\t\t\t// in case of a singleton instance having been registered with the container already.\n\t\t\t\treturn returnType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#getTypeForFactoryBean(beanName,mbd,allowInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the bean type for the given FactoryBean definition, as far as possible.\n\t * Only called if there is no singleton instance registered for the target bean\n\t * already. The implementation is allowed to instantiate the target factory bean if\n\t * {@code allowInit} is {@code true} and the type cannot be determined another way;\n\t * otherwise it is restricted to introspecting signatures and related metadata.\n\t * <p>If no {@link FactoryBean#OBJECT_TYPE_ATTRIBUTE} is set on the bean definition\n\t * and {@code allowInit} is {@code true}, the default implementation will create\n\t * the FactoryBean via {@code getBean} to call its {@code getObjectType} method.\n\t * Subclasses are encouraged to optimize this, typically by inspecting the generic\n\t * signature of the factory bean class or the factory method that creates it.\n\t * If subclasses do instantiate the FactoryBean, they should consider trying the\n\t * {@code getObjectType} method without fully populating the bean. If this fails,\n\t * a full FactoryBean creation as performed by this implementation should be used\n\t * as fallback.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param allowInit if initialization of the FactoryBean is permitted if the type\n\t * cannot be determined another way\n\t * @return the type for the bean if determinable, otherwise {@code ResolvableType.NONE}\n\t * @since 5.2\n\t * @see org.springframework.beans.factory.FactoryBean#getObjectType()\n\t * @see #getBean(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "allowInit"
    ],
    "position": {
      "column": 1,
      "line": 1714
    },
    "return": "ResolvableType",
    "signature": "protected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit)",
    "source_code": "\tprotected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit) {\n\t\ttry {\n\t\t\tResolvableType result = getTypeForFactoryBeanFromAttributes(mbd);\n\t\t\tif (result != ResolvableType.NONE) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\tString.valueOf(ex.getMessage()));\n\t\t}\n\n\t\tif (allowInit && mbd.isSingleton()) {\n\t\t\ttry {\n\t\t\t\tFactoryBean<?> factoryBean = doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, null, true);\n\t\t\t\tClass<?> objectType = getTypeForFactoryBean(factoryBean);\n\t\t\t\treturn (objectType != null ? ResolvableType.forClass(objectType) : ResolvableType.NONE);\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tif (ex.contains(BeanCurrentlyInCreationException.class)) {\n\t\t\t\t\tlogger.trace(LogMessage.format(\"Bean currently in creation on FactoryBean type check: %s\", ex));\n\t\t\t\t}\n\t\t\t\telse if (mbd.isLazyInit()) {\n\t\t\t\t\tlogger.trace(LogMessage.format(\"Bean creation exception on lazy FactoryBean type check: %s\", ex));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(LogMessage.format(\"Bean creation exception on eager FactoryBean type check: %s\", ex));\n\t\t\t\t}\n\t\t\t\tonSuppressedException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// FactoryBean type not resolvable\n\t\treturn ResolvableType.NONE;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#hasApplicableProcessors(bean,postProcessors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean has destruction-aware post-processors applying to it.\n\t * @param bean the bean instance\n\t * @param postProcessors the post-processor candidates\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "postProcessors"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "boolean",
    "signature": "public boolean hasApplicableProcessors(Object bean, List<DestructionAwareBeanPostProcessor> postProcessors)",
    "source_code": "\tpublic static boolean hasApplicableProcessors(Object bean, List<DestructionAwareBeanPostProcessor> postProcessors) {\n\t\tif (!CollectionUtils.isEmpty(postProcessors)) {\n\t\t\tfor (DestructionAwareBeanPostProcessor processor : postProcessors) {\n\t\t\t\tif (processor.requiresDestruction(bean)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#hasDestroyMethod(bean,beanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean has any kind of destroy method to call.\n\t * @param bean the bean instance\n\t * @param beanDefinition the corresponding bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "boolean",
    "signature": "public boolean hasDestroyMethod(Object bean, RootBeanDefinition beanDefinition)",
    "source_code": "\tpublic static boolean hasDestroyMethod(Object bean, RootBeanDefinition beanDefinition) {\n\t\treturn (bean instanceof DisposableBean ||\n\t\t\t\tinferDestroyMethodsIfNecessary(bean.getClass(), beanDefinition) != null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#initializeBean(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the given bean instance, applying factory callbacks\n\t * as well as init methods and bean post processors.\n\t * <p>Called from {@link #createBean} for traditionally defined beans,\n\t * and from {@link #initializeBean} for existing bean instances.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @return the initialized bean instance (potentially wrapped)\n\t * @see BeanNameAware\n\t * @see BeanClassLoaderAware\n\t * @see BeanFactoryAware\n\t * @see #applyBeanPostProcessorsBeforeInitialization\n\t * @see #invokeInitMethods\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1789
    },
    "return": "Object",
    "signature": "protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tinvokeAwareMethods(beanName, bean);\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#initializeBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\tpublic Object initializeBean(Object existingBean, String beanName) {\n\t\treturn initializeBean(beanName, existingBean, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(bd,beanName,owner)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\t// Don't override the class with CGLIB if no overrides.\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\tConstructor<?> constructorToUse;\n\t\t\tsynchronized (bd.constructorArgumentLock) {\n\t\t\t\tconstructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (constructorToUse == null) {\n\t\t\t\t\tClass<?> clazz = bd.getBeanClass();\n\t\t\t\t\tif (clazz.isInterface()) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"Specified class is an interface\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconstructorToUse = clazz.getDeclaredConstructor();\n\t\t\t\t\t\tbd.resolvedConstructorOrFactoryMethod = constructorToUse;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn BeanUtils.instantiateClass(constructorToUse);\n\t\t}\n\t\telse {\n\t\t\t// Must generate CGLIB subclass.\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(bd,beanName,owner,ctor,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\tConstructor<?> ctor, Object... args)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\tConstructor<?> ctor, Object... args) {\n\n\t\tif (!bd.hasMethodOverrides()) {\n\t\t\treturn BeanUtils.instantiateClass(ctor, args);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateWithMethodInjection(bd, beanName, owner, ctor, args);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(bd,beanName,owner,factoryBean,factoryMethod,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "factoryBean",
      "factoryMethod",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "Object",
    "signature": "public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Object factoryBean, Method factoryMethod, Object... args)",
    "source_code": "\tpublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Object factoryBean, Method factoryMethod, Object... args) {\n\n\t\treturn instantiateWithFactoryMethod(factoryMethod, () -> {\n\t\t\ttry {\n\t\t\t\tReflectionUtils.makeAccessible(factoryMethod);\n\t\t\t\tObject result = factoryMethod.invoke(factoryBean, args);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = new NullBean();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tif (factoryBean != null && !factoryMethod.getDeclaringClass().isAssignableFrom(factoryBean.getClass())) {\n\t\t\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\t\t\"Illegal factory instance for factory method '\" + factoryMethod.getName() + \"'; \" +\n\t\t\t\t\t\t\t\t\t\"instance: \" + factoryBean.getClass().getName(), ex);\n\t\t\t\t}\n\t\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\t\"Illegal arguments to factory method '\" + factoryMethod.getName() + \"'; \" +\n\t\t\t\t\t\t\t\t\"args: \" + StringUtils.arrayToCommaDelimitedString(args), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new BeanInstantiationException(factoryMethod,\n\t\t\t\t\t\t\"Cannot access factory method '\" + factoryMethod.getName() + \"'; is it public?\", ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tString msg = \"Factory method '\" + factoryMethod.getName() + \"' threw exception with message: \" +\n\t\t\t\t\t\tex.getTargetException().getMessage();\n\t\t\t\tif (bd.getFactoryBeanName() != null && owner instanceof ConfigurableBeanFactory cbf &&\n\t\t\t\t\t\tcbf.isCurrentlyInCreation(bd.getFactoryBeanName())) {\n\t\t\t\t\tmsg = \"Circular reference involving containing bean '\" + bd.getFactoryBeanName() + \"' - consider \" +\n\t\t\t\t\t\t\t\"declaring the factory method as static for independence from its containing instance. \" + msg;\n\t\t\t\t}\n\t\t\t\tthrow new BeanInstantiationException(factoryMethod, msg, ex.getTargetException());\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiate(ctor,args)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create a new instance of a dynamically generated subclass implementing the\n\t\t * required lookups.\n\t\t * @param ctor constructor to use. If this is {@code null}, use the\n\t\t * no-arg constructor (no parameterization, or Setter Injection)\n\t\t * @param args arguments to use for the constructor.\n\t\t * Ignored if the {@code ctor} parameter is {@code null}.\n\t\t * @return new instance of the dynamically generated subclass\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "public Object instantiate(@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\t\tpublic Object instantiate(@Nullable Constructor<?> ctor, Object... args) {\n\t\t\tClass<?> subclass = createEnhancedSubclass(this.beanDefinition);\n\t\t\tObject instance;\n\t\t\tif (ctor == null) {\n\t\t\t\tinstance = BeanUtils.instantiateClass(subclass);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tConstructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());\n\t\t\t\t\tinstance = enhancedSubclassConstructor.newInstance(args);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new BeanInstantiationException(this.beanDefinition.getBeanClass(),\n\t\t\t\t\t\t\t\"Failed to invoke constructor for CGLIB enhanced subclass [\" + subclass.getName() + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SPR-10785: set callbacks directly on the instance instead of in the\n\t\t\t// enhanced class (via the Enhancer) in order to avoid memory leaks.\n\t\t\tFactory factory = (Factory) instance;\n\t\t\tfactory.setCallbacks(new Callback[] {NoOp.INSTANCE,\n\t\t\t\t\tnew LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),\n\t\t\t\t\tnew ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});\n\t\t\treturn instance;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateBean(beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the given bean using its default constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return a BeanWrapper for the new instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1325
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {\n\t\ttry {\n\t\t\tObject beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);\n\t\t\tBeanWrapper bw = new BeanWrapperImpl(beanInstance);\n\t\t\tinitBeanWrapper(bw);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateUsingFactoryMethod(beanName,mbd,explicitArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * mbd parameter specifies a class, rather than a factoryBean, or an instance variable\n\t * on a factory object itself configured using Dependency Injection.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t * @see #getBean(String, Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "explicitArgs"
    ],
    "position": {
      "column": 1,
      "line": 1348
    },
    "return": "BeanWrapper",
    "signature": "protected BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)",
    "source_code": "\tprotected BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithFactoryMethod(method,instanceSupplier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@code instanceSupplier} with the factory method exposed\n\t * as being invoked.\n\t * @param method the factory method to expose\n\t * @param instanceSupplier the instance supplier\n\t * @param <T> the type of the instance\n\t * @return the result of the instance supplier\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "instanceSupplier"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "T",
    "signature": "public T instantiateWithFactoryMethod(Method method, Supplier<T> instanceSupplier)",
    "source_code": "\tpublic static <T> T instantiateWithFactoryMethod(Method method, Supplier<T> instanceSupplier) {\n\t\tMethod priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();\n\t\ttry {\n\t\t\tcurrentlyInvokedFactoryMethod.set(method);\n\t\t\treturn instanceSupplier.get();\n\t\t}\n\t\tfinally {\n\t\t\tif (priorInvokedFactoryMethod != null) {\n\t\t\t\tcurrentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrentlyInvokedFactoryMethod.remove();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithMethodInjection(bd,beanName,owner)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n\t\treturn instantiateWithMethodInjection(bd, beanName, owner, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#instantiateWithMethodInjection(bd,beanName,owner,ctor,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "beanName",
      "owner",
      "ctor",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "Object",
    "signature": "protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args)",
    "source_code": "\tprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,\n\t\t\t@Nullable Constructor<?> ctor, Object... args) {\n\n\t\treturn new CglibSubclassCreator(bd, owner).instantiate(ctor, args);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#intercept(obj,method,args,mp)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "mp"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n\t\t\tReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n\t\t\tAssert.state(ro != null, \"ReplaceOverride not found\");\n\t\t\t// TODO could cache if a singleton for minor performance optimization\n\t\t\tMethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class);\n\t\t\treturn processReturnType(method, mr.reimplement(obj, method, args));\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\tcase \"equals\" -> (proxy == args[0]); // Only consider equal when proxies are identical.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy); // Use hashCode of proxy.\n\t\t\t\tcase \"toString\" -> this.objectFactory.toString();\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tyield method.invoke(this.objectFactory.getObject(), args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invokeCustomInitMethod(beanName,bean,mbd,initMethodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified custom init method on the given bean.\n\t * <p>Called by {@link #invokeInitMethods(String, Object, RootBeanDefinition)}.\n\t * <p>Can be overridden in subclasses for custom resolution of init methods\n\t * with arguments.\n\t * @see #invokeInitMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd",
      "initMethodName"
    ],
    "position": {
      "column": 1,
      "line": 1873
    },
    "return": "void",
    "signature": "protected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)",
    "source_code": "\tprotected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)\n\t\t\tthrows Throwable {\n\n\t\tClass<?> beanClass = bean.getClass();\n\t\tMethodDescriptor descriptor = MethodDescriptor.create(beanName, beanClass, initMethodName);\n\t\tString methodName = descriptor.methodName();\n\n\t\tMethod initMethod = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\tBeanUtils.findMethod(descriptor.declaringClass(), methodName) :\n\t\t\t\tClassUtils.getMethodIfAvailable(beanClass, methodName));\n\n\t\tif (initMethod == null) {\n\t\t\tif (mbd.isEnforceInitMethod()) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\"Could not find an init method named '\" +\n\t\t\t\t\t\tmethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No default init method named '\" + methodName +\n\t\t\t\t\t\t\t\"' found on bean with name '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t\t// Ignore non-existent default lifecycle methods.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking init method '\" + methodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t}\n\t\tMethod methodToInvoke = ClassUtils.getPubliclyAccessibleMethodIfPossible(initMethod, beanClass);\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(methodToInvoke);\n\t\t\tmethodToInvoke.invoke(bean);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#invokeInitMethods(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Give a bean a chance to initialize itself after all its properties are set,\n\t * and a chance to know about its owning bean factory (this object).\n\t * <p>This means checking whether the bean implements {@link InitializingBean}\n\t * or defines any custom init methods, and invoking the necessary callback(s)\n\t * if it does.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the merged bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @throws Throwable if thrown by init methods or by the invocation process\n\t * @see #invokeCustomInitMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1841
    },
    "return": "void",
    "signature": "protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)",
    "source_code": "\tprotected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)\n\t\t\tthrows Throwable {\n\n\t\tboolean isInitializingBean = (bean instanceof InitializingBean);\n\t\tif (isInitializingBean && (mbd == null || !mbd.hasAnyExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t}\n\n\t\tif (mbd != null && bean.getClass() != NullBean.class) {\n\t\t\tString[] initMethodNames = mbd.getInitMethodNames();\n\t\t\tif (initMethodNames != null) {\n\t\t\t\tfor (String initMethodName : initMethodNames) {\n\t\t\t\t\tif (StringUtils.hasLength(initMethodName) &&\n\t\t\t\t\t\t\t!(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) &&\n\t\t\t\t\t\t\t!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {\n\t\t\t\t\t\tinvokeCustomInitMethod(beanName, bean, mbd, initMethodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(bdHolder,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bdHolder",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) {\n\t\tif (!super.isAutowireCandidate(bdHolder, descriptor)) {\n\t\t\t// If explicitly false, do not proceed with any other checks...\n\t\t\treturn false;\n\t\t}\n\t\treturn checkGenericTypeMatch(bdHolder, descriptor);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 854
    },
    "return": "boolean",
    "signature": "public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)",
    "source_code": "\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,descriptor,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(\n\t\t\tString beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(bdName)) {\n\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);\n\t\t}\n\t\telse if (containsSingleton(beanName)) {\n\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);\n\t\t}\n\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlbf) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn dlbf.isAutowireCandidate(beanName, descriptor, resolver);\n\t\t}\n\t\telse if (parent instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\t// If no DefaultListableBeanFactory, can't pass the resolver along.\n\t\t\treturn clbf.isAutowireCandidate(beanName, descriptor);\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isAutowireCandidate(beanName,mbd,descriptor,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param mbd the merged bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "descriptor",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 903
    },
    "return": "boolean",
    "signature": "protected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver)",
    "source_code": "\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver) {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tresolveBeanClass(mbd, bdName);\n\t\tif (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {\n\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n\t\t}\n\t\tBeanDefinitionHolder holder = (beanName.equals(bdName) ?\n\t\t\t\tthis.mergedBeanDefinitionHolders.computeIfAbsent(beanName,\n\t\t\t\t\t\tkey -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :\n\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));\n\t\treturn resolver.isAutowireCandidate(holder, descriptor);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isFactoryBean(beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given bean is defined as a {@link FactoryBean}.\n\t * @param beanName the name of the bean\n\t * @param mbd the corresponding bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1680
    },
    "return": "boolean",
    "signature": "protected boolean isFactoryBean(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected boolean isFactoryBean(String beanName, RootBeanDefinition mbd) {\n\t\tBoolean result = mbd.isFactoryBean;\n\t\tif (result == null) {\n\t\t\tClass<?> beanType = predictBeanType(beanName, mbd, FactoryBean.class);\n\t\t\tresult = (beanType != null && FactoryBean.class.isAssignableFrom(beanType));\n\t\t\tmbd.isFactoryBean = result;\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isPrimary(beanName,beanInstance)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a primary bean.\n\t * @param beanName the name of the bean\n\t * @param beanInstance the corresponding bean instance (can be {@code null})\n\t * @return whether the given bean qualifies as primary\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanInstance"
    ],
    "position": {
      "column": 1,
      "line": 2048
    },
    "return": "boolean",
    "signature": "protected boolean isPrimary(String beanName, Object beanInstance)",
    "source_code": "\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isPrimary();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isPrimary(transformedBeanName, beanInstance));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isSetterDefinedInInterface(pd,interfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the setter method of the given bean property is defined\n\t * in any of the given interfaces.\n\t * @param pd the PropertyDescriptor of the bean property\n\t * @param interfaces the Set of interfaces (Class objects)\n\t * @return whether the setter method is defined by an interface\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pd",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces)",
    "source_code": "\tpublic static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {\n\t\tMethod setter = pd.getWriteMethod();\n\t\tif (setter != null) {\n\t\t\tClass<?> targetClass = setter.getDeclaringClass();\n\t\t\tfor (Class<?> ifc : interfaces) {\n\t\t\t\tif (ifc.isAssignableFrom(targetClass) && ClassUtils.hasMethod(ifc, setter)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn isTypeMatch(name, ResolvableType.forRawClass(typeToMatch));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#isTypeMatch(name,typeToMatch,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Internal extended variant of {@link #isTypeMatch(String, ResolvableType)}\n\t * to check whether the bean with the given name matches the specified type. Allow\n\t * additional constraints to be applied to ensure that beans are not created early.\n\t * @param name the name of the bean to query\n\t * @param typeToMatch the type to match against (as a\n\t * {@code ResolvableType})\n\t * @return {@code true} if the bean type matches, {@code false} if it\n\t * doesn't match or cannot be determined yet\n\t * @throws NoSuchBeanDefinitionException if there is no bean with the given name\n\t * @since 5.2\n\t * @see #getBean\n\t * @see #getType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "typeToMatch",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "boolean",
    "signature": "protected boolean isTypeMatch(String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)",
    "source_code": "\tprotected boolean isTypeMatch(String name, ResolvableType typeToMatch, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString beanName = transformedBeanName(name);\n\t\tboolean isFactoryDereference = BeanFactoryUtils.isFactoryDereference(name);\n\n\t\t// Check manually registered singletons.\n\t\tObject beanInstance = getSingleton(beanName, false);\n\t\tif (beanInstance != null && beanInstance.getClass() != NullBean.class) {\n\n\t\t\t// Determine target for FactoryBean match if necessary.\n\t\t\tif (beanInstance instanceof FactoryBean<?> factoryBean) {\n\t\t\t\tif (!isFactoryDereference) {\n\t\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\t\tif (type == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeToMatch.isAssignableFrom(type)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeToMatch.hasGenerics() && containsBeanDefinition(beanName)) {\n\t\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t\t\tResolvableType targetType = mbd.targetType;\n\t\t\t\t\t\tif (targetType == null) {\n\t\t\t\t\t\t\ttargetType = mbd.factoryMethodReturnType;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (targetType == null) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tClass<?> targetClass = targetType.resolve();\n\t\t\t\t\t\tif (targetClass != null && FactoryBean.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\t\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\t\t\t\t\t\tif (classToMatch != null && !FactoryBean.class.isAssignableFrom(classToMatch) &&\n\t\t\t\t\t\t\t\t\t!classToMatch.isAssignableFrom(targetType.toClass())) {\n\t\t\t\t\t\t\t\treturn typeToMatch.isAssignableFrom(targetType.getGeneric());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn typeToMatch.isAssignableFrom(targetType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isFactoryDereference) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Actual matching against bean instance...\n\t\t\tif (typeToMatch.isInstance(beanInstance)) {\n\t\t\t\t// Direct match for exposed instance?\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (typeToMatch.hasGenerics() && containsBeanDefinition(beanName)) {\n\t\t\t\t// Generics potentially only match on the target class, not on the proxy...\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tClass<?> targetType = mbd.getTargetType();\n\t\t\t\tif (targetType != null && targetType != ClassUtils.getUserClass(beanInstance)) {\n\t\t\t\t\t// Check raw class match as well, making sure it's exposed on the proxy.\n\t\t\t\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\t\t\t\tif (classToMatch != null && !classToMatch.isInstance(beanInstance)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeToMatch.isAssignableFrom(targetType)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tResolvableType resolvableType = mbd.targetType;\n\t\t\t\tif (resolvableType == null) {\n\t\t\t\t\tresolvableType = mbd.factoryMethodReturnType;\n\t\t\t\t}\n\t\t\t\treturn (resolvableType != null && typeToMatch.isAssignableFrom(resolvableType));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (containsSingleton(beanName) && !containsBeanDefinition(beanName)) {\n\t\t\t// null instance registered\n\t\t\treturn false;\n\t\t}\n\n\t\t// No singleton instance found -> check bean definition.\n\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn parentBeanFactory.isTypeMatch(originalBeanName(name), typeToMatch);\n\t\t}\n\n\t\t// Retrieve corresponding bean definition.\n\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\tBeanDefinitionHolder dbd = mbd.getDecoratedDefinition();\n\n\t\t// Set up the types that we want to match against\n\t\tClass<?> classToMatch = typeToMatch.resolve();\n\t\tif (classToMatch == null) {\n\t\t\tclassToMatch = FactoryBean.class;\n\t\t}\n\t\tClass<?>[] typesToMatch = (FactoryBean.class == classToMatch ?\n\t\t\t\tnew Class<?>[] {classToMatch} : new Class<?>[] {FactoryBean.class, classToMatch});\n\n\t\t// Attempt to predict the bean type\n\t\tClass<?> predictedType = null;\n\n\t\t// We're looking for a regular reference, but we're a factory bean that has\n\t\t// a decorated bean definition. The target bean should be the same type\n\t\t// as FactoryBean would ultimately return.\n\t\tif (!isFactoryDereference && dbd != null && isFactoryBean(beanName, mbd)) {\n\t\t\t// We should only attempt if the user explicitly set lazy-init to true\n\t\t\t// and we know the merged bean definition is for a factory bean.\n\t\t\tif (!mbd.isLazyInit() || allowFactoryBeanInit) {\n\t\t\t\tRootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);\n\t\t\t\tClass<?> targetType = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);\n\t\t\t\tif (targetType != null && !FactoryBean.class.isAssignableFrom(targetType)) {\n\t\t\t\t\tpredictedType = targetType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we couldn't use the target type, try regular prediction.\n\t\tif (predictedType == null) {\n\t\t\tpredictedType = predictBeanType(beanName, mbd, typesToMatch);\n\t\t\tif (predictedType == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Attempt to get the actual ResolvableType for the bean.\n\t\tResolvableType beanType = null;\n\n\t\t// If it's a FactoryBean, we want to look at what it creates, not the factory class.\n\t\tif (FactoryBean.class.isAssignableFrom(predictedType)) {\n\t\t\tif (beanInstance == null && !isFactoryDereference) {\n\t\t\t\tbeanType = getTypeForFactoryBean(beanName, mbd, allowFactoryBeanInit);\n\t\t\t\tpredictedType = beanType.resolve();\n\t\t\t\tif (predictedType == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (isFactoryDereference) {\n\t\t\t// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean\n\t\t\t// type, but we nevertheless are being asked to dereference a FactoryBean...\n\t\t\t// Let's check the original bean class and proceed with it if it is a FactoryBean.\n\t\t\tpredictedType = predictBeanType(beanName, mbd, FactoryBean.class);\n\t\t\tif (predictedType == null || !FactoryBean.class.isAssignableFrom(predictedType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// We don't have an exact type but if bean definition target type or the factory\n\t\t// method return type matches the predicted type then we can use that.\n\t\tif (beanType == null) {\n\t\t\tResolvableType definedType = mbd.targetType;\n\t\t\tif (definedType == null) {\n\t\t\t\tdefinedType = mbd.factoryMethodReturnType;\n\t\t\t}\n\t\t\tif (definedType != null && definedType.resolve() == predictedType) {\n\t\t\t\tbeanType = definedType;\n\t\t\t}\n\t\t}\n\n\t\t// If we have a bean type use it so that generics are considered\n\t\tif (beanType != null) {\n\t\t\treturn typeToMatch.isAssignableFrom(beanType);\n\t\t}\n\n\t\t// If we don't have a bean type, fallback to the predicted type\n\t\treturn typeToMatch.isAssignableFrom(predictedType);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(encodedResource,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified properties file.\n\t * @param encodedResource the resource descriptor for the properties file,\n\t * allowing to specify an encoding to use for parsing the file\n\t * @param prefix a filter within the keys in the map: for example, 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "encodedResource",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix)",
    "source_code": "\tpublic int loadBeanDefinitions(EncodedResource encodedResource, @Nullable String prefix)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading properties bean definitions from \" + encodedResource);\n\t\t}\n\n\t\tProperties props = new Properties();\n\t\ttry {\n\t\t\ttry (InputStream is = encodedResource.getResource().getInputStream()) {\n\t\t\t\tif (encodedResource.getEncoding() != null) {\n\t\t\t\t\tgetPropertiesPersister().load(props, new InputStreamReader(is, encodedResource.getEncoding()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgetPropertiesPersister().load(props, is);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint count = registerBeanDefinitions(props, prefix, encodedResource.getResource().getDescription());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loaded \" + count + \" bean definitions from \" + encodedResource);\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"Could not parse properties from \" + encodedResource.getResource(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(location,actualResources)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified resource location.\n\t * <p>The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @param actualResources a Set to be filled with the actual Resource objects\n\t * that have been resolved during the loading process. May be {@code null}\n\t * to indicate that the caller is not interested in those Resource objects.\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "actualResources"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources)",
    "source_code": "\tpublic int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {\n\t\tResourceLoader resourceLoader = getResourceLoader();\n\t\tif (resourceLoader == null) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Cannot load bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t\t}\n\n\t\tif (resourceLoader instanceof ResourcePatternResolver resourcePatternResolver) {\n\t\t\t// Resource pattern matching available.\n\t\t\ttry {\n\t\t\t\tResource[] resources = resourcePatternResolver.getResources(location);\n\t\t\t\tint count = loadBeanDefinitions(resources);\n\t\t\t\tif (actualResources != null) {\n\t\t\t\t\tCollections.addAll(actualResources, resources);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Can only load single resources by absolute URL.\n\t\t\tResource resource = resourceLoader.getResource(location);\n\t\t\tint count = loadBeanDefinitions(resource);\n\t\t\tif (actualResources != null) {\n\t\t\t\tactualResources.add(resource);\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Loaded \" + count + \" bean definitions from location [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#loadBeanDefinitions(resource,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the specified properties file.\n\t * @param resource the resource descriptor for the properties file\n\t * @param prefix a filter within the keys in the map: for example, 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "int",
    "signature": "public int loadBeanDefinitions(Resource resource, @Nullable String prefix)",
    "source_code": "\tpublic int loadBeanDefinitions(Resource resource, @Nullable String prefix) throws BeanDefinitionStoreException {\n\t\treturn loadBeanDefinitions(new EncodedResource(resource), prefix);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#matchesBeanName(beanName,candidateName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given candidate name matches the bean name or the aliases\n\t * stored in this bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "candidateName"
    ],
    "position": {
      "column": 1,
      "line": 2097
    },
    "return": "boolean",
    "signature": "protected boolean matchesBeanName(String beanName, @Nullable String candidateName)",
    "source_code": "\tprotected boolean matchesBeanName(String beanName, @Nullable String candidateName) {\n\t\treturn (candidateName != null &&\n\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#obtainInstanceFromSupplier(supplier,beanName,mbd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "supplier",
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 975
    },
    "return": "Object",
    "signature": "protected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)\n\t\t\tthrows Exception {\n\n\t\tif (supplier instanceof InstanceSupplier<?> instanceSupplier) {\n\t\t\treturn instanceSupplier.get(RegisteredBean.of(this, beanName, mbd));\n\t\t}\n\t\treturn super.obtainInstanceFromSupplier(supplier, beanName, mbd);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#of(beanFactory,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link RegisteredBean} instance for a regular bean.\n\t * @param beanFactory the source bean factory\n\t * @param beanName the bean name\n\t * @return a new {@link RegisteredBean} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "RegisteredBean",
    "signature": "public RegisteredBean of(ConfigurableListableBeanFactory beanFactory, String beanName)",
    "source_code": "\tpublic static RegisteredBean of(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tAssert.notNull(beanFactory, \"'beanFactory' must not be null\");\n\t\tAssert.hasLength(beanName, \"'beanName' must not be empty\");\n\t\treturn new RegisteredBean(beanFactory, () -> beanName, false,\n\t\t\t\t() -> (RootBeanDefinition) beanFactory.getMergedBeanDefinition(beanName),\n\t\t\t\tnull);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#ofInnerBean(parent,innerBean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link RegisteredBean} instance for an inner-bean.\n\t * @param parent the parent of the inner-bean\n\t * @param innerBean a {@link BeanDefinitionHolder} for the inner bean\n\t * @return a new {@link RegisteredBean} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent",
      "innerBean"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "RegisteredBean",
    "signature": "public RegisteredBean ofInnerBean(RegisteredBean parent, BeanDefinitionHolder innerBean)",
    "source_code": "\tpublic static RegisteredBean ofInnerBean(RegisteredBean parent, BeanDefinitionHolder innerBean) {\n\t\tAssert.notNull(innerBean, \"'innerBean' must not be null\");\n\t\treturn ofInnerBean(parent, innerBean.getBeanName(), innerBean.getBeanDefinition());\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#ofInnerBean(parent,innerBeanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link RegisteredBean} instance for an inner-bean.\n\t * @param parent the parent of the inner-bean\n\t * @param innerBeanDefinition the inner-bean definition\n\t * @return a new {@link RegisteredBean} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent",
      "innerBeanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "RegisteredBean",
    "signature": "public RegisteredBean ofInnerBean(RegisteredBean parent, BeanDefinition innerBeanDefinition)",
    "source_code": "\tpublic static RegisteredBean ofInnerBean(RegisteredBean parent, BeanDefinition innerBeanDefinition) {\n\t\treturn ofInnerBean(parent, null, innerBeanDefinition);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#ofInnerBean(parent,innerBeanName,innerBeanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link RegisteredBean} instance for an inner-bean.\n\t * @param parent the parent of the inner-bean\n\t * @param innerBeanName the name of the inner bean or {@code null} to\n\t * generate a name\n\t * @param innerBeanDefinition the inner-bean definition\n\t * @return a new {@link RegisteredBean} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parent",
      "innerBeanName",
      "innerBeanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "RegisteredBean",
    "signature": "public RegisteredBean ofInnerBean(RegisteredBean parent,\n\t\t\t@Nullable String innerBeanName, BeanDefinition innerBeanDefinition)",
    "source_code": "\tpublic static RegisteredBean ofInnerBean(RegisteredBean parent,\n\t\t\t@Nullable String innerBeanName, BeanDefinition innerBeanDefinition) {\n\n\t\tAssert.notNull(parent, \"'parent' must not be null\");\n\t\tAssert.notNull(innerBeanDefinition, \"'innerBeanDefinition' must not be null\");\n\t\tInnerBeanResolver resolver = new InnerBeanResolver(parent, innerBeanName, innerBeanDefinition);\n\t\tSupplier<String> beanName = (StringUtils.hasLength(innerBeanName) ?\n\t\t\t\t() -> innerBeanName : resolver::resolveBeanName);\n\t\treturn new RegisteredBean(parent.getBeanFactory(), beanName,\n\t\t\t\tinnerBeanName == null, resolver::resolveMergedBeanDefinition, parent);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#populateBean(beanName,mbd,bw)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param bw the BeanWrapper with bean instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1381
    },
    "return": "void",
    "signature": "protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)",
    "source_code": "\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (bw.getWrappedClass().isRecord()) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to a record\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for records since they are immutable.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\t\tif (hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#postProcessObjectFromFactoryBean(object,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given object that has been obtained from the FactoryBean.\n\t * The resulting object will get exposed for bean references.\n\t * <p>The default implementation simply returns the given object as-is.\n\t * Subclasses may override this, for example, to apply post-processors.\n\t * @param object the object obtained from the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @return the object to expose\n\t * @throws org.springframework.beans.BeansException if any post-processing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Object",
    "signature": "protected Object postProcessObjectFromFactoryBean(Object object, String beanName)",
    "source_code": "\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException {\n\t\treturn object;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,Map<?,map,prefix,resourceDescription)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get all property values, given a prefix (which will be stripped)\n\t * and add the bean they define to the factory with the given name.\n\t * @param beanName name of the bean to define\n\t * @param map a Map containing string pairs\n\t * @param prefix prefix of each entry, which will be stripped\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @throws BeansException if the bean definition could not be parsed or registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(String beanName, Map<?, ?> map, String prefix, String resourceDescription)",
    "source_code": "\tprotected void registerBeanDefinition(String beanName, Map<?, ?> map, String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tString className = null;\n\t\tString parent = null;\n\t\tString scope = BeanDefinition.SCOPE_SINGLETON;\n\t\tboolean isAbstract = false;\n\t\tboolean lazyInit = false;\n\n\t\tConstructorArgumentValues cas = new ConstructorArgumentValues();\n\t\tMutablePropertyValues pvs = new MutablePropertyValues();\n\n\t\tString prefixWithSep = prefix + SEPARATOR;\n\t\tint beginIndex = prefixWithSep.length();\n\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tString key = ((String) entry.getKey()).strip();\n\t\t\tif (key.startsWith(prefixWithSep)) {\n\t\t\t\tString property = key.substring(beginIndex);\n\t\t\t\tif (CLASS_KEY.equals(property)) {\n\t\t\t\t\tclassName = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (PARENT_KEY.equals(property)) {\n\t\t\t\t\tparent = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (ABSTRACT_KEY.equals(property)) {\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tisAbstract = TRUE_VALUE.equals(val);\n\t\t\t\t}\n\t\t\t\telse if (SCOPE_KEY.equals(property)) {\n\t\t\t\t\t// Spring 2.0 style\n\t\t\t\t\tscope = ((String) entry.getValue()).strip();\n\t\t\t\t}\n\t\t\t\telse if (SINGLETON_KEY.equals(property)) {\n\t\t\t\t\t// Spring 1.2 style\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tscope = (!StringUtils.hasLength(val) || TRUE_VALUE.equals(val) ?\n\t\t\t\t\t\t\tBeanDefinition.SCOPE_SINGLETON : BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\t\t\t\telse if (LAZY_INIT_KEY.equals(property)) {\n\t\t\t\t\tString val = ((String) entry.getValue()).strip();\n\t\t\t\t\tlazyInit = TRUE_VALUE.equals(val);\n\t\t\t\t}\n\t\t\t\telse if (property.startsWith(CONSTRUCTOR_ARG_PREFIX)) {\n\t\t\t\t\tif (property.endsWith(REF_SUFFIX)) {\n\t\t\t\t\t\tint index = Integer.parseInt(property, 1, property.length() - REF_SUFFIX.length(), 10);\n\t\t\t\t\t\tcas.addIndexedArgumentValue(index, new RuntimeBeanReference(entry.getValue().toString()));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint index = Integer.parseInt(property, 1, property.length(), 10);\n\t\t\t\t\t\tcas.addIndexedArgumentValue(index, readValue(entry));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (property.endsWith(REF_SUFFIX)) {\n\t\t\t\t\t// This isn't a real property, but a reference to another prototype\n\t\t\t\t\t// Extract property name: property is of form dog(ref)\n\t\t\t\t\tproperty = property.substring(0, property.length() - REF_SUFFIX.length());\n\t\t\t\t\tString ref = ((String) entry.getValue()).strip();\n\n\t\t\t\t\t// It doesn't matter if the referenced bean hasn't yet been registered:\n\t\t\t\t\t// this will ensure that the reference is resolved at runtime.\n\t\t\t\t\tObject val = new RuntimeBeanReference(ref);\n\t\t\t\t\tpvs.add(property, val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// It's a normal bean property.\n\t\t\t\t\tpvs.add(property, readValue(entry));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Registering bean definition for bean name '\" + beanName + \"' with \" + pvs);\n\t\t}\n\n\t\t// Just use default parent if we're not dealing with the parent itself,\n\t\t// and if there's no class name specified. The latter has to happen for\n\t\t// backwards compatibility reasons.\n\t\tif (parent == null && className == null && !beanName.equals(this.defaultParentBean)) {\n\t\t\tparent = this.defaultParentBean;\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\t\tparent, className, getBeanClassLoader());\n\t\t\tbd.setScope(scope);\n\t\t\tbd.setAbstract(isAbstract);\n\t\t\tbd.setLazyInit(lazyInit);\n\t\t\tbd.setConstructorArgumentValues(cas);\n\t\t\tbd.setPropertyValues(pvs);\n\t\t\tgetRegistry().registerBeanDefinition(beanName, bd);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new CannotLoadBeanClassException(resourceDescription, beanName, className, ex);\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\tthrow new CannotLoadBeanClassException(resourceDescription, beanName, className, err);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 1132
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\tif (beanDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\ttry {\n\t\t\t\tabd.validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n\t\tif (existingDefinition != null) {\n\t\t\tif (!isBeanDefinitionOverridable(beanName)) {\n\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogBeanDefinitionOverriding(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tif (isAlias(beanName)) {\n\t\t\t\tString aliasedName = canonicalName(beanName);\n\t\t\t\tif (!isBeanDefinitionOverridable(aliasedName)) {\n\t\t\t\t\tif (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(\n\t\t\t\t\t\t\t\tbeanName, beanDefinition, getBeanDefinition(aliasedName));\n\t\t\t\t\t}\n\t\t\t\t\telse {  // alias pointing to non-existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Cannot register bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\t\"' since there is already an alias for bean '\" + aliasedName + \"' bound.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tremoveAlias(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\n\t\tif (existingDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\telse if (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\n\t\t// Cache a primary marker for the given bean.\n\t\tif (beanDefinition.isPrimary()) {\n\t\t\tthis.primaryBeanNames.add(beanName);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map, using all property keys (i.e. not\n\t * filtering by prefix).\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(java.util.Map, String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map) throws BeansException {\n\t\treturn registerBeanDefinitions(map, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: for example, 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix) throws BeansException {\n\t\treturn registerBeanDefinitions(map, prefix, \"Map \" + map);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(Map<?,map,prefix,resourceDescription)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a Map.\n\t * Ignore ineligible properties.\n\t * @param map a map of {@code name} to {@code property} (String or Object). Property\n\t * values will be strings if coming from a Properties file etc. Property names\n\t * (keys) <b>must</b> be Strings. Class keys must be Strings.\n\t * @param prefix a filter within the keys in the map: for example, 'beans.'\n\t * (can be empty or {@code null})\n\t * @param resourceDescription description of the resource that the\n\t * Map came from (for logging purposes)\n\t * @return the number of bean definitions found\n\t * @throws BeansException in case of loading or parsing errors\n\t * @see #registerBeanDefinitions(Map, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map",
      "prefix",
      "resourceDescription"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)",
    "source_code": "\tpublic int registerBeanDefinitions(Map<?, ?> map, @Nullable String prefix, String resourceDescription)\n\t\t\tthrows BeansException {\n\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\tint beanCount = 0;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tif (!(key instanceof String keyString)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Illegal key [\" + key + \"]: only Strings allowed\");\n\t\t\t}\n\t\t\tif (keyString.startsWith(prefix)) {\n\t\t\t\t// Key is of form: prefix<name>.property\n\t\t\t\tString nameAndProperty = keyString.substring(prefix.length());\n\t\t\t\t// Find dot before property name, ignoring dots in property keys.\n\t\t\t\tint sepIdx ;\n\t\t\t\tint propKeyIdx = nameAndProperty.indexOf(PropertyAccessor.PROPERTY_KEY_PREFIX);\n\t\t\t\tif (propKeyIdx != -1) {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR, propKeyIdx);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsepIdx = nameAndProperty.lastIndexOf(SEPARATOR);\n\t\t\t\t}\n\t\t\t\tif (sepIdx != -1) {\n\t\t\t\t\tString beanName = nameAndProperty.substring(0, sepIdx);\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Found bean name '\" + beanName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!getRegistry().containsBeanDefinition(beanName)) {\n\t\t\t\t\t\t// If we haven't already registered it...\n\t\t\t\t\t\tregisterBeanDefinition(beanName, map, prefix + beanName, resourceDescription);\n\t\t\t\t\t\t++beanCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Ignore it: It wasn't a valid bean name and property,\n\t\t\t\t\t// although it did start with the required prefix.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Invalid bean name and property [\" + nameAndProperty + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn beanCount;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerBeanDefinitions(rb,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register bean definitions contained in a ResourceBundle.\n\t * <p>Similar syntax as for a Map. This method is useful to enable\n\t * standard Java internationalization support.\n\t * @param rb the ResourceBundle to load from\n\t * @param prefix a filter within the keys in the map: for example, 'beans.'\n\t * (can be empty or {@code null})\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rb",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "int",
    "signature": "public int registerBeanDefinitions(ResourceBundle rb, @Nullable String prefix)",
    "source_code": "\tpublic int registerBeanDefinitions(ResourceBundle rb, @Nullable String prefix) throws BeanDefinitionStoreException {\n\t\t// Simply create a map and call overloaded method.\n\t\tMap<String, Object> map = new HashMap<>();\n\t\tEnumeration<String> keys = rb.getKeys();\n\t\twhile (keys.hasMoreElements()) {\n\t\t\tString key = keys.nextElement();\n\t\t\tmap.put(key, rb.getObject(key));\n\t\t}\n\t\treturn registerBeanDefinitions(map, prefix);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerCustomEditor(requiredType,propertyEditorClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditorClass"
    ],
    "position": {
      "column": 1,
      "line": 897
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, Class<? extends PropertyEditor> propertyEditorClass) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tAssert.notNull(propertyEditorClass, \"PropertyEditor class must not be null\");\n\t\tthis.customEditors.put(requiredType, propertyEditorClass);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerDisposableBeanIfNecessary(beanName,bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given bean to the list of disposable beans in this factory,\n\t * registering its DisposableBean interface and/or the given destroy method\n\t * to be called on factory shutdown (if applicable). Only applies to singletons.\n\t * @param beanName the name of the bean\n\t * @param bean the bean instance\n\t * @param mbd the bean definition for the bean\n\t * @see RootBeanDefinition#isSingleton\n\t * @see RootBeanDefinition#getDependsOn\n\t * @see #registerDisposableBean\n\t * @see #registerDependentBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1906
    },
    "return": "void",
    "signature": "protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {\n\t\tif (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {\n\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t// Register a DisposableBean implementation that performs all destruction\n\t\t\t\t// work for the given bean: DestructionAwareBeanPostProcessors,\n\t\t\t\t// DisposableBean interface, custom destroy method.\n\t\t\t\tregisterDisposableBean(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A bean with a custom scope...\n\t\t\t\tScope scope = this.scopes.get(mbd.getScope());\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + mbd.getScope() + \"'\");\n\t\t\t\t}\n\t\t\t\tscope.registerDestructionCallback(beanName, new DisposableBeanAdapter(\n\t\t\t\t\t\tbean, beanName, mbd, getBeanPostProcessorCache().destructionAware));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerResolvableDependency(dependencyType,autowiredValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dependencyType",
      "autowiredValue"
    ],
    "position": {
      "column": 1,
      "line": 842
    },
    "return": "void",
    "signature": "public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue)",
    "source_code": "\tpublic void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {\n\t\tAssert.notNull(dependencyType, \"Dependency type must not be null\");\n\t\tif (autowiredValue != null) {\n\t\t\tif (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {\n\t\t\t\tthrow new IllegalArgumentException(\"Value [\" + autowiredValue +\n\t\t\t\t\t\t\"] does not implement specified dependency type [\" + dependencyType.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerScope(scopeName,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scopeName",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 1067
    },
    "return": "void",
    "signature": "public void registerScope(String scopeName, Scope scope)",
    "source_code": "\tpublic void registerScope(String scopeName, Scope scope) {\n\t\tAssert.notNull(scopeName, \"Scope identifier must not be null\");\n\t\tAssert.notNull(scope, \"Scope must not be null\");\n\t\tif (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot replace existing scopes 'singleton' and 'prototype'\");\n\t\t}\n\t\tScope previous = this.scopes.put(scopeName, scope);\n\t\tif (previous != null && previous != scope) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Replacing scope '\" + scopeName + \"' from [\" + previous + \"] to [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering scope '\" + scopeName + \"' with implementation [\" + scope + \"]\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#registerSingleton(beanName,singletonObject)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "singletonObject"
    ],
    "position": {
      "column": 1,
      "line": 1348
    },
    "return": "void",
    "signature": "public void registerSingleton(String beanName, Object singletonObject)",
    "source_code": "\tpublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {\n\t\tsuper.registerSingleton(beanName, singletonObject);\n\t\tupdateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));\n\t\tclearByTypeCache();\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#requiresDestruction(bean,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given bean requires destruction on shutdown.\n\t * <p>The default implementation checks the DisposableBean interface as well as\n\t * a specified destroy method and registered DestructionAwareBeanPostProcessors.\n\t * @param bean the bean instance to check\n\t * @param mbd the corresponding bean definition\n\t * @see org.springframework.beans.factory.DisposableBean\n\t * @see AbstractBeanDefinition#getDestroyMethodName()\n\t * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1888
    },
    "return": "boolean",
    "signature": "protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd)",
    "source_code": "\tprotected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) {\n\t\treturn (bean.getClass() != NullBean.class && (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) ||\n\t\t\t\t(hasDestructionAwareBeanPostProcessors() && DisposableBeanAdapter.hasApplicableProcessors(\n\t\t\t\t\t\tbean, getBeanPostProcessorCache().destructionAware))));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveAutowiredArgument(descriptor,typeConverter,autowiredBeanNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve an autowired argument.\n\t * @param descriptor the descriptor for the dependency (field/method/constructor)\n\t * @param typeConverter the TypeConverter to use for populating arrays and collections\n\t * @param autowiredBeanNames a Set that all names of autowired beans (used for\n\t * resolving the given dependency) are supposed to be added to\n\t * @return the resolved object, or {@code null} if none found\n\t * @since 6.0.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "typeConverter",
      "autowiredBeanNames"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "Object",
    "signature": "public Object resolveAutowiredArgument(DependencyDescriptor descriptor, TypeConverter typeConverter, Set<String> autowiredBeanNames)",
    "source_code": "\tpublic Object resolveAutowiredArgument(\n\t\t\tDependencyDescriptor descriptor, TypeConverter typeConverter, Set<String> autowiredBeanNames) {\n\n\t\treturn new ConstructorResolver((AbstractAutowireCapableBeanFactory) getBeanFactory())\n\t\t\t\t.resolveAutowiredArgument(descriptor, descriptor.getDependencyType(),\n\t\t\t\t\t\tgetBeanName(), autowiredBeanNames, typeConverter, true);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveAutowiringValue(autowiringValue,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given autowiring value against the given required type,\n\t * for example, an {@link ObjectFactory} value to its actual object result.\n\t * @param autowiringValue the value to resolve\n\t * @param requiredType the type to assign the result to\n\t * @return the resolved value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "autowiringValue",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "Object",
    "signature": "public Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType)",
    "source_code": "\tpublic static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {\n\t\tif (autowiringValue instanceof ObjectFactory<?> factory && !requiredType.isInstance(autowiringValue)) {\n\t\t\tif (autowiringValue instanceof Serializable && requiredType.isInterface()) {\n\t\t\t\tautowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),\n\t\t\t\t\t\tnew Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn factory.getObject();\n\t\t\t}\n\t\t}\n\t\treturn autowiringValue;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeanByName(name,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) {\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\treturn getBean(name, descriptor.getDependencyType());\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveBeforeInstantiation(beanName,mbd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply before-instantiation post-processors, resolving whether there is a\n\t * before-instantiation shortcut for the specified bean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the shortcut-determined bean instance, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 1112
    },
    "return": "Object",
    "signature": "protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n\t\tObject bean = null;\n\t\tif (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n\t\t\t// Make sure bean class is actually resolved at this point.\n\t\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\t\tClass<?> targetType = determineTargetType(beanName, mbd);\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tbean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\tif (bean != null) {\n\t\t\t\t\t\tbean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmbd.beforeInstantiationResolved = (bean != null);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveCandidate(beanName,requiredType,beanFactory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "requiredType",
      "beanFactory"
    ],
    "position": {
      "column": 1,
      "line": 2354
    },
    "return": "Object",
    "signature": "public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory)",
    "source_code": "\t\t\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\t\t\treturn beanFactory.getBean(beanName, args);\n\t\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveConstructorOrFactoryMethod(beanName,mbd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "mbd"
    ],
    "position": {
      "column": 1,
      "line": 964
    },
    "return": "Executable",
    "signature": "public Executable resolveConstructorOrFactoryMethod(String beanName, RootBeanDefinition mbd)",
    "source_code": "\tpublic Executable resolveConstructorOrFactoryMethod(String beanName, RootBeanDefinition mbd) {\n\t\tSupplier<ResolvableType> beanType = () -> getBeanType(beanName, mbd);\n\t\tList<ResolvableType> valueTypes = (mbd.hasConstructorArgumentValues() ?\n\t\t\t\tdetermineParameterValueTypes(mbd) : Collections.emptyList());\n\t\tMethod resolvedFactoryMethod = resolveFactoryMethod(beanName, mbd, valueTypes);\n\t\tif (resolvedFactoryMethod != null) {\n\t\t\treturn resolvedFactoryMethod;\n\t\t}\n\n\t\tClass<?> factoryBeanClass = getFactoryBeanClass(beanName, mbd);\n\t\tif (factoryBeanClass != null && !factoryBeanClass.equals(mbd.getResolvableType().toClass())) {\n\t\t\tResolvableType resolvableType = mbd.getResolvableType();\n\t\t\tboolean isCompatible = ResolvableType.forClass(factoryBeanClass)\n\t\t\t\t\t.as(FactoryBean.class).getGeneric(0).isAssignableFrom(resolvableType);\n\t\t\tAssert.state(isCompatible, () -> String.format(\n\t\t\t\t\t\"Incompatible target type '%s' for factory bean '%s'\",\n\t\t\t\t\tresolvableType.toClass().getName(), factoryBeanClass.getName()));\n\t\t\tConstructor<?> constructor = resolveConstructor(beanName, mbd,\n\t\t\t\t\t() -> ResolvableType.forClass(factoryBeanClass), valueTypes);\n\t\t\tif (constructor != null) {\n\t\t\t\treturn constructor;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"No suitable FactoryBean constructor found for \" +\n\t\t\t\t\tmbd + \" and argument types \" + valueTypes);\n\n\t\t}\n\n\t\tConstructor<?> constructor = resolveConstructor(beanName, mbd, beanType, valueTypes);\n\t\tif (constructor != null) {\n\t\t\treturn constructor;\n\t\t}\n\n\t\tthrow new IllegalStateException(\"No constructor or factory method candidate found for \" +\n\t\t\t\tmbd + \" and argument types \" + valueTypes);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException {\n\t\treturn resolveDependency(descriptor, requestingBeanName, null, null);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 1493
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\t\tif (Optional.class == descriptor.getDependencyType()) {\n\t\t\treturn createOptionalDependency(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (ObjectFactory.class == descriptor.getDependencyType() ||\n\t\t\t\tObjectProvider.class == descriptor.getDependencyType()) {\n\t\t\treturn new DependencyObjectProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (jakartaInjectProviderClass == descriptor.getDependencyType()) {\n\t\t\treturn new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (descriptor.supportsLazyResolution()) {\n\t\t\tObject result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n\t\t\t\t\tdescriptor, requestingBeanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveInnerBean(innerBeanName,innerBd,BiFunction<String,RootBeanDefinition,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve an inner bean definition and invoke the specified {@code resolver}\n\t * on its merged bean definition.\n\t * @param innerBeanName the inner bean name (or {@code null} to assign one)\n\t * @param innerBd the inner raw bean definition\n\t * @param resolver the function to invoke to resolve\n\t * @param <T> the type of the resolution\n\t * @return a resolved inner bean, as a result of applying the {@code resolver}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "innerBeanName",
      "innerBd",
      "BiFunction<String",
      "RootBeanDefinition",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "T",
    "signature": "public T resolveInnerBean(@Nullable String innerBeanName, BeanDefinition innerBd,\n\t\t\tBiFunction<String, RootBeanDefinition, T> resolver)",
    "source_code": "\tpublic <T> T resolveInnerBean(@Nullable String innerBeanName, BeanDefinition innerBd,\n\t\t\tBiFunction<String, RootBeanDefinition, T> resolver) {\n\n\t\tString nameToUse = (innerBeanName != null ? innerBeanName : \"(inner bean)\" +\n\t\t\t\tBeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(innerBd));\n\t\treturn resolver.apply(nameToUse,\n\t\t\t\tthis.beanFactory.getMergedBeanDefinition(nameToUse, innerBd, this.beanDefinition));\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveNotUnique(type,Map<String,matchingBeans)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<String",
      "matchingBeans"
    ],
    "position": {
      "column": 1,
      "line": 2420
    },
    "return": "Object",
    "signature": "public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans)",
    "source_code": "\t\t\t\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {\n\t\t\t\t\treturn null;\n\t\t\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#resolveValueIfNecessary(argName,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Given a PropertyValue, return a value, resolving any references to other\n\t * beans in the factory if necessary. The value could be:\n\t * <li>A BeanDefinition, which leads to the creation of a corresponding\n\t * new bean instance. Singleton flags and names of such \"inner beans\"\n\t * are always ignored: Inner beans are anonymous prototypes.\n\t * <li>A RuntimeBeanReference, which must be resolved.\n\t * <li>A ManagedList. This is a special collection that may contain\n\t * RuntimeBeanReferences or Collections that will need to be resolved.\n\t * <li>A ManagedSet. May also contain RuntimeBeanReferences or\n\t * Collections that will need to be resolved.\n\t * <li>A ManagedMap. In this case the value may be a RuntimeBeanReference\n\t * or Collection that will need to be resolved.\n\t * <li>An ordinary object or {@code null}, in which case it's left alone.\n\t * @param argName the name of the argument that the value is defined for\n\t * @param value the value object to resolve\n\t * @return the resolved object\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object",
    "signature": "public Object resolveValueIfNecessary(Object argName, @Nullable Object value)",
    "source_code": "\tpublic Object resolveValueIfNecessary(Object argName, @Nullable Object value) {\n\t\t// We must check each value to see whether it requires a runtime reference\n\t\t// to another bean to be resolved.\n\t\tif (value instanceof RuntimeBeanReference ref) {\n\t\t\treturn resolveReference(argName, ref);\n\t\t}\n\t\telse if (value instanceof RuntimeBeanNameReference ref) {\n\t\t\tString refName = ref.getBeanName();\n\t\t\trefName = String.valueOf(doEvaluate(refName));\n\t\t\tif (!this.beanFactory.containsBean(refName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Invalid bean name '\" + refName + \"' in bean reference for \" + argName);\n\t\t\t}\n\t\t\treturn refName;\n\t\t}\n\t\telse if (value instanceof BeanDefinitionHolder bdHolder) {\n\t\t\t// Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.\n\t\t\treturn resolveInnerBean(bdHolder.getBeanName(), bdHolder.getBeanDefinition(),\n\t\t\t\t\t(name, mbd) -> resolveInnerBeanValue(argName, name, mbd));\n\t\t}\n\t\telse if (value instanceof BeanDefinition bd) {\n\t\t\treturn resolveInnerBean(null, bd,\n\t\t\t\t\t(name, mbd) -> resolveInnerBeanValue(argName, name, mbd));\n\t\t}\n\t\telse if (value instanceof DependencyDescriptor dependencyDescriptor) {\n\t\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(2);\n\t\t\tObject result = this.beanFactory.resolveDependency(\n\t\t\t\t\tdependencyDescriptor, this.beanName, autowiredBeanNames, this.typeConverter);\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (this.beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, this.beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse if (value instanceof ManagedArray managedArray) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\tClass<?> elementType = managedArray.resolvedElementType;\n\t\t\tif (elementType == null) {\n\t\t\t\tString elementTypeName = managedArray.getElementTypeName();\n\t\t\t\tif (StringUtils.hasText(elementTypeName)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\telementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader());\n\t\t\t\t\t\tmanagedArray.resolvedElementType = elementType;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t// Improve the message by showing the context.\n\t\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\t\t\"Error resolving array type for \" + argName, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telementType = Object.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resolveManagedArray(argName, (List<?>) value, elementType);\n\t\t}\n\t\telse if (value instanceof ManagedList<?> managedList) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedList(argName, managedList);\n\t\t}\n\t\telse if (value instanceof ManagedSet<?> managedSet) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedSet(argName, managedSet);\n\t\t}\n\t\telse if (value instanceof ManagedMap<?, ?> managedMap) {\n\t\t\t// May need to resolve contained runtime references.\n\t\t\treturn resolveManagedMap(argName, managedMap);\n\t\t}\n\t\telse if (value instanceof ManagedProperties original) {\n\t\t\t// Properties original = managedProperties;\n\t\t\tProperties copy = new Properties();\n\t\t\toriginal.forEach((propKey, propValue) -> {\n\t\t\t\tif (propKey instanceof TypedStringValue typedStringValue) {\n\t\t\t\t\tpropKey = evaluate(typedStringValue);\n\t\t\t\t}\n\t\t\t\tif (propValue instanceof TypedStringValue typedStringValue) {\n\t\t\t\t\tpropValue = evaluate(typedStringValue);\n\t\t\t\t}\n\t\t\t\tif (propKey == null || propValue == null) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\t\"Error converting Properties key/value pair for \" + argName + \": resolved to null\");\n\t\t\t\t}\n\t\t\t\tcopy.put(propKey, propValue);\n\t\t\t});\n\t\t\treturn copy;\n\t\t}\n\t\telse if (value instanceof TypedStringValue typedStringValue) {\n\t\t\t// Convert value to target type here.\n\t\t\tObject valueObject = evaluate(typedStringValue);\n\t\t\ttry {\n\t\t\t\tClass<?> resolvedTargetType = resolveTargetType(typedStringValue);\n\t\t\t\tif (resolvedTargetType != null) {\n\t\t\t\t\treturn this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn valueObject;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Improve the message by showing the context.\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tthis.beanDefinition.getResourceDescription(), this.beanName,\n\t\t\t\t\t\t\"Error converting typed String value for \" + argName, ex);\n\t\t\t}\n\t\t}\n\t\telse if (value instanceof NullBean) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn evaluate(value);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#set(index,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 1994
    },
    "return": "BeanPostProcessor",
    "signature": "public BeanPostProcessor set(int index, BeanPostProcessor element)",
    "source_code": "\t\tpublic BeanPostProcessor set(int index, BeanPostProcessor element) {\n\t\t\tBeanPostProcessor result = super.set(index, element);\n\t\t\tresetBeanPostProcessorCache();\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#storeCache(mbd,constructorOrFactoryMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mbd",
      "constructorOrFactoryMethod"
    ],
    "position": {
      "column": 1,
      "line": 1384
    },
    "return": "void",
    "signature": "public void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod)",
    "source_code": "\t\tpublic void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;\n\t\t\t\tmbd.constructorArgumentsResolved = true;\n\t\t\t\tif (this.resolveNecessary) {\n\t\t\t\t\tmbd.preparedConstructorArguments = this.preparedArguments;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmbd.resolvedConstructorArguments = this.arguments;\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.beans.factory.support.<unknown>#unsatisfiedNonSimpleProperties(mbd,bw)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an array of non-simple bean properties that are unsatisfied.\n\t * These are probably unsatisfied references to other beans in the\n\t * factory. Does not include simple properties like primitives or Strings.\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return an array of bean property names\n\t * @see org.springframework.beans.BeanUtils#isSimpleProperty\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mbd",
      "bw"
    ],
    "position": {
      "column": 1,
      "line": 1547
    },
    "return": "String[]",
    "signature": "protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw)",
    "source_code": "\tprotected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {\n\t\tSet<String> result = new TreeSet<>();\n\t\tPropertyValues pvs = mbd.getPropertyValues();\n\t\tPropertyDescriptor[] pds = bw.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&\n\t\t\t\t\t!BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n\t\t\t\tresult.add(pd.getName());\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#buildTypedStringValue(value,targetTypeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "targetTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "TypedStringValue",
    "signature": "protected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)",
    "source_code": "\tprotected TypedStringValue buildTypedStringValue(String value, @Nullable String targetTypeName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\tClassLoader classLoader = this.readerContext.getBeanClassLoader();\n\t\tTypedStringValue typedValue;\n\t\tif (!StringUtils.hasText(targetTypeName)) {\n\t\t\ttypedValue = new TypedStringValue(value);\n\t\t}\n\t\telse if (classLoader != null) {\n\t\t\tClass<?> targetType = ClassUtils.forName(targetTypeName, classLoader);\n\t\t\ttypedValue = new TypedStringValue(value, targetType);\n\t\t}\n\t\telse {\n\t\t\ttypedValue = new TypedStringValue(value, targetTypeName);\n\t\t}\n\t\treturn typedValue;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#buildTypedStringValueForMap(value,defaultTypeName,entryEle)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a typed String value Object for the given raw value.\n\t * @see org.springframework.beans.factory.config.TypedStringValue\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "defaultTypeName",
      "entryEle"
    ],
    "position": {
      "column": 1,
      "line": 1292
    },
    "return": "Object",
    "signature": "protected Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle)",
    "source_code": "\tprotected final Object buildTypedStringValueForMap(String value, String defaultTypeName, Element entryEle) {\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, defaultTypeName);\n\t\t\ttypedValue.setSource(extractSource(entryEle));\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + defaultTypeName + \"] not found for Map key/value type\", entryEle, ex);\n\t\t\treturn value;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#checkNameUniqueness(beanName,aliases,beanElement)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate that the specified bean name and aliases have not been used already\n\t * within the current level of beans element nesting.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "aliases",
      "beanElement"
    ],
    "position": {
      "column": 1,
      "line": 479
    },
    "return": "void",
    "signature": "protected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement)",
    "source_code": "\tprotected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {\n\t\tString foundName = null;\n\n\t\tif (StringUtils.hasText(beanName) && this.usedNames.contains(beanName)) {\n\t\t\tfoundName = beanName;\n\t\t}\n\t\tif (foundName == null) {\n\t\t\tfoundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);\n\t\t}\n\t\tif (foundName != null) {\n\t\t\terror(\"Bean name '\" + foundName + \"' is already used in this <beans> element\", beanElement);\n\t\t}\n\n\t\tthis.usedNames.add(beanName);\n\t\tthis.usedNames.addAll(aliases);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#createBeanDefinition(className,parentName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean definition for the given class name and parent name.\n\t * @param className the name of the bean class\n\t * @param parentName the name of the bean's parent bean\n\t * @return the newly created bean definition\n\t * @throws ClassNotFoundException if bean class resolution was attempted but failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "className",
      "parentName"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "AbstractBeanDefinition",
    "signature": "protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)",
    "source_code": "\tprotected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)\n\t\t\tthrows ClassNotFoundException {\n\n\t\treturn BeanDefinitionReaderUtils.createBeanDefinition(\n\t\t\t\tparentName, className, this.readerContext.getBeanClassLoader());\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#createDelegate(readerContext,root,parentDelegate)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "root",
      "parentDelegate"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "BeanDefinitionParserDelegate",
    "signature": "protected BeanDefinitionParserDelegate createDelegate(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate)",
    "source_code": "\tprotected BeanDefinitionParserDelegate createDelegate(\n\t\t\tXmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {\n\n\t\tBeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);\n\t\tdelegate.initDefaults(root, parentDelegate);\n\t\treturn delegate;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorate(node,definition,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "definition",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {\n\t\tif (node instanceof Attr attr) {\n\t\t\tString propertyName = parserContext.getDelegate().getLocalName(attr);\n\t\t\tString propertyValue = attr.getValue();\n\t\t\tMutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();\n\t\t\tif (pvs.contains(propertyName)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Property '\" + propertyName + \"' is already defined using \" +\n\t\t\t\t\t\t\"both <property> and inline syntax. Only one approach may be used per property.\", attr);\n\t\t\t}\n\t\t\tif (propertyName.endsWith(REF_SUFFIX)) {\n\t\t\t\tpropertyName = propertyName.substring(0, propertyName.length() - REF_SUFFIX.length());\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), new RuntimeBeanReference(propertyValue));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);\n\t\t\t}\n\t\t}\n\t\treturn definition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateBeanDefinitionIfRequired(ele,originalDef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "originalDef"
    ],
    "position": {
      "column": 1,
      "line": 1400
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef)",
    "source_code": "\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef) {\n\t\treturn decorateBeanDefinitionIfRequired(ele, originalDef, null);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateBeanDefinitionIfRequired(ele,originalDef,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler, if applicable.\n\t * @param ele the current element\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "originalDef",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1411
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinitionHolder decorateBeanDefinitionIfRequired(\n\t\t\tElement ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tBeanDefinitionHolder finalDefinition = originalDef;\n\n\t\t// Decorate based on custom attributes first.\n\t\tNamedNodeMap attributes = ele.getAttributes();\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tNode node = attributes.item(i);\n\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t}\n\n\t\t// Decorate based on custom nested elements.\n\t\tNodeList children = ele.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode node = children.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tfinalDefinition = decorateIfRequired(node, finalDefinition, containingBd);\n\t\t\t}\n\t\t}\n\t\treturn finalDefinition;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#decorateIfRequired(node,originalDef,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the given bean definition through a namespace handler,\n\t * if applicable.\n\t * @param node the current child node\n\t * @param originalDef the current bean definition\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the decorated bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "originalDef",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1442
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder decorateIfRequired(Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinitionHolder decorateIfRequired(\n\t\t\tNode node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {\n\n\t\tString namespaceUri = getNamespaceURI(node);\n\t\tif (namespaceUri != null && !isDefaultNamespace(namespaceUri)) {\n\t\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\t\tif (handler != null) {\n\t\t\t\tBeanDefinitionHolder decorated =\n\t\t\t\t\t\thandler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));\n\t\t\t\tif (decorated != null) {\n\t\t\t\t\treturn decorated;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (namespaceUri.startsWith(\"http://www.springframework.org/schema/\")) {\n\t\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A custom namespace, not to be handled by Spring - maybe \"xml:...\".\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No Spring NamespaceHandler found for XML schema namespace [\" + namespaceUri + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn originalDef;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#error(message,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Report an error with the given message for the given source element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "protected void error(String message, Element source)",
    "source_code": "\tprotected void error(String message, Element source) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot());\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#error(message,source,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Report an error with the given message for the given source element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "source",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "void",
    "signature": "protected void error(String message, Element source, Throwable cause)",
    "source_code": "\tprotected void error(String message, Element source, Throwable cause) {\n\t\tthis.readerContext.error(message, source, this.parseState.snapshot(), cause);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#initDefaults(root,parent)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the default lazy-init, autowire, dependency check settings,\n\t * init-method, destroy-method and merge settings. Support nested 'beans'\n\t * element use cases by falling back to the given parent in case the\n\t * defaults are not explicitly set locally.\n\t * @see #populateDefaults(DocumentDefaultsDefinition, DocumentDefaultsDefinition, org.w3c.dom.Element)\n\t * @see #getDefaults()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "root",
      "parent"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent)",
    "source_code": "\tpublic void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) {\n\t\tpopulateDefaults(this.defaults, (parent != null ? parent.defaults : null), root);\n\t\tthis.readerContext.fireDefaultsRegistered(this.defaults);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#nodeNameEquals(node,desiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the name of the supplied node is equal to the supplied name.\n\t * <p>The default implementation checks the supplied desired name against both\n\t * {@link Node#getNodeName()} and {@link Node#getLocalName()}.\n\t * <p>Subclasses may override the default implementation to provide a different\n\t * mechanism for comparing node names.\n\t * @param node the node to compare\n\t * @param desiredName the name to check for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "desiredName"
    ],
    "position": {
      "column": 1,
      "line": 1518
    },
    "return": "boolean",
    "signature": "public boolean nodeNameEquals(Node node, String desiredName)",
    "source_code": "\tpublic boolean nodeNameEquals(Node node, String desiredName) {\n\t\treturn desiredName.equals(node.getNodeName()) || desiredName.equals(getLocalName(node));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tparserContext.getReaderContext().error(\n\t\t\t\t\"Class [\" + getClass().getName() + \"] does not support custom elements.\", element);\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseArrayElement(arrayEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse an array element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arrayEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1118
    },
    "return": "Object",
    "signature": "public Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Object parseArrayElement(Element arrayEle, @Nullable BeanDefinition bd) {\n\t\tString elementType = arrayEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = arrayEle.getChildNodes();\n\t\tManagedArray target = new ManagedArray(elementType, nl.getLength());\n\t\ttarget.setSource(extractSource(arrayEle));\n\t\ttarget.setElementTypeName(elementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(arrayEle));\n\t\tparseCollectionElements(nl, target, bd, elementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionAttributes(ele,beanName,containingBean,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the attributes of the given bean element to the given bean * definition.\n\t * @param ele bean declaration element\n\t * @param beanName bean name\n\t * @param containingBean containing bean definition\n\t * @return a bean definition initialized according to the bean element attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n\t\t\t@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n\t\tif (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n\t\t\terror(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n\t\t}\n\t\telse if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n\t\t\tbd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n\t\t}\n\t\telse if (containingBean != null) {\n\t\t\t// Take default from containing bean in case of an inner bean definition.\n\t\t\tbd.setScope(containingBean.getScope());\n\t\t}\n\n\t\tif (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n\t\t\tbd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n\t\t}\n\n\t\tString lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\tlazyInit = this.defaults.getLazyInit();\n\t\t}\n\t\tbd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n\t\tString autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n\t\tbd.setAutowireMode(getAutowireMode(autowire));\n\n\t\tif (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n\t\t\tString dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n\t\t\tbd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n\t\t}\n\n\t\tString autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowireCandidate)) {\n\t\t\tString candidatePattern = this.defaults.getAutowireCandidates();\n\t\t\tif (candidatePattern != null) {\n\t\t\t\tString[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n\t\t\t\tbd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n\t\t}\n\n\t\tif (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n\t\t\tbd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n\t\t}\n\n\t\tif (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n\t\t\tString initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n\t\t\tbd.setInitMethodName(initMethodName);\n\t\t}\n\t\telse if (this.defaults.getInitMethod() != null) {\n\t\t\tbd.setInitMethodName(this.defaults.getInitMethod());\n\t\t\tbd.setEnforceInitMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tString destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n\t\t\tbd.setDestroyMethodName(destroyMethodName);\n\t\t}\n\t\telse if (this.defaults.getDestroyMethod() != null) {\n\t\t\tbd.setDestroyMethodName(this.defaults.getDestroyMethod());\n\t\t\tbd.setEnforceDestroyMethod(false);\n\t\t}\n\n\t\tif (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n\t\t\tbd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n\t\t}\n\t\tif (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n\t\t\tbd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n\t\t}\n\n\t\treturn bd;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,beanName,containingBean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "beanName",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "AbstractBeanDefinition",
    "signature": "public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, @Nullable BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\t\tString parent = null;\n\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t}\n\n\t\ttry {\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\tparseMetaElements(ele, bd);\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitionElement(ele,containingBean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parses the supplied {@code <bean>} element. May return {@code null}\n\t * if there were errors during parse. Errors are reported to the\n\t * {@link org.springframework.beans.factory.parsing.ProblemReporter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "containingBean"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "BeanDefinitionHolder",
    "signature": "public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean)",
    "source_code": "\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n\t\tList<String> aliases = new ArrayList<>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\t\tif (beanDefinition != null) {\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// Register an alias for the plain bean class name, if still possible,\n\t\t\t\t\t\t// if the generator returned the class name plus a suffix.\n\t\t\t\t\t\t// This is expected for Spring 1.2/2.0 backwards compatibility.\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n\t\t\t\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseBeanDefinitions(root,delegate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the elements at the root level in the document:\n\t * \"import\", \"alias\", \"bean\".\n\t * @param root the DOM root element of the document\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "root",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n\t\tif (delegate.isDefaultNamespace(root)) {\n\t\t\tNodeList nl = root.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (node instanceof Element ele) {\n\t\t\t\t\tif (delegate.isDefaultNamespace(ele)) {\n\t\t\t\t\t\tparseDefaultElement(ele, delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdelegate.parseCustomElement(ele);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdelegate.parseCustomElement(root);\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseCollectionElements(elementNodes,target,bd,defaultElementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementNodes",
      "target",
      "bd",
      "defaultElementType"
    ],
    "position": {
      "column": 1,
      "line": 1157
    },
    "return": "void",
    "signature": "protected void parseCollectionElements(NodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType)",
    "source_code": "\tprotected void parseCollectionElements(\n\t\t\tNodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType) {\n\n\t\tfor (int i = 0; i < elementNodes.getLength(); i++) {\n\t\t\tNode node = elementNodes.item(i);\n\t\t\tif (node instanceof Element currentElement && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {\n\t\t\t\ttarget.add(parsePropertySubElement(currentElement, bd, defaultElementType));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseConstructorArgElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a constructor-arg element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 779
    },
    "return": "void",
    "signature": "public void parseConstructorArgElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parseConstructorArgElement(Element ele, BeanDefinition bd) {\n\t\tString indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);\n\t\tString typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (StringUtils.hasLength(indexAttr)) {\n\t\t\ttry {\n\t\t\t\tint index = Integer.parseInt(indexAttr);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\terror(\"'index' cannot be lower than 0\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry(index));\n\t\t\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\t\t\tif (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {\n\t\t\t\t\t\t\terror(\"Ambiguous constructor-arg entries for index \" + index, ele);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tthis.parseState.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NumberFormatException ex) {\n\t\t\t\terror(\"Attribute 'index' of tag 'constructor-arg' must be an integer\", ele);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthis.parseState.push(new ConstructorArgumentEntry());\n\t\t\t\tObject value = parsePropertyValue(ele, bd, null);\n\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);\n\t\t\t\tif (StringUtils.hasLength(typeAttr)) {\n\t\t\t\t\tvalueHolder.setType(typeAttr);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\t\t\tvalueHolder.setName(nameAttr);\n\t\t\t\t}\n\t\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.parseState.pop();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseConstructorArgElements(beanEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse constructor-arg sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 695
    },
    "return": "void",
    "signature": "public void parseConstructorArgElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {\n\t\t\t\tparseConstructorArgElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseCustomElement(ele,containingBd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a custom element (outside the default namespace).\n\t * @param ele the element to parse\n\t * @param containingBd the containing bean definition (if any)\n\t * @return the resulting bean definition\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "containingBd"
    ],
    "position": {
      "column": 1,
      "line": 1381
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd)",
    "source_code": "\tpublic BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\tif (namespaceUri == null) {\n\t\t\treturn null;\n\t\t}\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseKeyElement(keyEle,bd,defaultKeyTypeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a key sub-element of a map element.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "keyEle",
      "bd",
      "defaultKeyTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1308
    },
    "return": "Object",
    "signature": "protected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName)",
    "source_code": "\tprotected Object parseKeyElement(Element keyEle, @Nullable BeanDefinition bd, String defaultKeyTypeName) {\n\t\tNodeList nl = keyEle.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element currentElement) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(\"<key> element must not contain more than one value sub-element\", keyEle);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = currentElement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (subElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn parsePropertySubElement(subElement, bd, defaultKeyTypeName);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseListElement(collectionEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a list element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1132
    },
    "return": "List<Object>",
    "signature": "public List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedList<Object> target = new ManagedList<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseLookupOverrideSubElements(beanEle,overrides)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse lookup-override sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "overrides"
    ],
    "position": {
      "column": 1,
      "line": 734
    },
    "return": "void",
    "signature": "public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides)",
    "source_code": "\tpublic void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {\n\t\t\t\tElement ele = (Element) node;\n\t\t\t\tString methodName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString beanRef = ele.getAttribute(BEAN_ELEMENT);\n\t\t\t\tLookupOverride override = new LookupOverride(methodName, beanRef);\n\t\t\t\toverride.setSource(extractSource(ele));\n\t\t\t\toverrides.addOverride(override);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseMapElement(mapEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a map element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1171
    },
    "return": "Object>",
    "signature": "public Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Map<Object, Object> parseMapElement(Element mapEle, @Nullable BeanDefinition bd) {\n\t\tString defaultKeyType = mapEle.getAttribute(KEY_TYPE_ATTRIBUTE);\n\t\tString defaultValueType = mapEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\n\t\tList<Element> entryEles = DomUtils.getChildElementsByTagName(mapEle, ENTRY_ELEMENT);\n\t\tManagedMap<Object, Object> map = new ManagedMap<>(entryEles.size());\n\t\tmap.setSource(extractSource(mapEle));\n\t\tmap.setKeyTypeName(defaultKeyType);\n\t\tmap.setValueTypeName(defaultValueType);\n\t\tmap.setMergeEnabled(parseMergeAttribute(mapEle));\n\n\t\tfor (Element entryEle : entryEles) {\n\t\t\t// Should only have one value child element: ref, value, list, etc.\n\t\t\t// Optionally, there might be a key child element.\n\t\t\tNodeList entrySubNodes = entryEle.getChildNodes();\n\t\t\tElement keyEle = null;\n\t\t\tElement valueEle = null;\n\t\t\tfor (int j = 0; j < entrySubNodes.getLength(); j++) {\n\t\t\t\tNode node = entrySubNodes.item(j);\n\t\t\t\tif (node instanceof Element candidateEle) {\n\t\t\t\t\tif (nodeNameEquals(candidateEle, KEY_ELEMENT)) {\n\t\t\t\t\t\tif (keyEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element is only allowed to contain one <key> sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tkeyEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Child element is what we're looking for.\n\t\t\t\t\t\tif (nodeNameEquals(candidateEle, DESCRIPTION_ELEMENT)) {\n\t\t\t\t\t\t\t// the element is a <description> -> ignore it\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (valueEle != null) {\n\t\t\t\t\t\t\terror(\"<entry> element must not contain more than one value sub-element\", entryEle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvalueEle = candidateEle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extract key from attribute or sub-element.\n\t\t\tObject key = null;\n\t\t\tboolean hasKeyAttribute = entryEle.hasAttribute(KEY_ATTRIBUTE);\n\t\t\tboolean hasKeyRefAttribute = entryEle.hasAttribute(KEY_REF_ATTRIBUTE);\n\t\t\tif ((hasKeyAttribute && hasKeyRefAttribute) ||\n\t\t\t\t\t(hasKeyAttribute || hasKeyRefAttribute) && keyEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"a 'key' attribute OR a 'key-ref' attribute OR a <key> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif (hasKeyAttribute) {\n\t\t\t\tkey = buildTypedStringValueForMap(entryEle.getAttribute(KEY_ATTRIBUTE), defaultKeyType, entryEle);\n\t\t\t}\n\t\t\telse if (hasKeyRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(KEY_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'key-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tkey = ref;\n\t\t\t}\n\t\t\telse if (keyEle != null) {\n\t\t\t\tkey = parseKeyElement(keyEle, bd, defaultKeyType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a key\", entryEle);\n\t\t\t}\n\n\t\t\t// Extract value from attribute or sub-element.\n\t\t\tObject value = null;\n\t\t\tboolean hasValueAttribute = entryEle.hasAttribute(VALUE_ATTRIBUTE);\n\t\t\tboolean hasValueRefAttribute = entryEle.hasAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\tboolean hasValueTypeAttribute = entryEle.hasAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\tif ((hasValueAttribute && hasValueRefAttribute) ||\n\t\t\t\t\t(hasValueAttribute || hasValueRefAttribute) && valueEle != null) {\n\t\t\t\terror(\"<entry> element is only allowed to contain either \" +\n\t\t\t\t\t\t\"'value' attribute OR 'value-ref' attribute OR <value> sub-element\", entryEle);\n\t\t\t}\n\t\t\tif ((hasValueTypeAttribute && hasValueRefAttribute) ||\n\t\t\t\t(hasValueTypeAttribute && !hasValueAttribute) ||\n\t\t\t\t\t(hasValueTypeAttribute && valueEle != null)) {\n\t\t\t\terror(\"<entry> element is only allowed to contain a 'value-type' \" +\n\t\t\t\t\t\t\"attribute when it has a 'value' attribute\", entryEle);\n\t\t\t}\n\t\t\tif (hasValueAttribute) {\n\t\t\t\tString valueType = entryEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(valueType)) {\n\t\t\t\t\tvalueType = defaultValueType;\n\t\t\t\t}\n\t\t\t\tvalue = buildTypedStringValueForMap(entryEle.getAttribute(VALUE_ATTRIBUTE), valueType, entryEle);\n\t\t\t}\n\t\t\telse if (hasValueRefAttribute) {\n\t\t\t\tString refName = entryEle.getAttribute(VALUE_REF_ATTRIBUTE);\n\t\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\t\terror(\"<entry> element contains empty 'value-ref' attribute\", entryEle);\n\t\t\t\t}\n\t\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\t\tref.setSource(extractSource(entryEle));\n\t\t\t\tvalue = ref;\n\t\t\t}\n\t\t\telse if (valueEle != null) {\n\t\t\t\tvalue = parsePropertySubElement(valueEle, bd, defaultValueType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\terror(\"<entry> element must specify a value\", entryEle);\n\t\t\t}\n\n\t\t\t// Add final key and value to the Map.\n\t\t\tmap.put(key, value);\n\t\t}\n\n\t\treturn map;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseMetaElements(ele,attributeAccessor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the meta elements underneath the given element, if any.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "attributeAccessor"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "void",
    "signature": "public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor)",
    "source_code": "\tpublic void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {\n\t\tNodeList nl = ele.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\tElement metaElement = (Element) node;\n\t\t\t\tString key = metaElement.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\tString value = metaElement.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);\n\t\t\t\tattribute.setSource(extractSource(metaElement));\n\t\t\t\tattributeAccessor.addMetadataAttribute(attribute);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a property element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "void",
    "signature": "public void parsePropertyElement(Element ele, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElement(Element ele, BeanDefinition bd) {\n\t\tString propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(propertyName)) {\n\t\t\terror(\"Tag 'property' must have a 'name' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new PropertyEntry(propertyName));\n\t\ttry {\n\t\t\tif (bd.getPropertyValues().contains(propertyName)) {\n\t\t\t\terror(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject val = parsePropertyValue(ele, bd, propertyName);\n\t\t\tPropertyValue pv = new PropertyValue(propertyName, val);\n\t\t\tparseMetaElements(ele, pv);\n\t\t\tpv.setSource(extractSource(ele));\n\t\t\tbd.getPropertyValues().addPropertyValue(pv);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyElements(beanEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse property sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "public void parsePropertyElements(Element beanEle, BeanDefinition bd)",
    "source_code": "\tpublic void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {\n\t\t\t\tparsePropertyElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertySubElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 971
    },
    "return": "Object",
    "signature": "public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) {\n\t\treturn parsePropertySubElement(ele, bd, null);\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertySubElement(ele,bd,defaultValueType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a value, ref or collection sub-element of a property or\n\t * constructor-arg element.\n\t * @param ele subelement of property element; we don't know which yet\n\t * @param bd the current bean definition (if any)\n\t * @param defaultValueType the default type (class name) for any\n\t * {@code <value>} tag that might be created\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd",
      "defaultValueType"
    ],
    "position": {
      "column": 1,
      "line": 984
    },
    "return": "Object",
    "signature": "public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType)",
    "source_code": "\tpublic Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {\n\t\tif (!isDefaultNamespace(ele)) {\n\t\t\treturn parseNestedCustomElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t\tBeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);\n\t\t\tif (nestedBd != null) {\n\t\t\t\tnestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);\n\t\t\t}\n\t\t\treturn nestedBd;\n\t\t}\n\t\telse if (nodeNameEquals(ele, REF_ELEMENT)) {\n\t\t\t// A generic reference to any name of any bean.\n\t\t\tString refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);\n\t\t\tboolean toParent = false;\n\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t// A reference to the id of another bean in a parent context.\n\t\t\t\trefName = ele.getAttribute(PARENT_REF_ATTRIBUTE);\n\t\t\t\ttoParent = true;\n\t\t\t\tif (!StringUtils.hasLength(refName)) {\n\t\t\t\t\terror(\"'bean' or 'parent' is required for <ref> element\", ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(\"<ref> element contains empty target attribute\", ele);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (nodeNameEquals(ele, IDREF_ELEMENT)) {\n\t\t\treturn parseIdRefElement(ele);\n\t\t}\n\t\telse if (nodeNameEquals(ele, VALUE_ELEMENT)) {\n\t\t\treturn parseValueElement(ele, defaultValueType);\n\t\t}\n\t\telse if (nodeNameEquals(ele, NULL_ELEMENT)) {\n\t\t\t// It's a distinguished null value. Let's wrap it in a TypedStringValue\n\t\t\t// object in order to preserve the source location.\n\t\t\tTypedStringValue nullHolder = new TypedStringValue(null);\n\t\t\tnullHolder.setSource(extractSource(ele));\n\t\t\treturn nullHolder;\n\t\t}\n\t\telse if (nodeNameEquals(ele, ARRAY_ELEMENT)) {\n\t\t\treturn parseArrayElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, LIST_ELEMENT)) {\n\t\t\treturn parseListElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, SET_ELEMENT)) {\n\t\t\treturn parseSetElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, MAP_ELEMENT)) {\n\t\t\treturn parseMapElement(ele, bd);\n\t\t}\n\t\telse if (nodeNameEquals(ele, PROPS_ELEMENT)) {\n\t\t\treturn parsePropsElement(ele);\n\t\t}\n\t\telse {\n\t\t\terror(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parsePropertyValue(ele,bd,propertyName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the value of a property element. May be a list etc.\n\t * Also used for constructor arguments, \"propertyName\" being null in this case.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 910
    },
    "return": "Object",
    "signature": "public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName)",
    "source_code": "\tpublic Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {\n\t\tString elementName = (propertyName != null ?\n\t\t\t\t\"<property> element for property '\" + propertyName + \"'\" :\n\t\t\t\t\"<constructor-arg> element\");\n\n\t\t// Should only have one child element: ref, value, list, etc.\n\t\tNodeList nl = ele.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element currentElement && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&\n\t\t\t\t\t!nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(elementName + \" must not contain more than one sub-element\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = currentElement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n\t\tboolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\t\tif ((hasRefAttribute && hasValueAttribute) ||\n\t\t\t\t((hasRefAttribute || hasValueAttribute) && subElement != null)) {\n\t\t\terror(elementName +\n\t\t\t\t\t\" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n\t\t}\n\n\t\tif (hasRefAttribute) {\n\t\t\tString refName = ele.getAttribute(REF_ATTRIBUTE);\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(elementName + \" contains empty 'ref' attribute\", ele);\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t}\n\t\telse if (hasValueAttribute) {\n\t\t\tTypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\treturn valueHolder;\n\t\t}\n\t\telse if (subElement != null) {\n\t\t\treturn parsePropertySubElement(subElement, bd);\n\t\t}\n\t\telse {\n\t\t\t// Neither child element nor \"ref\" or \"value\" attribute found.\n\t\t\terror(elementName + \" must specify a ref or value\", ele);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseQualifierElement(ele,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a qualifier element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 866
    },
    "return": "void",
    "signature": "public void parseQualifierElement(Element ele, AbstractBeanDefinition bd)",
    "source_code": "\tpublic void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {\n\t\tString typeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(typeName)) {\n\t\t\terror(\"Tag 'qualifier' must have a 'type' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new QualifierEntry(typeName));\n\t\ttry {\n\t\t\tAutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);\n\t\t\tqualifier.setSource(extractSource(ele));\n\t\t\tString value = ele.getAttribute(VALUE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasLength(value)) {\n\t\t\t\tqualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);\n\t\t\t}\n\t\t\tNodeList nl = ele.getChildNodes();\n\t\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {\n\t\t\t\t\tElement attributeEle = (Element) node;\n\t\t\t\t\tString attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);\n\t\t\t\t\tString attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);\n\t\t\t\t\tif (StringUtils.hasLength(attributeName) && StringUtils.hasLength(attributeValue)) {\n\t\t\t\t\t\tBeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);\n\t\t\t\t\t\tattribute.setSource(extractSource(attributeEle));\n\t\t\t\t\t\tqualifier.addMetadataAttribute(attribute);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\terror(\"Qualifier 'attribute' tag must have a 'key' and 'value'\", attributeEle);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbd.addQualifier(qualifier);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseQualifierElements(beanEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse qualifier sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 721
    },
    "return": "void",
    "signature": "public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd)",
    "source_code": "\tpublic void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ELEMENT)) {\n\t\t\t\tparseQualifierElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseReplacedMethodSubElements(beanEle,overrides)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse replaced-method sub-elements of the given bean element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanEle",
      "overrides"
    ],
    "position": {
      "column": 1,
      "line": 752
    },
    "return": "void",
    "signature": "public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)",
    "source_code": "\tpublic void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {\n\t\t\t\tElement replacedMethodEle = (Element) node;\n\t\t\t\tString name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);\n\t\t\t\tString callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);\n\t\t\t\tReplaceOverride replaceOverride = new ReplaceOverride(name, callback);\n\t\t\t\t// Look for arg-type match elements.\n\t\t\t\tList<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);\n\t\t\t\tfor (Element argTypeEle : argTypeEles) {\n\t\t\t\t\tString match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);\n\t\t\t\t\tmatch = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));\n\t\t\t\t\tif (StringUtils.hasText(match)) {\n\t\t\t\t\t\treplaceOverride.addTypeIdentifier(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treplaceOverride.setSource(extractSource(replacedMethodEle));\n\t\t\t\toverrides.addOverride(replaceOverride);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseSetElement(collectionEle,bd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse a set element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionEle",
      "bd"
    ],
    "position": {
      "column": 1,
      "line": 1146
    },
    "return": "Set<Object>",
    "signature": "public Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd)",
    "source_code": "\tpublic Set<Object> parseSetElement(Element collectionEle, @Nullable BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedSet<Object> target = new ManagedSet<>(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#parseValueElement(ele,defaultTypeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a typed String value Object for the given value element.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "defaultTypeName"
    ],
    "position": {
      "column": 1,
      "line": 1073
    },
    "return": "Object",
    "signature": "public Object parseValueElement(Element ele, @Nullable String defaultTypeName)",
    "source_code": "\tpublic Object parseValueElement(Element ele, @Nullable String defaultTypeName) {\n\t\t// It's a literal value.\n\t\tString value = DomUtils.getTextValue(ele);\n\t\tString specifiedTypeName = ele.getAttribute(TYPE_ATTRIBUTE);\n\t\tString typeName = specifiedTypeName;\n\t\tif (!StringUtils.hasText(typeName)) {\n\t\t\ttypeName = defaultTypeName;\n\t\t}\n\t\ttry {\n\t\t\tTypedStringValue typedValue = buildTypedStringValue(value, typeName);\n\t\t\ttypedValue.setSource(extractSource(ele));\n\t\t\ttypedValue.setSpecifiedTypeName(specifiedTypeName);\n\t\t\treturn typedValue;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Type class [\" + typeName + \"] not found for <value> element\", ele, ex);\n\t\t\treturn value;\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#populateDefaults(defaults,parentDefaults,root)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,\n\t * autowire, dependency check settings, init-method, destroy-method and merge settings.\n\t * Support nested 'beans' element use cases by falling back to {@code parentDefaults}\n\t * in case the defaults are not explicitly set locally.\n\t * @param defaults the defaults to populate\n\t * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to\n\t * @param root the root element of the current bean definition document (or nested beans element)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "defaults",
      "parentDefaults",
      "root"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "void",
    "signature": "protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root)",
    "source_code": "\tprotected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) {\n\t\tString lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);\n\t\tif (isDefaultValue(lazyInit)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tlazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setLazyInit(lazyInit);\n\n\t\tString merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);\n\t\tif (isDefaultValue(merge)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to false.\n\t\t\tmerge = (parentDefaults != null ? parentDefaults.getMerge() : FALSE_VALUE);\n\t\t}\n\t\tdefaults.setMerge(merge);\n\n\t\tString autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);\n\t\tif (isDefaultValue(autowire)) {\n\t\t\t// Potentially inherited from outer <beans> sections, otherwise falling back to 'no'.\n\t\t\tautowire = (parentDefaults != null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);\n\t\t}\n\t\tdefaults.setAutowire(autowire);\n\n\t\tif (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {\n\t\t\tdefaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setInitMethod(parentDefaults.getInitMethod());\n\t\t}\n\n\t\tif (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {\n\t\t\tdefaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));\n\t\t}\n\t\telse if (parentDefaults != null) {\n\t\t\tdefaults.setDestroyMethod(parentDefaults.getDestroyMethod());\n\t\t}\n\n\t\tdefaults.setSource(this.readerContext.extractSource(root));\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#processBeanDefinition(ele,delegate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ele",
      "delegate"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)",
    "source_code": "\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t// Register the final decorated instance.\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}"
  },
  "org.springframework.beans.factory.xml.<unknown>#registerBeanDefinitions(doc,readerContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation parses bean definitions according to the \"spring-beans\" XSD\n\t * (or DTD, historically).\n\t * <p>Opens a DOM Document; then initializes the default settings\n\t * specified at the {@code <beans/>} level; then parses the contained bean definitions.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "doc",
      "readerContext"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)",
    "source_code": "\tpublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n\t\tthis.readerContext = readerContext;\n\t\tdoRegisterBeanDefinitions(doc.getDocumentElement());\n\t}"
  },
  "org.springframework.beans.propertyeditors.<unknown>#createCollection(collectionType,initialCapacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Collection of the given type, with the given\n\t * initial capacity (if supported by the Collection type).\n\t * @param collectionType a sub-interface of Collection\n\t * @param initialCapacity the initial capacity\n\t * @return the new Collection instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "collectionType",
      "initialCapacity"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "Collection<Object>",
    "signature": "protected Collection<Object> createCollection(Class<? extends Collection> collectionType, int initialCapacity)",
    "source_code": "\tprotected Collection<Object> createCollection(Class<? extends Collection> collectionType, int initialCapacity) {\n\t\tif (!collectionType.isInterface()) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Could not instantiate collection class: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse if (List.class == collectionType) {\n\t\t\treturn new ArrayList<>(initialCapacity);\n\t\t}\n\t\telse if (SortedSet.class == collectionType) {\n\t\t\treturn new TreeSet<>();\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashSet<>(initialCapacity);\n\t\t}\n\t}"
  },
  "org.springframework.beans.propertyeditors.<unknown>#createMap(mapType,initialCapacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Map of the given type, with the given\n\t * initial capacity (if supported by the Map type).\n\t * @param mapType a sub-interface of Map\n\t * @param initialCapacity the initial capacity\n\t * @return the new Map instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapType",
      "initialCapacity"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "Object>",
    "signature": "protected Object> createMap(Class<? extends Map> mapType, int initialCapacity)",
    "source_code": "\tprotected Map<Object, Object> createMap(Class<? extends Map> mapType, int initialCapacity) {\n\t\tif (!mapType.isInterface()) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Could not instantiate map class: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse if (SortedMap.class == mapType) {\n\t\t\treturn new TreeMap<>();\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashMap<>(initialCapacity);\n\t\t}\n\t}"
  },
  "org.springframework.beans.support.<unknown>#compare(o1,o2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "int",
    "signature": "public int compare(T o1, T o2)",
    "source_code": "\tpublic int compare(T o1, T o2) {\n\t\tObject v1 = getPropertyValue(o1);\n\t\tObject v2 = getPropertyValue(o2);\n\t\tif (this.sortDefinition.isIgnoreCase() && (v1 instanceof String text1) && (v2 instanceof String text2)) {\n\t\t\tv1 = text1.toLowerCase(Locale.ROOT);\n\t\t\tv2 = text2.toLowerCase(Locale.ROOT);\n\t\t}\n\n\t\tint result;\n\n\t\t// Put an object with null property at the end of the sort result.\n\t\ttry {\n\t\t\tif (v1 != null) {\n\t\t\t\tresult = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (v2 != null ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not sort objects [\" + o1 + \"] and [\" + o2 + \"]\", ex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (this.sortDefinition.isAscending() ? result : -result);\n\t}"
  },
  "org.springframework.beans.support.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given custom property editor for all properties of the given type.\n\t * <p>Typically used in conjunction with the default\n\t * {@link org.springframework.beans.SimpleTypeConverter}; will work with any\n\t * TypeConverter that implements the PropertyEditorRegistry interface as well.\n\t * @param requiredType type of the property\n\t * @param propertyEditor editor to register\n\t * @see #setTypeConverter\n\t * @see org.springframework.beans.PropertyEditorRegistry#registerCustomEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tTypeConverter converter = getTypeConverter();\n\t\tif (!(converter instanceof PropertyEditorRegistry registry)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"TypeConverter does not implement PropertyEditorRegistry interface: \" + converter);\n\t\t}\n\t\tregistry.registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.beans.support.<unknown>#sort(source,sortDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Sort the given source according to the given sort definition.\n\t * <p>Note: Contained objects have to provide the given property\n\t * in the form of a bean property, i.e. a getXXX method.\n\t * @param source input source\n\t * @param sortDefinition the parameters to sort by\n\t * @throws java.lang.IllegalArgumentException in case of a missing propertyName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sortDefinition"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void sort(Object[] source, SortDefinition sortDefinition)",
    "source_code": "\tpublic static void sort(Object[] source, SortDefinition sortDefinition) throws BeansException {\n\t\tif (StringUtils.hasText(sortDefinition.getProperty())) {\n\t\t\tArrays.sort(source, new PropertyComparator<>(sortDefinition));\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#adaptCaffeineCache(name,AsyncCache<Object,cache)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new Caffeine AsyncCache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the Caffeine AsyncCache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 6.1\n\t * @see CaffeineCache#CaffeineCache(String, AsyncCache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, AsyncCache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#adaptCaffeineCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given new native Caffeine Cache instance to Spring's {@link Cache}\n\t * abstraction for the specified cache name.\n\t * @param name the name of the cache\n\t * @param cache the native Caffeine Cache instance\n\t * @return the Spring CaffeineCache adapter (or a decorator thereof)\n\t * @since 5.2.8\n\t * @see CaffeineCache#CaffeineCache(String, com.github.benmanes.caffeine.cache.Cache, boolean)\n\t * @see #isAllowNullValues()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "Cache",
    "signature": "protected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tprotected Cache adaptCaffeineCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\treturn new CaffeineCache(name, cache, isAllowNullValues());\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#get(key,valueLoader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "T",
    "signature": "public T get(Object key, Callable<T> valueLoader)",
    "source_code": "\tpublic <T> T get(Object key, Callable<T> valueLoader) {\n\t\treturn (T) fromStoreValue(this.cache.get(key, new LoadFunction(valueLoader)));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void put(Object key, @Nullable Object value)",
    "source_code": "\tpublic void put(Object key, @Nullable Object value) {\n\t\tthis.cache.put(key, toStoreValue(value));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#putIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "ValueWrapper",
    "signature": "public ValueWrapper putIfAbsent(Object key, @Nullable Object value)",
    "source_code": "\tpublic ValueWrapper putIfAbsent(Object key, @Nullable Object value) {\n\t\tPutIfAbsentFunction callable = new PutIfAbsentFunction(value);\n\t\tObject result = this.cache.get(key, callable);\n\t\treturn (callable.called ? null : toValueWrapper(result));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#registerCustomCache(name,AsyncCache<Object,cache)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Caffeine AsyncCache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).buildAsync())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n\t * @param name the name of the cache\n\t * @param cache the custom Caffeine AsyncCache instance to register\n\t * @since 6.1\n\t * @see #adaptCaffeineCache(String, AsyncCache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "AsyncCache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, AsyncCache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, AsyncCache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#registerCustomCache(name,com.github.benmanes.caffeine.cache.Cache<Object,cache)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given native Caffeine Cache instance with this cache manager,\n\t * adapting it to Spring's cache API for exposure through {@link #getCache}.\n\t * Any number of such custom caches may be registered side by side.\n\t * <p>This allows for custom settings per cache (as opposed to all caches\n\t * sharing the common settings in the cache manager's configuration) and\n\t * is typically used with the Caffeine builder API:\n\t * {@code registerCustomCache(\"myCache\", Caffeine.newBuilder().maximumSize(10).build())}\n\t * <p>Note that any other caches, whether statically specified through\n\t * {@link #setCacheNames} or dynamically built on demand, still operate\n\t * with the common settings in the cache manager's configuration.\n \t * @param name the name of the cache\n\t * @param cache the custom Caffeine Cache instance to register\n\t * @since 5.2.8\n\t * @see #adaptCaffeineCache(String, com.github.benmanes.caffeine.cache.Cache)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "com.github.benmanes.caffeine.cache.Cache<Object",
      "cache"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "public void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache)",
    "source_code": "\tpublic void registerCustomCache(String name, com.github.benmanes.caffeine.cache.Cache<Object, Object> cache) {\n\t\tthis.customCacheNames.add(name);\n\t\tthis.cacheMap.put(name, adaptCaffeineCache(name, cache));\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#retrieve(key,valueLoader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "valueLoader"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "CompletableFuture<T>",
    "signature": "public CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader)",
    "source_code": "\tpublic <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {\n\t\tif (isAllowNullValues()) {\n\t\t\treturn (CompletableFuture<T>) getAsyncCache()\n\t\t\t\t\t.get(key, (k, e) -> valueLoader.get().thenApply(this::toStoreValue))\n\t\t\t\t\t.thenApply(this::fromStoreValue);\n\t\t}\n\t\telse {\n\t\t\treturn (CompletableFuture<T>) getAsyncCache().get(key, (k, e) -> valueLoader.get());\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#setAsyncCacheLoader(AsyncCacheLoader<Object,cacheLoader)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine AsyncCacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * <p>This implicitly switches the {@link #setAsyncCacheMode \"asyncCacheMode\"}\n\t * flag to {@code true}.\n\t * @since 6.1\n\t * @see #createAsyncCaffeineCache\n\t * @see Caffeine#buildAsync(AsyncCacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "AsyncCacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "public void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setAsyncCacheLoader(AsyncCacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\tthis.asyncCacheMode = true;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#setCacheLoader(CacheLoader<Object,cacheLoader)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine CacheLoader to use for building each individual\n\t * {@link CaffeineCache} instance, turning it into a LoadingCache.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build(CacheLoader)\n\t * @see com.github.benmanes.caffeine.cache.LoadingCache\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "CacheLoader<Object",
      "cacheLoader"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void setCacheLoader(CacheLoader<Object, Object> cacheLoader)",
    "source_code": "\tpublic void setCacheLoader(CacheLoader<Object, Object> cacheLoader) {\n\t\tif (!ObjectUtils.nullSafeEquals(this.cacheLoader, cacheLoader)) {\n\t\t\tthis.cacheLoader = cacheLoader;\n\t\t\trefreshCommonCaches();\n\t\t}\n\t}"
  },
  "org.springframework.cache.caffeine.<unknown>#setCaffeine(Caffeine<Object,caffeine)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the Caffeine to use for building each individual\n\t * {@link CaffeineCache} instance.\n\t * @see #createNativeCaffeineCache\n\t * @see Caffeine#build()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Caffeine<Object",
      "caffeine"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "void",
    "signature": "public void setCaffeine(Caffeine<Object, Object> caffeine)",
    "source_code": "\tpublic void setCaffeine(Caffeine<Object, Object> caffeine) {\n\t\tAssert.notNull(caffeine, \"Caffeine must not be null\");\n\t\tdoSetCaffeine(caffeine);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#addCacheMethod(methodName,ops)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a cacheable method.\n\t * <p>Method names can be exact matches, or of the pattern \"xxx*\",\n\t * \"*xxx\" or \"*xxx*\" for matching multiple methods.\n\t * @param methodName the name of the method\n\t * @param ops operation associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "ops"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void addCacheMethod(String methodName, Collection<CacheOperation> ops)",
    "source_code": "\tpublic void addCacheMethod(String methodName, Collection<CacheOperation> ops) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding method [\" + methodName + \"] with cache operations [\" + ops + \"]\");\n\t\t}\n\t\tthis.nameMap.put(methodName, ops);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#configure(errorHandler,keyGenerator,cacheResolver,cacheManager)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure this aspect with the given error handler, key generator and cache resolver/manager\n\t * suppliers, applying the corresponding default if a supplier is not resolvable.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorHandler",
      "keyGenerator",
      "cacheResolver",
      "cacheManager"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void configure(@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager)",
    "source_code": "\tpublic void configure(\n\t\t\t@Nullable Supplier<CacheErrorHandler> errorHandler, @Nullable Supplier<KeyGenerator> keyGenerator,\n\t\t\t@Nullable Supplier<CacheResolver> cacheResolver, @Nullable Supplier<CacheManager> cacheManager) {\n\n\t\tthis.errorHandler = new SingletonSupplier<>(errorHandler, SimpleCacheErrorHandler::new);\n\t\tthis.keyGenerator = new SingletonSupplier<>(keyGenerator, SimpleKeyGenerator::new);\n\t\tthis.cacheResolver = new SingletonSupplier<>(cacheResolver,\n\t\t\t\t() -> SimpleCacheResolver.of(SupplierUtils.resolve(cacheManager)));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#execute(invoker,target,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "target",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "Object",
    "signature": "protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args)",
    "source_code": "\tprotected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {\n\t\t// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)\n\t\tif (this.initialized) {\n\t\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(target);\n\t\t\tCacheOperationSource cacheOperationSource = getCacheOperationSource();\n\t\t\tif (cacheOperationSource != null) {\n\t\t\t\tCollection<CacheOperation> operations = cacheOperationSource.getCacheOperations(method, targetClass);\n\t\t\t\tif (!CollectionUtils.isEmpty(operations)) {\n\t\t\t\t\treturn execute(invoker, method,\n\t\t\t\t\t\t\tnew CacheOperationContexts(operations, method, args, target, targetClass));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invokeOperation(invoker);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#executeSynchronized(invoker,method,cache,key)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "invoker",
      "method",
      "cache",
      "key"
    ],
    "position": {
      "column": 1,
      "line": 1101
    },
    "return": "Object",
    "signature": "public Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key)",
    "source_code": "\t\tpublic Object executeSynchronized(CacheOperationInvoker invoker, Method method, Cache cache, Object key) {\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(method.getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\t// Flux or similar\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Flux.from(adapter.toPublisher(invokeOperation(invoker))).collectList().toFuture())))\n\t\t\t\t\t\t\t.flatMap(Flux::fromIterable));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mono or similar\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(\n\t\t\t\t\t\t\tcache.retrieve(key,\n\t\t\t\t\t\t\t\t\t() -> Mono.from(adapter.toPublisher(invokeOperation(invoker))).toFuture())));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\treturn Mono.fromFuture(cache.retrieve(key, () -> {\n\t\t\t\t\tMono<?> mono = ((Mono<?>) invokeOperation(invoker));\n\t\t\t\t\tif (mono == null) {\n\t\t\t\t\t\tmono = Mono.empty();\n\t\t\t\t\t}\n\t\t\t\t\treturn mono.toFuture();\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#findInCaches(context,cache,key,invoker,method,contexts)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "cache",
      "key",
      "invoker",
      "method",
      "contexts"
    ],
    "position": {
      "column": 1,
      "line": 1142
    },
    "return": "Object",
    "signature": "public Object findInCaches(CacheOperationContext context, Cache cache, Object key,\n\t\t\t\tCacheOperationInvoker invoker, Method method, CacheOperationContexts contexts)",
    "source_code": "\t\tpublic Object findInCaches(CacheOperationContext context, Cache cache, Object key,\n\t\t\t\tCacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) {\n\n\t\t\tReactiveAdapter adapter = this.registry.getAdapter(context.getMethod().getReturnType());\n\t\t\tif (adapter != null) {\n\t\t\t\tCompletableFuture<?> cachedFuture = doRetrieve(cache, key);\n\t\t\t\tif (cachedFuture == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\treturn adapter.fromPublisher(Flux.from(Mono.fromFuture(cachedFuture))\n\t\t\t\t\t\t\t.switchIfEmpty(Flux.defer(() -> (Flux) evaluate(null, invoker, method, contexts)))\n\t\t\t\t\t\t\t.flatMap(v -> evaluate(valueToFlux(v, contexts), invoker, method, contexts))\n\t\t\t\t\t\t\t.onErrorResume(RuntimeException.class, ex -> {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tgetErrorHandler().handleCacheGetError((RuntimeException) ex, cache, key);\n\t\t\t\t\t\t\t\t\tObject e = evaluate(null, invoker, method, contexts);\n\t\t\t\t\t\t\t\t\treturn (e != null ? e : Flux.error((RuntimeException) ex));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (RuntimeException exception) {\n\t\t\t\t\t\t\t\t\treturn Flux.error(exception);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.fromFuture(cachedFuture)\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> (Mono) evaluate(null, invoker, method, contexts)))\n\t\t\t\t\t\t\t.flatMap(v -> evaluate(Mono.justOrEmpty(unwrapCacheValue(v)), invoker, method, contexts))\n\t\t\t\t\t\t\t.onErrorResume(RuntimeException.class, ex -> {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tgetErrorHandler().handleCacheGetError((RuntimeException) ex, cache, key);\n\t\t\t\t\t\t\t\t\tObject e = evaluate(null, invoker, method, contexts);\n\t\t\t\t\t\t\t\t\treturn (e != null ? e : Mono.error((RuntimeException) ex));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (RuntimeException exception) {\n\t\t\t\t\t\t\t\t\treturn Mono.error(exception);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getBean(name,serviceType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a bean with the specified name and type.\n\t * Used to resolve services that are referenced by name in a {@link CacheOperation}.\n\t * @param name the name of the bean, as defined by the cache operation\n\t * @param serviceType the type expected by the operation's service reference\n\t * @return the bean matching the expected type, qualified by the given name\n\t * @throws org.springframework.beans.factory.NoSuchBeanDefinitionException if such bean does not exist\n\t * @see CacheOperation#getKeyGenerator()\n\t * @see CacheOperation#getCacheManager()\n\t * @see CacheOperation#getCacheResolver()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "serviceType"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "T",
    "signature": "protected T getBean(String name, Class<T> serviceType)",
    "source_code": "\tprotected <T> T getBean(String name, Class<T> serviceType) {\n\t\tif (this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"BeanFactory must be set on cache aspect for \" + serviceType.getSimpleName() + \" retrieval\");\n\t\t}\n\t\treturn BeanFactoryAnnotationUtils.qualifiedBeanOfType(this.beanFactory, serviceType, name);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperationMetadata(operation,method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the {@link CacheOperationMetadata} for the specified operation.\n\t * <p>Resolve the {@link CacheResolver} and the {@link KeyGenerator} to be\n\t * used for the operation.\n\t * @param operation the operation\n\t * @param method the method on which the operation is invoked\n\t * @param targetClass the target type\n\t * @return the resolved metadata for the operation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "CacheOperationMetadata",
    "signature": "protected CacheOperationMetadata getCacheOperationMetadata(CacheOperation operation, Method method, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationMetadata getCacheOperationMetadata(\n\t\t\tCacheOperation operation, Method method, Class<?> targetClass) {\n\n\t\tCacheOperationCacheKey cacheKey = new CacheOperationCacheKey(operation, method, targetClass);\n\t\tCacheOperationMetadata metadata = this.metadataCache.get(cacheKey);\n\t\tif (metadata == null) {\n\t\t\tKeyGenerator operationKeyGenerator;\n\t\t\tif (StringUtils.hasText(operation.getKeyGenerator())) {\n\t\t\t\toperationKeyGenerator = getBean(operation.getKeyGenerator(), KeyGenerator.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationKeyGenerator = getKeyGenerator();\n\t\t\t}\n\t\t\tCacheResolver operationCacheResolver;\n\t\t\tif (StringUtils.hasText(operation.getCacheResolver())) {\n\t\t\t\toperationCacheResolver = getBean(operation.getCacheResolver(), CacheResolver.class);\n\t\t\t}\n\t\t\telse if (StringUtils.hasText(operation.getCacheManager())) {\n\t\t\t\tCacheManager cacheManager = getBean(operation.getCacheManager(), CacheManager.class);\n\t\t\t\toperationCacheResolver = new SimpleCacheResolver(cacheManager);\n\t\t\t}\n\t\t\telse {\n\t\t\t\toperationCacheResolver = getCacheResolver();\n\t\t\t\tAssert.state(operationCacheResolver != null, \"No CacheResolver/CacheManager set\");\n\t\t\t}\n\t\t\tmetadata = new CacheOperationMetadata(operation, method, targetClass,\n\t\t\t\t\toperationKeyGenerator, operationCacheResolver);\n\t\t\tthis.metadataCache.put(cacheKey, metadata);\n\t\t}\n\t\treturn metadata;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getCacheOperations(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Collection<CacheOperation>",
    "signature": "public Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass) {\n\t\t// look for direct name match\n\t\tString methodName = method.getName();\n\t\tCollection<CacheOperation> ops = this.nameMap.get(methodName);\n\n\t\tif (ops == null) {\n\t\t\t// Look for most specific name match.\n\t\t\tString bestNameMatch = null;\n\t\t\tfor (String mappedName : this.nameMap.keySet()) {\n\t\t\t\tif (isMatch(methodName, mappedName)\n\t\t\t\t\t\t&& (bestNameMatch == null || bestNameMatch.length() <= mappedName.length())) {\n\t\t\t\t\tops = this.nameMap.get(mappedName);\n\t\t\t\t\tbestNameMatch = mappedName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ops;\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#getOperationContext(operation,method,args,target,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "operation",
      "method",
      "args",
      "target",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "CacheOperationContext",
    "signature": "protected CacheOperationContext getOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass)",
    "source_code": "\tprotected CacheOperationContext getOperationContext(\n\t\t\tCacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {\n\n\t\tCacheOperationMetadata metadata = getCacheOperationMetadata(operation, method, targetClass);\n\t\treturn new CacheOperationContext(metadata, args, target);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\" matches,\n\t * as well as direct equality. Can be overridden in subclasses.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\tthis.cacheOperationSource.hasCacheOperations(method, targetClass));\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#methodIdentification(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to return a String representation of this Method\n\t * for use in logging. Can be overridden in subclasses to provide a\n\t * different identifier for the given method.\n\t * @param method the method we're interested in\n\t * @param targetClass class the method is on\n\t * @return log message identifying this method\n\t * @see org.springframework.util.ClassUtils#getQualifiedMethodName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "String",
    "signature": "protected String methodIdentification(Method method, Class<?> targetClass)",
    "source_code": "\tprotected String methodIdentification(Method method, Class<?> targetClass) {\n\t\tMethod specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\n\t\treturn ClassUtils.getQualifiedMethodName(specificMethod);\n\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#processCacheEvicts(contexts,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contexts",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1131
    },
    "return": "Object",
    "signature": "public Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result)",
    "source_code": "\t\tpublic Object processCacheEvicts(List<CacheOperationContext> contexts, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t.doOnSuccess(value -> performCacheEvicts(contexts, value)));\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#processPutRequest(request,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 1192
    },
    "return": "Object",
    "signature": "public Object processPutRequest(CachePutRequest request, @Nullable Object result)",
    "source_code": "\t\tpublic Object processPutRequest(CachePutRequest request, @Nullable Object result) {\n\t\t\tReactiveAdapter adapter = (result != null ? this.registry.getAdapter(result.getClass()) : null);\n\t\t\tif (adapter != null) {\n\t\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\t\tFlux<?> source = Flux.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.publish().refCount(2);\n\t\t\t\t\tsource.subscribe(new CachePutListSubscriber(request));\n\t\t\t\t\treturn adapter.fromPublisher(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn adapter.fromPublisher(Mono.from(adapter.toPublisher(result))\n\t\t\t\t\t\t\t.doOnSuccess(request::performCachePut));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NOT_HANDLED;\n\t\t}"
  },
  "org.springframework.cache.interceptor.<unknown>#setNameMap(Map<String,nameMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of method names\n\t * (for example, \"myMethod\") and CacheOperation instances\n\t * (or Strings to be converted to CacheOperation instances).\n\t * @see CacheOperation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "nameMap"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void setNameMap(Map<String, Collection<CacheOperation>> nameMap)",
    "source_code": "\tpublic void setNameMap(Map<String, Collection<CacheOperation>> nameMap) {\n\t\tnameMap.forEach(this::addCacheMethod);\n\t}"
  },
  "org.springframework.cache.jcache.interceptor.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.cacheOperationSource == null ||\n\t\t\t\tthis.cacheOperationSource.hasCacheOperation(method, targetClass));\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,descriptors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors)",
    "source_code": "\tpublic static void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors) {\n\t\tfor (PropertyDescriptor descriptor : descriptors) {\n\t\t\tgen.addProperty(descriptor.getName(), descriptor.getPropertyType());\n\t\t}\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,props)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Map props)",
    "source_code": "\tpublic static void addProperties(BeanGenerator gen, Map props) {\n\t\tfor (Iterator it = props.keySet().iterator(); it.hasNext();) {\n\t\t\tString name = (String)it.next();\n\t\t\tgen.addProperty(name, (Class)props.get(name));\n\t\t}\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#addProperties(gen,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "public void addProperties(BeanGenerator gen, Class type)",
    "source_code": "\tpublic static void addProperties(BeanGenerator gen, Class type) {\n\t\taddProperties(gen, ReflectUtils.getBeanProperties(type));\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#addProperty(name,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void addProperty(String name, Class type)",
    "source_code": "\tpublic void addProperty(String name, Class type) {\n\t\tif (props.containsKey(name)) {\n\t\t\tthrow new IllegalArgumentException(\"Duplicate property name \\\"\" + name + \"\\\"\");\n\t\t}\n\t\tprops.put(name, Type.getType(type));\n\t}"
  },
  "org.springframework.cglib.beans.<unknown>#newInstance(superclass,props)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "superclass",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 44
    },
    "return": "Object",
    "signature": "public Object newInstance(String superclass, Map props)",
    "source_code": "\t\tpublic Object newInstance(String superclass, Map props);"
  },
  "org.springframework.cglib.beans.<unknown>#newInstance(type,require)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "require"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, int require)",
    "source_code": "\t\t\tpublic Object newInstance(Class type, int require);"
  },
  "org.springframework.cglib.beans.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\tpublic Object put(Object key, Object value) {\n\t\treturn put(bean, key, value);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#add(t1,t2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t1",
      "t2"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Type[]",
    "signature": "public Type[] add(Type[] t1, Type[] t2)",
    "source_code": "    public static Type[] add(Type[] t1, Type[] t2) {\n        // TODO: set semantics?\n        Type[] all = new Type[t1.length + t2.length];\n        System.arraycopy(t1, 0, all, 0, t1.length);\n        System.arraycopy(t2, 0, all, t1.length, t2.length);\n        return all;\n    }"
  },
  "org.springframework.cglib.core.<unknown>#add(types,extra)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types",
      "extra"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Type[]",
    "signature": "public Type[] add(Type[] types, Type extra)",
    "source_code": "    public static Type[] add(Type[] types, Type extra) {\n        if (types == null) {\n            return new Type[]{ extra };\n        } else {\n            List list = Arrays.asList(types);\n            if (list.contains(extra)) {\n                return types;\n            }\n            Type[] copy = new Type[types.length + 1];\n            System.arraycopy(types, 0, copy, 0, types.length);\n            copy[types.length] = extra;\n            return copy;\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#addAllInterfaces(type,list)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "List",
    "signature": "public List addAllInterfaces(Class type, List list)",
    "source_code": "\tpublic static List addAllInterfaces(Class type, List list) {\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\tlist.addAll(Arrays.asList(type.getInterfaces()));\n\t\t\taddAllInterfaces(superclass, list);\n\t\t}\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#addAllMethods(type,list)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "list"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "List",
    "signature": "public List addAllMethods(final Class type, final List list)",
    "source_code": "\tpublic static List addAllMethods(final Class type, final List list) {\n\t\tif (type == Object.class) {\n\t\t\tlist.addAll(OBJECT_METHODS);\n\t\t}\n\t\telse {\n\t\t\tlist.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));\n\t\t}\n\n\t\tClass superclass = type.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\taddAllMethods(superclass, list);\n\t\t}\n\t\tClass[] interfaces = type.getInterfaces();\n\t\tfor (Class element : interfaces) {\n\t\t\taddAllMethods(element, list);\n\t\t}\n\n\t\treturn list;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#add_properties(ce,names,types)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "names",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 867
    },
    "return": "void",
    "signature": "public void add_properties(ClassEmitter ce, String[] names, Type[] types)",
    "source_code": "    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#add_property(ce,name,type,fieldName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "name",
      "type",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "void",
    "signature": "public void add_property(ClassEmitter ce, String name, Type type, String fieldName)",
    "source_code": "    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#append_string(e,type,delims,customizer)": {
    "deprecated": false,
    "doc": "    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "void",
    "signature": "public void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer)",
    "source_code": "    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#append_string(e,type,delims,registry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "void",
    "signature": "public void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry)",
    "source_code": "    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_class(version,access,className,superType,interfaces,source)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "className",
      "superType",
      "interfaces",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "void",
    "signature": "public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source)",
    "source_code": "    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {\n        final Type classType = Type.getType(\"L\" + className.replace('.', '/') + \";\");\n        classInfo = new ClassInfo() {\n            @Override\n\t\t\tpublic Type getType() {\n                return classType;\n            }\n            @Override\n\t\t\tpublic Type getSuperType() {\n                return (superType != null) ? superType : Constants.TYPE_OBJECT;\n            }\n            @Override\n\t\t\tpublic Type[] getInterfaces() {\n                return interfaces;\n            }\n            @Override\n\t\t\tpublic int getModifiers() {\n                return access;\n            }\n        };\n        cv.visit(version,\n                 access,\n                 classInfo.getType().getInternalName(),\n                 null,\n                 classInfo.getSuperType().getInternalName(),\n                 TypeUtils.toInternalNames(interfaces));\n        if (source != null) {\n\t\t\tcv.visitSource(source, null);\n\t\t}\n        init();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(access,sig,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "sig",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions)",
    "source_code": "    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n        if (classInfo == null) {\n\t\t\tthrow new IllegalStateException(\"classInfo is null! \" + this);\n\t\t}\n        MethodVisitor v = cv.visitMethod(access,\n                                         sig.getName(),\n                                         sig.getDescriptor(),\n                                         null,\n                                         TypeUtils.toInternalNames(exceptions));\n        if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {\n            rawStaticInit = v;\n            MethodVisitor wrapped = new MethodVisitor(Constants.ASM_API, v) {\n                @Override\n\t\t\t\tpublic void visitMaxs(int maxStack, int maxLocals) {\n                    // ignore\n                }\n                @Override\n\t\t\t\tpublic void visitInsn(int insn) {\n                    if (insn != Constants.RETURN) {\n                        super.visitInsn(insn);\n                    }\n                }\n            };\n            staticInit = new CodeEmitter(this, wrapped, access, sig, exceptions);\n            if (staticHook == null) {\n                // force static hook creation\n                getStaticHook();\n            } else {\n                staticInit.invoke_static_this(staticHookSig);\n            }\n            return staticInit;\n        } else if (sig.equals(staticHookSig)) {\n            return new CodeEmitter(this, v, access, sig, exceptions) {\n                @Override\n\t\t\t\tpublic boolean isStaticHook() {\n                    return true;\n                }\n            };\n        } else {\n            return new CodeEmitter(this, v, access, sig, exceptions);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 944
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\n        return begin_method(e, method, method.getModifiers());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#begin_method(e,method,access)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "CodeEmitter",
    "signature": "public CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access)",
    "source_code": "    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n        return e.begin_method(access,\n                              method.getSignature(),\n                              method.getExceptionTypes());\n    }"
  },
  "org.springframework.cglib.core.<unknown>#constructor_switch(e,constructors,callback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "constructors",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "public void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback)",
    "source_code": "    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#declare_field(access,name,type,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void declare_field(int access, String name, Type type, Object value)",
    "source_code": "    public void declare_field(int access, String name, Type type, Object value) {\n        FieldInfo existing = (FieldInfo)fieldInfo.get(name);\n        FieldInfo info = new FieldInfo(access, name, type, value);\n        if (existing != null) {\n            if (!info.equals(existing)) {\n                throw new IllegalArgumentException(\"Field \\\"\" + name + \"\\\" has been declared differently\");\n            }\n        } else {\n            fieldInfo.put(name, info);\n            cv.visitField(access, name, type.getDescriptor(), null, value);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception {\n\t\treturn defineClass(className, b, loader, null, null);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader,protectionDomain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain) throws Exception {\n\n\t\treturn defineClass(className, b, loader, protectionDomain, null);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#defineClass(className,b,loader,protectionDomain,contextClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "className",
      "b",
      "loader",
      "protectionDomain",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 448
    },
    "return": "Class",
    "signature": "public Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass)",
    "source_code": "\tpublic static Class defineClass(String className, byte[] b, ClassLoader loader,\n\t\t\tProtectionDomain protectionDomain, Class<?> contextClass) throws Exception {\n\n\t\tClass c = null;\n\t\tThrowable t = THROWABLE;\n\n\t\tBiConsumer<String, byte[]> handlerToUse = generatedClassHandler;\n\t\tif (handlerToUse != null) {\n\t\t\thandlerToUse.accept(className, b);\n\t\t}\n\n\t\t// Preferred option: JDK 9+ Lookup.defineClass API if ClassLoader matches\n\t\tif (contextClass != null && contextClass.getClassLoader() == loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (LinkageError | IllegalArgumentException ex) {\n\t\t\t\t// in case of plain LinkageError (class already defined)\n\t\t\t\t// or IllegalArgumentException (class in different package):\n\t\t\t\t// fall through to traditional ClassLoader.defineClass below\n\t\t\t\tt = ex;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// Direct defineClass attempt on the target Classloader\n\t\tif (c == null) {\n\t\t\tif (protectionDomain == null) {\n\t\t\t\tprotectionDomain = PROTECTION_DOMAIN;\n\t\t\t}\n\n\t\t\t// Look for publicDefineClass(String name, byte[] b, ProtectionDomain protectionDomain)\n\t\t\ttry {\n\t\t\t\tMethod publicDefineClass = loader.getClass().getMethod(\n\t\t\t\t\t\t\"publicDefineClass\", String.class, byte[].class, ProtectionDomain.class);\n\t\t\t\tc = (Class) publicDefineClass.invoke(loader, className, b, protectionDomain);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tif (!(ex.getTargetException() instanceof UnsupportedOperationException)) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\t// in case of UnsupportedOperationException, fall through\n\t\t\t\tt = ex.getTargetException();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// publicDefineClass method not available -> fall through\n\t\t\t\tt = ex;\n\t\t\t}\n\n\t\t\t// Classic option: protected ClassLoader.defineClass method\n\t\t\tif (c == null && classLoaderDefineClassMethod != null) {\n\t\t\t\tObject[] args = new Object[]{className, b, 0, b.length, protectionDomain};\n\t\t\t\ttry {\n\t\t\t\t\tif (!classLoaderDefineClassMethod.isAccessible()) {\n\t\t\t\t\t\tclassLoaderDefineClassMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t\tc = (Class) classLoaderDefineClassMethod.invoke(loader, args);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n\t\t\t\t}\n\t\t\t\tcatch (InaccessibleObjectException ex) {\n\t\t\t\t\t// setAccessible failed with JDK 9+ InaccessibleObjectException -> fall through\n\t\t\t\t\t// Avoid through JVM startup with --add-opens=java.base/java.lang=ALL-UNNAMED\n\t\t\t\t\tt = ex;\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fallback option: JDK 9+ Lookup.defineClass API even if ClassLoader does not match\n\t\tif (c == null && contextClass != null && contextClass.getClassLoader() != loader) {\n\t\t\ttry {\n\t\t\t\tMethodHandles.Lookup lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());\n\t\t\t\tc = lookup.defineClass(b);\n\t\t\t}\n\t\t\tcatch (LinkageError | IllegalAccessException ex) {\n\t\t\t\tthrow new CodeGenerationException(ex) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getMessage() {\n\t\t\t\t\t\treturn \"ClassLoader mismatch for [\" + contextClass.getName() +\n\t\t\t\t\t\t\t\t\"]: JVM should be started with --add-opens=java.base/java.lang=ALL-UNNAMED \" +\n\t\t\t\t\t\t\t\t\"for ClassLoader.defineClass to be accessible on \" + loader.getClass().getName() +\n\t\t\t\t\t\t\t\t\"; consider co-locating the affected class in that target ClassLoader instead.\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new CodeGenerationException(ex);\n\t\t\t}\n\t\t}\n\n\t\t// No defineClass variant available at all?\n\t\tif (c == null) {\n\t\t\tthrow new CodeGenerationException(t) {\n\t\t\t\t@Override\n\t\t\t\tpublic String getMessage() {\n\t\t\t\t\treturn \"No compatible defineClass mechanism detected: \" +\n\t\t\t\t\t\t\t\"JVM should be started with --add-opens=java.base/java.lang=ALL-UNNAMED \" +\n\t\t\t\t\t\t\t\"for ClassLoader.defineClass to be accessible. On the module path, \" +\n\t\t\t\t\t\t\t\"you may not be able to define this CGLIB-generated class at all.\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Force static initializers to run.\n\t\tClass.forName(className, true, loader);\n\t\treturn c;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#factory_method(ce,sig)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ce",
      "sig"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void factory_method(ClassEmitter ce, Signature sig)",
    "source_code": "    public static void factory_method(ClassEmitter ce, Signature sig) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        e.new_instance_this();\n        e.dup();\n        e.load_args();\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        e.return_value();\n        e.end_method();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#findConstructor(desc,loader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Constructor",
    "signature": "public Constructor findConstructor(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Constructor findConstructor(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tString className = desc.substring(0, lparen).trim();\n\t\t\treturn getClass(className, loader).getConstructor(parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findDeclaredMethod(type,methodName,parameterTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "methodName",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "Method",
    "signature": "public Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)",
    "source_code": "\tpublic static Method findDeclaredMethod(final Class type,\n\t\t\tfinal String methodName, final Class[] parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tClass cl = type;\n\t\twhile (cl != null) {\n\t\t\ttry {\n\t\t\t\treturn cl.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException e) {\n\t\t\t\tcl = cl.getSuperclass();\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchMethodException(methodName);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findMethod(desc,loader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc",
      "loader"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Method",
    "signature": "public Method findMethod(String desc, ClassLoader loader)",
    "source_code": "\tpublic static Method findMethod(String desc, ClassLoader loader) {\n\t\ttry {\n\t\t\tint lparen = desc.indexOf('(');\n\t\t\tint dot = desc.lastIndexOf('.', lparen);\n\t\t\tString className = desc.substring(0, dot).trim();\n\t\t\tString methodName = desc.substring(dot + 1, lparen).trim();\n\t\t\treturn getClass(className, loader).getDeclaredMethod(methodName, parseTypes(desc, loader));\n\t\t}\n\t\tcatch (ClassNotFoundException | NoSuchMethodException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#findMethods(namesAndDescriptors,methods)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "namesAndDescriptors",
      "methods"
    ],
    "position": {
      "column": 1,
      "line": 646
    },
    "return": "Method[]",
    "signature": "public Method[] findMethods(String[] namesAndDescriptors, Method[] methods)",
    "source_code": "\tpublic static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) {\n\t\tMap map = new HashMap();\n\t\tfor (Method method : methods) {\n\t\t\tmap.put(method.getName() + Type.getMethodDescriptor(method), method);\n\t\t}\n\t\tMethod[] result = new Method[namesAndDescriptors.length / 2];\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tresult[i] = (Method) map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);\n\t\t\tif (result[i] == null) {\n\t\t\t\t// TODO: error?\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#get(gen,useCache)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "gen",
      "useCache"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "public Object get(AbstractClassGenerator gen, boolean useCache)",
    "source_code": "\t\tpublic Object get(AbstractClassGenerator gen, boolean useCache) {\n\t\t\tif (!useCache) {\n\t\t\t\treturn gen.generate(ClassLoaderData.this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject cachedValue = generatedClasses.get(gen);\n\t\t\t\treturn gen.unwrapCachedValue(cachedValue);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.cglib.core.<unknown>#getClassName(prefix,source,key,names)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix",
      "source",
      "key",
      "names"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "String",
    "signature": "public String getClassName(String prefix, String source, Object key, Predicate names)",
    "source_code": "    public String getClassName(String prefix, String source, Object key, Predicate names) {\n        if (prefix == null) {\n            prefix = \"org.springframework.cglib.empty.Object\";\n        } else if (prefix.startsWith(\"java\")) {\n            prefix = \"$\" + prefix;\n        }\n        String base =\n            prefix + \"$$\" +\n            source.substring(source.lastIndexOf('.') + 1) +\n            getTag() + \"$$\" +\n            Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\n        String attempt = base;\n        int index = 2;\n        while (names.evaluate(attempt)) {\n\t\t\tattempt = base + \"_\" + index++;\n\t\t}\n        return attempt;\n    }"
  },
  "org.springframework.cglib.core.<unknown>#getConstructor(type,parameterTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "Constructor",
    "signature": "public Constructor getConstructor(Class type, Class[] parameterTypes)",
    "source_code": "\tpublic static Constructor getConstructor(Class type, Class[] parameterTypes) {\n\t\ttry {\n\t\t\tConstructor constructor = type.getDeclaredConstructor(parameterTypes);\n\t\t\tconstructor.setAccessible(true);\n\t\t\treturn constructor;\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#getMethodInfo(member,modifiers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "member",
      "modifiers"
    ],
    "position": {
      "column": 1,
      "line": 588
    },
    "return": "MethodInfo",
    "signature": "public MethodInfo getMethodInfo(final Member member, final int modifiers)",
    "source_code": "\tpublic static MethodInfo getMethodInfo(final Member member, final int modifiers) {\n\t\tfinal Signature sig = getSignature(member);\n\t\treturn new MethodInfo() {\n\t\t\tprivate ClassInfo ci;\n\n\t\t\t@Override\n\t\t\tpublic ClassInfo getClassInfo() {\n\t\t\t\tif (ci == null) {\n\t\t\t\t\tci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n\t\t\t\t}\n\t\t\t\treturn ci;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getModifiers() {\n\t\t\t\treturn modifiers;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Signature getSignature() {\n\t\t\t\treturn sig;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Type[] getExceptionTypes() {\n\t\t\t\treturn ReflectUtils.getExceptionTypes(member);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#getPropertyMethods(properties,read,write)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "read",
      "write"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "Method[]",
    "signature": "public Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write)",
    "source_code": "\tpublic static Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write) {\n\t\tSet methods = new HashSet();\n\t\tfor (PropertyDescriptor pd : properties) {\n\t\t\tif (read) {\n\t\t\t\tmethods.add(pd.getReadMethod());\n\t\t\t}\n\t\t\tif (write) {\n\t\t\t\tmethods.add(pd.getWriteMethod());\n\t\t\t}\n\t\t}\n\t\tmethods.remove(null);\n\t\treturn (Method[]) methods.toArray(new Method[methods.size()]);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#hash_code(e,type,multiplier,customizer)": {
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#hash_code(e,type,multiplier,registry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "multiplier",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "void",
    "signature": "public void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry)",
    "source_code": "    public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\n        if (TypeUtils.isArray(type)) {\n            hash_array(e, type, multiplier, registry);\n        } else {\n            e.swap(Type.INT_TYPE, type);\n            e.push(multiplier);\n            e.math(CodeEmitter.MUL, Type.INT_TYPE);\n            e.swap(type, Type.INT_TYPE);\n            if (TypeUtils.isPrimitive(type)) {\n                hash_primitive(e, type);\n            } else {\n                hash_object(e, type, registry);\n            }\n            e.math(CodeEmitter.ADD, Type.INT_TYPE);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#load_class(e,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "public void load_class(CodeEmitter e, Type type)",
    "source_code": "    public static void load_class(CodeEmitter e, Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                throw new IllegalArgumentException(\"cannot load void type\");\n            }\n            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n        } else {\n            load_class_helper(e, type);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#load_method(e,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 705
    },
    "return": "void",
    "signature": "public void load_method(CodeEmitter e, MethodInfo method)",
    "source_code": "    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#method_switch(e,methods,callback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "methods",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 716
    },
    "return": "void",
    "signature": "public void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback)",
    "source_code": "    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#newInstance(cstruct,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cstruct",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "Object",
    "signature": "public Object newInstance(final Constructor cstruct, final Object[] args)",
    "source_code": "\tpublic static Object newInstance(final Constructor cstruct, final Object[] args) {\n\t\tboolean flag = cstruct.isAccessible();\n\t\ttry {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(true);\n\t\t\t}\n\t\t\tObject result = cstruct.newInstance(args);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow new CodeGenerationException(e.getTargetException());\n\t\t}\n\t\tfinally {\n\t\t\tif (!flag) {\n\t\t\t\tcstruct.setAccessible(flag);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#newInstance(type,parameterTypes,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "Object",
    "signature": "public Object newInstance(Class type, Class[] parameterTypes, Object[] args)",
    "source_code": "\tpublic static Object newInstance(Class type, Class[] parameterTypes, Object[] args) {\n\t\treturn newInstance(getConstructor(type, parameterTypes), args);\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#not_equals(e,type,notEquals,customizer)": {
    "deprecated": false,
    "doc": "    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "notEquals",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "void",
    "signature": "public void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer)",
    "source_code": "    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#not_equals(e,type,notEquals,registry)": {
    "deprecated": false,
    "doc": "    /**\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "notEquals",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "public void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry)",
    "source_code": "    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\n        (new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                not_equals_helper(e, type, notEquals, registry, this);\n            }\n        }).processElement(type);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#processCase(key,dontUseEnd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "dontUseEnd"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "void",
    "signature": "public void processCase(Object key, Label dontUseEnd)",
    "source_code": "                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }"
  },
  "org.springframework.cglib.core.<unknown>#processCase(key,ignore_end)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "ignore_end"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void processCase(int key, Label ignore_end)",
    "source_code": "            public void processCase(int key, Label ignore_end) throws Exception {\n                List bucket = (List)buckets.get(key);\n                Label next = null;\n                if (skipEquals && bucket.size() == 1) {\n                    if (skipEquals) {\n\t\t\t\t\t\te.pop();\n\t\t\t\t\t}\n                    callback.processCase(bucket.get(0), end);\n                } else {\n                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n                        String string = (String)it.next();\n                        if (next != null) {\n                            e.mark(next);\n                        }\n                        if (it.hasNext()) {\n                            e.dup();\n                        }\n                        e.push(string);\n                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                        if (it.hasNext()) {\n                            e.if_jump(CodeEmitter.EQ, next = e.make_label());\n                            e.pop();\n                        } else {\n                            e.if_jump(CodeEmitter.EQ, def);\n                        }\n                        callback.processCase(string, end);\n                    }\n                }\n            }"
  },
  "org.springframework.cglib.core.<unknown>#process_array(e,type,callback)": {
    "deprecated": false,
    "doc": "    /**\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback)",
    "source_code": "    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#process_arrays(e,type,callback)": {
    "deprecated": false,
    "doc": "    /**\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback)",
    "source_code": "    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array1 = e.make_local();\n        Local array2 = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array1);\n        e.store_local(array2);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array1);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        e.load_local(array2);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array1);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#push_array(e,array)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void push_array(CodeEmitter e, Object[] array)",
    "source_code": "    public static void push_array(CodeEmitter e, Object[] array) {\n        e.push(array.length);\n        e.newarray(Type.getType(remapComponentType(array.getClass().componentType())));\n        for (int i = 0; i < array.length; i++) {\n            e.dup();\n            e.push(i);\n            push_object(e, array[i]);\n            e.aastore();\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#push_object(e,obj)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void push_object(CodeEmitter e, Object obj)",
    "source_code": "    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#setGeneratedClassHandler(BiConsumer<String,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "void",
    "signature": "public void setGeneratedClassHandler(BiConsumer<String, byte[]> handler)",
    "source_code": "\tpublic static void setGeneratedClassHandler(BiConsumer<String, byte[]> handler) {\n\t\tgeneratedClassHandler = handler;\n\t}"
  },
  "org.springframework.cglib.core.<unknown>#string_switch(e,strings,switchStyle,callback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "strings",
      "switchStyle",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "public void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback)",
    "source_code": "    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n        try {\n            switch (switchStyle) {\n            case Constants.SWITCH_STYLE_TRIE:\n                string_switch_trie(e, strings, callback);\n                break;\n            case Constants.SWITCH_STYLE_HASH:\n                string_switch_hash(e, strings, callback, false);\n                break;\n            case Constants.SWITCH_STYLE_HASHONLY:\n                string_switch_hash(e, strings, callback, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n            }\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }"
  },
  "org.springframework.cglib.core.<unknown>#to_string(e,type,delims,registry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "type",
      "delims",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "void",
    "signature": "public void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry)",
    "source_code": "    public static void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry) {\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\n        e.dup();\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n        e.swap();\n        append_string(e, type, delims, registry);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visit(version,access,name,signature,superName,interfaces)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "name",
      "signature",
      "superName",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "void",
    "signature": "public void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces)",
    "source_code": "\tpublic void visit(int version,\n                      int access,\n                      String name,\n                      String signature,\n                      String superName,\n                      String[] interfaces) {\n        begin_class(version,\n                    access,\n                    name.replace('/', '.'),\n                    TypeUtils.fromInternalName(superName),\n                    TypeUtils.fromInternalNames(interfaces),\n                    null); // TODO\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitField(access,name,desc,signature,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "FieldVisitor",
    "signature": "public FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value)",
    "source_code": "\tpublic FieldVisitor visitField(int access,\n                                   String name,\n                                   String desc,\n                                   String signature,\n                                   Object value) {\n        declare_field(access, name, Type.getType(desc), value);\n        return null; // TODO\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitIincInsn(var,increment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "var",
      "increment"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void visitIincInsn(final int var, final int increment)",
    "source_code": "\tpublic void visitIincInsn(final int var, final int increment) {\n        mv.visitIincInsn(remap(var, 1), increment);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitLocalVariable(name,desc,signature,start,end,index)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "desc",
      "signature",
      "start",
      "end",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void visitLocalVariable(final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)",
    "source_code": "\tpublic void visitLocalVariable(\n        final String name,\n        final String desc,\n        final String signature,\n        final Label start,\n        final Label end,\n        final int index)\n    {\n        mv.visitLocalVariable(name, desc, signature, start, end, remap(index));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitMaxs(maxStack,maxLocals)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "maxStack",
      "maxLocals"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void visitMaxs(final int maxStack, final int maxLocals)",
    "source_code": "\tpublic void visitMaxs(final int maxStack, final int maxLocals) {\n        mv.visitMaxs(maxStack, state.nextLocal);\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitMethod(access,name,desc,signature,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "desc",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(int access,\n                                     String name,\n                                     String desc,\n                                     String signature,\n                                     String[] exceptions) {\n        return begin_method(access,\n                            new Signature(name, desc),\n                            TypeUtils.fromInternalNames(exceptions));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#visitVarInsn(opcode,var)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "opcode",
      "var"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void visitVarInsn(final int opcode, final int var)",
    "source_code": "\tpublic void visitVarInsn(final int opcode, final int var) {\n        int size = switch (opcode) {\n\t\t\tcase Opcodes.LLOAD, Opcodes.LSTORE, Opcodes.DLOAD, Opcodes.DSTORE -> 2;\n\t\t\tdefault -> 1;\n\t\t};\n        mv.visitVarInsn(opcode, remap(var, size));\n    }"
  },
  "org.springframework.cglib.core.<unknown>#wrap_throwable(block,wrapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "block",
      "wrapper"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "void",
    "signature": "public void wrap_throwable(Block block, Type wrapper)",
    "source_code": "    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }"
  },
  "org.springframework.cglib.core.<unknown>#wrap_undeclared_throwable(e,handler,exceptions,wrapper)": {
    "deprecated": false,
    "doc": "    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */\n    @Deprecated\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }\n\n    private static void append_string_helper(CodeEmitter e,\n                                             Type type,\n                                             ArrayDelimiters delims,\n                                             CustomizerRegistry registry,\n                                             ProcessArrayCallback callback) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n                break;\n            case Type.DOUBLE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n                break;\n            case Type.FLOAT:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n                break;\n            case Type.LONG:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n                break;\n            case Type.BOOLEAN:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n                break;\n            case Type.CHAR:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n                break;\n            }\n        } else if (TypeUtils.isArray(type)) {\n            e.dup();\n            e.ifnull(skip);\n            e.swap();\n            if (delims != null && delims.before != null && !delims.before.isEmpty()) {\n                e.push(delims.before);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                e.swap();\n            }\n            EmitUtils.process_array(e, type, callback);\n            shrinkStringBuffer(e, 2);\n            if (delims != null && delims.after != null && !delims.after.isEmpty()) {\n                e.push(delims.after);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        } else {\n            e.dup();\n            e.ifnull(skip);\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(\"null\");\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        e.mark(end);\n    }\n\n    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n        e.dup();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n        e.push(amt);\n        e.math(CodeEmitter.SUB, Type.INT_TYPE);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n    }\n\n    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }\n\n    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }\n\n    private interface ParameterTyper {\n        Type[] getParameterTypes(MethodInfo member);\n    }\n\n    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }\n\n    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }\n\n    private static void member_switch_helper(final CodeEmitter e,\n                                             List members,\n                                             final ObjectSwitchCallback callback,\n                                             boolean useName) {\n        try {\n            final Map cache = new HashMap();\n            final ParameterTyper cached = member -> {\n                Type[] types = (Type[]) cache.get(member);\n                if (types == null) {\n                    cache.put(member, types = member.getSignature().getArgumentTypes());\n                }\n                return types;\n            };\n            final Label def = e.make_label();\n            final Label end = e.make_label();\n            if (useName) {\n                e.swap();\n                final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo)value).getSignature().getName());\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                        @Override\n                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n                        }\n                        @Override\n                        public void processDefault() throws Exception {\n                            e.goTo(def);\n                        }\n                    });\n            } else {\n                member_helper_size(e, members, callback, cached, def, end);\n            }\n            e.mark(def);\n            e.pop();\n            callback.processDefault();\n            e.mark(end);\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void member_helper_size(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end) throws Exception {\n        final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo)value).length);\n        e.dup();\n        e.arraylength();\n        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label dontUseEnd) throws Exception {\n                List bucket = (List)buckets.get(key);\n                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n            }\n            @Override\n            public void processDefault() throws Exception {\n                e.goTo(def);\n            }\n        });\n    }\n\n    private static void member_helper_type(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end,\n                                           final BitSet checked) throws Exception {\n        if (members.size() == 1) {\n            MethodInfo member = (MethodInfo)members.get(0);\n            Type[] types = typer.getParameterTypes(member);\n            // need to check classes that have not already been checked via switches\n            for (int i = 0; i < types.length; i++) {\n                if (checked == null || !checked.get(i)) {\n                    e.dup();\n                    e.aaload(i);\n                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n                    e.push(TypeUtils.emulateClassGetName(types[i]));\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                    e.if_jump(CodeEmitter.EQ, def);\n                }\n            }\n            e.pop();\n            callback.processCase(member, end);\n        } else {\n            // choose the index that has the best chance of uniquely identifying member\n            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n            Map buckets = null;\n            int index = -1;\n            for (int i = 0; i < example.length; i++) {\n                final int j = i;\n                Map test = CollectionUtils.bucket(members,\n                        value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]));\n                if (buckets == null || test.size() > buckets.size()) {\n                    buckets = test;\n                    index = i;\n                }\n            }\n            if (buckets == null || buckets.size() == 1) {\n                // TODO: switch by returnType\n                // must have two methods with same name, types, and different return types\n                e.goTo(def);\n            } else {\n                checked.set(index);\n\n                e.dup();\n                e.aaload(index);\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n\n                final Map fbuckets = buckets;\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                    @Override\n                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }\n                    @Override\n                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }\n                });\n            }\n        }\n    }\n\n    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }\n\n    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }\n\n    /* generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }\n    */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "e",
      "handler",
      "exceptions",
      "wrapper"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "public void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper)",
    "source_code": "    public static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\n        Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\n\n        if (set.contains(Constants.TYPE_THROWABLE)) {\n\t\t\treturn;\n\t\t}\n\n        boolean needThrow = exceptions != null;\n        if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\n            e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\n            needThrow = true;\n        }\n        if (!set.contains(Constants.TYPE_ERROR)) {\n            e.catch_exception(handler, Constants.TYPE_ERROR);\n            needThrow = true;\n        }\n        if (exceptions != null) {\n            for (Type exception : exceptions) {\n                e.catch_exception(handler, exception);\n            }\n        }\n        if (needThrow) {\n            e.athrow();\n        }\n        // e -> eo -> oeo -> ooe -> o\n        e.catch_exception(handler, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }"
  },
  "org.springframework.cglib.core.internal.<unknown>#createEntry(key,cacheKey,v)": {
    "deprecated": false,
    "doc": "    /**\n     * Loads entry to the cache.\n     * If entry is missing, put {@link FutureTask} first so other competing thread might wait for the result.\n     * @param key original key that would be used to load the instance\n     * @param cacheKey key that would be used to store the entry in internal map\n     * @param v null or {@link FutureTask<V>}\n     * @return newly created instance\n     */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "cacheKey",
      "v"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "V",
    "signature": "protected V createEntry(final K key, KK cacheKey, Object v)",
    "source_code": "    protected V createEntry(final K key, KK cacheKey, Object v) {\n        FutureTask<V> task;\n        boolean creator = false;\n        if (v != null) {\n            // Another thread is already loading an instance\n            task = (FutureTask<V>) v;\n        } else {\n            task = new FutureTask<>(() -> loader.apply(key));\n            Object prevTask = map.putIfAbsent(cacheKey, task);\n            if (prevTask == null) {\n                // creator does the load\n                creator = true;\n                task.run();\n            } else if (prevTask instanceof FutureTask) {\n                task = (FutureTask<V>) prevTask;\n            } else {\n                return (V) prevTask;\n            }\n        }\n\n        V result;\n        try {\n            result = task.get();\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(\"Interrupted while loading cache item\", e);\n        } catch (ExecutionException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException runtimeException) {\n                throw runtimeException;\n            }\n            throw new IllegalStateException(\"Unable to load cache item\", cause);\n        }\n        if (creator) {\n            map.put(cacheKey, result);\n        }\n        return result;\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#create(loader,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "loader",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "FastClass",
    "signature": "public FastClass create(ClassLoader loader, Class type)",
    "source_code": "    public static FastClass create(ClassLoader loader, Class type) {\n        Generator gen = new Generator();\n        gen.setType(type);\n        gen.setClassLoader(loader);\n        return gen.create();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getMethod(name,parameterTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "FastMethod",
    "signature": "public FastMethod getMethod(String name, Class[] parameterTypes)",
    "source_code": "    public FastMethod getMethod(String name, Class[] parameterTypes) {\n        try {\n            return getMethod(type.getMethod(name, parameterTypes));\n        } catch (NoSuchMethodException e) {\n            throw new NoSuchMethodError(e.getMessage());\n        }\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#getSignatureWithoutReturnType(name,parameterTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "protected String getSignatureWithoutReturnType(String name, Class[] parameterTypes)",
    "source_code": "    protected static String getSignatureWithoutReturnType(String name, Class[] parameterTypes) {\n\t\tStringBuilder sb = new StringBuilder();\n        sb.append(name);\n        sb.append('(');\n        for (Class parameterType : parameterTypes) {\n            sb.append(Type.getDescriptor(parameterType));\n        }\n        sb.append(')');\n        return sb.toString();\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#invoke(name,parameterTypes,obj,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "parameterTypes",
      "obj",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Object",
    "signature": "public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args)",
    "source_code": "    public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) throws InvocationTargetException {\n        return invoke(getIndex(name, parameterTypes), obj, args);\n    }"
  },
  "org.springframework.cglib.reflect.<unknown>#newInstance(parameterTypes,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterTypes",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object newInstance(Class[] parameterTypes, Object[] args)",
    "source_code": "    public Object newInstance(Class[] parameterTypes, Object[] args) throws InvocationTargetException {\n        return newInstance(getIndex(parameterTypes), args);\n    }"
  },
  "org.springframework.context.annotation.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 678
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tregisterRuntimeHints(generationContext.getRuntimeHints());\n\t\t\tGeneratedMethod generatedMethod = beanFactoryInitializationCode.getMethods()\n\t\t\t\t\t.add(\"processPropertySources\", this::generateAddPropertySourceProcessorMethod);\n\t\t\tbeanFactoryInitializationCode.addInitializer(generatedMethod.toMethodReference());\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 881
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"ResourceAutowiring\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Resource autowiring for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generateMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply resource autowiring.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(generatedClass.getName(),\n\t\t\t\t\t\tgenerationContext.getRuntimeHints()));\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generateMethod.toMethodReference());\n\n\t\t\tregisterHints(generationContext.getRuntimeHints());\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#autowireResource(factory,element,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a resource object for the given name and type through autowiring\n\t * based on the given factory.\n\t * @param factory the factory to autowire against\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @throws NoSuchBeanDefinitionException if no corresponding target resource found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "factory",
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "Object",
    "signature": "protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tObject resource;\n\t\tSet<String> autowiredBeanNames;\n\t\tString name = element.name;\n\n\t\tif (factory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) {\n\t\t\tif (this.fallbackToDefaultTypeMatch && element.isDefaultName && !factory.containsBean(name)) {\n\t\t\t\tautowiredBeanNames = new LinkedHashSet<>();\n\t\t\t\tresource = autowireCapableBeanFactory.resolveDependency(\n\t\t\t\t\t\telement.getDependencyDescriptor(), requestingBeanName, autowiredBeanNames, null);\n\t\t\t\tif (resource == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(element.getLookupType(), \"No resolvable resource object\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresource = autowireCapableBeanFactory.resolveBeanByName(name, element.getDependencyDescriptor());\n\t\t\t\tautowiredBeanNames = Collections.singleton(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresource = factory.getBean(name, element.lookupType);\n\t\t\tautowiredBeanNames = Collections.singleton(name);\n\t\t}\n\n\t\tif (factory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\tif (requestingBeanName != null && configurableBeanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\tconfigurableBeanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resource;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildDefaultBeanName(definition,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Derive a default bean name from the given bean definition.\n\t * <p>The default implementation delegates to {@link #buildDefaultBeanName(BeanDefinition)}.\n\t * @param definition the bean definition to build a bean name for\n\t * @param registry the registry that the given bean definition is being registered with\n\t * @return the default bean name (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definition",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "String",
    "signature": "protected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected String buildDefaultBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\treturn buildDefaultBeanName(definition);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#buildLazyResourceProxy(element,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a lazily resolving resource proxy for the given name and type,\n\t * delegating to {@link #getResource} on demand once a method call comes in.\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @since 4.2\n\t * @see #getResource\n\t * @see Lazy\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "Object",
    "signature": "protected Object buildLazyResourceProxy(LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object buildLazyResourceProxy(LookupElement element, @Nullable String requestingBeanName) {\n\t\tTargetSource ts = new TargetSource() {\n\t\t\t@Override\n\t\t\tpublic Class<?> getTargetClass() {\n\t\t\t\treturn element.lookupType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Object getTarget() {\n\t\t\t\treturn getResource(element, requestingBeanName);\n\t\t\t}\n\t\t};\n\n\t\tProxyFactory pf = new ProxyFactory();\n\t\tpf.setTargetSource(ts);\n\t\tif (element.lookupType.isInterface()) {\n\t\t\tpf.addInterface(element.lookupType);\n\t\t}\n\t\tClassLoader classLoader = (this.beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory ?\n\t\t\t\tconfigurableBeanFactory.getBeanClassLoader() : null);\n\t\treturn pf.getProxy(classLoader);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#checkCandidate(beanName,beanDefinition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given candidate's bean name, determining whether the corresponding\n\t * bean definition needs to be registered or conflicts with an existing definition.\n\t * @param beanName the suggested name for the bean\n\t * @param beanDefinition the corresponding bean definition\n\t * @return {@code true} if the bean can be registered as-is;\n\t * {@code false} if it should be skipped because there is an\n\t * existing, compatible bean definition for the specified name\n\t * @throws IllegalStateException if an existing, incompatible bean definition\n\t * has been found for the specified name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "boolean",
    "signature": "protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tBeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n\t\tBeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n\t\tif (originatingDef != null) {\n\t\t\texistingDef = originatingDef;\n\t\t}\n\n\t\t// Explicitly registered overriding bean?\n\t\tif (!(existingDef instanceof ScannedGenericBeanDefinition) &&\n\t\t\t\t(this.registry.isBeanDefinitionOverridable(beanName) || ObjectUtils.nullSafeEquals(\n\t\t\t\t\t\tbeanDefinition.getBeanClassName(), existingDef.getBeanClassName()))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Scanned same file or equivalent class twice?\n\t\tif (isCompatible(beanDefinition, existingDef)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow new ConflictingBeanDefinitionException(\"Annotation-specified bean name '\" + beanName +\n\t\t\t\t\"' for bean class [\" + beanDefinition.getBeanClassName() + \"] conflicts with existing, \" +\n\t\t\t\t\"non-compatible bean definition of same name and class [\" + existingDef.getBeanClassName() + \"]\");\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#configureScanner(parserContext,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parserContext",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "ClassPathBeanDefinitionScanner",
    "signature": "protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element)",
    "source_code": "\tprotected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n\t\tboolean useDefaultFilters = true;\n\t\tif (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n\t\t\tuseDefaultFilters = Boolean.parseBoolean(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n\t\t}\n\n\t\t// Delegate bean definition registration to scanner class.\n\t\tClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);\n\t\tscanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());\n\t\tscanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());\n\n\t\tif (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {\n\t\t\tscanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));\n\t\t}\n\n\t\ttry {\n\t\t\tparseBeanNameGenerator(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tString message = ex.getMessage();\n\t\t\tAssert.state(message != null, \"Exception message must not be null\");\n\t\t\tparserContext.getReaderContext().error(message, parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\ttry {\n\t\t\tparseScope(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tString message = ex.getMessage();\n\t\t\tAssert.state(message != null, \"Exception message must not be null\");\n\t\t\tparserContext.getReaderContext().error(message, parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\tparseTypeFilters(element, scanner, parserContext);\n\n\t\treturn scanner;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#createScanner(readerContext,useDefaultFilters)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "useDefaultFilters"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "ClassPathBeanDefinitionScanner",
    "signature": "protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters)",
    "source_code": "\tprotected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {\n\t\treturn new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters,\n\t\t\t\treaderContext.getEnvironment(), readerContext.getResourceLoader());\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#createTypeFilter(element,classLoader,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "classLoader",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "TypeFilter",
    "signature": "protected TypeFilter createTypeFilter(Element element, @Nullable ClassLoader classLoader,\n\t\t\tParserContext parserContext)",
    "source_code": "\tprotected TypeFilter createTypeFilter(Element element, @Nullable ClassLoader classLoader,\n\t\t\tParserContext parserContext) throws ClassNotFoundException {\n\n\t\tString filterType = element.getAttribute(FILTER_TYPE_ATTRIBUTE);\n\t\tString expression = element.getAttribute(FILTER_EXPRESSION_ATTRIBUTE);\n\t\texpression = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(expression);\n\t\tswitch (filterType) {\n\t\t\tcase \"annotation\" -> {\n\t\t\t\treturn new AnnotationTypeFilter((Class<Annotation>) ClassUtils.forName(expression, classLoader));\n\t\t\t}\n\t\t\tcase \"assignable\" -> {\n\t\t\t\treturn new AssignableTypeFilter(ClassUtils.forName(expression, classLoader));\n\t\t\t}\n\t\t\tcase \"aspectj\" -> {\n\t\t\t\treturn new AspectJTypeFilter(expression, classLoader);\n\t\t\t}\n\t\t\tcase \"regex\" -> {\n\t\t\t\treturn new RegexPatternTypeFilter(Pattern.compile(expression));\n\t\t\t}\n\t\t\tcase \"custom\" -> {\n\t\t\t\tClass<?> filterClass = ClassUtils.forName(expression, classLoader);\n\t\t\t\tif (!TypeFilter.class.isAssignableFrom(filterClass)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"Class is not assignable to [\" + TypeFilter.class.getName() + \"]: \" + expression);\n\t\t\t\t}\n\t\t\t\treturn (TypeFilter) BeanUtils.instantiateClass(filterClass);\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Unsupported filter type: \" + filterType);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#createTypeFiltersFor(filterAttributes,environment,resourceLoader,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@linkplain TypeFilter type filters} from the supplied\n\t * {@link AnnotationAttributes}, such as those sourced from\n\t * {@link ComponentScan#includeFilters()} or {@link ComponentScan#excludeFilters()}.\n\t * <p>Each {@link TypeFilter} will be instantiated using an appropriate\n\t * constructor, with {@code BeanClassLoaderAware}, {@code BeanFactoryAware},\n\t * {@code EnvironmentAware}, and {@code ResourceLoaderAware} contracts\n\t * invoked if they are implemented by the type filter.\n\t * @param filterAttributes {@code AnnotationAttributes} for a\n\t * {@link ComponentScan.Filter @Filter} declaration\n\t * @param environment the {@code Environment} to make available to filters\n\t * @param resourceLoader the {@code ResourceLoader} to make available to filters\n\t * @param registry the {@code BeanDefinitionRegistry} to make available to filters\n\t * as a {@link org.springframework.beans.factory.BeanFactory} if applicable\n\t * @return a list of instantiated and configured type filters\n\t * @see TypeFilter\n\t * @see AnnotationTypeFilter\n\t * @see AssignableTypeFilter\n\t * @see AspectJTypeFilter\n\t * @see RegexPatternTypeFilter\n\t * @see org.springframework.beans.factory.BeanClassLoaderAware\n\t * @see org.springframework.beans.factory.BeanFactoryAware\n\t * @see org.springframework.context.EnvironmentAware\n\t * @see org.springframework.context.ResourceLoaderAware\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filterAttributes",
      "environment",
      "resourceLoader",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "List<TypeFilter>",
    "signature": "public List<TypeFilter> createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,\n\t\t\tResourceLoader resourceLoader, BeanDefinitionRegistry registry)",
    "source_code": "\tpublic static List<TypeFilter> createTypeFiltersFor(AnnotationAttributes filterAttributes, Environment environment,\n\t\t\tResourceLoader resourceLoader, BeanDefinitionRegistry registry) {\n\n\t\tList<TypeFilter> typeFilters = new ArrayList<>();\n\t\tFilterType filterType = filterAttributes.getEnum(\"type\");\n\n\t\tfor (Class<?> filterClass : filterAttributes.getClassArray(\"classes\")) {\n\t\t\tswitch (filterType) {\n\t\t\t\tcase ANNOTATION -> {\n\t\t\t\t\tAssert.isAssignable(Annotation.class, filterClass,\n\t\t\t\t\t\t\t\"@ComponentScan ANNOTATION type filter requires an annotation type\");\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tClass<Annotation> annotationType = (Class<Annotation>) filterClass;\n\t\t\t\t\ttypeFilters.add(new AnnotationTypeFilter(annotationType));\n\t\t\t\t}\n\t\t\t\tcase ASSIGNABLE_TYPE -> typeFilters.add(new AssignableTypeFilter(filterClass));\n\t\t\t\tcase CUSTOM -> {\n\t\t\t\t\tAssert.isAssignable(TypeFilter.class, filterClass,\n\t\t\t\t\t\t\t\"@ComponentScan CUSTOM type filter requires a TypeFilter implementation\");\n\t\t\t\t\tTypeFilter filter = ParserStrategyUtils.instantiateClass(filterClass, TypeFilter.class,\n\t\t\t\t\t\t\tenvironment, resourceLoader, registry);\n\t\t\t\t\ttypeFilters.add(filter);\n\t\t\t\t}\n\t\t\t\tdefault ->\n\t\t\t\t\tthrow new IllegalArgumentException(\"Filter type not supported with Class value: \" + filterType);\n\t\t\t}\n\t\t}\n\n\t\tfor (String expression : filterAttributes.getStringArray(\"pattern\")) {\n\t\t\tswitch (filterType) {\n\t\t\t\tcase ASPECTJ -> typeFilters.add(new AspectJTypeFilter(expression, resourceLoader.getClassLoader()));\n\t\t\t\tcase REGEX -> typeFilters.add(new RegexPatternTypeFilter(Pattern.compile(expression)));\n\t\t\t\tdefault ->\n\t\t\t\t\tthrow new IllegalArgumentException(\"Filter type not supported with String pattern: \" + filterType);\n\t\t\t}\n\t\t}\n\n\t\treturn typeFilters;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#doProcessConfigurationClass(configClass,sourceClass,filter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "sourceClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "SourceClass",
    "signature": "protected SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)",
    "source_code": "\tprotected final SourceClass doProcessConfigurationClass(\n\t\t\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass, filter);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,\n\t\t\t\tPropertySources.class, true)) {\n\t\t\tif (this.propertySourceRegistry != null) {\n\t\t\t\tthis.propertySourceRegistry.processPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Search for locally declared @ComponentScan annotations first.\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,\n\t\t\t\tMergedAnnotation::isDirectlyPresent);\n\n\t\t// Fall back to searching for @ComponentScan meta-annotations (which indirectly\n\t\t// includes locally declared composed annotations).\n\t\tif (componentScans.isEmpty()) {\n\t\t\tcomponentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),\n\t\t\t\t\tComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);\n\t\t}\n\n\t\tif (!componentScans.isEmpty()) {\n\t\t\tList<Condition> registerBeanConditions = collectRegisterBeanConditions(configClass);\n\t\t\tif (!registerBeanConditions.isEmpty()) {\n\t\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\t\"Component scan for configuration class [%s] could not be used with conditions in REGISTER_BEAN phase: %s\"\n\t\t\t\t\t\t\t\t.formatted(configClass.getMetadata().getClassName(), registerBeanConditions));\n\t\t\t}\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), filter, true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tif (methodMetadata.isAnnotated(\"kotlin.jvm.JvmStatic\") && !methodMetadata.isStatic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\")) {\n\t\t\t\tboolean superclassKnown = this.knownSuperclasses.containsKey(superclass);\n\t\t\t\tthis.knownSuperclasses.add(superclass, configClass);\n\t\t\t\tif (!superclassKnown) {\n\t\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateBeanName(definition,registry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "definition",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "String",
    "signature": "public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry)",
    "source_code": "\tpublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n\t\tif (definition instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {\n\t\t\tString beanName = determineBeanNameFromAnnotation(annotatedBeanDefinition);\n\t\t\tif (StringUtils.hasText(beanName)) {\n\t\t\t\t// Explicit bean name found.\n\t\t\t\treturn beanName;\n\t\t\t}\n\t\t}\n\t\t// Fallback: generate a unique default bean name.\n\t\treturn buildDefaultBeanName(definition, registry);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateInstanceSupplierCode(generationContext,beanRegistrationCode,allowDirectSupplierShortcut)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "allowDirectSupplierShortcut"
    ],
    "position": {
      "column": 1,
      "line": 797
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut)",
    "source_code": "\t\tpublic CodeBlock generateInstanceSupplierCode(\n\t\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tboolean allowDirectSupplierShortcut) {\n\n\t\t\tInstantiationDescriptor instantiationDescriptor = proxyInstantiationDescriptor(\n\t\t\t\t\tgenerationContext.getRuntimeHints(), this.registeredBean.resolveInstantiationDescriptor());\n\n\t\t\treturn new InstanceSupplierCodeGenerator(generationContext,\n\t\t\t\t\tbeanRegistrationCode.getClassName(), beanRegistrationCode.getMethods(), allowDirectSupplierShortcut)\n\t\t\t\t\t.generateCode(this.registeredBean, instantiationDescriptor);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#generateSetBeanDefinitionPropertiesCode(generationContext,beanRegistrationCode,beanDefinition,attributeFilter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode",
      "beanDefinition",
      "attributeFilter"
    ],
    "position": {
      "column": 1,
      "line": 784
    },
    "return": "CodeBlock",
    "signature": "public CodeBlock generateSetBeanDefinitionPropertiesCode(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter)",
    "source_code": "\t\tpublic CodeBlock generateSetBeanDefinitionPropertiesCode(\n\t\t\t\tGenerationContext generationContext, BeanRegistrationCode beanRegistrationCode,\n\t\t\t\tRootBeanDefinition beanDefinition, Predicate<String> attributeFilter) {\n\n\t\t\tCodeBlock.Builder code = CodeBlock.builder();\n\t\t\tcode.add(super.generateSetBeanDefinitionPropertiesCode(generationContext,\n\t\t\t\t\tbeanRegistrationCode, beanDefinition, attributeFilter));\n\t\t\tcode.addStatement(\"$T.initializeConfigurationClass($T.class)\",\n\t\t\t\t\tConfigurationClassUtils.class, ClassUtils.getUserClass(this.proxyClass));\n\t\t\treturn code.build();\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getAnnotationAttributes(annType,attribute)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annType",
      "attribute"
    ],
    "position": {
      "column": 1,
      "line": 1084
    },
    "return": "Collection<SourceClass>",
    "signature": "public Collection<SourceClass> getAnnotationAttributes(String annType, String attribute)",
    "source_code": "\t\tpublic Collection<SourceClass> getAnnotationAttributes(String annType, String attribute) throws IOException {\n\t\t\tMap<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true);\n\t\t\tif (annotationAttributes == null || !annotationAttributes.containsKey(attribute)) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tString[] classNames = (String[]) annotationAttributes.get(attribute);\n\t\t\tSet<SourceClass> result = CollectionUtils.newLinkedHashSet(classNames.length);\n\t\t\tfor (String className : classNames) {\n\t\t\t\tresult.add(getRelated(className));\n\t\t\t}\n\t\t\treturn result;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResource(element,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the resource object for the given name and type.\n\t * @param element the descriptor for the annotated field/method\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the resource object (never {@code null})\n\t * @throws NoSuchBeanDefinitionException if no corresponding target resource found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "Object",
    "signature": "protected Object getResource(LookupElement element, @Nullable String requestingBeanName)",
    "source_code": "\tprotected Object getResource(LookupElement element, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\t// JNDI lookup to perform?\n\t\tString jndiName = null;\n\t\tif (StringUtils.hasLength(element.mappedName)) {\n\t\t\tjndiName = element.mappedName;\n\t\t}\n\t\telse if (this.alwaysUseJndiLookup) {\n\t\t\tjndiName = element.name;\n\t\t}\n\t\tif (jndiName != null) {\n\t\t\tif (this.jndiFactory == null) {\n\t\t\t\tthrow new NoSuchBeanDefinitionException(element.lookupType,\n\t\t\t\t\t\t\"No JNDI factory configured - specify the 'jndiFactory' property\");\n\t\t\t}\n\t\t\treturn this.jndiFactory.getBean(jndiName, element.lookupType);\n\t\t}\n\n\t\t// Regular resource autowiring\n\t\tif (this.resourceFactory == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(element.lookupType,\n\t\t\t\t\t\"No resource factory configured - specify the 'resourceFactory' property\");\n\t\t}\n\t\treturn autowireResource(this.resourceFactory, element, requestingBeanName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 835
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\tif (StringUtils.hasLength(this.beanName)) {\n\t\t\t\tif (beanFactory != null && beanFactory.containsBean(this.beanName)) {\n\t\t\t\t\t// Local match found for explicitly specified local bean name.\n\t\t\t\t\tObject bean = beanFactory.getBean(this.beanName, this.lookupType);\n\t\t\t\t\tif (requestingBeanName != null && beanFactory instanceof ConfigurableBeanFactory configurableBeanFactory) {\n\t\t\t\t\t\tconfigurableBeanFactory.registerDependentBean(this.beanName, requestingBeanName);\n\t\t\t\t\t}\n\t\t\t\t\treturn bean;\n\t\t\t\t}\n\t\t\t\telse if (this.isDefaultName && !StringUtils.hasLength(this.mappedName)) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.beanName,\n\t\t\t\t\t\t\t\"Cannot resolve 'beanName' in local BeanFactory. Consider specifying a general 'name' value instead.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// JNDI name lookup - may still go to a local BeanFactory.\n\t\t\treturn getResource(this, requestingBeanName);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#intercept(enhancedConfigInstance,beanMethod,beanMethodArgs,cglibMethodProxy)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the\n\t\t * existence of this bean object.\n\t\t * @throws Throwable as a catch-all for any exception that may be thrown when invoking the\n\t\t * super implementation of the proxied method i.e., the actual {@code @Bean} method\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enhancedConfigInstance",
      "beanMethod",
      "beanMethodArgs",
      "cglibMethodProxy"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "Object",
    "signature": "public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,\n\t\t\t\t\tMethodProxy cglibMethodProxy)",
    "source_code": "\t\tpublic Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,\n\t\t\t\t\tMethodProxy cglibMethodProxy) throws Throwable {\n\n\t\t\tConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);\n\t\t\tString beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);\n\n\t\t\t// Determine whether this bean is a scoped-proxy\n\t\t\tif (BeanAnnotationHelper.isScopedProxy(beanMethod)) {\n\t\t\t\tString scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);\n\t\t\t\tif (beanFactory.isCurrentlyInCreation(scopedBeanName)) {\n\t\t\t\t\tbeanName = scopedBeanName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// To handle the case of an inter-bean method reference, we must explicitly check the\n\t\t\t// container for already cached instances.\n\n\t\t\t// First, check to see if the requested bean is a FactoryBean. If so, create a subclass\n\t\t\t// proxy that intercepts calls to getObject() and returns any cached bean instance.\n\t\t\t// This ensures that the semantics of calling a FactoryBean from within @Bean methods\n\t\t\t// is the same as that of referring to a FactoryBean within XML. See SPR-6602.\n\t\t\tif (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&\n\t\t\t\t\tfactoryContainsBean(beanFactory, beanName)) {\n\t\t\t\tObject factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\tif (factoryBean instanceof ScopedProxyFactoryBean) {\n\t\t\t\t\t// Scoped proxy factory beans are a special case and should not be further proxied\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// It is a candidate FactoryBean - go ahead with enhancement\n\t\t\t\t\treturn enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCurrentlyInvokedFactoryMethod(beanMethod)) {\n\t\t\t\t// The factory is calling the bean method in order to instantiate and register the bean\n\t\t\t\t// (i.e. via a getBean() call) -> invoke the super implementation of the method to actually\n\t\t\t\t// create the bean instance.\n\t\t\t\tif (logger.isInfoEnabled() &&\n\t\t\t\t\t\tBeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {\n\t\t\t\t\tlogger.info(String.format(\"@Bean method %s.%s is non-static and returns an object \" +\n\t\t\t\t\t\t\t\t\t\"assignable to Spring's BeanFactoryPostProcessor interface. This will \" +\n\t\t\t\t\t\t\t\t\t\"result in a failure to process annotations such as @Autowired, \" +\n\t\t\t\t\t\t\t\t\t\"@Resource and @PostConstruct within the method's declaring \" +\n\t\t\t\t\t\t\t\t\t\"@Configuration class. Add the 'static' modifier to this method to avoid \" +\n\t\t\t\t\t\t\t\t\t\"these container lifecycle issues; see @Bean javadoc for complete details.\",\n\t\t\t\t\t\t\tbeanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));\n\t\t\t\t}\n\t\t\t\treturn cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);\n\t\t\t}\n\n\t\t\treturn resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#intercept(obj,method,args,proxy)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "Object",
    "signature": "public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy)",
    "source_code": "\t\tpublic Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n\t\t\tField field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);\n\t\t\tAssert.state(field != null, \"Unable to find generated BeanFactory field\");\n\t\t\tfield.set(obj, args[0]);\n\n\t\t\t// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?\n\t\t\t// If so, call its setBeanFactory() method. If not, just exit.\n\t\t\tif (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) {\n\t\t\t\treturn proxy.invokeSuper(obj, args);\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#isCompatible(newDef,existingDef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given new bean definition is compatible with\n\t * the given existing bean definition.\n\t * <p>The default implementation considers them as compatible when the existing\n\t * bean definition comes from the same source or from a non-scanning source.\n\t * @param newDef the new bean definition, originated from scanning\n\t * @param existingDef the existing bean definition, potentially an\n\t * explicitly defined one or a previously generated one from scanning\n\t * @return whether the definitions are considered as compatible, with the\n\t * new definition to be skipped in favor of the existing definition\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "newDef",
      "existingDef"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "boolean",
    "signature": "protected boolean isCompatible(BeanDefinition newDef, BeanDefinition existingDef)",
    "source_code": "\tprotected boolean isCompatible(BeanDefinition newDef, BeanDefinition existingDef) {\n\t\treturn ((newDef.getSource() != null && newDef.getSource().equals(existingDef.getSource())) ||\n\t\t\t\tnewDef.equals(existingDef));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#isOverriddenByExistingDefinition(beanMethod,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanMethod",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "boolean",
    "signature": "protected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName)",
    "source_code": "\tprotected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName) {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn false;\n\t\t}\n\t\tBeanDefinition existingBeanDef = this.registry.getBeanDefinition(beanName);\n\n\t\t// If the bean method is an overloaded case on the same configuration class,\n\t\t// preserve the existing bean definition and mark it as overloaded.\n\t\tif (existingBeanDef instanceof ConfigurationClassBeanDefinition ccbd) {\n\t\t\tif (ccbd.getMetadata().getClassName().equals(beanMethod.getConfigurationClass().getMetadata().getClassName()) &&\n\t\t\t\t\tccbd.getFactoryMethodMetadata().getMethodName().equals(beanMethod.getMetadata().getMethodName())) {\n\t\t\t\tccbd.setNonUniqueFactoryMethodName(ccbd.getFactoryMethodMetadata().getMethodName());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// A bean definition resulting from a component scan can be silently overridden\n\t\t// by an @Bean method - and as of 6.1, even when general overriding is disabled\n\t\t// as long as the bean class is the same.\n\t\tif (existingBeanDef instanceof ScannedGenericBeanDefinition scannedBeanDef) {\n\t\t\tif (beanMethod.getMetadata().getReturnTypeName().equals(scannedBeanDef.getBeanClassName())) {\n\t\t\t\tthis.registry.removeBeanDefinition(beanName);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// Has the existing bean definition bean marked as a framework-generated bean?\n\t\t// -> allow the current bean method to override it, since it is application-level\n\t\tif (existingBeanDef.getRole() > BeanDefinition.ROLE_APPLICATION) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// At this point, it's a top-level override (probably XML), just having been parsed\n\t\t// before configuration class processing kicks in...\n\t\tif (this.registry instanceof DefaultListableBeanFactory dlbf && !dlbf.isBeanDefinitionOverridable(beanName)) {\n\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\tbeanName, \"@Bean definition illegally overridden by existing bean definition: \" + existingBeanDef);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Skipping bean definition for %s: a definition for bean '%s' \" +\n\t\t\t\t\t\"already exists. This top-level bean definition is considered as an override.\",\n\t\t\t\t\tbeanMethod, beanName));\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#isStereotypeWithNameValue(annotationType,metaAnnotationTypes,Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given annotation is a stereotype that is allowed\n\t * to suggest a component name through its {@code value()} attribute.\n\t * @param annotationType the name of the annotation class to check\n\t * @param metaAnnotationTypes the names of meta-annotations on the given annotation\n\t * @param attributes the map of attributes for the given annotation\n\t * @return whether the annotation qualifies as a stereotype with component name\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "metaAnnotationTypes",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "protected boolean isStereotypeWithNameValue(String annotationType,\n\t\t\tSet<String> metaAnnotationTypes, Map<String, Object> attributes)",
    "source_code": "\tprotected boolean isStereotypeWithNameValue(String annotationType,\n\t\t\tSet<String> metaAnnotationTypes, Map<String, Object> attributes) {\n\n\t\tboolean isStereotype = metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME) ||\n\t\t\t\tannotationType.equals(\"jakarta.annotation.ManagedBean\") ||\n\t\t\t\tannotationType.equals(\"javax.annotation.ManagedBean\") ||\n\t\t\t\tannotationType.equals(\"jakarta.inject.Named\") ||\n\t\t\t\tannotationType.equals(\"javax.inject.Named\");\n\n\t\treturn (isStereotype && attributes.containsKey(\"value\"));\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tString basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n\t\tbasePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);\n\t\tString[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n\t\t\t\tConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n\n\t\t// Actually scan for bean definitions and register them.\n\t\tClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n\t\tSet<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);\n\t\tregisterComponents(parserContext.getReaderContext(), beanDefinitions, element);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parseBeanNameGenerator(element,scanner)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "scanner"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "void",
    "signature": "protected void parseBeanNameGenerator(Element element, ClassPathBeanDefinitionScanner scanner)",
    "source_code": "\tprotected void parseBeanNameGenerator(Element element, ClassPathBeanDefinitionScanner scanner) {\n\t\tif (element.hasAttribute(NAME_GENERATOR_ATTRIBUTE)) {\n\t\t\tBeanNameGenerator beanNameGenerator = (BeanNameGenerator) instantiateUserDefinedStrategy(\n\t\t\t\t\telement.getAttribute(NAME_GENERATOR_ATTRIBUTE), BeanNameGenerator.class,\n\t\t\t\t\tscanner.getResourceLoader().getClassLoader());\n\t\t\tscanner.setBeanNameGenerator(beanNameGenerator);\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parseScope(element,scanner)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "scanner"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "protected void parseScope(Element element, ClassPathBeanDefinitionScanner scanner)",
    "source_code": "\tprotected void parseScope(Element element, ClassPathBeanDefinitionScanner scanner) {\n\t\t// Register ScopeMetadataResolver if class name provided.\n\t\tif (element.hasAttribute(SCOPE_RESOLVER_ATTRIBUTE)) {\n\t\t\tif (element.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot define both 'scope-resolver' and 'scoped-proxy' on <component-scan> tag\");\n\t\t\t}\n\t\t\tScopeMetadataResolver scopeMetadataResolver = (ScopeMetadataResolver) instantiateUserDefinedStrategy(\n\t\t\t\t\telement.getAttribute(SCOPE_RESOLVER_ATTRIBUTE), ScopeMetadataResolver.class,\n\t\t\t\t\tscanner.getResourceLoader().getClassLoader());\n\t\t\tscanner.setScopeMetadataResolver(scopeMetadataResolver);\n\t\t}\n\n\t\tif (element.hasAttribute(SCOPED_PROXY_ATTRIBUTE)) {\n\t\t\tString mode = element.getAttribute(SCOPED_PROXY_ATTRIBUTE);\n\t\t\tswitch (mode) {\n\t\t\t\tcase \"targetClass\" -> scanner.setScopedProxyMode(ScopedProxyMode.TARGET_CLASS);\n\t\t\t\tcase \"interfaces\" -> scanner.setScopedProxyMode(ScopedProxyMode.INTERFACES);\n\t\t\t\tcase \"no\" -> scanner.setScopedProxyMode(ScopedProxyMode.NO);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"scoped-proxy only supports 'no', 'interfaces' and 'targetClass'\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#parseTypeFilters(element,scanner,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "scanner",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext)",
    "source_code": "\tprotected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext) {\n\t\t// Parse exclude and include filter elements.\n\t\tClassLoader classLoader = scanner.getResourceLoader().getClassLoader();\n\t\tNodeList nodeList = element.getChildNodes();\n\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\tNode node = nodeList.item(i);\n\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tString localName = parserContext.getDelegate().getLocalName(node);\n\t\t\t\ttry {\n\t\t\t\t\tif (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addIncludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t\telse if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n\t\t\t\t\t\tTypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n\t\t\t\t\t\tscanner.addExcludeFilter(typeFilter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tparserContext.getReaderContext().warning(\n\t\t\t\t\t\t\t\"Ignoring non-present type filter class: \" + ex, parserContext.extractSource(element));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tString message = ex.getMessage();\n\t\t\t\t\tAssert.state(message != null, \"Exception message must not be null\");\n\t\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\tmessage, parserContext.extractSource(element), ex.getCause());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessAfterInstantiation(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "boolean",
    "signature": "public boolean postProcessAfterInstantiation(Object bean, String beanName)",
    "source_code": "\tpublic boolean postProcessAfterInstantiation(Object bean, String beanName) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeanDefinition(beanDefinition,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply further settings to the given bean definition,\n\t * beyond the contents retrieved from scanning the component class.\n\t * @param beanDefinition the scanned bean definition\n\t * @param beanName the generated bean name for the given bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanDefinition",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "void",
    "signature": "protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName)",
    "source_code": "\tprotected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) {\n\t\tbeanDefinition.applyDefaults(this.beanDefinitionDefaults);\n\t\tif (this.autowireCandidatePatterns != null) {\n\t\t\tbeanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));\n\t\t}\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 572
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\t\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\t\tif (bean instanceof ImportAware importAware) {\n\t\t\t\tImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);\n\t\t\t\tAnnotationMetadata importingClass = ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());\n\t\t\t\tif (importingClass != null) {\n\t\t\t\t\timportAware.setImportMetadata(importingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bean;\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tsuper.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);\n\t\tmetadata.checkConfigMembers(beanDefinition);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of resource dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#process(metadata,selector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "selector"
    ],
    "position": {
      "column": 1,
      "line": 927
    },
    "return": "void",
    "signature": "public void process(AnnotationMetadata metadata, DeferredImportSelector selector)",
    "source_code": "\t\tpublic void process(AnnotationMetadata metadata, DeferredImportSelector selector) {\n\t\t\tfor (String importClassName : selector.selectImports(metadata)) {\n\t\t\t\tthis.imports.add(new Entry(metadata, importClassName));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.annotation.<unknown>#processConfigurationClass(configClass,filter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "configClass",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "void",
    "signature": "protected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter)",
    "source_code": "\tprotected void processConfigurationClass(ConfigurationClass configClass, Predicate<String> filter) {\n\t\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClass existingClass = this.configurationClasses.get(configClass);\n\t\tif (existingClass != null) {\n\t\t\tif (configClass.isImported()) {\n\t\t\t\tif (existingClass.isImported()) {\n\t\t\t\t\texistingClass.mergeImportedBy(configClass);\n\t\t\t\t}\n\t\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (configClass.isScanned()) {\n\t\t\t\tString beanName = configClass.getBeanName();\n\t\t\t\tif (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {\n\t\t\t\t\tthis.registry.removeBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t\t// An implicitly scanned bean definition should not override an explicit import.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t\t// Let's remove the old one and go with the new one.\n\t\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\t\tremoveKnownSuperclass(configClass.getMetadata().getClassName(), false);\n\t\t\t}\n\t\t}\n\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tSourceClass sourceClass = null;\n\t\ttry {\n\t\t\tsourceClass = asSourceClass(configClass, filter);\n\t\t\tdo {\n\t\t\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);\n\t\t\t}\n\t\t\twhile (sourceClass != null);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"I/O failure while processing configuration class [\" + sourceClass + \"]\", ex);\n\t\t}\n\n\t\tthis.configurationClasses.put(configClass, configClass);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerAnnotationConfigProcessors(registry,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "registry",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Set<BeanDefinitionHolder>",
    "signature": "public Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)",
    "source_code": "\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, @Nullable Object source) {\n\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n\t\tif (beanFactory != null) {\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\tbeanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = CollectionUtils.newLinkedHashSet(6);\n\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for Jakarta Annotations support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\tif ((jakartaAnnotationsPresent || jsr250Present) &&\n\t\t\t\t!registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name) {\n\t\tdoRegisterBean(beanClass, name, null, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,qualifiers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, @Nullable String name,\n\t\t\tClass<? extends Annotation>... qualifiers) {\n\n\t\tdoRegisterBean(beanClass, name, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, name, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,name,supplier,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param name an explicit name for the bean\n\t * (or {@code null} for generating a default bean name)\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, for example, setting a lazy-init or primary flag\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "name",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable String name, @Nullable Supplier<T> supplier,\n\t\t\tBeanDefinitionCustomizer... customizers) {\n\n\t\tdoRegisterBean(beanClass, name, null, supplier, customizers);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,qualifiers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations.\n\t * @param beanClass the class of the bean\n\t * @param qualifiers specific qualifier annotations to consider,\n\t * in addition to qualifiers at the bean class level\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "qualifiers"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "public void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers)",
    "source_code": "\tpublic void registerBean(Class<?> beanClass, Class<? extends Annotation>... qualifiers) {\n\t\tdoRegisterBean(beanClass, null, qualifiers, null, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBean(beanClass,supplier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, deriving its metadata from\n\t * class-declared annotations, using the given supplier for obtaining a new\n\t * instance (possibly declared as a lambda expression or method reference).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * (may be {@code null})\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, @Nullable Supplier<T> supplier) {\n\t\tdoRegisterBean(beanClass, null, null, supplier, null);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerBeanDefinition(definitionHolder,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified bean with the given registry.\n\t * <p>Can be overridden in subclasses, for example, to adapt the registration\n\t * process or to register further bean definitions for each scanned bean.\n\t * @param definitionHolder the bean definition plus bean name for the bean\n\t * @param registry the BeanDefinitionRegistry to register the bean with\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "definitionHolder",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "void",
    "signature": "protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)",
    "source_code": "\tprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerComponents(readerContext,beanDefinitions,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readerContext",
      "beanDefinitions",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "protected void registerComponents(XmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element)",
    "source_code": "\tprotected void registerComponents(\n\t\t\tXmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element) {\n\n\t\tObject source = readerContext.extractSource(element);\n\t\tCompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source);\n\n\t\tfor (BeanDefinitionHolder beanDefHolder : beanDefinitions) {\n\t\t\tcompositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder));\n\t\t}\n\n\t\t// Register annotation config processors, if necessary.\n\t\tboolean annotationConfig = true;\n\t\tif (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {\n\t\t\tannotationConfig = Boolean.parseBoolean(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));\n\t\t}\n\t\tif (annotationConfig) {\n\t\t\tSet<BeanDefinitionHolder> processorDefinitions =\n\t\t\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);\n\t\t\tfor (BeanDefinitionHolder processorDefinition : processorDefinitions) {\n\t\t\t\tcompositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition));\n\t\t\t}\n\t\t}\n\n\t\treaderContext.fireComponentRegistered(compositeDef);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#registerScope(annotationType,scopeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an extended JSR-330 scope annotation, mapping it onto a\n\t * specific Spring scope by name.\n\t * @param annotationType the JSR-330 annotation type by name\n\t * @param scopeName the Spring scope name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "scopeName"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void registerScope(String annotationType, String scopeName)",
    "source_code": "\tpublic final void registerScope(String annotationType, String scopeName) {\n\t\tthis.scopeMap.put(annotationType, scopeName);\n\t}"
  },
  "org.springframework.context.annotation.<unknown>#shouldSkip(metadata,phase)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * @param metadata the meta data\n\t * @param phase the phase of the call\n\t * @return if the item should be skipped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "phase"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "boolean",
    "signature": "public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)",
    "source_code": "\tpublic boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {\n\t\tif (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (phase == null) {\n\t\t\tif (metadata instanceof AnnotationMetadata annotationMetadata &&\n\t\t\t\t\tConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) {\n\t\t\t\treturn shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t\t}\n\t\t\treturn shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n\t\t}\n\n\t\tList<Condition> conditions = collectConditions(metadata);\n\t\tfor (Condition condition : conditions) {\n\t\t\tConfigurationPhase requiredPhase = null;\n\t\t\tif (condition instanceof ConfigurationCondition configurationCondition) {\n\t\t\t\trequiredPhase = configurationCondition.getConfigurationPhase();\n\t\t\t}\n\t\t\tif ((requiredPhase == null || requiredPhase == phase) && !condition.matches(this.context, metadata)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.aot.<unknown>#applyTo(generationContext,beanFactoryInitializationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanFactoryInitializationCode"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanFactoryInitializationCode beanFactoryInitializationCode) {\n\t\t\tRuntimeHints runtimeHints = generationContext.getRuntimeHints();\n\t\t\tregistrar.registerRuntimeHints(runtimeHints, this.classes);\n\t\t}"
  },
  "org.springframework.context.aot.<unknown>#scan(classLoader,packageNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Scan the given {@code packageNames} and their sub-packages for classes\n\t * that uses {@link Reflective}.\n\t * <p>This performs a \"deep scan\" by loading every class in the specified\n\t * packages and search for {@link Reflective} on types, constructors, methods,\n\t * and fields. Enclosed classes are candidates as well. Classes that fail to\n\t * load are ignored.\n\t * @param classLoader the classloader to use\n\t * @param packageNames the package names to scan\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "classLoader",
      "packageNames"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ReflectiveProcessorAotContributionBuilder",
    "signature": "public ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames)",
    "source_code": "\tpublic ReflectiveProcessorAotContributionBuilder scan(@Nullable ClassLoader classLoader, String... packageNames) {\n\t\tReflectiveClassPathScanner scanner = new ReflectiveClassPathScanner(classLoader);\n\t\treturn withClasses(scanner.scan(packageNames));\n\t}"
  },
  "org.springframework.context.event.<unknown>#getDetailedErrorMessage(bean,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add additional details such as the bean type and method signature to\n\t * the given error message.\n\t * @param message error message to append the HandlerMethod details to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "String",
    "signature": "protected String getDetailedErrorMessage(Object bean, @Nullable String message)",
    "source_code": "\tprotected String getDetailedErrorMessage(Object bean, @Nullable String message) {\n\t\tStringBuilder sb = (StringUtils.hasLength(message) ? new StringBuilder(message).append('\\n') : new StringBuilder());\n\t\tsb.append(\"HandlerMethod details: \\n\");\n\t\tsb.append(\"Bean [\").append(bean.getClass().getName()).append(\"]\\n\");\n\t\tsb.append(\"Method [\").append(this.method.toGenericString()).append(\"]\\n\");\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.context.event.<unknown>#invokeListener(listener,event)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given listener with the given event.\n\t * @param listener the ApplicationListener to invoke\n\t * @param event the current event to propagate\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "event"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event)",
    "source_code": "\tprotected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {\n\t\tErrorHandler errorHandler = getErrorHandler();\n\t\tif (errorHandler != null) {\n\t\t\ttry {\n\t\t\t\tdoInvokeListener(listener, event);\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\terrorHandler.handleError(err);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoInvokeListener(listener, event);\n\t\t}\n\t}"
  },
  "org.springframework.context.event.<unknown>#multicastEvent(event,eventType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType)",
    "source_code": "\tpublic void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) {\n\t\tResolvableType type = (eventType != null ? eventType : ResolvableType.forInstance(event));\n\t\tExecutor executor = getTaskExecutor();\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n\t\t\tif (executor != null && listener.supportsAsyncExecution()) {\n\t\t\t\ttry {\n\t\t\t\t\texecutor.execute(() -> invokeListener(listener, event));\n\t\t\t\t}\n\t\t\t\tcatch (RejectedExecutionException ex) {\n\t\t\t\t\t// Probably on shutdown -> invoke listener locally instead\n\t\t\t\t\tinvokeListener(listener, event);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinvokeListener(listener, event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.event.<unknown>#supportsEvent(listener,eventType,sourceType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given listener supports the given event.\n\t * <p>The default implementation detects the {@link SmartApplicationListener}\n\t * and {@link GenericApplicationListener} interfaces. In case of a standard\n\t * {@link ApplicationListener}, a {@link GenericApplicationListenerAdapter}\n\t * will be used to introspect the generically declared type of the target listener.\n\t * @param listener the target listener to check\n\t * @param eventType the event type to check against\n\t * @param sourceType the source type to check against\n\t * @return whether the given listener should be included in the candidates\n\t * for the given event type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "eventType",
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "boolean",
    "signature": "protected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType)",
    "source_code": "\tprotected boolean supportsEvent(\n\t\t\tApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {\n\n\t\tGenericApplicationListener smartListener = (listener instanceof GenericApplicationListener gal ? gal :\n\t\t\t\tnew GenericApplicationListenerAdapter(listener));\n\t\treturn (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));\n\t}"
  },
  "org.springframework.context.event.<unknown>#supportsEvent(listenerType,eventType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter a listener early through checking its generically declared event\n\t * type before trying to instantiate it.\n\t * <p>If this method returns {@code true} for a given listener as a first pass,\n\t * the listener instance will get retrieved and fully evaluated through a\n\t * {@link #supportsEvent(ApplicationListener, ResolvableType, Class)} call afterwards.\n\t * @param listenerType the listener's type as determined by the BeanFactory\n\t * @param eventType the event type to check\n\t * @return whether the given listener should be included in the candidates\n\t * for the given event type\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listenerType",
      "eventType"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "boolean",
    "signature": "protected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType)",
    "source_code": "\tprotected boolean supportsEvent(Class<?> listenerType, ResolvableType eventType) {\n\t\tResolvableType declaredEventType = GenericApplicationListenerAdapter.resolveDeclaredEventType(listenerType);\n\t\treturn (declaredEventType == null || declaredEventType.isAssignableFrom(eventType));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canRead(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn (target instanceof BeanExpressionContext bec && bec.containsObject(name));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#canWrite(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.expression.<unknown>#generateCode(propertyName,mv,cf)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\tString descriptor = cf.lastDescriptor();\n\t\tif (descriptor == null || !descriptor.equals(\"Ljava/util/Map\")) {\n\t\t\tif (descriptor == null) {\n\t\t\t\tcf.loadTarget(mv);\n\t\t\t}\n\t\t\tCodeFlow.insertCheckCast(mv, \"Ljava/util/Map\");\n\t\t}\n\t\tmv.visitLdcInsn(propertyName);\n\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n\t}"
  },
  "org.springframework.context.expression.<unknown>#getExpression(Map<ExpressionKey,cache,elementKey,expression)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the parsed {@link Expression} for the specified SpEL expression.\n\t * <p>{@linkplain #parseExpression(String) Parses} the expression if it hasn't\n\t * already been parsed and cached.\n\t * @param cache the cache to use\n\t * @param elementKey the {@code AnnotatedElementKey} containing the element\n\t * on which the expression is defined\n\t * @param expression the expression to parse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<ExpressionKey",
      "cache",
      "elementKey",
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "Expression",
    "signature": "protected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression)",
    "source_code": "\tprotected Expression getExpression(Map<ExpressionKey, Expression> cache,\n\t\t\tAnnotatedElementKey elementKey, String expression) {\n\n\t\tExpressionKey expressionKey = createKey(elementKey, expression);\n\t\treturn cache.computeIfAbsent(expressionKey, key -> parseExpression(expression));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#read(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target instanceof BeanExpressionContext, \"Target must be of type BeanExpressionContext\");\n\t\treturn new TypedValue(((BeanExpressionContext) target).getObject(name));\n\t}"
  },
  "org.springframework.context.expression.<unknown>#write(context,target,name,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)\n\t\t\tthrows AccessException {\n\n\t\tthrow new AccessException(\"Beans in a BeanFactory are read-only\");\n\t}"
  },
  "org.springframework.context.i18n.<unknown>#setLocale(locale,inheritable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given Locale with the current thread,\n\t * preserving any TimeZone that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param locale the current Locale, or {@code null} to reset\n\t * the locale part of thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setTimeZone(TimeZone, boolean)\n\t * @see SimpleLocaleContext#SimpleLocaleContext(Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void setLocale(@Nullable Locale locale, boolean inheritable)",
    "source_code": "\tpublic static void setLocale(@Nullable Locale locale, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tTimeZone timeZone = (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAware ?\n\t\t\t\ttimeZoneAware.getTimeZone() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}"
  },
  "org.springframework.context.i18n.<unknown>#setLocaleContext(localeContext,inheritable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given LocaleContext with the current thread.\n\t * <p>The given LocaleContext may be a {@link TimeZoneAwareLocaleContext},\n\t * containing a locale with associated time zone information.\n\t * @param localeContext the current LocaleContext,\n\t * or {@code null} to reset the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see SimpleLocaleContext\n\t * @see SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "localeContext",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable)",
    "source_code": "\tpublic static void setLocaleContext(@Nullable LocaleContext localeContext, boolean inheritable) {\n\t\tif (localeContext == null) {\n\t\t\tresetLocaleContext();\n\t\t}\n\t\telse {\n\t\t\tif (inheritable) {\n\t\t\t\tinheritableLocaleContextHolder.set(localeContext);\n\t\t\t\tlocaleContextHolder.remove();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlocaleContextHolder.set(localeContext);\n\t\t\t\tinheritableLocaleContextHolder.remove();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.i18n.<unknown>#setTimeZone(timeZone,inheritable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given TimeZone with the current thread,\n\t * preserving any Locale that may have been set already.\n\t * <p>Will implicitly create a LocaleContext for the given Locale.\n\t * @param timeZone the current TimeZone, or {@code null} to reset\n\t * the time zone part of the thread-bound context\n\t * @param inheritable whether to expose the LocaleContext as inheritable\n\t * for child threads (using an {@link InheritableThreadLocal})\n\t * @see #setLocale(Locale, boolean)\n\t * @see SimpleTimeZoneAwareLocaleContext#SimpleTimeZoneAwareLocaleContext(Locale, TimeZone)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeZone",
      "inheritable"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "void",
    "signature": "public void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable)",
    "source_code": "\tpublic static void setTimeZone(@Nullable TimeZone timeZone, boolean inheritable) {\n\t\tLocaleContext localeContext = getLocaleContext();\n\t\tLocale locale = (localeContext != null ? localeContext.getLocale() : null);\n\t\tif (timeZone != null) {\n\t\t\tlocaleContext = new SimpleTimeZoneAwareLocaleContext(locale, timeZone);\n\t\t}\n\t\telse if (locale != null) {\n\t\t\tlocaleContext = new SimpleLocaleContext(locale);\n\t\t}\n\t\telse {\n\t\t\tlocaleContext = null;\n\t\t}\n\t\tsetLocaleContext(localeContext, inheritable);\n\t}"
  },
  "org.springframework.context.index.processor.<unknown>#process(annotations,roundEnv)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotations",
      "roundEnv"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "boolean",
    "signature": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv)",
    "source_code": "\tpublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t\tthis.metadataCollector.processing(roundEnv);\n\t\troundEnv.getRootElements().forEach(this::processElement);\n\t\tif (roundEnv.processingOver()) {\n\t\t\twriteMetaData();\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.context.support.<unknown>#add(name,bean)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "public void add(String name, Lifecycle bean)",
    "source_code": "\t\tpublic void add(String name, Lifecycle bean) {\n\t\t\tthis.members.add(new LifecycleGroupMember(name, bean));\n\t\t\tif (bean instanceof SmartLifecycle) {\n\t\t\t\tthis.smartMemberCount++;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#calculateAllFilenames(basename,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate all filenames for the given bundle basename and Locale.\n\t * Will calculate filenames for the given Locale, the system Locale\n\t * (if applicable), and the default file.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t * @see #setFallbackToSystemLocale\n\t * @see #calculateFilenamesForLocale\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateAllFilenames(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateAllFilenames(String basename, Locale locale) {\n\t\tMap<Locale, List<String>> localeMap = this.cachedFilenames.get(basename);\n\t\tif (localeMap != null) {\n\t\t\tList<String> filenames = localeMap.get(locale);\n\t\t\tif (filenames != null) {\n\t\t\t\treturn filenames;\n\t\t\t}\n\t\t}\n\n\t\t// Filenames for given Locale\n\t\tList<String> filenames = new ArrayList<>(7);\n\t\tfilenames.addAll(calculateFilenamesForLocale(basename, locale));\n\n\t\t// Filenames for default Locale, if any\n\t\tLocale defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale != null && !defaultLocale.equals(locale)) {\n\t\t\tList<String> fallbackFilenames = calculateFilenamesForLocale(basename, defaultLocale);\n\t\t\tfor (String fallbackFilename : fallbackFilenames) {\n\t\t\t\tif (!filenames.contains(fallbackFilename)) {\n\t\t\t\t\t// Entry for fallback locale that isn't already in filenames list.\n\t\t\t\t\tfilenames.add(fallbackFilename);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Filename for default bundle file\n\t\tfilenames.add(basename);\n\n\t\tif (localeMap == null) {\n\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\tMap<Locale, List<String>> existing = this.cachedFilenames.putIfAbsent(basename, localeMap);\n\t\t\tif (existing != null) {\n\t\t\t\tlocaleMap = existing;\n\t\t\t}\n\t\t}\n\t\tlocaleMap.put(locale, filenames);\n\t\treturn filenames;\n\t}"
  },
  "org.springframework.context.support.<unknown>#calculateFilenamesForLocale(basename,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate the filenames for the given bundle basename and Locale,\n\t * appending language code, country code, and variant code.\n\t * <p>For example, basename \"messages\", Locale \"de_AT_oo\" &rarr; \"messages_de_AT_OO\",\n\t * \"messages_de_AT\", \"messages_de\".\n\t * <p>Follows the rules defined by {@link java.util.Locale#toString()}.\n\t * @param basename the basename of the bundle\n\t * @param locale the locale\n\t * @return the List of filenames to check\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "basename",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "List<String>",
    "signature": "protected List<String> calculateFilenamesForLocale(String basename, Locale locale)",
    "source_code": "\tprotected List<String> calculateFilenamesForLocale(String basename, Locale locale) {\n\t\tList<String> result = new ArrayList<>(3);\n\t\tString language = locale.getLanguage();\n\t\tString country = locale.getCountry();\n\t\tString variant = locale.getVariant();\n\t\tStringBuilder temp = new StringBuilder(basename);\n\n\t\ttemp.append('_');\n\t\tif (language.length() > 0) {\n\t\t\ttemp.append(language);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\ttemp.append('_');\n\t\tif (country.length() > 0) {\n\t\t\ttemp.append(country);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\tif (variant.length() > 0 && (language.length() > 0 || country.length() > 0)) {\n\t\t\ttemp.append('_').append(variant);\n\t\t\tresult.add(0, temp.toString());\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 1463
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 1445
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 1454
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1282
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(name,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 1276
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(name, requiredType);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBean(requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1294
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBean(requiredType, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1410
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1386
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 1422
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getDefaultMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a default message for the given {@code MessageSourceResolvable}.\n\t * <p>This implementation fully renders the default message if available,\n\t * or just returns the plain default message {@code String} if the primary\n\t * message code is being used as a default message.\n\t * @param resolvable the value object to resolve a default message for\n\t * @param locale the current locale\n\t * @return the default message, or {@code null} if none\n\t * @since 4.3.6\n\t * @see #renderDefaultMessage(String, Object[], Locale)\n\t * @see #getDefaultMessage(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\tString defaultMessage = resolvable.getDefaultMessage();\n\t\tString[] codes = resolvable.getCodes();\n\t\tif (defaultMessage != null) {\n\t\t\tif (resolvable instanceof DefaultMessageSourceResolvable defaultMessageSourceResolvable &&\n\t\t\t\t\t!defaultMessageSourceResolvable.shouldRenderDefaultMessage()) {\n\t\t\t\t// Given default message does not contain any argument placeholders\n\t\t\t\t// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {\n\t\t\t\t// Never format a code-as-default-message, even with alwaysUseMessageFormat=true\n\t\t\t\treturn defaultMessage;\n\t\t\t}\n\t\t\treturn renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);\n\t\t}\n\t\treturn (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1505
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn getMessageSource().getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(code,args,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1510
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 1515
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn getMessageSource().getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageFormat(code,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 697
    },
    "return": "MessageFormat",
    "signature": "public MessageFormat getMessageFormat(String code, Locale locale)",
    "source_code": "\t\tpublic MessageFormat getMessageFormat(String code, Locale locale) {\n\t\t\tif (this.properties == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<Locale, MessageFormat> localeMap = this.cachedMessageFormats.get(code);\n\t\t\tif (localeMap != null) {\n\t\t\t\tMessageFormat result = localeMap.get(locale);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString msg = this.properties.getProperty(code);\n\t\t\tif (msg != null) {\n\t\t\t\tif (localeMap == null) {\n\t\t\t\t\tlocaleMap = new ConcurrentHashMap<>();\n\t\t\t\t\tMap<Locale, MessageFormat> existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tlocaleMap = existing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMessageFormat result = createMessageFormat(msg, locale);\n\t\t\t\tlocaleMap.put(locale, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageFromParent(code,args,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Try to retrieve the given message from the parent {@code MessageSource}, if any.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getParentMessageSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "String",
    "signature": "protected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale) {\n\t\tMessageSource parent = getParentMessageSource();\n\t\tif (parent != null) {\n\t\t\tif (parent instanceof AbstractMessageSource abstractMessageSource) {\n\t\t\t\t// Call internal method to avoid getting the default code back\n\t\t\t\t// in case of \"useCodeAsDefaultMessage\" being activated.\n\t\t\t\treturn abstractMessageSource.getMessageInternal(code, args, locale);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check parent MessageSource, returning null if not found there.\n\t\t\t\t// Covers custom MessageSource impls and DelegatingMessageSource.\n\t\t\t\treturn parent.getMessage(code, args, null, locale);\n\t\t\t}\n\t\t}\n\t\t// Not found in parent either.\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.<unknown>#getMessageInternal(code,args,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given code and arguments as message in the given Locale,\n\t * returning {@code null} if not found. Does <i>not</i> fall back to\n\t * the code as default message. Invoked by {@code getMessage} methods.\n\t * @param code the code to lookup up, such as 'calculator.noRateSet'\n\t * @param args array of arguments that will be filled in for params\n\t * within the message\n\t * @param locale the locale in which to do the lookup\n\t * @return the resolved message, or {@code null} if not found\n\t * @see #getMessage(String, Object[], String, Locale)\n\t * @see #getMessage(String, Object[], Locale)\n\t * @see #getMessage(MessageSourceResolvable, Locale)\n\t * @see #setUseCodeAsDefaultMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "String",
    "signature": "protected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale)",
    "source_code": "\tprotected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale) {\n\t\tif (code == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (locale == null) {\n\t\t\tlocale = Locale.getDefault();\n\t\t}\n\t\tObject[] argsToUse = args;\n\n\t\tif (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {\n\t\t\t// Optimized resolution: no arguments to apply,\n\t\t\t// therefore no MessageFormat needs to be involved.\n\t\t\t// Note that the default implementation still uses MessageFormat;\n\t\t\t// this can be overridden in specific subclasses.\n\t\t\tString message = resolveCodeWithoutArguments(code, locale);\n\t\t\tif (message != null) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resolve arguments eagerly, for the case where the message\n\t\t\t// is defined in a parent MessageSource but resolvable arguments\n\t\t\t// are defined in the child MessageSource.\n\t\t\targsToUse = resolveArguments(args, locale);\n\n\t\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\t\tif (messageFormat != null) {\n\t\t\t\tsynchronized (messageFormat) {\n\t\t\t\t\treturn messageFormat.format(argsToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check locale-independent common messages for the given message code.\n\t\tProperties commonMessages = getCommonMessages();\n\t\tif (commonMessages != null) {\n\t\t\tString commonMessage = commonMessages.getProperty(code);\n\t\t\tif (commonMessage != null) {\n\t\t\t\treturn formatMessage(commonMessage, args, locale);\n\t\t\t}\n\t\t}\n\n\t\t// Not found -> check parent, if any.\n\t\treturn getMessageFromParent(code, argsToUse, locale);\n\t}"
  },
  "org.springframework.context.support.<unknown>#invokeBeanFactoryPostProcessors(beanFactory,beanFactoryPostProcessors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "beanFactoryPostProcessors"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "void",
    "signature": "public void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)",
    "source_code": "\tpublic static void invokeBeanFactoryPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\t// Invoke BeanDefinitionRegistryPostProcessors first, if any.\n\t\tSet<String> processedBeans = new HashSet<>();\n\n\t\tif (beanFactory instanceof BeanDefinitionRegistry registry) {\n\t\t\tList<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();\n\t\t\tList<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();\n\n\t\t\tfor (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n\t\t\t\tif (postProcessor instanceof BeanDefinitionRegistryPostProcessor registryProcessor) {\n\t\t\t\t\tregistryProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t\t\t\tregistryProcessors.add(registryProcessor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregularPostProcessors.add(postProcessor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\t\t// Separate between BeanDefinitionRegistryPostProcessors that implement\n\t\t\t// PriorityOrdered, Ordered, and the rest.\n\t\t\tList<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();\n\n\t\t\t// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n\t\t\tString[] postProcessorNames =\n\t\t\t\t\tbeanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\tif (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\tcurrentRegistryProcessors.clear();\n\n\t\t\t// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n\t\t\tboolean reiterate = true;\n\t\t\twhile (reiterate) {\n\t\t\t\treiterate = false;\n\t\t\t\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\t\t\t\tfor (String ppName : postProcessorNames) {\n\t\t\t\t\tif (!processedBeans.contains(ppName)) {\n\t\t\t\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\t\t\t\tprocessedBeans.add(ppName);\n\t\t\t\t\t\treiterate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\t\t\t\tregistryProcessors.addAll(currentRegistryProcessors);\n\t\t\t\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());\n\t\t\t\tcurrentRegistryProcessors.clear();\n\t\t\t}\n\n\t\t\t// Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n\t\t\tinvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n\t\t\tinvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n\t\t}\n\n\t\telse {\n\t\t\t// Invoke factory processors registered with the context instance.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n\t\t}\n\n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let the bean factory post-processors apply to them!\n\t\tString[] postProcessorNames =\n\t\t\t\tbeanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n\t\t// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (processedBeans.contains(ppName)) {\n\t\t\t\t// skip - already processed in first phase above\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tpriorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n\t\t// Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n\t\tList<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : orderedPostProcessorNames) {\n\t\t\torderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n\t\t// Finally, invoke all other BeanFactoryPostProcessors.\n\t\tList<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String postProcessorName : nonOrderedPostProcessorNames) {\n\t\t\tnonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n\t\t}\n\t\tinvokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n\t\t// Clear cached merged bean definitions since the post-processors might have\n\t\t// modified the original metadata, for example, replacing placeholders in values...\n\t\tbeanFactory.clearMetadataCache();\n\t}"
  },
  "org.springframework.context.support.<unknown>#invokeMethod(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "public Object invokeMethod(String name, Object args)",
    "source_code": "\tpublic Object invokeMethod(String name, Object args) {\n\t\treturn this.metaClass.invokeMethod(this, name, args);\n\t}"
  },
  "org.springframework.context.support.<unknown>#isTypeMatch(name,typeToMatch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 1335
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\tassertBeanFactoryActive();\n\t\treturn getBeanFactory().isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.context.support.<unknown>#load(relativeClass,resourceNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions from the given Groovy scripts or XML files.\n\t * <p>Note that \".xml\" files will be parsed as XML content; all other kinds\n\t * of resources will be parsed as Groovy scripts.\n\t * @param relativeClass class whose package will be used as a prefix when\n\t * loading each specified resource name\n\t * @param resourceNames relatively-qualified names of resources to load\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeClass",
      "resourceNames"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "void",
    "signature": "public void load(Class<?> relativeClass, String... resourceNames)",
    "source_code": "\tpublic void load(Class<?> relativeClass, String... resourceNames) {\n\t\tResource[] resources = new Resource[resourceNames.length];\n\t\tfor (int i = 0; i < resourceNames.length; i++) {\n\t\t\tresources[i] = new ClassPathResource(resourceNames[i], relativeClass);\n\t\t}\n\t\tload(resources);\n\t}"
  },
  "org.springframework.context.support.<unknown>#loadProperties(resource,filename)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load the properties from the given resource.\n\t * @param resource the resource to load from\n\t * @param filename the original bundle filename (basename + Locale)\n\t * @return the populated Properties instance\n\t * @throws IOException if properties loading failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resource",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 563
    },
    "return": "Properties",
    "signature": "protected Properties loadProperties(Resource resource, String filename)",
    "source_code": "\tprotected Properties loadProperties(Resource resource, String filename) throws IOException {\n\t\tProperties props = newProperties();\n\t\ttry (InputStream is = resource.getInputStream()) {\n\t\t\tString resourceFilename = resource.getFilename();\n\t\t\tif (resourceFilename != null && resourceFilename.endsWith(XML_EXTENSION)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.propertiesPersister.loadFromXml(props, is);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString encoding = null;\n\t\t\t\tif (this.fileEncodings != null) {\n\t\t\t\t\tencoding = this.fileEncodings.getProperty(filename);\n\t\t\t\t}\n\t\t\t\tif (encoding == null) {\n\t\t\t\t\tencoding = getDefaultEncoding();\n\t\t\t\t}\n\t\t\t\tif (encoding != null) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"] with encoding '\" + encoding + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, new InputStreamReader(is, encoding));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Loading properties [\" + resource.getFilename() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.propertiesPersister.load(props, is);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn props;\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof ApplicationListener<?> applicationListener) {\n\t\t\t// potentially not detected as a listener by getBeanNamesForType retrieval\n\t\t\tBoolean flag = this.singletonNames.get(beanName);\n\t\t\tif (Boolean.TRUE.equals(flag)) {\n\t\t\t\t// singleton bean (top-level or inner): register on the fly\n\t\t\t\tthis.applicationContext.addApplicationListener(applicationListener);\n\t\t\t}\n\t\t\telse if (Boolean.FALSE.equals(flag)) {\n\t\t\t\tif (logger.isWarnEnabled() && !this.applicationContext.containsBean(beanName)) {\n\t\t\t\t\t// inner bean with other scope - can't reliably process events\n\t\t\t\t\tlogger.warn(\"Inner bean '\" + beanName + \"' implements ApplicationListener interface \" +\n\t\t\t\t\t\t\t\"but is not reachable for event multicasting by its containing ApplicationContext \" +\n\t\t\t\t\t\t\t\"because it does not have singleton scope. Only top-level listener beans are allowed \" +\n\t\t\t\t\t\t\t\"to be of non-singleton scope.\");\n\t\t\t\t}\n\t\t\t\tthis.singletonNames.remove(beanName);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tif (bean instanceof ApplicationListener<?> applicationListener) {\n\t\t\ttry {\n\t\t\t\tApplicationEventMulticaster multicaster = this.applicationContext.getApplicationEventMulticaster();\n\t\t\t\tmulticaster.removeApplicationListener(applicationListener);\n\t\t\t\tmulticaster.removeApplicationListenerBean(beanName);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t// ApplicationEventMulticaster not initialized yet - no need to remove a listener\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.context.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tif (ApplicationListener.class.isAssignableFrom(beanType)) {\n\t\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactory,props)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Implemented for compatibility with\n\t * {@link org.springframework.beans.factory.config.PlaceholderConfigurerSupport}.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @deprecated in favor of\n\t * {@link #processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "props"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"Call processProperties(ConfigurableListableBeanFactory, ConfigurablePropertyResolver) instead\");\n\t}"
  },
  "org.springframework.context.support.<unknown>#processProperties(beanFactoryToProcess,propertyResolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Visit each bean definition in the given bean factory and attempt to replace ${...} property\n\t * placeholders with values from the given properties.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactoryToProcess",
      "propertyResolver"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,\n\t\t\tfinal ConfigurablePropertyResolver propertyResolver)",
    "source_code": "\tprotected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,\n\t\t\tfinal ConfigurablePropertyResolver propertyResolver) throws BeansException {\n\n\t\tpropertyResolver.setPlaceholderPrefix(this.placeholderPrefix);\n\t\tpropertyResolver.setPlaceholderSuffix(this.placeholderSuffix);\n\t\tpropertyResolver.setValueSeparator(this.valueSeparator);\n\t\tpropertyResolver.setEscapeCharacter(this.escapeCharacter);\n\n\t\tStringValueResolver valueResolver = strVal -> {\n\t\t\tString resolved = (this.ignoreUnresolvablePlaceholders ?\n\t\t\t\t\tpropertyResolver.resolvePlaceholders(strVal) :\n\t\t\t\t\tpropertyResolver.resolveRequiredPlaceholders(strVal));\n\t\t\tif (this.trimValues) {\n\t\t\t\tresolved = resolved.trim();\n\t\t\t}\n\t\t\treturn (resolved.equals(this.nullValue) ? null : resolved);\n\t\t};\n\n\t\tdoProcessProperties(beanFactoryToProcess, valueResolver);\n\t}"
  },
  "org.springframework.context.support.<unknown>#publishEvent(event,typeHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Publish the given event to all listeners.\n\t * <p>This is the internal delegate that all other {@code publishEvent}\n\t * methods refer to. It is not meant to be called directly but rather serves\n\t * as a propagation mechanism between application contexts in a hierarchy,\n\t * potentially overridden in subclasses for a custom propagation arrangement.\n\t * @param event the event to publish (may be an {@link ApplicationEvent}\n\t * or a payload object to be turned into a {@link PayloadApplicationEvent})\n\t * @param typeHint the resolved event type, if known.\n\t * The implementation of this method also tolerates a payload type hint for\n\t * a payload object to be turned into a {@link PayloadApplicationEvent}.\n\t * However, the recommended way is to construct an actual event object via\n\t * {@link PayloadApplicationEvent#PayloadApplicationEvent(Object, Object, ResolvableType)}\n\t * instead for such scenarios.\n\t * @since 4.2\n\t * @see ApplicationEventMulticaster#multicastEvent(ApplicationEvent, ResolvableType)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "event",
      "typeHint"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "void",
    "signature": "protected void publishEvent(Object event, @Nullable ResolvableType typeHint)",
    "source_code": "\tprotected void publishEvent(Object event, @Nullable ResolvableType typeHint) {\n\t\tAssert.notNull(event, \"Event must not be null\");\n\t\tResolvableType eventType = null;\n\n\t\t// Decorate event as an ApplicationEvent if necessary\n\t\tApplicationEvent applicationEvent;\n\t\tif (event instanceof ApplicationEvent applEvent) {\n\t\t\tapplicationEvent = applEvent;\n\t\t\teventType = typeHint;\n\t\t}\n\t\telse {\n\t\t\tResolvableType payloadType = null;\n\t\t\tif (typeHint != null && ApplicationEvent.class.isAssignableFrom(typeHint.toClass())) {\n\t\t\t\teventType = typeHint;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpayloadType = typeHint;\n\t\t\t}\n\t\t\tapplicationEvent = new PayloadApplicationEvent<>(this, event, payloadType);\n\t\t}\n\n\t\t// Determine event type only once (for multicast and parent publish)\n\t\tif (eventType == null) {\n\t\t\teventType = ResolvableType.forInstance(applicationEvent);\n\t\t\tif (typeHint == null) {\n\t\t\t\ttypeHint = eventType;\n\t\t\t}\n\t\t}\n\n\t\t// Multicast right now if possible - or lazily once the multicaster is initialized\n\t\tif (this.earlyApplicationEvents != null) {\n\t\t\tthis.earlyApplicationEvents.add(applicationEvent);\n\t\t}\n\t\telse if (this.applicationEventMulticaster != null) {\n\t\t\tthis.applicationEventMulticaster.multicastEvent(applicationEvent, eventType);\n\t\t}\n\n\t\t// Publish event via parent context as well...\n\t\tif (this.parent != null) {\n\t\t\tif (this.parent instanceof AbstractApplicationContext abstractApplicationContext) {\n\t\t\t\tabstractApplicationContext.publishEvent(event, typeHint);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.parent.publishEvent(event);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#refreshProperties(filename,propHolder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the PropertiesHolder for the given bundle filename.\n\t * <p>The holder can be {@code null} if not cached before, or a timed-out cache entry\n\t * (potentially getting re-validated against the current last-modified timestamp).\n\t * @param filename the bundle filename (basename + Locale)\n\t * @param propHolder the current PropertiesHolder for the bundle\n\t * @see #resolveResource(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "filename",
      "propHolder"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "PropertiesHolder",
    "signature": "protected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder)",
    "source_code": "\tprotected PropertiesHolder refreshProperties(String filename, @Nullable PropertiesHolder propHolder) {\n\t\tlong refreshTimestamp = (getCacheMillis() < 0 ? -1 : System.currentTimeMillis());\n\n\t\tResource resource = resolveResource(filename);\n\t\tif (resource != null) {\n\t\t\tlong fileTimestamp = -1;\n\t\t\tif (getCacheMillis() >= 0) {\n\t\t\t\t// Last-modified timestamp of file will just be read if caching with timeout.\n\t\t\t\ttry {\n\t\t\t\t\tfileTimestamp = resource.lastModified();\n\t\t\t\t\tif (propHolder != null && propHolder.getFileTimestamp() == fileTimestamp) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Re-caching properties for filename [\" + filename + \"] - file hasn't been modified\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\t\t\t\t\treturn propHolder;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// Probably a class path resource: cache it forever.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(resource + \" could not be resolved in the file system - assuming that it hasn't changed\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tfileTimestamp = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tProperties props = loadProperties(resource, filename);\n\t\t\t\tpropHolder = new PropertiesHolder(props, fileTimestamp);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Could not parse properties file [\" + resource.getFilename() + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t// Empty holder representing \"not valid\".\n\t\t\t\tpropHolder = new PropertiesHolder();\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Resource does not exist.\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No properties file found for [\" + filename + \"]\");\n\t\t\t}\n\t\t\t// Empty holder representing \"not found\".\n\t\t\tpropHolder = new PropertiesHolder();\n\t\t}\n\n\t\tpropHolder.setRefreshTimestamp(refreshTimestamp);\n\t\tthis.cachedProperties.put(filename, propHolder);\n\t\treturn propHolder;\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerAlias(beanName,alias)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "alias"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "void",
    "signature": "public void registerAlias(String beanName, String alias)",
    "source_code": "\tpublic void registerAlias(String beanName, String alias) {\n\t\tthis.beanFactory.registerAlias(beanName, alias);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,constructorArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(null, beanClass, constructorArgs);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, for example, setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 529
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\t\tregisterBean(null, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanClass,supplier,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, for example, setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "void",
    "signature": "public void registerBean(Class<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\tClass<T> beanClass, Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(null, beanClass, supplier, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,constructorArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally providing explicit\n\t * constructor arguments for consideration in the autowiring process.\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param constructorArgs custom argument values to be fed into Spring's\n\t * constructor resolution algorithm, resolving either all arguments or just\n\t * specific ones, with the rest to be resolved through regular autowiring\n\t * (may be {@code null} or empty)\n\t * @since 5.2 (since 5.0 on the AnnotationConfigApplicationContext subclass)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "constructorArgs"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass, Object... constructorArgs) {\n\t\tregisterBean(beanName, beanClass, (Supplier<T>) null,\n\t\t\t\tbd -> {\n\t\t\t\t\tfor (Object arg : constructorArgs) {\n\t\t\t\t\t\tbd.getConstructorArgumentValues().addGenericArgumentValue(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, optionally customizing its\n\t * bean definition metadata (typically declared as a lambda expression).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean (resolving a public constructor\n\t * to be autowired, possibly simply the default constructor)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, for example, setting a lazy-init or primary flag\n\t * @since 5.0\n\t * @see #registerBean(String, Class, Supplier, BeanDefinitionCustomizer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic final <T> void registerBean(\n\t\t\t@Nullable String beanName, Class<T> beanClass, BeanDefinitionCustomizer... customizers) {\n\n\t\tregisterBean(beanName, beanClass, null, customizers);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBean(beanName,beanClass,supplier,customizers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a bean from the given bean class, using the given supplier for\n\t * obtaining a new instance (typically declared as a lambda expression or\n\t * method reference), optionally customizing its bean definition metadata\n\t * (again typically declared as a lambda expression).\n\t * <p>This method can be overridden to adapt the registration mechanism for\n\t * all {@code registerBean} methods (since they all delegate to this one).\n\t * @param beanName the name of the bean (may be {@code null})\n\t * @param beanClass the class of the bean\n\t * @param supplier a callback for creating an instance of the bean (in case\n\t * of {@code null}, resolving a public constructor to be autowired instead)\n\t * @param customizers one or more callbacks for customizing the factory's\n\t * {@link BeanDefinition}, for example, setting a lazy-init or primary flag\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanClass",
      "supplier",
      "customizers"
    ],
    "position": {
      "column": 1,
      "line": 583
    },
    "return": "void",
    "signature": "public void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers)",
    "source_code": "\tpublic <T> void registerBean(@Nullable String beanName, Class<T> beanClass,\n\t\t\t@Nullable Supplier<T> supplier, BeanDefinitionCustomizer... customizers) {\n\n\t\tClassDerivedBeanDefinition beanDefinition = new ClassDerivedBeanDefinition(beanClass);\n\t\tif (supplier != null) {\n\t\t\tbeanDefinition.setInstanceSupplier(supplier);\n\t\t}\n\t\tfor (BeanDefinitionCustomizer customizer : customizers) {\n\t\t\tcustomizer.customize(beanDefinition);\n\t\t}\n\n\t\tString nameToUse = (beanName != null ? beanName : beanClass.getName());\n\t\tregisterBeanDefinition(nameToUse, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanDefinition(beanName,beanDefinition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "beanDefinition"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)",
    "source_code": "\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tthis.beanFactory.registerBeanDefinition(beanName, beanDefinition);\n\t}"
  },
  "org.springframework.context.support.<unknown>#registerBeanPostProcessors(beanFactory,applicationContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "void",
    "signature": "public void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)",
    "source_code": "\tpublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\n\t\t// WARNING: Although it may appear that the body of this method can be easily\n\t\t// refactored to avoid the use of multiple loops and multiple lists, the use\n\t\t// of multiple lists and multiple passes over the names of processors is\n\t\t// intentional. We must ensure that we honor the contracts for PriorityOrdered\n\t\t// and Ordered processors. Specifically, we must NOT cause processors to be\n\t\t// instantiated (via getBean() invocations) or registered in the ApplicationContext\n\t\t// in the wrong order.\n\t\t//\n\t\t// Before submitting a pull request (PR) to change this method, please review the\n\t\t// list of all declined PRs involving changes to PostProcessorRegistrationDelegate\n\t\t// to ensure that your proposal does not result in a breaking change:\n\t\t// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22\n\n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n\t\t// Register BeanPostProcessorChecker that logs a warn message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n\t\tbeanFactory.addBeanPostProcessor(\n\t\t\t\tnew BeanPostProcessorChecker(beanFactory, postProcessorNames, beanProcessorTargetCount));\n\n\t\t// Separate between BeanPostProcessors that implement PriorityOrdered,\n\t\t// Ordered, and the rest.\n\t\tList<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t// First, register the BeanPostProcessors that implement PriorityOrdered.\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t// Next, register the BeanPostProcessors that implement Ordered.\n\t\tList<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t// Now, register all regular BeanPostProcessors.\n\t\tList<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t// Finally, re-register all internal BeanPostProcessors.\n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveArguments(args,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Searches through the given array of objects, finds any MessageSourceResolvable\n\t * objects and resolves them.\n\t * <p>Allows for messages to have MessageSourceResolvables as arguments.\n\t * @param args array of arguments for a message\n\t * @param locale the locale to resolve through\n\t * @return an array of arguments with any MessageSourceResolvables resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Object[]",
    "signature": "protected Object[] resolveArguments(@Nullable Object[] args, Locale locale)",
    "source_code": "\tprotected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {\n\t\tif (ObjectUtils.isEmpty(args)) {\n\t\t\treturn super.resolveArguments(args, locale);\n\t\t}\n\t\tList<Object> resolvedArgs = new ArrayList<>(args.length);\n\t\tfor (Object arg : args) {\n\t\t\tif (arg instanceof MessageSourceResolvable messageSourceResolvable) {\n\t\t\t\tresolvedArgs.add(getMessage(messageSourceResolvable, locale));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolvedArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs.toArray();\n\t}"
  },
  "org.springframework.context.support.<unknown>#resolveCode(code,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to resolve a message.\n\t * <p>Returns a MessageFormat instance rather than a message String,\n\t * to allow for appropriate caching of MessageFormats in subclasses.\n\t * <p><b>Subclasses are encouraged to provide optimized resolution\n\t * for messages without arguments, not involving MessageFormat.</b>\n\t * See the {@link #resolveCodeWithoutArguments} javadoc for details.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the MessageFormat for the message, or {@code null} if not found\n\t * @see #resolveCodeWithoutArguments(String, java.util.Locale)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 392
    },
    "return": "MessageFormat",
    "signature": "protected MessageFormat resolveCode(String code, Locale locale)",
    "source_code": "\tprotected abstract MessageFormat resolveCode(String code, Locale locale);"
  },
  "org.springframework.context.support.<unknown>#resolveCodeWithoutArguments(code,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to resolve a message without arguments\n\t * in an optimized fashion, i.e. to resolve without involving a MessageFormat.\n\t * <p>The default implementation <i>does</i> use MessageFormat, through\n\t * delegating to the {@link #resolveCode} method. Subclasses are encouraged\n\t * to replace this with optimized resolution.\n\t * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented\n\t * in an efficient fashion. In particular, it does not detect that a message\n\t * pattern doesn't contain argument placeholders in the first place. Therefore,\n\t * it is advisable to circumvent MessageFormat for messages without arguments.\n\t * @param code the code of the message to resolve\n\t * @param locale the locale to resolve the code for\n\t * (subclasses are encouraged to support internationalization)\n\t * @return the message String, or {@code null} if not found\n\t * @see #resolveCode\n\t * @see java.text.MessageFormat\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "code",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "String",
    "signature": "protected String resolveCodeWithoutArguments(String code, Locale locale)",
    "source_code": "\tprotected String resolveCodeWithoutArguments(String code, Locale locale) {\n\t\tMessageFormat messageFormat = resolveCode(code, locale);\n\t\tif (messageFormat != null) {\n\t\t\tsynchronized (messageFormat) {\n\t\t\t\treturn messageFormat.format(new Object[0]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.context.support.<unknown>#setProperty(property,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "void",
    "signature": "public void setProperty(String property, Object newValue)",
    "source_code": "\tpublic void setProperty(String property, Object newValue) {\n\t\tif (newValue instanceof BeanDefinition beanDefinition) {\n\t\t\tregisterBeanDefinition(property, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tthis.metaClass.setProperty(this, property, newValue);\n\t\t}\n\t}"
  },
  "org.springframework.context.support.<unknown>#setTimeoutForShutdownPhase(phase,timeout)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of a specific phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param phase the phase value (matching {@link SmartLifecycle#getPhase()})\n\t * @param timeout the corresponding timeout value (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "phase",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setTimeoutForShutdownPhase(int phase, long timeout)",
    "source_code": "\tpublic void setTimeoutForShutdownPhase(int phase, long timeout) {\n\t\tthis.timeoutsForShutdownPhases.put(phase, timeout);\n\t}"
  },
  "org.springframework.context.support.<unknown>#setTimeoutsForShutdownPhases(Map<Integer,timeoutsForShutdownPhases)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the maximum time allotted for the shutdown of each given phase\n\t * (group of {@link SmartLifecycle} beans with the same 'phase' value).\n\t * <p>In case of no specific timeout configured, the default timeout per\n\t * shutdown phase will apply: 10000 milliseconds (10 seconds) as of 6.2.\n\t * @param timeoutsForShutdownPhases a map of phase values (matching\n\t * {@link SmartLifecycle#getPhase()}) and corresponding timeout values\n\t * (in milliseconds)\n\t * @since 6.2\n\t * @see SmartLifecycle#getPhase()\n\t * @see #setTimeoutPerShutdownPhase\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Integer",
      "timeoutsForShutdownPhases"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "public void setTimeoutsForShutdownPhases(Map<Integer, Long> timeoutsForShutdownPhases)",
    "source_code": "\tpublic void setTimeoutsForShutdownPhases(Map<Integer, Long> timeoutsForShutdownPhases) {\n\t\tthis.timeoutsForShutdownPhases.putAll(timeoutsForShutdownPhases);\n\t}"
  },
  "org.springframework.context.weaving.<unknown>#postProcessAfterInitialization(bean,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String name)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String name) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.context.weaving.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof LoadTimeWeaverAware loadTimeWeaverAware) {\n\t\t\tLoadTimeWeaver ltw = this.loadTimeWeaver;\n\t\t\tif (ltw == null) {\n\t\t\t\tAssert.state(this.beanFactory != null,\n\t\t\t\t\t\t\"BeanFactory required if no LoadTimeWeaver explicitly specified\");\n\t\t\t\tltw = this.beanFactory.getBean(\n\t\t\t\t\t\tConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);\n\t\t\t}\n\t\t\tloadTimeWeaverAware.setLoadTimeWeaver(ltw);\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.core.<unknown>#compare(o1,o2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "int",
    "signature": "public int compare(@Nullable Object o1, @Nullable Object o2)",
    "source_code": "\tpublic int compare(@Nullable Object o1, @Nullable Object o2) {\n\t\treturn doCompare(o1, o2, null);\n\t}"
  },
  "org.springframework.core.<unknown>#computeAttribute(name,Function<String,computeFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.core.<unknown>#createApproximateCollection(collection,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most approximate collection for the given collection.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the type of elements contained in the supplied\n\t * {@code collection}, type safety cannot be guaranteed if the supplied\n\t * {@code collection} is an {@link EnumSet}. In such scenarios, the caller\n\t * is responsible for ensuring that the element type for the supplied\n\t * {@code collection} is an enum type matching type {@code E}. As an\n\t * alternative, the caller may wish to treat the return value as a raw\n\t * collection or collection of {@link Object}.\n\t * @param collection the original collection object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty collection instance\n\t * @see #isApproximableCollectionType\n\t * @see java.util.LinkedList\n\t * @see java.util.ArrayList\n\t * @see java.util.EnumSet\n\t * @see java.util.TreeSet\n\t * @see java.util.LinkedHashSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createApproximateCollection(@Nullable Object collection, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {\n\t\tif (collection instanceof EnumSet enumSet) {\n\t\t\tCollection<E> copy = EnumSet.copyOf(enumSet);\n\t\t\tcopy.clear();\n\t\t\treturn copy;\n\t\t}\n\t\telse if (collection instanceof SortedSet sortedSet) {\n\t\t\treturn new TreeSet<>(sortedSet.comparator());\n\t\t}\n\t\telse if (collection instanceof LinkedList) {\n\t\t\treturn new LinkedList<>();\n\t\t}\n\t\telse if (collection instanceof List) {\n\t\t\treturn new ArrayList<>(capacity);\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createApproximateMap(map,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most approximate map for the given map.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K} is\n\t * not bound to the type of keys contained in the supplied {@code map},\n\t * type safety cannot be guaranteed if the supplied {@code map} is an\n\t * {@link EnumMap}. In such scenarios, the caller is responsible for\n\t * ensuring that the key type in the supplied {@code map} is an enum type\n\t * matching type {@code K}. As an alternative, the caller may wish to\n\t * treat the return value as a raw map or map keyed by {@link Object}.\n\t * @param map the original map object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty map instance\n\t * @see #isApproximableMapType\n\t * @see java.util.EnumMap\n\t * @see java.util.TreeMap\n\t * @see java.util.LinkedHashMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "map",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "V>",
    "signature": "public V> createApproximateMap(@Nullable Object map, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {\n\t\tif (map instanceof EnumMap enumMap) {\n\t\t\tEnumMap copy = new EnumMap(enumMap);\n\t\t\tcopy.clear();\n\t\t\treturn copy;\n\t\t}\n\t\telse if (map instanceof SortedMap sortedMap) {\n\t\t\treturn new TreeMap<>(sortedMap.comparator());\n\t\t}\n\t\telse if (map instanceof MultiValueMap) {\n\t\t\treturn new LinkedMultiValueMap(capacity);\n\t\t}\n\t\telse {\n\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p>Delegates to {@link #createCollection(Class, Class, int)} with a\n\t * {@code null} element type.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType}\n\t * is {@code null} or of type {@link EnumSet}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {\n\t\treturn createCollection(collectionType, null, capacity);\n\t}"
  },
  "org.springframework.core.<unknown>#createCollection(collectionType,elementType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate collection for the given collection type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the supplied {@code elementType}, type safety cannot be\n\t * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\n\t * In such scenarios, the caller is responsible for ensuring that the\n\t * supplied {@code elementType} is an enum type matching type {@code E}.\n\t * As an alternative, the caller may wish to treat the return value as a\n\t * raw collection or collection of {@link Object}.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param elementType the collection's element type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumSet} creation)\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType} is\n\t * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\n\t * the supplied {@code elementType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashSet\n\t * @see java.util.ArrayList\n\t * @see java.util.TreeSet\n\t * @see java.util.EnumSet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Collection<E>",
    "signature": "public Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity)",
    "source_code": "\tpublic static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (LinkedHashSet.class == collectionType ||\n\t\t\t\tSet.class == collectionType || Collection.class == collectionType ||\n\t\t\t\tcollectionType.getName().equals(\"java.util.SequencedSet\") ||\n\t\t\t\tcollectionType.getName().equals(\"java.util.SequencedCollection\")) {\n\t\t\treturn new LinkedHashSet<>(capacity);\n\t\t}\n\t\telse if (ArrayList.class == collectionType || List.class == collectionType) {\n\t\t\treturn new ArrayList<>(capacity);\n\t\t}\n\t\telse if (LinkedList.class == collectionType) {\n\t\t\treturn new LinkedList<>();\n\t\t}\n\t\telse if (TreeSet.class == collectionType || NavigableSet.class == collectionType ||\n\t\t\t\tSortedSet.class == collectionType) {\n\t\t\treturn new TreeSet<>();\n\t\t}\n\t\telse if (EnumSet.class.isAssignableFrom(collectionType)) {\n\t\t\tAssert.notNull(elementType, \"Cannot create EnumSet for unknown element type\");\n\t\t\treturn EnumSet.noneOf(asEnumType(elementType));\n\t\t}\n\t\telse if (HashSet.class == collectionType) {\n\t\t\treturn new HashSet<>(capacity);\n\t\t}\n\t\telse {\n\t\t\tif (collectionType.isInterface() || !Collection.class.isAssignableFrom(collectionType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Collection type: \" + collectionType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not instantiate Collection type: \" + collectionType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p>Delegates to {@link #createMap(Class, Class, int)} with a\n\t * {@code null} key type.\n\t * @param mapType the desired type of the target map\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null} or of type {@link EnumMap}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {\n\t\treturn createMap(mapType, null, capacity);\n\t}"
  },
  "org.springframework.core.<unknown>#createMap(mapType,keyType,capacity)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the most appropriate map for the given map type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K}\n\t * is not bound to the supplied {@code keyType}, type safety cannot be\n\t * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\n\t * scenarios, the caller is responsible for ensuring that the {@code keyType}\n\t * is an enum type matching type {@code K}. As an alternative, the caller\n\t * may wish to treat the return value as a raw map or map keyed by\n\t * {@link Object}. Similarly, type safety cannot be enforced if the\n\t * desired {@code mapType} is {@link MultiValueMap}.\n\t * @param mapType the desired type of the target map (never {@code null})\n\t * @param keyType the map's key type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumMap} creation)\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\n\t * the supplied {@code keyType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashMap\n\t * @see java.util.TreeMap\n\t * @see org.springframework.util.LinkedMultiValueMap\n\t * @see java.util.EnumMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyType",
      "capacity"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "V>",
    "signature": "public V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity)",
    "source_code": "\tpublic static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (LinkedHashMap.class == mapType || Map.class == mapType ||\n\t\t\t\tmapType.getName().equals(\"java.util.SequencedMap\")) {\n\t\t\treturn new LinkedHashMap<>(capacity);\n\t\t}\n\t\telse if (LinkedMultiValueMap.class == mapType || MultiValueMap.class == mapType) {\n\t\t\treturn new LinkedMultiValueMap();\n\t\t}\n\t\telse if (TreeMap.class == mapType || SortedMap.class == mapType || NavigableMap.class == mapType) {\n\t\t\treturn new TreeMap<>();\n\t\t}\n\t\telse if (EnumMap.class == mapType) {\n\t\t\tAssert.notNull(keyType, \"Cannot create EnumMap for unknown key type\");\n\t\t\treturn new EnumMap(asEnumType(keyType));\n\t\t}\n\t\telse if (HashMap.class == mapType) {\n\t\t\treturn new HashMap<>(capacity);\n\t\t}\n\t\telse {\n\t\t\tif (mapType.isInterface() || !Map.class.isAssignableFrom(mapType)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Map type: \" + mapType.getName());\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not instantiate Map type: \" + mapType.getName(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#createSortedProperties(properties,omitComments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@code Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * <p>The returned {@code Properties} instance will be populated with\n\t * properties from the supplied {@code properties} object, but default\n\t * properties from the supplied {@code properties} object will not be copied.\n\t * @param properties the {@code Properties} object from which to copy the\n\t * initial properties\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "properties",
      "omitComments"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "Properties",
    "signature": "public Properties createSortedProperties(Properties properties, boolean omitComments)",
    "source_code": "\tpublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\n\t\treturn new SortedProperties(properties, omitComments);\n\t}"
  },
  "org.springframework.core.<unknown>#forClass(baseType,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified base type\n\t * (interface or base class) with a given implementation class.\n\t * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\n\t * @param baseType the base type (must not be {@code null})\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified base type backed by the\n\t * given implementation class\n\t * @see #forClass(Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseType",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1162
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forClass(Class<?> baseType, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {\n\t\tAssert.notNull(baseType, \"Base type must not be null\");\n\t\tResolvableType asType = forType(implementationClass).as(baseType);\n\t\treturn (asType == NONE ? forType(baseType) : asType);\n\t}"
  },
  "org.springframework.core.<unknown>#forClassWithGenerics(clazz,generics)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@code ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "generics"
    ],
    "position": {
      "column": 1,
      "line": 1192
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forClassWithGenerics(Class<?> clazz, @Nullable ResolvableType... generics)",
    "source_code": "\tpublic static ResolvableType forClassWithGenerics(Class<?> clazz, @Nullable ResolvableType... generics) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tTypeVariable<?>[] variables = clazz.getTypeParameters();\n\t\tif (generics != null) {\n\t\t\tAssert.isTrue(variables.length == generics.length,\n\t\t\t\t\t() -> \"Mismatched number of generics specified for \" + clazz.toGenericString());\n\t\t}\n\t\tType[] arguments = new Type[variables.length];\n\t\tfor (int i = 0; i < variables.length; i++) {\n\t\t\tResolvableType generic = (generics != null ? generics[i] : null);\n\t\t\tType argument = (generic != null ? generic.getType() : null);\n\t\t\targuments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);\n\t\t}\n\t\treturn forType(new SyntheticParameterizedType(clazz, arguments),\n\t\t\t\t(generics != null ? new TypeVariablesVariableResolver(variables, generics) : null));\n\t}"
  },
  "org.springframework.core.<unknown>#forConstructorParameter(constructor,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Constructor} parameter.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@code ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1312
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(constructor, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forConstructorParameter(constructor,parameterIndex,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Constructor} parameter\n\t * with a given implementation. Use this variant when the class that declares the\n\t * constructor includes generic parameter variables that are satisfied by the\n\t * implementation class.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "parameterIndex",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1328
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass) {\n\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forExecutable(executable,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 812
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forExecutable(Executable executable, int parameterIndex)",
    "source_code": "\tpublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new MethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new MethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1251
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,implementationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation type.\n\t * @param field the source field\n\t * @param implementationType the implementation type\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1267
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, @Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = (implementationType != null ? implementationType : NONE);\n\t\towner = owner.as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with the\n\t * given nesting level.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 1282
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, int nestingLevel)",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\treturn forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forField(field,nestingLevel,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation and the given nesting level.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1299
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forFieldAwareConstructor(ctor,parameterIndex,fieldName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * for example, on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ctor",
      "parameterIndex",
      "fieldName"
    ],
    "position": {
      "column": 1,
      "line": 875
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName)",
    "source_code": "\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodOrConstructor(methodOrConstructor,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param methodOrConstructor the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @deprecated as of 5.0, in favor of {@link #forExecutable}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodOrConstructor",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 795
    },
    "return": "MethodParameter",
    "signature": "public MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex)",
    "source_code": "\tpublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\n\t\tif (!(methodOrConstructor instanceof Executable executable)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\n\t\t}\n\t\treturn forExecutable(executable, parameterIndex);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} parameter.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 1370
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(method, parameterIndex));\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(method,parameterIndex,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} parameter with a\n\t * given implementation. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation class.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "parameterIndex",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1386
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,implementationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "implementationType"
    ],
    "position": {
      "column": 1,
      "line": 1411
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType) {\n\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\timplementationType = (implementationType != null ? implementationType :\n\t\t\t\tforType(methodParameter.getContainingClass()));\n\t\tResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\n\t\treturn forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodParameter(methodParameter,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter},\n\t * overriding the target type to resolve with a specific given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 1430
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType)",
    "source_code": "\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\treturn forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());\n\t}"
  },
  "org.springframework.core.<unknown>#forMethodReturnType(method,implementationClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} return type.\n\t * <p>Use this variant when the class that declares the method includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param method the source for the method return type\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "implementationClass"
    ],
    "position": {
      "column": 1,
      "line": 1356
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forMethodReturnType(Method method, Class<?> implementationClass)",
    "source_code": "\tpublic static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}"
  },
  "org.springframework.core.<unknown>#forType(type,owner)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@code ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "owner"
    ],
    "position": {
      "column": 1,
      "line": 1485
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner)",
    "source_code": "\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}"
  },
  "org.springframework.core.<unknown>#getAdapter(reactiveType,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the adapter for the given reactive type. Or if a \"source\" object is\n\t * provided, its actual type is used instead.\n\t * @param reactiveType the reactive type\n\t * (may be {@code null} if a concrete source object is given)\n\t * @param source an instance of the reactive type\n\t * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reactiveType",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ReactiveAdapter",
    "signature": "public ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source)",
    "source_code": "\tpublic ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\n\t\tif (this.adapters.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\n\t\tClass<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType() == clazz) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType().isAssignableFrom(clazz)) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.<unknown>#getNested(nestingLevel,Map<Integer,typeIndexesPerLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (for example, a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (can be {@code null})\n\t * @return a {@code ResolvableType} for the nested level, or {@link #NONE}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "nestingLevel",
      "Map<Integer",
      "typeIndexesPerLevel"
    ],
    "position": {
      "column": 1,
      "line": 725
    },
    "return": "ResolvableType",
    "signature": "public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel)",
    "source_code": "\tpublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\n\t\tResolvableType result = this;\n\t\tfor (int i = 2; i <= nestingLevel; i++) {\n\t\t\tif (result.isArray()) {\n\t\t\t\tresult = result.getComponentType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle derived types\n\t\t\t\twhile (result != ResolvableType.NONE && !result.hasGenerics()) {\n\t\t\t\t\tresult = result.getSuperType();\n\t\t\t\t}\n\t\t\t\tInteger index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\n\t\t\t\tindex = (index == null ? result.getGenerics().length - 1 : index);\n\t\t\t\tresult = result.getGeneric(index);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.<unknown>#getQualifiedAttributeName(enclosingClass,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enclosingClass",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "String",
    "signature": "public String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName)",
    "source_code": "\tpublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\n\t\tAssert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\treturn enclosingClass.getName() + '.' + attributeName;\n\t}"
  },
  "org.springframework.core.<unknown>#getVariableNameForReturnType(method,resolvedType,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, for example, {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "resolvedType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "String",
    "signature": "public String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value)",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\n\t\tif (Object.class == resolvedType) {\n\t\t\tAssert.notNull(value, \"Cannot generate variable name for an Object return type with null value\");\n\t\t\treturn getVariableName(value);\n\t\t}\n\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (resolvedType.isArray()) {\n\t\t\tvalueClass = resolvedType.componentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(resolvedType)) {\n\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tif (!(value instanceof Collection<?> collection)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and a non-Collection value\");\n\t\t\t\t}\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and an empty Collection value\");\n\t\t\t\t}\n\t\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = resolvedType;\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}"
  },
  "org.springframework.core.<unknown>#getVariableNameForReturnType(method,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, for example, {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "String",
    "signature": "public String getVariableNameForReturnType(Method method, @Nullable Object value)",
    "source_code": "\tpublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), value);\n\t}"
  },
  "org.springframework.core.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\tObject other = args[0];\n\t\t\t\t\t// Unwrap proxies for speed\n\t\t\t\t\tif (other instanceof Type otherType) {\n\t\t\t\t\t\tother = unwrap(otherType);\n\t\t\t\t\t}\n\t\t\t\t\treturn ObjectUtils.nullSafeEquals(this.provider.getType(), other);\n\t\t\t\t}\n\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\treturn ObjectUtils.nullSafeHashCode(this.provider.getType());\n\t\t\t\t}\n\t\t\t\tcase \"getTypeProvider\" -> {\n\t\t\t\t\treturn this.provider;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Type.class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\n\t\t\t\treturn forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));\n\t\t\t}\n\t\t\telse if (Type[].class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\n\t\t\t\tObject returnValue = ReflectionUtils.invokeMethod(method, this.provider.getType());\n\t\t\t\tif (returnValue == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tType[] result = new Type[((Type[]) returnValue).length];\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tresult[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tType type = this.provider.getType();\n\t\t\tif (type instanceof TypeVariable<?> tv && method.getName().equals(\"getName\")) {\n\t\t\t\t// Avoid reflection for common comparison of type variables\n\t\t\t\treturn tv.getName();\n\t\t\t}\n\t\t\treturn ReflectionUtils.invokeMethod(method, type, args);\n\t\t}"
  },
  "org.springframework.core.<unknown>#isAssignableFrom(type,Map<Type,matchedBefore)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1745
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.<unknown>#isAssignableFrom(types,Map<Type,matchedBefore)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "types",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1730
    },
    "return": "boolean",
    "signature": "public boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType type : types) {\n\t\t\t\tif (!isAssignableFrom(type, matchedBefore)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.core.<unknown>#isAssignableTo(type,Map<Type,matchedBefore)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "Map<Type",
      "matchedBefore"
    ],
    "position": {
      "column": 1,
      "line": 1761
    },
    "return": "boolean",
    "signature": "public boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore)",
    "source_code": "\t\tpublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tif (this.kind == Kind.UPPER) {\n\t\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\t\tif (type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (type.resolve() == Object.class);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.<unknown>#registerReactiveType(descriptor,Function<Object,toAdapter,Function<Publisher<?>,fromAdapter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter after existing adapters.\n\t * It will be matched for the exact reactive type if no earlier adapter was\n\t * registered for the specific type, and it will be matched for assignability\n\t * in a second pass if no earlier adapter had an assignable type before.\n\t * @see #registerReactiveTypeOverride\n\t * @see #getAdapter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "Function<Object",
      "toAdapter",
      "Function<Publisher<?>",
      "fromAdapter"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter)",
    "source_code": "\tpublic void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\tthis.adapters.add(buildAdapter(descriptor, toAdapter, fromAdapter));\n\t}"
  },
  "org.springframework.core.<unknown>#registerReactiveTypeOverride(descriptor,Function<Object,toAdapter,Function<Publisher<?>,fromAdapter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter first, effectively overriding\n\t * any previously registered adapters for the same reactive type. This allows\n\t * for overriding existing adapters, in particular default adapters.\n\t * <p>Note that existing adapters for specific types will still match before\n\t * an assignability match with the new adapter. In order to override all\n\t * existing matches, a new reactive type adapter needs to be registered\n\t * for every specific type, not relying on subtype assignability matches.\n\t * @since 5.3.30\n\t * @see #registerReactiveType\n\t * @see #getAdapter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "Function<Object",
      "toAdapter",
      "Function<Publisher<?>",
      "fromAdapter"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter)",
    "source_code": "\tpublic void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\tthis.adapters.add(0, buildAdapter(descriptor, toAdapter, fromAdapter));\n\t}"
  },
  "org.springframework.core.<unknown>#resolveType(genericType,contextClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given generic type against the given context class,\n\t * substituting type variables as far as possible.\n\t * <p>As of 6.2, this method resolves type variables recursively.\n\t * @param genericType the (potentially) generic type\n\t * @param contextClass a context class for the target type, for example a class\n\t * in which the target type appears in a method signature (can be {@code null})\n\t * @return the resolved type (possibly the given generic type as-is)\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "genericType",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "Type",
    "signature": "public Type resolveType(Type genericType, @Nullable Class<?> contextClass)",
    "source_code": "\tpublic static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {\n\t\tif (contextClass != null) {\n\t\t\tif (genericType instanceof TypeVariable<?> typeVariable) {\n\t\t\t\tResolvableType resolvedTypeVariable = resolveVariable(\n\t\t\t\t\t\ttypeVariable, ResolvableType.forClass(contextClass));\n\t\t\t\tif (resolvedTypeVariable != ResolvableType.NONE) {\n\t\t\t\t\tClass<?> resolved = resolvedTypeVariable.resolve();\n\t\t\t\t\tif (resolved != null) {\n\t\t\t\t\t\treturn resolved;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (genericType instanceof ParameterizedType parameterizedType) {\n\t\t\t\tResolvableType resolvedType = ResolvableType.forType(genericType);\n\t\t\t\tif (resolvedType.hasUnresolvableGenerics()) {\n\t\t\t\t\tResolvableType[] generics = new ResolvableType[parameterizedType.getActualTypeArguments().length];\n\t\t\t\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\t\t\t\tResolvableType contextType = ResolvableType.forClass(contextClass);\n\t\t\t\t\tfor (int i = 0; i < typeArguments.length; i++) {\n\t\t\t\t\t\tType typeArgument = typeArguments[i];\n\t\t\t\t\t\tif (typeArgument instanceof TypeVariable<?> typeVariable) {\n\t\t\t\t\t\t\tResolvableType resolvedTypeArgument = resolveVariable(typeVariable, contextType);\n\t\t\t\t\t\t\tif (resolvedTypeArgument != ResolvableType.NONE) {\n\t\t\t\t\t\t\t\tgenerics[i] = resolvedTypeArgument;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tgenerics[i] = ResolvableType.forType(typeArgument);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeArgument instanceof ParameterizedType) {\n\t\t\t\t\t\t\tgenerics[i] = ResolvableType.forType(resolveType(typeArgument, contextClass));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tgenerics[i] = ResolvableType.forType(typeArgument);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tClass<?> rawClass = resolvedType.getRawClass();\n\t\t\t\t\tif (rawClass != null) {\n\t\t\t\t\t\treturn ResolvableType.forClassWithGenerics(rawClass, generics).getType();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn genericType;\n\t}"
  },
  "org.springframework.core.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tif (value != null) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}"
  },
  "org.springframework.core.<unknown>#toCode(value,namePrefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "namePrefix"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "String",
    "signature": "public String toCode(Object value, @Nullable String namePrefix)",
    "source_code": "\tpublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, prefixToUse, value);\n\t}"
  },
  "org.springframework.core.<unknown>#toCodeForProperty(value,propertyName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the group of constants for\n\t * the given bean property name. Will return the first match.\n\t * @param value constant value to look up\n\t * @param propertyName the name of the bean property\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t * @see #propertyToConstantNamePrefix\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "propertyName"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "String",
    "signature": "public String toCodeForProperty(Object value, String propertyName)",
    "source_code": "\tpublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\n\t\treturn toCode(value, propertyToConstantNamePrefix(propertyName));\n\t}"
  },
  "org.springframework.core.<unknown>#toCodeForSuffix(value,nameSuffix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "nameSuffix"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "String",
    "signature": "public String toCodeForSuffix(Object value, @Nullable String nameSuffix)",
    "source_code": "\tpublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, suffixToUse, value);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#asMap(Function<MergedAnnotation<?>,factory,adaptations)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<MergedAnnotation<?>",
      "factory",
      "adaptations"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "T",
    "signature": "public T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations)",
    "source_code": "\tpublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\n\t\tT map = factory.apply(this);\n\t\tAssert.state(map != null, \"Factory used to create MergedAnnotation Map must not return null\");\n\t\tAttributeMethods attributes = this.mapping.getAttributes();\n\t\tfor (int i = 0; i < attributes.size(); i++) {\n\t\t\tMethod attribute = attributes.get(i);\n\t\t\tObject value = (isFiltered(attribute.getName()) ? null :\n\t\t\t\t\tgetValue(i, getTypeForMapOptions(attribute, adaptations)));\n\t\t\tif (value != null) {\n\t\t\t\tmap.put(attribute.getName(),\n\t\t\t\t\t\tadaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the supplied element.\n\t * <p><strong>Warning</strong>: this method operates generically on\n\t * annotated elements. In other words, this method does not execute\n\t * specialized search algorithms for classes or methods. If you require\n\t * the more specific semantics of {@link #findAnnotation(Class, Class)}\n\t * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\n\t * instead.\n\t * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "A",
    "signature": "public A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(\n\t\t\tAnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\n\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(clazz,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link Class}, traversing its interfaces, annotations, and\n\t * superclasses if the annotation is not <em>directly present</em> on\n\t * the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\n\t * as meta-annotations and annotations on interfaces</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return it if found.\n\t * <li>Recursively search through all annotations that the given class declares.\n\t * <li>Recursively search through all interfaces that the given class declares.\n\t * <li>Recursively search through the superclass hierarchy of the given class.\n\t * </ol>\n\t * <p>Note: in this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current interface,\n\t * annotation, or superclass as the class to look for annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "A",
    "signature": "public A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\tA annotation = clazz.getDeclaredAnnotation(annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t\t// For backwards compatibility, perform a superclass search with plain annotations\n\t\t\t// even if not marked as @Inherited: for example, a findAnnotation search for @Deprecated\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass == null || superclass == Object.class) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn findAnnotation(superclass, annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#findAnnotation(method,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "A",
    "signature": "public A findAnnotation(Method method, @Nullable Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\n\t\t\treturn method.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#firstRunOf(MergedAnnotation<A>,valueExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches only\n\t * the first run of an extracted value. For example,\n\t * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\n\t * will match the first annotation, and any subsequent runs that have the\n\t * same distance.\n\t * <p>NOTE: This predicate only matches the first run. Once the extracted\n\t * value changes, the predicate always returns {@code false}. For example,\n\t * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\n\t * only the first two will match.\n\t * @param valueExtractor function used to extract the value to check\n\t * @return a {@link Predicate} that matches the first run of the extracted\n\t * values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MergedAnnotation<A>",
      "valueExtractor"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "Predicate<MergedAnnotation<A>>",
    "signature": "public Predicate<MergedAnnotation<A>> firstRunOf(Function<? super MergedAnnotation<A>, ?> valueExtractor)",
    "source_code": "\tpublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(\n\t\t\tFunction<? super MergedAnnotation<A>, ?> valueExtractor) {\n\n\t\treturn new FirstRunOfPredicate<>(valueExtractor);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#forExecutable(executable,parameterIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new SynthesizingMethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding SynthesizingMethodParameter instance\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "parameterIndex"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "SynthesizingMethodParameter",
    "signature": "public SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex)",
    "source_code": "\tpublic static SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new SynthesizingMethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new SynthesizingMethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#fromMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an {@link AnnotationAttributes} instance based on the given map.\n\t * <p>If the map is already an {@code AnnotationAttributes} instance, it\n\t * will be cast and returned immediately without creating a new instance.\n\t * Otherwise a new instance will be created by passing the supplied map\n\t * to the {@link #AnnotationAttributes(Map)} constructor.\n\t * @param map original source of annotation attribute <em>key-value</em> pairs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes fromMap(@Nullable Map<String, Object> map)",
    "source_code": "\tpublic static AnnotationAttributes fromMap(@Nullable Map<String, Object> map) {\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (map instanceof AnnotationAttributes annotationAttributes) {\n\t\t\treturn annotationAttributes;\n\t\t}\n\t\treturn new AnnotationAttributes(map);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\n\t * <em>meta-present</em> on the {@code AnnotatedElement}.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(AnnotatedElement, Class)} instead.\n\t * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "A",
    "signature": "public A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(annotation,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * annotation: either the given annotation itself or a direct meta-annotation\n\t * thereof.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use one of the\n\t * {@code find*()} methods instead.\n\t * @param annotation the Annotation to check\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "A",
    "signature": "public A getAnnotation(Annotation annotation, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (annotationType.isInstance(annotation)) {\n\t\t\treturn synthesizeAnnotation((A) annotation, annotationType);\n\t\t}\n\t\t// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {\n\t\t\treturn null;\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotation, new Annotation[] {annotation}, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(attributeName,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the annotation of type {@code annotationType} stored under the\n\t * specified {@code attributeName}.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "A",
    "signature": "public A getAnnotation(String attributeName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {\n\t\treturn getRequiredAttribute(attributeName, annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "MergedAnnotation<T>",
    "signature": "public MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)\n\t\t\tthrows NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.isAssignable(type, attribute.getReturnType(),\n\t\t\t\t() -> \"Attribute \" + attributeName + \" type mismatch:\");\n\t\treturn (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotation(method,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the\n\t * supplied {@link Method}, where the annotation is either <em>present</em>\n\t * or <em>meta-present</em> on the method.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(Method, Class)} instead.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see #getAnnotation(AnnotatedElement, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "A",
    "signature": "public A getAnnotation(Method method, Class<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {\n\t\tMethod resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\treturn getAnnotation((AnnotatedElement) resolvedMethod, annotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationArray(attributeName,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the array of type {@code annotationType} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an {@code Annotation}, it will be wrapped in a single-element array\n\t * before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation array\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "A[]",
    "signature": "public A[] getAnnotationArray(String attributeName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {\n\t\treturn (A[]) getRequiredAttribute(attributeName, annotationType.arrayType());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationArray(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "MergedAnnotation<T>[]",
    "signature": "public MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(\n\t\t\tString attributeName, Class<T> type) throws NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tClass<?> componentType = attribute.getReturnType().componentType();\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.notNull(componentType, () -> \"Attribute \" + attributeName + \" is not an array\");\n\t\tAssert.isAssignable(type, componentType, () -> \"Attribute \" + attributeName + \" component type mismatch:\");\n\t\treturn (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\n\n\t\treturn getAnnotationAttributes(annotatedElement, annotation, false, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotatedElement,annotation,classValuesAsString,nestedAnnotationsAsMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotation",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn MergedAnnotation.from(annotatedElement, annotation)\n\t\t\t\t.withNonMergedAttributes()\n\t\t\t\t.asMap(mergedAnnotation ->\n\t\t\t\t\t\tnew AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotation,classValuesAsString)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as a {@link Map}.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(Annotation annotation, boolean classValuesAsString)",
    "source_code": "\tpublic static Map<String, Object> getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString) {\n\n\t\treturn getAnnotationAttributes(annotation, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAnnotationAttributes(annotation,classValuesAsString,nestedAnnotationsAsMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 3.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "classValuesAsString",
      "nestedAnnotationsAsMap"
    ],
    "position": {
      "column": 1,
      "line": 825
    },
    "return": "AnnotationAttributes",
    "signature": "public AnnotationAttributes getAnnotationAttributes(Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap)",
    "source_code": "\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\treturn getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getAttributeValue(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "T",
    "signature": "protected T getAttributeValue(String attributeName, Class<T> type)",
    "source_code": "\tprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\treturn (attributeIndex != -1 ? getValue(attributeIndex, type) : null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDeclaredRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType",
      "containerAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "Set<A>",
    "signature": "public Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables();\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotation,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1172
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\treturn (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(annotationType,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given the\n\t * {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @param attributeName the name of the attribute value to retrieve.\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1197
    },
    "return": "Object",
    "signature": "public Object getDefaultValue(@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getDefaultValue(\n\t\t\t@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\n\n\t\tif (annotationType == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getDefaultValue(attributeName,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Optional<T>",
    "signature": "public Optional<T> getDefaultValue(String attributeName, Class<T> type)",
    "source_code": "\tpublic <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\tif (attributeIndex == -1) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\treturn Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getOrder(type,defaultOrder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the order on the specified {@code type}, or the specified\n\t * default value if none can be found.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param type the type to handle\n\t * @return the priority value, or the specified default order if none can be found\n\t * @see #getPriority(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "defaultOrder"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Integer",
    "signature": "public Integer getOrder(Class<?> type, @Nullable Integer defaultOrder)",
    "source_code": "\tpublic static Integer getOrder(Class<?> type, @Nullable Integer defaultOrder) {\n\t\tInteger order = getOrder(type);\n\t\treturn (order != null ? order : defaultOrder);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getRepeatableAnnotations(annotatedElement,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Set<A>",
    "signature": "public Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "annotationType",
      "containerAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Set<A>",
    "signature": "public Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType)",
    "source_code": "\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = (containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables());\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#getValue(annotation,attributeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "attributeName"
    ],
    "position": {
      "column": 1,
      "line": 1050
    },
    "return": "Object",
    "signature": "public Object getValue(@Nullable Annotation annotation, @Nullable String attributeName)",
    "source_code": "\tpublic static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\tif (annotation == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tfor (Method method : annotation.annotationType().getDeclaredMethods()) {\n\t\t\t\tif (method.getName().equals(attributeName) && method.getParameterCount() == 0) {\n\t\t\t\t\treturn invokeAnnotationMethod(method, annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleValueRetrievalFailure(annotation, ex);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\tpublic Object invoke(Object proxy, Method method, Object[] args) {\n\t\tif (this.attributes.indexOf(method.getName()) != -1) {\n\t\t\treturn getAttributeValue(method);\n\t\t}\n\t\tif (method.getParameterCount() == 0) {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"annotationType\": return this.type;\n\t\t\t\tcase \"hashCode\": return annotationHashCode();\n\t\t\t\tcase \"toString\": return annotationToString();\n\t\t\t}\n\t\t}\n\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\treturn annotationEquals(args[0]);\n\t\t}\n\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\"Method [%s] is unsupported for synthesized annotation type [%s]\", method, this.type));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationDeclaredLocally(annotationType,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is declared locally (i.e. <em>directly present</em>) on the supplied\n\t * {@code clazz}.\n\t * <p>The supplied {@link Class} may represent any type.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>Note: This method does <strong>not</strong> determine if the annotation\n\t * is {@linkplain java.lang.annotation.Inherited inherited}.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>directly present</em>\n\t * @see java.lang.Class#getDeclaredAnnotations()\n\t * @see java.lang.Class#getDeclaredAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationInherited(annotationType,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@code clazz} and is\n\t * {@linkplain java.lang.annotation.Inherited inherited}\n\t * (i.e. not <em>directly present</em>).\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked. In accordance with standard meta-annotation\n\t * semantics in Java, the inheritance hierarchy for interfaces will not\n\t * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\n\t * for the {@code @Inherited} meta-annotation for further details regarding\n\t * annotation inheritance.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> and <em>inherited</em>\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see #isAnnotationDeclaredLocally(Class, Class)\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz)",
    "source_code": "\tpublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotation::isDirectlyPresent)\n\t\t\t\t.findFirst().orElseGet(MergedAnnotation::missing)\n\t\t\t\t.getAggregateIndex() > 0;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isAnnotationMetaPresent(annotationType,metaAnnotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if an annotation of type {@code metaAnnotationType} is\n\t * <em>meta-present</em> on the supplied {@code annotationType}.\n\t * @param annotationType the annotation type to search on\n\t * @param metaAnnotationType the type of meta-annotation to search for\n\t * @return {@code true} if such an annotation is meta-present\n\t * @since 4.2.1\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationType",
      "metaAnnotationType"
    ],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "boolean",
    "signature": "public boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType)",
    "source_code": "\tpublic static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType) {\n\n\t\tif (metaAnnotationType == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(metaAnnotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {\n\t\t\treturn annotationType.isAnnotationPresent(metaAnnotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS,\n\t\t\t\tRepeatableContainers.none()).isPresent(metaAnnotationType);\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationName the fully-qualified name of the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationName"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, String annotationName)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\n\t\tif (annotationName.startsWith(\"java.\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationType the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, @Nullable Class<? extends Annotation> annotationType)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, @Nullable Class<? extends Annotation> annotationType) {\n\t\treturn (annotationType != null && isCandidateClass(clazz, annotationType.getName()));\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#isCandidateClass(clazz,annotationTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given class is a candidate for carrying one of the specified\n\t * annotations (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationTypes the searchable annotation types\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t * @see #isCandidateClass(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "annotationTypes"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "boolean",
    "signature": "public boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes)",
    "source_code": "\tpublic static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tif (isCandidateClass(clazz, annotationType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#postProcessAnnotationAttributes(annotatedElement,attributes,classValuesAsString)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the supplied {@link AnnotationAttributes}, preserving nested\n\t * annotations as {@code Annotation} instances.\n\t * <p>Specifically, this method enforces <em>attribute alias</em> semantics\n\t * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\n\t * and replaces default value placeholders with their original default values.\n\t * @param annotatedElement the element that is annotated with an annotation or\n\t * annotation hierarchy from which the supplied attributes were created;\n\t * may be {@code null} if unknown\n\t * @param attributes the annotation attributes to post-process\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @since 4.3.2\n\t * @see #getDefaultValue(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotatedElement",
      "attributes",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 947
    },
    "return": "void",
    "signature": "public void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString)",
    "source_code": "\tpublic static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {\n\n\t\tif (attributes == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!attributes.validated) {\n\t\t\tClass<? extends Annotation> annotationType = attributes.annotationType();\n\t\t\tif (annotationType == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n\t\t\tfor (int i = 0; i < mapping.getMirrorSets().size(); i++) {\n\t\t\t\tMirrorSet mirrorSet = mapping.getMirrorSets().get(i);\n\t\t\t\tint resolved = mirrorSet.resolve(attributes.displayName, attributes,\n\t\t\t\t\t\tAnnotationUtils::getAttributeValueForMirrorResolution);\n\t\t\t\tif (resolved != -1) {\n\t\t\t\t\tMethod attribute = mapping.getAttributes().get(resolved);\n\t\t\t\t\tObject value = attributes.get(attribute.getName());\n\t\t\t\t\tfor (int j = 0; j < mirrorSet.size(); j++) {\n\t\t\t\t\t\tMethod mirror = mirrorSet.get(j);\n\t\t\t\t\t\tif (mirror != attribute) {\n\t\t\t\t\t\t\tattributes.put(mirror.getName(),\n\t\t\t\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {\n\t\t\tString attributeName = attributeEntry.getKey();\n\t\t\tObject value = attributeEntry.getValue();\n\t\t\tif (value instanceof DefaultValueHolder defaultValueHolder) {\n\t\t\t\tvalue = defaultValueHolder.defaultValue;\n\t\t\t\tattributes.put(attributeName,\n\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesizeAnnotation(Map<String,attributes,annotationType,annotatedElement)": {
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Synthesize</em> an annotation from the supplied map of annotation\n\t * attributes by wrapping the map in a dynamic proxy that implements an\n\t * annotation of the specified {@code annotationType} and transparently\n\t * enforces <em>attribute alias</em> semantics for annotation attributes\n\t * that are annotated with {@link AliasFor @AliasFor}.\n\t * <p>The supplied map must contain a key-value pair for every attribute\n\t * defined in the supplied {@code annotationType} that is not aliased or\n\t * does not have a default value. Nested maps and nested arrays of maps\n\t * will be recursively synthesized into nested annotations or nested\n\t * arrays of annotations, respectively.\n\t * <p>Note that {@link AnnotationAttributes} is a specialized type of\n\t * {@link Map} that is an ideal candidate for this method's\n\t * {@code attributes} argument.\n\t * @param attributes the map of annotation attributes to synthesize\n\t * @param annotationType the type of annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the annotation\n\t * corresponding to the supplied attributes; may be {@code null} if unknown\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing or if an\n\t * attribute is not of the correct type\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes",
      "annotationType",
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 1280
    },
    "return": "A",
    "signature": "public A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement) {\n\n\t\ttry {\n\t\t\treturn MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();\n\t\t}\n\t\tcatch (NoSuchElementException | IllegalStateException ex) {\n\t\t\tthrow new IllegalArgumentException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#synthesizeAnnotation(annotation,annotatedElement)": {
    "deprecated": false,
    "doc": "\t/**\n\t * <em>Synthesize</em> an annotation from the supplied {@code annotation}\n\t * by wrapping it in a dynamic proxy that transparently enforces\n\t * <em>attribute alias</em> semantics for annotation attributes that are\n\t * annotated with {@link AliasFor @AliasFor}.\n\t * @param annotation the annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * annotation; may be {@code null} if unknown\n\t * @return the synthesized annotation if the supplied annotation is\n\t * <em>synthesizable</em>; {@code null} if the supplied annotation is\n\t * {@code null}; otherwise the supplied annotation unmodified\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotation",
      "annotatedElement"
    ],
    "position": {
      "column": 1,
      "line": 1223
    },
    "return": "A",
    "signature": "public A synthesizeAnnotation(A annotation, @Nullable AnnotatedElement annotatedElement)",
    "source_code": "\tpublic static <A extends Annotation> A synthesizeAnnotation(\n\t\t\tA annotation, @Nullable AnnotatedElement annotatedElement) {\n\n\t\tif (isSynthesizedAnnotation(annotation) || AnnotationFilter.PLAIN.matches(annotation)) {\n\t\t\treturn annotation;\n\t\t}\n\t\treturn MergedAnnotation.from(annotatedElement, annotation).synthesize();\n\t}"
  },
  "org.springframework.core.annotation.<unknown>#unique(MergedAnnotation<A>,keyExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches\n\t * annotations that are unique based on the extracted key. For example\n\t * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\n\t * match the first time a unique type is encountered.\n\t * @param keyExtractor function used to extract the key used to test for\n\t * uniqueness\n\t * @return a {@link Predicate} that matches a unique annotation based on the\n\t * extracted key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MergedAnnotation<A>",
      "keyExtractor"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "Predicate<MergedAnnotation<A>>",
    "signature": "public Predicate<MergedAnnotation<A>> unique(Function<? super MergedAnnotation<A>, K> keyExtractor)",
    "source_code": "\tpublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(\n\t\t\tFunction<? super MergedAnnotation<A>, K> keyExtractor) {\n\n\t\treturn new UniquePredicate<>(keyExtractor);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#canDecode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\treturn (ByteBuf.class.isAssignableFrom(elementType.toClass()) &&\n\t\t\t\tsuper.canDecode(elementType, mimeType));\n\t}"
  },
  "org.springframework.core.codec.<unknown>#canEncode(type,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType type, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tClass<?> clazz = type.toClass();\n\t\treturn super.canEncode(type, mimeType) && ByteBuf.class.isAssignableFrom(clazz);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#decode(dataBuffer,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "ByteBuf",
    "signature": "public ByteBuf decode(DataBuffer dataBuffer, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic ByteBuf decode(DataBuffer dataBuffer, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Read \" + dataBuffer.readableByteCount() + \" bytes\");\n\t\t}\n\t\tif (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\n\t\t\treturn nettyDataBuffer.getNativeBuffer();\n\t\t}\n\t\tByteBuf byteBuf;\n\t\tbyte[] bytes = new byte[dataBuffer.readableByteCount()];\n\t\tdataBuffer.read(bytes);\n\t\tbyteBuf = Unpooled.wrappedBuffer(bytes);\n\t\tDataBufferUtils.release(dataBuffer);\n\t\treturn byteBuf;\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream,\n\t\t\tDataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(inputStream).map(byteBuffer ->\n\t\t\t\tencodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encodeValue(buffer,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffer",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Buffer buffer, DataBufferFactory bufferFactory, ResolvableType valueType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Buffer buffer, DataBufferFactory bufferFactory, ResolvableType valueType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + buffer.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof Netty5DataBufferFactory netty5DataBufferFactory) {\n\t\t\treturn netty5DataBufferFactory.wrap(buffer);\n\t\t}\n\t\tbyte[] bytes = new byte[buffer.readableBytes()];\n\t\tbuffer.readBytes(bytes, 0, bytes.length);\n\t\tbuffer.close();\n\t\treturn bufferFactory.wrap(bytes);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#encodeValue(byteBuf,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuf",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\n\t\t\tString logPrefix = Hints.getLogPrefix(hints);\n\t\t\tlogger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\n\t\t}\n\t\tif (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\n\t\t\treturn nettyDataBufferFactory.wrap(byteBuf);\n\t\t}\n\t\tbyte[] bytes = new byte[byteBuf.readableBytes()];\n\t\tbyteBuf.readBytes(bytes);\n\t\tbyteBuf.release();\n\t\treturn bufferFactory.wrap(bytes);\n\t}"
  },
  "org.springframework.core.codec.<unknown>#parseSseLines(state,blackhole)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "public void parseSseLines(SseLinesState state, Blackhole blackhole)",
    "source_code": "\tpublic void parseSseLines(SseLinesState state, Blackhole blackhole) {\n\t\tblackhole.consume(state.parseLines().blockLast());\n\t}"
  },
  "org.springframework.core.convert.<unknown>#collection(collectionType,elementTypeDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new type descriptor from a {@link java.util.Collection} type.\n\t * <p>Useful for converting to typed Collections.\n\t * <p>For example, a {@code List<String>} could be converted to a\n\t * {@code List<EmailAddress>} by converting to a targetType built with this method.\n\t * The method call to construct such a {@code TypeDescriptor} would look something\n\t * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}\n\t * @param collectionType the collection type, which must implement {@link Collection}.\n\t * @param elementTypeDescriptor a descriptor for the collection's element type,\n\t * used to convert collection elements\n\t * @return the collection type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collectionType",
      "elementTypeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor)",
    "source_code": "\tpublic static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (!Collection.class.isAssignableFrom(collectionType)) {\n\t\t\tthrow new IllegalArgumentException(\"Collection type must be a [java.util.Collection]\");\n\t\t}\n\t\tResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#map(mapType,keyTypeDescriptor,valueTypeDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new type descriptor from a {@link java.util.Map} type.\n\t * <p>Useful for converting to typed Maps.\n\t * <p>For example, a {@code Map<String, String>} could be converted to a {@code Map<Id, EmailAddress>}\n\t * by converting to a targetType built with this method:\n\t * The method call to construct such a TypeDescriptor would look something like:\n\t * <pre class=\"code\">\n\t * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));\n\t * </pre>\n\t * @param mapType the map type, which must implement {@link Map}\n\t * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys\n\t * @param valueTypeDescriptor the map's value type, used to convert map values\n\t * @return the map type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapType",
      "keyTypeDescriptor",
      "valueTypeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor)",
    "source_code": "\tpublic static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor) {\n\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\tthrow new IllegalArgumentException(\"Map type must be a [java.util.Map]\");\n\t\t}\n\t\tResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);\n\t\tResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(field,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the field.\n\t * <p>For example, if the field is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the field is a {@code List<List<String>>} and the nesting level is\n\t * 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the field is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the field is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param field the field\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the field\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 709
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Field field, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Field field, int nestingLevel) {\n\t\treturn new TypeDescriptor(field).nested(nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(methodParameter,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the method parameter.\n\t * <p>For example, if the methodParameter is a {@code List<String>} and the\n\t * nesting level is 1, the nested type descriptor will be String.class.\n\t * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\n\t * level is 2, the nested type descriptor will also be a String.class.\n\t * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\n\t * level is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\n\t * nesting level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\n\t * For example, if the method parameter is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param methodParameter the method parameter with a nestingLevel of 1\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the method parameter\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the nesting level of the input\n\t * {@link MethodParameter} argument is not 1, or if the types up to the\n\t * specified nesting level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 679
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {\n\t\tif (methodParameter.getNestingLevel() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"MethodParameter nesting level must be 1: \" +\n\t\t\t\t\t\"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal\");\n\t\t}\n\t\treturn new TypeDescriptor(methodParameter).nested(nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.<unknown>#nested(property,nestingLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a type descriptor for a nested type declared within the property.\n\t * <p>For example, if the property is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the property is a {@code List<List<String>>} and the nesting level\n\t * is 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the property is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the property is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param property the property\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "property",
      "nestingLevel"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "TypeDescriptor",
    "signature": "public TypeDescriptor nested(Property property, int nestingLevel)",
    "source_code": "\tpublic static TypeDescriptor nested(Property property, int nestingLevel) {\n\t\treturn new TypeDescriptor(property).nested(nestingLevel);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(Converter<?,converter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Converter<?",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void addConverter(Converter<?, ?> converter)",
    "source_code": "\tpublic void addConverter(Converter<?, ?> converter) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);\n\t\tif (typeInfo == null && converter instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), Converter.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"Converter [\" + converter.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverter(sourceType,targetType,S,converter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType",
      "S",
      "converter"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter)",
    "source_code": "\tpublic <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter) {\n\t\taddConverter(new ConverterAdapter(\n\t\t\t\tconverter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#addConverterFactory(ConverterFactory<?,factory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ConverterFactory<?",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void addConverterFactory(ConverterFactory<?, ?> factory)",
    "source_code": "\tpublic void addConverterFactory(ConverterFactory<?, ?> factory) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);\n\t\tif (typeInfo == null && factory instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), ConverterFactory.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"ConverterFactory [\" + factory.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterFactoryAdapter(factory,\n\t\t\t\tnew ConvertiblePair(typeInfo[0].toClass(), typeInfo[1].toClass())));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#canBypassConvert(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether conversion between the source type and the target type can be bypassed.\n\t * <p>More precisely, this method will return true if objects of sourceType can be\n\t * converted to the target type by returning the source object unchanged.\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return {@code true} if conversion can be bypassed; {@code false} otherwise\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t * @since 3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "boolean",
    "signature": "public boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (sourceType == null || getConverter(sourceType, targetType) == NO_OP_CONVERTER);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#canConvert(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "boolean",
    "signature": "public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (sourceType == null || getConverter(sourceType, targetType) != null);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (this.conversionService instanceof GenericConversionService genericConversionService) {\n\t\t\tTypeDescriptor targetElement = targetType.getElementTypeDescriptor();\n\t\t\tif (targetElement != null && targetType.getType().isInstance(source) &&\n\t\t\t\t\tgenericConversionService.canBypassConvert(sourceType.getElementTypeDescriptor(), targetElement)) {\n\t\t\t\treturn source;\n\t\t\t}\n\t\t}\n\t\tList<Object> sourceList = Arrays.asList(ObjectUtils.toObjectArray(source));\n\t\treturn this.helperConverter.convert(sourceList, sourceType, targetType);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convert(source,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "T",
    "signature": "public T convert(@Nullable Object source, Class<T> targetType)",
    "source_code": "\tpublic <T> T convert(@Nullable Object source, Class<T> targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#convertNullSource(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method to convert a {@code null} source.\n\t * <p>The default implementation returns {@code null} or the Java 8\n\t * {@link java.util.Optional#empty()} instance if the target type is\n\t * {@code java.util.Optional}. Subclasses may override this to return\n\t * custom {@code null} objects for specific target types.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the converted null object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "Object",
    "signature": "protected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tprotected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType.getObjectType() == Optional.class) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#find(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Find a {@link GenericConverter} given a source and target type.\n\t\t * <p>This method will attempt to match all possible converters by working\n\t\t * through the class and interface hierarchy of the types.\n\t\t * @param sourceType the source type\n\t\t * @param targetType the target type\n\t\t * @return a matching {@link GenericConverter}, or {@code null} if none found\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Search the full type hierarchy\n\t\t\tList<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());\n\t\t\tList<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());\n\t\t\tfor (Class<?> sourceCandidate : sourceCandidates) {\n\t\t\t\tfor (Class<?> targetCandidate : targetCandidates) {\n\t\t\t\t\tConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);\n\t\t\t\t\tGenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);\n\t\t\t\t\tif (converter != null) {\n\t\t\t\t\t\treturn converter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#getConverter(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 625
    },
    "return": "GenericConverter",
    "signature": "public GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tfor (GenericConverter converter : this.converters) {\n\t\t\t\tif (!(converter instanceof ConditionalGenericConverter genericConverter) ||\n\t\t\t\t\t\tgenericConverter.matches(sourceType, targetType)) {\n\t\t\t\t\treturn converter;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#getDefaultConverter(sourceType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default converter if no converter is found for the given sourceType/targetType pair.\n\t * <p>Returns a NO_OP Converter if the source type is assignable to the target type.\n\t * Returns {@code null} otherwise, indicating no suitable converter could be found.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the default generic converter that will perform the conversion\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "GenericConverter",
    "signature": "protected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tprotected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#matches(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn this.helperConverter.matches(sourceType, targetType);\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#registerConverters(converters,registry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given Converter objects with the given target ConverterRegistry.\n\t * @param converters the converter objects: implementing {@link Converter},\n\t * {@link ConverterFactory}, or {@link GenericConverter}\n\t * @param registry the target registry\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "converters",
      "registry"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "void",
    "signature": "public void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry)",
    "source_code": "\tpublic static void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry) {\n\t\tif (converters != null) {\n\t\t\tfor (Object candidate : converters) {\n\t\t\t\tif (candidate instanceof GenericConverter genericConverter) {\n\t\t\t\t\tregistry.addConverter(genericConverter);\n\t\t\t\t}\n\t\t\t\telse if (candidate instanceof Converter<?, ?> converter) {\n\t\t\t\t\tregistry.addConverter(converter);\n\t\t\t\t}\n\t\t\t\telse if (candidate instanceof ConverterFactory<?, ?> converterFactory) {\n\t\t\t\t\tregistry.addConverterFactory(converterFactory);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Each converter object must implement one of the \" +\n\t\t\t\t\t\t\t\"Converter, ConverterFactory, or GenericConverter interfaces\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.convert.support.<unknown>#remove(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "void",
    "signature": "public void remove(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\t\tpublic void remove(Class<?> sourceType, Class<?> targetType) {\n\t\t\tthis.converters.remove(new ConvertiblePair(sourceType, targetType));\n\t\t}"
  },
  "org.springframework.core.convert.support.<unknown>#removeConvertible(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void removeConvertible(Class<?> sourceType, Class<?> targetType)",
    "source_code": "\tpublic void removeConvertible(Class<?> sourceType, Class<?> targetType) {\n\t\tthis.converters.remove(sourceType, targetType);\n\t\tinvalidateCache();\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetValueType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "targetValueType"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "T",
    "signature": "public T getProperty(String key, Class<T> targetValueType)",
    "source_code": "\tpublic <T> T getProperty(String key, Class<T> targetValueType) {\n\t\treturn getProperty(key, targetValueType, true);\n\t}"
  },
  "org.springframework.core.env.<unknown>#getProperty(key,targetValueType,resolveNestedPlaceholders)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "targetValueType",
      "resolveNestedPlaceholders"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "T",
    "signature": "protected T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders)",
    "source_code": "\tprotected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {\n\t\tif (this.propertySources != null) {\n\t\t\tfor (PropertySource<?> propertySource : this.propertySources) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Searching for key '\" + key + \"' in PropertySource '\" +\n\t\t\t\t\t\t\tpropertySource.getName() + \"'\");\n\t\t\t\t}\n\t\t\t\tObject value = propertySource.getProperty(key);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tif (resolveNestedPlaceholders) {\n\t\t\t\t\t\tif (value instanceof String string) {\n\t\t\t\t\t\t\tvalue = resolveNestedPlaceholders(string);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((value instanceof CharSequence cs) && (String.class.equals(targetValueType) ||\n\t\t\t\t\t\t\t\tCharSequence.class.equals(targetValueType))) {\n\t\t\t\t\t\t\tvalue = resolveNestedPlaceholders(cs.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogKeyFound(key, propertySource, value);\n\t\t\t\t\treturn convertValueIfNecessary(value, targetValueType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Could not find key '\" + key + \"' in any property source\");\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.core.env.<unknown>#logKeyFound(key,propertySource,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Log the given key as found in the given {@link PropertySource}, resulting in\n\t * the given value.\n\t * <p>The default implementation writes a debug log message with key and source.\n\t * As of 4.3.3, this does not log the value anymore in order to avoid accidental\n\t * logging of sensitive settings. Subclasses may override this method to change\n\t * the log level and/or log message, including the property's value if desired.\n\t * @param key the key found\n\t * @param propertySource the {@code PropertySource} that the key has been found in\n\t * @param value the corresponding value\n\t * @since 4.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "propertySource",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "protected void logKeyFound(String key, PropertySource<?> propertySource, Object value)",
    "source_code": "\tprotected void logKeyFound(String key, PropertySource<?> propertySource, Object value) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Found key '\" + key + \"' in PropertySource '\" + propertySource.getName() +\n\t\t\t\t\t\"' with value of type \" + value.getClass().getSimpleName());\n\t\t}\n\t}"
  },
  "org.springframework.core.io.<unknown>#invokeVfsMethod(method,target,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "Object",
    "signature": "protected Object invokeVfsMethod(Method method, @Nullable Object target, Object... args)",
    "source_code": "\tprotected static Object invokeVfsMethod(Method method, @Nullable Object target, Object... args) throws IOException {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof IOException ioException) {\n\t\t\t\tthrow ioException;\n\t\t\t}\n\t\t\tReflectionUtils.handleInvocationTargetException(ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tReflectionUtils.handleReflectionException(ex);\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Invalid code path reached\");\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#asByteBuffer(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\tcheckIndex(index, length);\n\n\t\tByteBuffer duplicate = this.byteBuffer.duplicate();\n\t\tduplicate.position(index);\n\t\tduplicate.limit(index + length);\n\t\treturn duplicate.slice();\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(read,attachment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "read",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1050
    },
    "return": "void",
    "signature": "public void completed(Integer read, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer read, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\t\t\tDataBuffer dataBuffer = attachment.dataBuffer();\n\n\t\t\tif (this.state.get() == State.DISPOSED) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (read == -1) {\n\t\t\t\trelease(dataBuffer);\n\t\t\t\tcloseChannel(this.channel);\n\t\t\t\tthis.state.set(State.DISPOSED);\n\t\t\t\tthis.sink.complete();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.position.addAndGet(read);\n\t\t\tdataBuffer.writePosition(read);\n\t\t\tthis.sink.next(dataBuffer);\n\n\t\t\t// Stay in READING mode if there is demand\n\t\t\tif (this.sink.requestedFromDownstream() > 0) {\n\t\t\t\tread();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Release READING mode and then try again in case of concurrent \"request\"\n\t\t\tif (this.state.compareAndSet(State.READING, State.IDLE)) {\n\t\t\t\ttryRead();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#completed(written,attachment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "written",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1212
    },
    "return": "void",
    "signature": "public void completed(Integer written, Attachment attachment)",
    "source_code": "\t\tpublic void completed(Integer written, Attachment attachment) {\n\t\t\tDataBuffer.ByteBufferIterator iterator = attachment.iterator();\n\t\t\titerator.close();\n\n\t\t\tlong pos = this.position.addAndGet(written);\n\t\t\tByteBuffer byteBuffer = attachment.byteBuffer();\n\n\t\t\tif (byteBuffer.hasRemaining()) {\n\t\t\t\tthis.channel.write(byteBuffer, pos, attachment, this);\n\t\t\t}\n\t\t\telse if (iterator.hasNext()) {\n\t\t\t\tByteBuffer next = iterator.next();\n\t\t\t\tthis.channel.write(next, pos, attachment, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\t\tthis.writing.set(false);\n\n\t\t\t\tThrowable throwable = this.error.get();\n\t\t\t\tif (throwable != null) {\n\t\t\t\t\tthis.sink.error(throwable);\n\t\t\t\t}\n\t\t\t\telse if (this.completed.get()) {\n\t\t\t\t\tthis.sink.complete();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trequest(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#failed(ex,attachment)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "attachment"
    ],
    "position": {
      "column": 1,
      "line": 1244
    },
    "return": "void",
    "signature": "public void failed(Throwable ex, Attachment attachment)",
    "source_code": "\t\tpublic void failed(Throwable ex, Attachment attachment) {\n\t\t\tattachment.iterator().close();\n\n\t\t\tthis.sink.next(attachment.dataBuffer());\n\t\t\tthis.writing.set(false);\n\n\t\t\tthis.sink.error(ex);\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#indexOf(predicate,fromIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tif (fromIndex < 0) {\n\t\t\tfromIndex = 0;\n\t\t}\n\t\telse if (fromIndex >= this.writePosition) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int i = fromIndex; i < this.writePosition; i++) {\n\t\t\tbyte b = this.byteBuffer.get(i);\n\t\t\tif (predicate.test(b)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#join(buffers,maxByteCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #join(Publisher)} that behaves the same way up until\n\t * the specified max number of bytes to buffer. Once the limit is exceeded,\n\t * {@link DataBufferLimitException} is raised.\n\t * @param buffers the data buffers that are to be composed\n\t * @param maxByteCount the max number of bytes to buffer, or -1 for unlimited\n\t * @return a buffer with the aggregated content, possibly an empty Mono if\n\t * the max number of bytes to buffer is exceeded.\n\t * @throws DataBufferLimitException if maxByteCount is exceeded\n\t * @since 5.1.11\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buffers",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "Mono<DataBuffer>",
    "signature": "public Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount)",
    "source_code": "\tpublic static Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount) {\n\t\tAssert.notNull(buffers, \"'buffers' must not be null\");\n\n\t\tif (buffers instanceof Mono mono) {\n\t\t\treturn mono;\n\t\t}\n\n\t\treturn Flux.from(buffers)\n\t\t\t\t.collect(() -> new LimitedDataBufferList(maxByteCount), LimitedDataBufferList::add)\n\t\t\t\t.filter(list -> !list.isEmpty())\n\t\t\t\t.map(list -> list.get(0).factory().join(list))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#lastIndexOf(predicate,fromIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\tAssert.notNull(predicate, \"IntPredicate must not be null\");\n\t\tint i = Math.min(fromIndex, this.writePosition - 1);\n\t\tfor (; i >= 0; i--) {\n\t\t\tbyte b = this.byteBuffer.get(i);\n\t\t\tif (predicate.test(b)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#map(b,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 1278
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic DataBuffer map(byte[] b, int off, int len) {\n\t\t\tDataBuffer buffer = this.bufferFactory.allocateBuffer(len);\n\t\t\tbuffer.write(b, off, len);\n\t\t\treturn buffer;\n\t\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#outputStreamPublisher(consumer,bufferFactory,executor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@code Publisher<DataBuffer>} based on bytes written to a\n\t * {@code OutputStream}.\n\t * <ul>\n\t * <li>The parameter {@code outputStreamConsumer} is invoked once per\n\t * subscription of the returned {@code Publisher}, when the first\n\t * item is\n\t * {@linkplain Subscription#request(long) requested}.</li>\n\t * <li>{@link OutputStream#write(byte[], int, int) OutputStream.write()}\n\t * invocations made by {@code outputStreamConsumer} are buffered until they\n\t * exceed the default chunk size of 1024, or when the stream is\n\t * {@linkplain OutputStream#flush() flushed} and then result in a\n\t * {@linkplain Subscriber#onNext(Object) published} item\n\t * if there is {@linkplain Subscription#request(long) demand}.</li>\n\t * <li>If there is <em>no demand</em>, {@code OutputStream.write()} will block\n\t * until there is.</li>\n\t * <li>If the subscription is {@linkplain Subscription#cancel() cancelled},\n\t * {@code OutputStream.write()} will throw a {@code IOException}.</li>\n\t * <li>The subscription is\n\t * {@linkplain Subscriber#onComplete() completed} when\n\t * {@code outputStreamHandler} completes.</li>\n\t * <li>Any exceptions thrown from {@code outputStreamHandler} will\n\t * be dispatched to the {@linkplain Subscriber#onError(Throwable) Subscriber}.\n\t * </ul>\n\t * @param consumer invoked when the first buffer is requested\n\t * @param executor used to invoke the {@code outputStreamHandler}\n\t * @return a {@code Publisher<DataBuffer>} based on bytes written by\n\t * {@code outputStreamHandler}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer",
      "bufferFactory",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(\n\t\t\tConsumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor) {\n\n\t\treturn new OutputStreamPublisher<>(\n\t\t\t\tconsumer::accept, new DataBufferMapper(bufferFactory), executor, null);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#outputStreamPublisher(consumer,bufferFactory,executor,chunkSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #outputStreamPublisher(Consumer, DataBufferFactory, Executor)}\n\t * providing control over the chunk sizes to be produced by the publisher.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "consumer",
      "bufferFactory",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "Publisher<DataBuffer>",
    "signature": "public Publisher<DataBuffer> outputStreamPublisher(Consumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor, int chunkSize)",
    "source_code": "\tpublic static Publisher<DataBuffer> outputStreamPublisher(\n\t\t\tConsumer<OutputStream> consumer, DataBufferFactory bufferFactory, Executor executor, int chunkSize) {\n\n\t\treturn new OutputStreamPublisher<>(\n\t\t\t\tconsumer::accept, new DataBufferMapper(bufferFactory), executor, chunkSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(destination,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer read(byte[] destination, int offset, int length) {\n\t\tAssert.notNull(destination, \"Byte array must not be null\");\n\t\tassertIndex(this.readPosition <= this.writePosition - length,\n\t\t\t\t\"readPosition %d and length %d should be smaller than writePosition %d\",\n\t\t\t\tthis.readPosition, length, this.writePosition);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.readPosition + length;\n\t\ttmp.clear().position(this.readPosition).limit(limit);\n\t\ttmp.get(destination, offset, length);\n\n\t\tthis.readPosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(path,bufferFactory,bufferSize,options)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read bytes from the given file {@code Path} into a {@code Flux} of {@code DataBuffer}s.\n\t * The method ensures that the file is closed when the flux is terminated.\n\t * @param path the path to read bytes from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "bufferFactory",
      "bufferSize",
      "options"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Path path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options)",
    "source_code": "\tpublic static Flux<DataBuffer> read(\n\t\t\tPath path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options) {\n\n\t\tAssert.notNull(path, \"Path must not be null\");\n\t\tAssert.notNull(bufferFactory, \"DataBufferFactory must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\t\tif (options.length > 0) {\n\t\t\tfor (OpenOption option : options) {\n\t\t\t\tAssert.isTrue(!(option == StandardOpenOption.APPEND || option == StandardOpenOption.WRITE),\n\t\t\t\t\t\t() -> \"'\" + option + \"' not allowed\");\n\t\t\t}\n\t\t}\n\n\t\treturn readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(path, options),\n\t\t\t\tbufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(resource,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s.\n\t * <p>If the resource is a file, it is read into an\n\t * {@code AsynchronousFileChannel} and turned to {@code Flux} via\n\t * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else\n\t * fall back to {@link #readByteChannel(Callable, DataBufferFactory, int)}.\n\t * Closes the channel when the flux is terminated.\n\t * @param resource the resource to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize) {\n\t\treturn read(resource, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#read(resource,position,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s\n\t * starting at the given position.\n\t * <p>If the resource is a file, it is read into an\n\t * {@code AsynchronousFileChannel} and turned to {@code Flux} via\n\t * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else\n\t * fall back on {@link #readByteChannel(Callable, DataBufferFactory, int)}.\n\t * Closes the channel when the flux is terminated.\n\t * @param resource the resource to read from\n\t * @param position the position to start reading from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resource",
      "position",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> read(Resource resource, long position, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> read(\n\t\t\tResource resource, long position, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\ttry {\n\t\t\tif (resource.isFile()) {\n\t\t\t\tFile file = resource.getFile();\n\t\t\t\treturn readAsynchronousFileChannel(\n\t\t\t\t\t\t() -> AsynchronousFileChannel.open(file.toPath(), StandardOpenOption.READ),\n\t\t\t\t\t\tposition, bufferFactory, bufferSize);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ignore) {\n\t\t\t// fallback to resource.readableChannel(), below\n\t\t}\n\t\tFlux<DataBuffer> result = readByteChannel(resource::readableChannel, bufferFactory, bufferSize);\n\t\treturn position == 0 ? result : skipUntilByteCount(result, position);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@code AsynchronousFileChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\treturn readAsynchronousFileChannel(channelSupplier, 0, bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readAsynchronousFileChannel(channelSupplier,position,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@code AsynchronousFileChannel} from the given supplier, and\n\t * read it into a {@code Flux} of {@code DataBuffer}s, starting at the given\n\t * position. Closes the channel when the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param position the position to start reading from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "position",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readAsynchronousFileChannel(Callable<AsynchronousFileChannel> channelSupplier, long position,\n\t\t\tDataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readAsynchronousFileChannel(\n\t\t\tCallable<AsynchronousFileChannel> channelSupplier, long position,\n\t\t\tDataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(channelSupplier, \"'channelSupplier' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be >= 0\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\n\t\tFlux<DataBuffer> flux = Flux.using(channelSupplier,\n\t\t\t\tchannel -> Flux.create(sink -> {\n\t\t\t\t\tReadCompletionHandler handler =\n\t\t\t\t\t\t\tnew ReadCompletionHandler(channel, sink, position, bufferFactory, bufferSize);\n\t\t\t\t\tsink.onCancel(handler::cancel);\n\t\t\t\t\tsink.onRequest(handler::request);\n\t\t\t\t}),\n\t\t\t\tchannel -> {\n\t\t\t\t\t// Do not close channel from here, rather wait for the current read callback\n\t\t\t\t\t// and then complete after releasing the DataBuffer.\n\t\t\t\t});\n\n\t\treturn flux.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readByteChannel(channelSupplier,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a {@link ReadableByteChannel} from the given supplier, and read\n\t * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when\n\t * the Flux is terminated.\n\t * @param channelSupplier the supplier for the channel to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channelSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readByteChannel(Callable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readByteChannel(\n\t\t\tCallable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(channelSupplier, \"'channelSupplier' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be > 0\");\n\n\t\treturn Flux.using(channelSupplier,\n\t\t\t\tchannel -> Flux.generate(new ReadableByteChannelGenerator(channel, bufferFactory, bufferSize)),\n\t\t\t\tDataBufferUtils::closeChannel);\n\n\t\t// No doOnDiscard as operators used do not cache\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#readInputStream(inputStreamSupplier,bufferFactory,bufferSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an {@link InputStream} from the given supplier, and read it into a\n\t * {@code Flux} of {@code DataBuffer}s. Closes the input stream when the\n\t * Flux is terminated.\n\t * @param inputStreamSupplier the supplier for the input stream to read from\n\t * @param bufferFactory the factory to create data buffers with\n\t * @param bufferSize the maximum size of the data buffers\n\t * @return a Flux of data buffers read from the given channel\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStreamSupplier",
      "bufferFactory",
      "bufferSize"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> readInputStream(Callable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize)",
    "source_code": "\tpublic static Flux<DataBuffer> readInputStream(\n\t\t\tCallable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize) {\n\n\t\tAssert.notNull(inputStreamSupplier, \"'inputStreamSupplier' must not be null\");\n\t\treturn readByteChannel(() -> Channels.newChannel(inputStreamSupplier.call()), bufferFactory, bufferSize);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#retainedSlice(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "NettyDataBuffer",
    "signature": "public NettyDataBuffer retainedSlice(int index, int length)",
    "source_code": "\tpublic NettyDataBuffer retainedSlice(int index, int length) {\n\t\tByteBuf slice = this.byteBuf.retainedSlice(index, length);\n\t\treturn new NettyDataBuffer(slice, this.dataBufferFactory);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#skipUntilByteCount(publisher,maxByteCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Skip buffers from the given {@link Publisher} until the total\n\t * {@linkplain DataBuffer#readableByteCount() byte count} reaches\n\t * the given maximum byte count, or until the publisher is complete.\n\t * @param publisher the publisher to filter\n\t * @param maxByteCount the maximum byte count\n\t * @return a flux with the remaining part of the given publisher\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> skipUntilByteCount(Publisher<T> publisher, long maxByteCount)",
    "source_code": "\tpublic static <T extends DataBuffer> Flux<T> skipUntilByteCount(Publisher<T> publisher, long maxByteCount) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(maxByteCount >= 0, \"'maxByteCount' must be >= 0\");\n\n\t\treturn Flux.defer(() -> {\n\t\t\tAtomicLong countDown = new AtomicLong(maxByteCount);\n\t\t\treturn Flux.from(publisher)\n\t\t\t\t\t.skipUntil(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.addAndGet(-buffer.readableByteCount());\n\t\t\t\t\t\treturn remainder < 0;\n\t\t\t\t\t})\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.get();\n\t\t\t\t\t\tif (remainder < 0) {\n\t\t\t\t\t\t\tcountDown.set(0);\n\t\t\t\t\t\t\tint start = buffer.readableByteCount() + (int)remainder;\n\t\t\t\t\t\t\tDataBuffer split = buffer.split(start);\n\t\t\t\t\t\t\trelease(split);\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}).doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#slice(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer slice(int index, int length)",
    "source_code": "\tpublic DefaultDataBuffer slice(int index, int length) {\n\t\tcheckIndex(index, length);\n\t\tint oldPosition = this.byteBuffer.position();\n\t\ttry {\n\t\t\tthis.byteBuffer.position(index);\n\t\t\tByteBuffer slice = this.byteBuffer.slice();\n\t\t\tslice.limit(length);\n\t\t\treturn new SlicedDefaultDataBuffer(slice, this.dataBufferFactory, length);\n\t\t}\n\t\tfinally {\n\t\t\tthis.byteBuffer.position(oldPosition);\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#takeUntilByteCount(publisher,maxByteCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Relay buffers from the given {@link Publisher} until the total\n\t * {@linkplain DataBuffer#readableByteCount() byte count} reaches\n\t * the given maximum byte count, or until the publisher is complete.\n\t * @param publisher the publisher to filter\n\t * @param maxByteCount the maximum byte count\n\t * @return a flux whose maximum byte count is {@code maxByteCount}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "maxByteCount"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> takeUntilByteCount(Publisher<T> publisher, long maxByteCount)",
    "source_code": "\tpublic static <T extends DataBuffer> Flux<T> takeUntilByteCount(Publisher<T> publisher, long maxByteCount) {\n\t\tAssert.notNull(publisher, \"Publisher must not be null\");\n\t\tAssert.isTrue(maxByteCount >= 0, \"'maxByteCount' must be >= 0\");\n\n\t\treturn Flux.defer(() -> {\n\t\t\tAtomicLong countDown = new AtomicLong(maxByteCount);\n\t\t\treturn Flux.from(publisher)\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tlong remainder = countDown.addAndGet(-buffer.readableByteCount());\n\t\t\t\t\t\tif (remainder < 0) {\n\t\t\t\t\t\t\tint index = buffer.readableByteCount() + (int) remainder;\n\t\t\t\t\t\t\tDataBuffer split = buffer.split(index);\n\t\t\t\t\t\t\trelease(buffer);\n\t\t\t\t\t\t\treturn (T)split;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.takeUntil(buffer -> countDown.get() <= 0);\n\t\t});\n\n\t\t// No doOnDiscard as operators used do not cache (and drop) buffers\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toByteBuffer(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\tcheckIndex(index, length);\n\n\t\tByteBuffer copy = allocate(length, this.byteBuffer.isDirect());\n\t\tByteBuffer readOnly = this.byteBuffer.asReadOnlyBuffer();\n\t\treadOnly.clear().position(index).limit(index + length);\n\t\tcopy.put(readOnly);\n\t\treturn copy.flip();\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\tcheckIndex(srcPos, length);\n\t\tAssert.notNull(dest, \"Dest must not be null\");\n\n\t\tdest = dest.duplicate().clear();\n\t\tdest.put(destPos, this.byteBuffer, srcPos, length);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#toString(index,length,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 433
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\tpublic String toString(int index, int length, Charset charset) {\n\t\tcheckIndex(index, length);\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tbyte[] bytes;\n\t\tint offset;\n\n\t\tif (this.byteBuffer.hasArray()) {\n\t\t\tbytes = this.byteBuffer.array();\n\t\t\toffset = this.byteBuffer.arrayOffset() + index;\n\t\t}\n\t\telse {\n\t\t\tbytes = new byte[length];\n\t\t\toffset = 0;\n\t\t\tByteBuffer duplicate = this.byteBuffer.duplicate();\n\t\t\tduplicate.clear().position(index).limit(index + length);\n\t\t\tduplicate.get(bytes, 0, length);\n\t\t}\n\t\treturn new String(bytes, offset, length, charset);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#touch(dataBuffer,hint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Associate the given hint with the data buffer if it is a pooled buffer\n\t * and supports leak tracking.\n\t * @param dataBuffer the data buffer to attach the hint to\n\t * @param hint the hint to attach\n\t * @return the input buffer\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "hint"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "T",
    "signature": "public T touch(T dataBuffer, Object hint)",
    "source_code": "\tpublic static <T extends DataBuffer> T touch(T dataBuffer, Object hint) {\n\t\tif (dataBuffer instanceof TouchableDataBuffer touchableDataBuffer) {\n\t\t\treturn (T) touchableDataBuffer.touch(hint);\n\t\t}\n\t\telse {\n\t\t\treturn dataBuffer;\n\t\t}\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(charSequence,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charSequence",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(CharSequence charSequence, Charset charset)",
    "source_code": "\tpublic DataBuffer write(CharSequence charSequence, Charset charset) {\n\t\tAssert.notNull(charSequence, \"CharSequence must not be null\");\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\t\tif (StandardCharsets.UTF_8.equals(charset)) {\n\t\t\tByteBufUtil.writeUtf8(this.byteBuf, charSequence);\n\t\t}\n\t\telse if (StandardCharsets.US_ASCII.equals(charset)) {\n\t\t\tByteBufUtil.writeAscii(this.byteBuf, charSequence);\n\t\t}\n\t\telse {\n\t\t\treturn PooledDataBuffer.super.write(charSequence, charset);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,channel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the\n\t * channel when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux}\n\t * with a {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param channel the channel to write to\n\t * @return a Flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t * @since 5.0.10\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "channel"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel)",
    "source_code": "\tpublic static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {\n\t\treturn write(source, channel, 0);\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,channel,position)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the channel\n\t * when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux} with a\n\t * {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param channel the channel to write to\n\t * @param position the file position where writing is to begin; must be non-negative\n\t * @return a flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "channel",
      "position"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position)",
    "source_code": "\tpublic static Flux<DataBuffer> write(\n\t\t\tPublisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position) {\n\n\t\tAssert.notNull(source, \"'source' must not be null\");\n\t\tAssert.notNull(channel, \"'channel' must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be >= 0\");\n\n\t\tFlux<DataBuffer> flux = Flux.from(source);\n\t\treturn Flux.create(sink -> {\n\t\t\tWriteCompletionHandler handler = new WriteCompletionHandler(sink, channel, position);\n\t\t\tsink.onDispose(handler);\n\t\t\tflux.subscribe(handler);\n\t\t});\n\n\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,destination,options)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * file {@link Path}. The optional {@code options} parameter specifies\n\t * how the file is created or opened (defaults to\n\t * {@link StandardOpenOption#CREATE CREATE},\n\t * {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and\n\t * {@link StandardOpenOption#WRITE WRITE}).\n\t * @param source the stream of data buffers to be written\n\t * @param destination the path to the file\n\t * @param options the options specifying how the file is opened\n\t * @return a {@link Mono} that indicates completion or error\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "destination",
      "options"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options)",
    "source_code": "\tpublic static Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options) {\n\t\tAssert.notNull(source, \"Source must not be null\");\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSet<OpenOption> optionSet = checkWriteOptions(options);\n\n\t\treturn Mono.create(sink -> {\n\t\t\ttry {\n\t\t\t\tAsynchronousFileChannel channel = AsynchronousFileChannel.open(destination, optionSet, null);\n\t\t\t\tsink.onDispose(() -> closeChannel(channel));\n\t\t\t\twrite(source, channel).subscribe(DataBufferUtils::release,\n\t\t\t\t\t\tsink::error,\n\t\t\t\t\t\tsink::success,\n\t\t\t\t\t\tContext.of(sink.contextView()));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsink.error(ex);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 296
    },
    "return": "DefaultDataBuffer",
    "signature": "public DefaultDataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\tpublic DefaultDataBuffer write(byte[] source, int offset, int length) {\n\t\tAssert.notNull(source, \"Byte array must not be null\");\n\t\tensureWritable(length);\n\n\t\tByteBuffer tmp = this.byteBuffer.duplicate();\n\t\tint limit = this.writePosition + length;\n\t\ttmp.clear().position(this.writePosition).limit(limit);\n\t\ttmp.put(source, offset, length);\n\n\t\tthis.writePosition += length;\n\t\treturn this;\n\t}"
  },
  "org.springframework.core.io.buffer.<unknown>#write(source,outputStream)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given stream of {@link DataBuffer DataBuffers} to the given\n\t * {@code OutputStream}. Does <strong>not</strong> close the output stream\n\t * when the flux is terminated, and does <strong>not</strong>\n\t * {@linkplain #release(DataBuffer) release} the data buffers in the source.\n\t * If releasing is required, then subscribe to the returned {@code Flux}\n\t * with a {@link #releaseConsumer()}.\n\t * <p>Note that the writing process does not start until the returned\n\t * {@code Flux} is subscribed to.\n\t * @param source the stream of data buffers to be written\n\t * @param outputStream the output stream to write to\n\t * @return a Flux containing the same buffers as in {@code source}, that\n\t * starts the writing process when subscribed to, and that publishes any\n\t * writing errors and the completion signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream)",
    "source_code": "\tpublic static Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream) {\n\t\tAssert.notNull(source, \"'source' must not be null\");\n\t\tAssert.notNull(outputStream, \"'outputStream' must not be null\");\n\n\t\tWritableByteChannel channel = Channels.newChannel(outputStream);\n\t\treturn write(source, channel);\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#PropertySourceDescriptor(locations,ignoreResourceNotFound,name,propertySourceFactory,encoding)": {
    "deprecated": false,
    "doc": "/**\n * Descriptor for a {@link org.springframework.core.env.PropertySource PropertySource}.\n *\n * @author Stephane Nicoll\n * @since 6.0\n * @param locations the locations to consider\n * @param ignoreResourceNotFound whether a failure to find a property resource\n * should be ignored\n * @param name the name of the property source, or {@code null} to infer one\n * @param propertySourceFactory the type of {@link PropertySourceFactory} to use,\n * or {@code null} to use the default\n * @param encoding the encoding, or {@code null} to use the default encoding\n * @see org.springframework.core.env.PropertySource\n * @see org.springframework.context.annotation.PropertySource\n */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locations",
      "ignoreResourceNotFound",
      "name",
      "propertySourceFactory",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "record",
    "signature": "public record PropertySourceDescriptor(List<String> locations, boolean ignoreResourceNotFound,\n\t\t@Nullable String name, @Nullable Class<? extends PropertySourceFactory> propertySourceFactory,\n\t\t@Nullable String encoding)",
    "source_code": "public record PropertySourceDescriptor(List<String> locations, boolean ignoreResourceNotFound,\n\t\t@Nullable String name, @Nullable Class<? extends PropertySourceFactory> propertySourceFactory,\n\t\t@Nullable String encoding) {\n\n\t/**\n\t * Create a descriptor with the specified locations.\n\t * @param locations the locations to consider\n\t */\n\tpublic PropertySourceDescriptor(String... locations) {\n\t\tthis(Arrays.asList(locations), false, null, null, null);\n\t}\n\n}"
  },
  "org.springframework.core.io.support.<unknown>#addAllClassLoaderJarRoots(classLoader,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Search all {@link URLClassLoader} URLs for jar file references and add each to the\n\t * given set of resources in the form of a pointer to the root of the jar file content.\n\t * @param classLoader the ClassLoader to search (including its ancestors)\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.1.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "classLoader",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "void",
    "signature": "protected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result)",
    "source_code": "\tprotected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {\n\t\tif (classLoader instanceof URLClassLoader urlClassLoader) {\n\t\t\ttry {\n\t\t\t\tfor (URL url : urlClassLoader.getURLs()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tUrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ?\n\t\t\t\t\t\t\t\tnew UrlResource(url) :\n\t\t\t\t\t\t\t\tnew UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));\n\t\t\t\t\t\tif (jarResource.exists()) {\n\t\t\t\t\t\t\tresult.add(jarResource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + url +\n\t\t\t\t\t\t\t\t\t\"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files since ClassLoader [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getURLs()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classLoader == ClassLoader.getSystemClassLoader()) {\n\t\t\t// JAR \"Class-Path\" manifest header evaluation...\n\t\t\taddClassPathManifestEntries(result);\n\t\t}\n\n\t\tif (classLoader != null) {\n\t\t\ttry {\n\t\t\t\t// Hierarchy traversal...\n\t\t\t\taddAllClassLoaderJarRoots(classLoader.getParent(), result);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files in parent ClassLoader since [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getParent()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindPathMatchingFileResources(rootDirResource,subPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in the file system of the supplied root directory that\n\t * match the given location sub pattern via the Ant-style {@link #getPathMatcher()\n\t * PathMatcher}.\n\t * @param rootDirResource the root directory as a Resource\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 923
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\tURI rootDirUri;\n\t\ttry {\n\t\t\trootDirUri = rootDirResource.getURI();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to resolve directory [%s] as URI: %s\".formatted(rootDirResource, ex));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tPath rootPath = null;\n\t\tif (rootDirUri.isAbsolute() && !rootDirUri.isOpaque()) {\n\t\t\t// Prefer Path resolution from URI if possible\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\trootPath = Path.of(rootDirUri);\n\t\t\t\t}\n\t\t\t\tcatch (FileSystemNotFoundException ex) {\n\t\t\t\t\t// If the file system was not found, assume it's a custom file system that needs to be installed.\n\t\t\t\t\tFileSystems.newFileSystem(rootDirUri, Map.of(), ClassUtils.getDefaultClassLoader());\n\t\t\t\t\trootPath = Path.of(rootDirUri);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to resolve %s in file system: %s\".formatted(rootDirUri, ex));\n\t\t\t\t}\n\t\t\t\t// Fallback via Resource.getFile() below\n\t\t\t}\n\t\t}\n\n\t\tif (rootPath == null) {\n\t\t\t// Resource.getFile() resolution as a fallback -\n\t\t\t// for custom URI formats and custom Resource implementations\n\t\t\ttry {\n\t\t\t\trootPath = Path.of(rootDirResource.getFile().getAbsolutePath());\n\t\t\t}\n\t\t\tcatch (FileNotFoundException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath \" + rootDirResource +\n\t\t\t\t\t\t\t\" in the file system: \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Failed to resolve \" + rootDirResource + \" in the file system: \" + ex);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tif (!Files.exists(rootPath)) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Skipping search for files matching pattern [%s]: directory [%s] does not exist\"\n\t\t\t\t\t\t.formatted(subPattern, rootPath.toAbsolutePath()));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tString rootDir = StringUtils.cleanPath(rootPath.toString());\n\t\tif (!rootDir.endsWith(\"/\")) {\n\t\t\trootDir += \"/\";\n\t\t}\n\n\t\tPath rootPathForPattern = rootPath;\n\t\tString resourcePattern = rootDir + StringUtils.cleanPath(subPattern);\n\t\tPredicate<Path> isMatchingFile = path -> (!path.equals(rootPathForPattern) &&\n\t\t\t\tgetPathMatcher().match(resourcePattern, StringUtils.cleanPath(path.toString())));\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Searching directory [%s] for files matching pattern [%s]\"\n\t\t\t\t\t.formatted(rootPath.toAbsolutePath(), subPattern));\n\t\t}\n\n\t\ttry (Stream<Path> files = Files.walk(rootPath, FileVisitOption.FOLLOW_LINKS)) {\n\t\t\tfiles.filter(isMatchingFile).sorted().map(FileSystemResource::new).forEach(result::add);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to search in directory [%s] for files matching pattern [%s]: %s\"\n\t\t\t\t\t\t.formatted(rootPath.toAbsolutePath(), subPattern, ex));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#doFindPathMatchingJarResources(rootDirResource,rootDirUrl,subPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find all resources in jar files that match the given location pattern\n\t * via the Ant-style {@link #getPathMatcher() PathMatcher}.\n\t * @param rootDirResource the root directory as Resource\n\t * @param rootDirUrl the pre-resolved root directory URL\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see java.net.JarURLConnection\n\t * @see org.springframework.util.PathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "rootDirUrl",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 796
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tString jarFileUrl = null;\n\t\tString rootEntryPath = \"\";\n\n\t\tString urlFile = rootDirUrl.getFile();\n\t\tint separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\n\t\tif (separatorIndex == -1) {\n\t\t\tseparatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t}\n\t\tif (separatorIndex != -1) {\n\t\t\tjarFileUrl = urlFile.substring(0, separatorIndex);\n\t\t\trootEntryPath = urlFile.substring(separatorIndex + 2);  // both separators are 2 chars\n\t\t\tNavigableSet<String> entriesCache = this.jarEntriesCache.get(jarFileUrl);\n\t\t\tif (entriesCache != null) {\n\t\t\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\t\t\t// Search sorted entries from first entry with rootEntryPath prefix\n\t\t\t\tfor (String entryPath : entriesCache.tailSet(rootEntryPath, false)) {\n\t\t\t\t\tif (!entryPath.startsWith(rootEntryPath)) {\n\t\t\t\t\t\t// We are beyond the potential matches in the current TreeSet.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tString relativePath = entryPath.substring(rootEntryPath.length());\n\t\t\t\t\tif (getPathMatcher().match(subPattern, relativePath)) {\n\t\t\t\t\t\tresult.add(rootDirResource.createRelative(relativePath));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tURLConnection con = rootDirUrl.openConnection();\n\t\tJarFile jarFile;\n\t\tboolean closeJarFile;\n\n\t\tif (con instanceof JarURLConnection jarCon) {\n\t\t\t// Should usually be the case for traditional JAR files.\n\t\t\tjarFile = jarCon.getJarFile();\n\t\t\tjarFileUrl = jarCon.getJarFileURL().toExternalForm();\n\t\t\tJarEntry jarEntry = jarCon.getJarEntry();\n\t\t\trootEntryPath = (jarEntry != null ? jarEntry.getName() : \"\");\n\t\t\tcloseJarFile = !jarCon.getUseCaches();\n\t\t}\n\t\telse {\n\t\t\t// No JarURLConnection -> need to resort to URL file parsing.\n\t\t\t// We'll assume URLs of the format \"jar:path!/entry\", with the protocol\n\t\t\t// being arbitrary as long as following the entry format.\n\t\t\t// We'll also handle paths with and without leading \"file:\" prefix.\n\t\t\ttry {\n\t\t\t\tif (jarFileUrl != null) {\n\t\t\t\t\tjarFile = getJarFile(jarFileUrl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjarFile = new JarFile(urlFile);\n\t\t\t\t\tjarFileUrl = urlFile;\n\t\t\t\t\trootEntryPath = \"\";\n\t\t\t\t}\n\t\t\t\tcloseJarFile = true;\n\t\t\t}\n\t\t\tcatch (ZipException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Skipping invalid jar class path entry [\" + urlFile + \"]\");\n\t\t\t\t}\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Looking for matching resources in jar file [\" + jarFileUrl + \"]\");\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\n\t\t\t\t// Root entry path must end with slash to allow for proper matching.\n\t\t\t\t// The Sun JRE does not return a slash here, but BEA JRockit does.\n\t\t\t\trootEntryPath = rootEntryPath + \"/\";\n\t\t\t}\n\t\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\t\tNavigableSet<String> entriesCache = new TreeSet<>();\n\t\t\tfor (String entryPath : jarFile.stream().map(JarEntry::getName).sorted().toList()) {\n\t\t\t\tentriesCache.add(entryPath);\n\t\t\t\tif (entryPath.startsWith(rootEntryPath)) {\n\t\t\t\t\tString relativePath = entryPath.substring(rootEntryPath.length());\n\t\t\t\t\tif (getPathMatcher().match(subPattern, relativePath)) {\n\t\t\t\t\t\tresult.add(rootDirResource.createRelative(relativePath));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Cache jar entries in TreeSet for efficient searching on re-encounter.\n\t\t\tthis.jarEntriesCache.put(jarFileUrl, entriesCache);\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tif (closeJarFile) {\n\t\t\t\tjarFile.close();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.io.support.<unknown>#findMatchingResources(rootDirUrl,locationPattern,pathMatcher)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rootDirUrl",
      "locationPattern",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 1112
    },
    "return": "Set<Resource>",
    "signature": "public Set<Resource> findMatchingResources(URL rootDirUrl, String locationPattern, PathMatcher pathMatcher)",
    "source_code": "\t\tpublic static Set<Resource> findMatchingResources(\n\t\t\t\tURL rootDirUrl, String locationPattern, PathMatcher pathMatcher) throws IOException {\n\n\t\t\tObject root = VfsPatternUtils.findRoot(rootDirUrl);\n\t\t\tPatternVirtualFileVisitor visitor =\n\t\t\t\t\tnew PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\n\t\t\tVfsPatternUtils.visit(root, visitor);\n\t\t\treturn visitor.getResources();\n\t\t}"
  },
  "org.springframework.core.io.support.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1146
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tString methodName = method.getName();\n\t\t\tif (Object.class == method.getDeclaringClass()) {\n\t\t\t\tswitch (methodName) {\n\t\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t\t}\n\t\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn switch (methodName) {\n\t\t\t\tcase \"getAttributes\" -> getAttributes();\n\t\t\t\tcase \"visit\" -> {\n\t\t\t\t\tvisit(args[0]);\n\t\t\t\t\tyield null;\n\t\t\t\t}\n\t\t\t\tcase \"toString\" -> toString();\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected method invocation: \" + method);\n\t\t\t};\n\t\t}"
  },
  "org.springframework.core.style.<unknown>#styleMap(Map<K,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map}.\n\t * @return a styled version of the supplied map\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "String",
    "signature": "protected String styleMap(Map<K, V> map)",
    "source_code": "\tprotected <K, V> String styleMap(Map<K, V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn EMPTY_MAP;\n\t\t}\n\n\t\tStringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Map.Entry<K, V> entry : map.entrySet()) {\n\t\t\tresult.add(styleMapEntry(entry));\n\t\t}\n\t\treturn MAP + result;\n\t}"
  },
  "org.springframework.core.style.<unknown>#styleMapEntry(Map.Entry<?,entry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate a styled version of the supplied {@link Map.Entry}.\n\t * @return a styled version of the supplied map entry\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<?",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "String",
    "signature": "protected String styleMapEntry(Map.Entry<?, ?> entry)",
    "source_code": "\tprotected String styleMapEntry(Map.Entry<?, ?> entry) {\n\t\treturn style(entry.getKey()) + \" -> \" + style(entry.getValue());\n\t}"
  },
  "org.springframework.core.task.support.<unknown>#doExecute(concurrentExecutor,taskDecorator,runnable)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the given {@code Runnable} (which may be a user-supplied task\n\t * or a wrapper around a user-supplied task) with the given executor.\n\t * @param concurrentExecutor the underlying JDK concurrent executor to delegate to\n\t * @param taskDecorator the specified decorator to be applied, if any\n\t * @param runnable the runnable to execute\n\t * @throws RejectedExecutionException if the given runnable cannot be accepted\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "concurrentExecutor",
      "taskDecorator",
      "runnable"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "void",
    "signature": "protected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable)",
    "source_code": "\tprotected void doExecute(Executor concurrentExecutor, @Nullable TaskDecorator taskDecorator, Runnable runnable)\n\t\t\tthrows RejectedExecutionException{\n\n\t\tconcurrentExecutor.execute(taskDecorator != null ? taskDecorator.decorate(runnable) : runnable);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#getFileForOutput(location,packageName,relativeName,sibling)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "packageName",
      "relativeName",
      "sibling"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "FileObject",
    "signature": "public FileObject getFileForOutput(Location location, String packageName,\n\t\t\tString relativeName, FileObject sibling)",
    "source_code": "\tpublic FileObject getFileForOutput(Location location, String packageName,\n\t\t\tString relativeName, FileObject sibling) {\n\t\tResourceFile resourceFile = this.resourceFiles.get(relativeName);\n\t\tif (resourceFile != null) {\n\t\t\treturn new DynamicResourceFileObject(relativeName, resourceFile.getContent());\n\t\t}\n\t\treturn this.dynamicResourceFiles.computeIfAbsent(relativeName, DynamicResourceFileObject::new);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#getJavaFileForOutput(location,className,kind,sibling)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "className",
      "kind",
      "sibling"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "JavaFileObject",
    "signature": "public JavaFileObject getJavaFileForOutput(Location location, String className,\n\t\t\tJavaFileObject.Kind kind, FileObject sibling)",
    "source_code": "\tpublic JavaFileObject getJavaFileForOutput(Location location, String className,\n\t\t\tJavaFileObject.Kind kind, FileObject sibling) throws IOException {\n\t\tif (kind == JavaFileObject.Kind.CLASS) {\n\t\t\tClassFile classFile = this.classFiles.get(className);\n\t\t\tif (classFile != null) {\n\t\t\t\treturn new DynamicClassFileObject(className, classFile.getContent());\n\t\t\t}\n\t\t\treturn this.dynamicClassFiles.computeIfAbsent(className, DynamicClassFileObject::new);\n\t\t}\n\t\treturn super.getJavaFileForOutput(location, className, kind, sibling);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#inferBinaryName(location,file)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "String",
    "signature": "public String inferBinaryName(Location location, JavaFileObject file)",
    "source_code": "\tpublic String inferBinaryName(Location location, JavaFileObject file) {\n\t\tif (file instanceof DynamicClassFileObject dynamicClassFileObject) {\n\t\t\treturn dynamicClassFileObject.getClassName();\n\t\t}\n\t\treturn super.inferBinaryName(location, file);\n\t}"
  },
  "org.springframework.core.test.tools.<unknown>#list(location,packageName,kinds,recurse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "packageName",
      "kinds",
      "recurse"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Iterable<JavaFileObject>",
    "signature": "public Iterable<JavaFileObject> list(Location location, String packageName,\n\t\t\tSet<Kind> kinds, boolean recurse)",
    "source_code": "\tpublic Iterable<JavaFileObject> list(Location location, String packageName,\n\t\t\tSet<Kind> kinds, boolean recurse) throws IOException {\n\t\tList<JavaFileObject> result = new ArrayList<>();\n\t\tif (kinds.contains(Kind.CLASS)) {\n\t\t\tfor (ClassFile candidate : this.classFiles) {\n\t\t\t\tString existingPackageName = ClassUtils.getPackageName(candidate.getName());\n\t\t\t\tif (existingPackageName.equals(packageName) || (recurse && existingPackageName.startsWith(packageName + \".\"))) {\n\t\t\t\t\tresult.add(new DynamicClassFileObject(candidate.getName(), candidate.getContent()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (DynamicClassFileObject candidate : this.dynamicClassFiles.values()) {\n\t\t\t\tString existingPackageName = ClassUtils.getPackageName(candidate.getClassName());\n\t\t\t\tif (existingPackageName.equals(packageName) || (recurse && existingPackageName.startsWith(packageName + \".\"))) {\n\t\t\t\t\tresult.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.list(location, packageName, kinds, recurse).forEach(result::add);\n\t\treturn result;\n\t}"
  },
  "org.springframework.core.type.<unknown>#getAllAnnotationAttributes(annotationName,classValuesAsString)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Object>",
    "signature": "public Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.<unknown>#getAnnotationAttributes(annotationName,classValuesAsString)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "annotationName",
      "classValuesAsString"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object>",
    "signature": "public Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString)",
    "source_code": "\tpublic Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\n\t\tif (this.nestedAnnotationsAsMap) {\n\t\t\treturn MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod,\n\t\t\t\tannotationName, classValuesAsString, false);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#removeEldestEntry(Map.Entry<Resource,eldest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<Resource",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<Resource, MetadataReader> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<Resource, MetadataReader> eldest) {\n\t\t\treturn size() > this.cacheLimit;\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visit(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void visit(String name, Object value)",
    "source_code": "\t\tpublic void visit(String name, Object value) {\n\t\t\tif (value instanceof Type type) {\n\t\t\t\tvalue = type.getClassName();\n\t\t\t}\n\t\t\tthis.elements.add(value);\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visit(version,access,name,signature,supername,interfaces)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "access",
      "name",
      "signature",
      "supername",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void visit(int version, int access, String name, String signature,\n\t\t\t@Nullable String supername, String[] interfaces)",
    "source_code": "\tpublic void visit(int version, int access, String name, String signature,\n\t\t\t@Nullable String supername, String[] interfaces) {\n\n\t\tthis.className = toClassName(name);\n\t\tthis.access = access;\n\t\tif (supername != null && !isInterface(access)) {\n\t\t\tthis.superClassName = toClassName(supername);\n\t\t}\n\t\tfor (String element : interfaces) {\n\t\t\tthis.interfaceNames.add(toClassName(element));\n\t\t}\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitAnnotation(descriptor,visible)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "visible"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "AnnotationVisitor",
    "signature": "public AnnotationVisitor visitAnnotation(String descriptor, boolean visible)",
    "source_code": "\tpublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n\t\treturn MergedAnnotationReadingVisitor.get(this.classLoader, getSource(),\n\t\t\t\tdescriptor, visible, this.annotations::add);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitAnnotation(name,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 177
    },
    "return": "AnnotationVisitor",
    "signature": "public AnnotationVisitor visitAnnotation(String name, String descriptor)",
    "source_code": "\t\tpublic AnnotationVisitor visitAnnotation(String name, String descriptor) {\n\t\t\treturn MergedAnnotationReadingVisitor.this.visitAnnotation(descriptor, this.elements::add);\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitEnum(descriptor,value,consumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "value",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "public void visitEnum(String descriptor, String value, Consumer<E> consumer)",
    "source_code": "\tpublic <E extends Enum<E>> void visitEnum(String descriptor, String value, Consumer<E> consumer) {\n\t\tString className = Type.getType(descriptor).getClassName();\n\t\tClass<E> type = (Class<E>) ClassUtils.resolveClassName(className, this.classLoader);\n\t\tconsumer.accept(Enum.valueOf(type, value));\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitEnum(name,descriptor,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void visitEnum(String name, String descriptor, String value)",
    "source_code": "\t\tpublic void visitEnum(String name, String descriptor, String value) {\n\t\t\tMergedAnnotationReadingVisitor.this.visitEnum(descriptor, value, this.elements::add);\n\t\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitInnerClass(name,outerName,innerName,access)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "outerName",
      "innerName",
      "access"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "void",
    "signature": "public void visitInnerClass(String name, @Nullable String outerName, String innerName, int access)",
    "source_code": "\tpublic void visitInnerClass(String name, @Nullable String outerName, String innerName, int access) {\n\t\tif (outerName != null) {\n\t\t\tString className = toClassName(name);\n\t\t\tString outerClassName = toClassName(outerName);\n\t\t\tif (this.className.equals(className)) {\n\t\t\t\tthis.enclosingClassName = outerClassName;\n\t\t\t\tthis.independentInnerClass = ((access & Opcodes.ACC_STATIC) != 0);\n\t\t\t}\n\t\t\telse if (this.className.equals(outerClassName)) {\n\t\t\t\tthis.memberClassNames.add(className);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitMethod(access,name,descriptor,signature,exceptions)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "access",
      "name",
      "descriptor",
      "signature",
      "exceptions"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "MethodVisitor",
    "signature": "public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions)",
    "source_code": "\tpublic MethodVisitor visitMethod(\n\t\t\tint access, String name, String descriptor, String signature, String[] exceptions) {\n\n\t\t// Skip bridge methods and constructors - we're only interested in original user methods.\n\t\tif (isBridge(access) || name.equals(\"<init>\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new SimpleMethodMetadataReadingVisitor(this.classLoader, this.className,\n\t\t\t\taccess, name, descriptor, this.declaredMethods::add);\n\t}"
  },
  "org.springframework.core.type.classreading.<unknown>#visitOuterClass(owner,name,desc)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "owner",
      "name",
      "desc"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void visitOuterClass(String owner, String name, String desc)",
    "source_code": "\tpublic void visitOuterClass(String owner, String name, String desc) {\n\t\tthis.enclosingClassName = toClassName(owner);\n\t}"
  },
  "org.springframework.dao.support.<unknown>#objectResult(results,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a unique result object from the given Collection.\n\t * Throws an exception if 0 or more than 1 result objects found,\n\t * of if the unique result object is not convertible to the\n\t * specified required type.\n\t * @param results the result Collection (can be {@code null}\n\t * but is not expected to contain {@code null} elements)\n\t * @return the unique result object\n\t * @throws IncorrectResultSizeDataAccessException if more than one\n\t * result object has been found in the given Collection\n\t * @throws EmptyResultDataAccessException if no result object\n\t * at all has been found in the given Collection\n\t * @throws TypeMismatchDataAccessException if the unique object does\n\t * not match the specified required type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "results",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "T",
    "signature": "public T objectResult(@Nullable Collection<?> results, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T objectResult(@Nullable Collection<?> results, @Nullable Class<T> requiredType)\n\t\t\tthrows IncorrectResultSizeDataAccessException, TypeMismatchDataAccessException {\n\n\t\tObject result = requiredUniqueResult(results);\n\t\tif (requiredType != null && !requiredType.isInstance(result)) {\n\t\t\tif (String.class == requiredType) {\n\t\t\t\tresult = result.toString();\n\t\t\t}\n\t\t\telse if (Number.class.isAssignableFrom(requiredType) && result instanceof Number number) {\n\t\t\t\ttry {\n\t\t\t\t\tresult = NumberUtils.convertNumberToTargetClass(number, (Class<? extends Number>) requiredType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tthrow new TypeMismatchDataAccessException(ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Result object is of type [\" + result.getClass().getName() +\n\t\t\t\t\t\t\"] and could not be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}"
  },
  "org.springframework.dao.support.<unknown>#translateIfNecessary(rawException,pet)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a translated exception if this is appropriate,\n\t * otherwise return the given exception as-is.\n\t * @param rawException an exception that we may wish to translate\n\t * @param pet the PersistenceExceptionTranslator to use to perform the translation\n\t * @return a translated persistence exception if translation is possible,\n\t * or the raw exception if it is not\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawException",
      "pet"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "RuntimeException",
    "signature": "public RuntimeException translateIfNecessary(RuntimeException rawException, PersistenceExceptionTranslator pet)",
    "source_code": "\tpublic static RuntimeException translateIfNecessary(\n\t\t\tRuntimeException rawException, PersistenceExceptionTranslator pet) {\n\n\t\tAssert.notNull(pet, \"PersistenceExceptionTranslator must not be null\");\n\t\tDataAccessException dae = pet.translateExceptionIfPossible(rawException);\n\t\treturn (dae != null ? dae : rawException);\n\t}"
  },
  "org.springframework.expression.common.<unknown>#doParseExpression(expressionString,context)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually parse the expression string and return an Expression object.\n\t * @param expressionString the raw expression string to parse\n\t * @param context a context for influencing this expression parsing routine (optional)\n\t * @return an evaluator for the parsed expression\n\t * @throws ParseException if an exception occurred during parsing\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "expressionString",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Expression",
    "signature": "protected Expression doParseExpression(String expressionString, @Nullable ParserContext context)",
    "source_code": "\tprotected abstract Expression doParseExpression(String expressionString, @Nullable ParserContext context)\n\t\t\tthrows ParseException;\n\n\n\t/**\n\t * This captures a type of bracket and the position in which it occurs in the\n\t * expression. The positional information is used if an error has to be reported\n\t * because the related end bracket cannot be found. Bracket is used to describe\n\t * square brackets [], round brackets (), and curly brackets {}."
  },
  "org.springframework.expression.common.<unknown>#parseExpression(expressionString,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionString",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Expression",
    "signature": "public Expression parseExpression(String expressionString, @Nullable ParserContext context)",
    "source_code": "\tpublic Expression parseExpression(String expressionString, @Nullable ParserContext context) throws ParseException {\n\t\tif (context != null && context.isTemplate()) {\n\t\t\tAssert.notNull(expressionString, \"'expressionString' must not be null\");\n\t\t\treturn parseTemplate(expressionString, context);\n\t\t}\n\t\telse {\n\t\t\tAssert.hasText(expressionString, \"'expressionString' must not be null or blank\");\n\t\t\treturn doParseExpression(expressionString, context);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#areBoxingCompatible(desc1,desc2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether boxing/unboxing can get from one type to the other.\n\t * <p>Assumes at least one of the types is in boxed form (i.e. single char descriptor).\n\t * @return {@code true} if it is possible to get (via boxing) from one descriptor to the other\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "desc1",
      "desc2"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "boolean",
    "signature": "public boolean areBoxingCompatible(String desc1, String desc2)",
    "source_code": "\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n\t\tif (desc1.equals(desc2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (desc1.length() == 1) {\n\t\t\treturn checkPairs(desc1, desc2);\n\t\t}\n\t\telse if (desc2.length() == 1) {\n\t\t\treturn checkPairs(desc2, desc1);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#generateCodeForArgument(methodVisitor,argument,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>Delegates to {@link #generateCodeForArgument(MethodVisitor, SpelNode, String)}\n\t * with the {@linkplain #toDescriptor(Class) descriptor} for\n\t * the supplied {@code requiredType}.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredType}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, int.class)}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredType the required type for the argument when invoking the\n\t * corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, Class<?> requiredType) {\n\t\tgenerateCodeForArgument(methodVisitor, argument, toDescriptor(requiredType));\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#generateCodeForArgument(methodVisitor,argument,requiredTypeDesc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code requiredTypeDesc}.\n\t * <p>Use this method when a node in the AST will be used as an argument for\n\t * a constructor or method invocation. For example, if you wish to invoke a\n\t * method with an {@code indexNode} that must be of type {@code int} for the\n\t * actual method invocation within bytecode, you would call\n\t * {@code codeFlow.generateCodeForArgument(methodVisitor, indexNode, \"I\")}.\n\t * @param methodVisitor the ASM {@link MethodVisitor} into which code should\n\t * be generated\n\t * @param argument a {@link SpelNode} that represents an argument to a method\n\t * or constructor\n\t * @param requiredTypeDesc a descriptor for the required type for the argument\n\t * when invoking the corresponding constructor or method\n\t * @since 6.2\n\t * @see #generateCodeForArgument(MethodVisitor, SpelNode, Class)\n\t * @see #toDescriptor(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodVisitor",
      "argument",
      "requiredTypeDesc"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc)",
    "source_code": "\tpublic void generateCodeForArgument(MethodVisitor methodVisitor, SpelNode argument, String requiredTypeDesc) {\n\t\tenterCompilationScope();\n\t\targument.generateCode(methodVisitor, this);\n\t\tString lastDesc = lastDescriptor();\n\t\tAssert.state(lastDesc != null, \"No last descriptor\");\n\t\tboolean primitiveOnStack = isPrimitive(lastDesc);\n\t\t// Check if we need to box it.\n\t\tif (primitiveOnStack && requiredTypeDesc.charAt(0) == 'L') {\n\t\t\tinsertBoxIfNecessary(methodVisitor, lastDesc.charAt(0));\n\t\t}\n\t\t// Check if we need to unbox it.\n\t\telse if (requiredTypeDesc.length() == 1 && !primitiveOnStack) {\n\t\t\tinsertUnboxInsns(methodVisitor, requiredTypeDesc.charAt(0), lastDesc);\n\t\t}\n\t\t// Check if we need to check-cast\n\t\telse if (!requiredTypeDesc.equals(lastDesc)) {\n\t\t\t// This would be unnecessary in the case of subtyping (for example, method takes Number but Integer passed in)\n\t\t\tinsertCheckCast(methodVisitor, requiredTypeDesc);\n\t\t}\n\t\texitCompilationScope();\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertAnyNecessaryTypeConversionBytecodes(mv,targetDescriptor,stackDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary numeric conversion bytecodes based upon what is on the\n\t * stack and the desired target type.\n\t * @param mv the method visitor into which instructions should be placed\n\t * @param targetDescriptor the (primitive) descriptor of the target type\n\t * @param stackDescriptor the descriptor of the operand on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "void",
    "signature": "public void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor)",
    "source_code": "\tpublic static void insertAnyNecessaryTypeConversionBytecodes(MethodVisitor mv, char targetDescriptor, String stackDescriptor) {\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\treturn;\n\t\t}\n\t\tchar stackTop = stackDescriptor.charAt(0);\n\t\tswitch (stackTop){\n\t\t\tcase 'I', 'B', 'S', 'C' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(I2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(I2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(I2L);\n\t\t\t\t\tcase 'I' -> { /* no-op */ }\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(L2D);\n\t\t\t\t\tcase 'F' -> mv.visitInsn(L2F);\n\t\t\t\t\tcase 'J' -> { /* no-op */ }\n\t\t\t\t\tcase 'I' -> mv.visitInsn(L2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> mv.visitInsn(F2D);\n\t\t\t\t\tcase 'F' -> { /* no-op */ }\n\t\t\t\t\tcase 'J' -> mv.visitInsn(F2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(F2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackTop + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tswitch (targetDescriptor) {\n\t\t\t\t\tcase 'D' -> { /* no-op */ }\n\t\t\t\t\tcase 'F' -> mv.visitInsn(D2F);\n\t\t\t\t\tcase 'J' -> mv.visitInsn(D2L);\n\t\t\t\t\tcase 'I' -> mv.visitInsn(D2I);\n\t\t\t\t\tdefault ->\n\t\t\t\t\t\tthrow new IllegalStateException(\"Cannot get from \" + stackDescriptor + \" to \" + targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertArrayStore(mv,arrayComponentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Produce appropriate bytecode to store a stack item in an array.\n\t * <p>The instruction to use varies depending on whether the type is a\n\t * primitive or reference type.\n\t * @param mv where to insert the bytecode\n\t * @param arrayComponentType the component type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "arrayComponentType"
    ],
    "position": {
      "column": 1,
      "line": 908
    },
    "return": "void",
    "signature": "public void insertArrayStore(MethodVisitor mv, String arrayComponentType)",
    "source_code": "\tpublic static void insertArrayStore(MethodVisitor mv, String arrayComponentType) {\n\t\tif (arrayComponentType.length() == 1) {\n\t\t\tchar componentType = arrayComponentType.charAt(0);\n\t\t\tswitch (componentType) {\n\t\t\t\tcase 'B', 'Z' -> mv.visitInsn(BASTORE);\n\t\t\t\tcase 'I' -> mv.visitInsn(IASTORE);\n\t\t\t\tcase 'J' -> mv.visitInsn(LASTORE);\n\t\t\t\tcase 'F' -> mv.visitInsn(FASTORE);\n\t\t\t\tcase 'D' -> mv.visitInsn(DASTORE);\n\t\t\t\tcase 'C' -> mv.visitInsn(CASTORE);\n\t\t\t\tcase 'S' -> mv.visitInsn(SASTORE);\n\t\t\t\tdefault -> throw new IllegalArgumentException(\"Unexpected array component type \" + componentType);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(AASTORE);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertBoxIfNecessary(mv,ch)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param ch the descriptor of the type that might need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch"
    ],
    "position": {
      "column": 1,
      "line": 765
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, char ch)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, char ch) {\n\t\tswitch (ch) {\n\t\t\tcase 'Z' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\", false);\n\t\t\tcase 'B' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\", false);\n\t\t\tcase 'C' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\", false);\n\t\t\tcase 'D' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\", false);\n\t\t\tcase 'F' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\", false);\n\t\t\tcase 'I' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false);\n\t\t\tcase 'J' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false);\n\t\t\tcase 'S' ->\n\t\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\", false);\n\t\t\tcase 'L', 'V', '[' -> {\n\t\t\t\t// no box needed\n\t\t\t}\n\t\t\tdefault -> throw new IllegalArgumentException(\"Boxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertBoxIfNecessary(mv,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the appropriate boxing instruction for a specific type (if it needs\n\t * boxing) and insert the instruction into the supplied visitor.\n\t * @param mv the method visitor for the new instructions\n\t * @param descriptor the descriptor of a type that may or may not need boxing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 753
    },
    "return": "void",
    "signature": "public void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertBoxIfNecessary(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() == 1) {\n\t\t\tinsertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertCheckCast(mv,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n\t * @param mv the method visitor into which the instruction should be inserted\n\t * @param descriptor the descriptor of the type to cast to\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "void",
    "signature": "public void insertCheckCast(MethodVisitor mv, @Nullable String descriptor)",
    "source_code": "\tpublic static void insertCheckCast(MethodVisitor mv, @Nullable String descriptor) {\n\t\tif (descriptor != null && descriptor.length() != 1) {\n\t\t\tif (descriptor.charAt(0) == '[') {\n\t\t\t\tif (isPrimitiveArray(descriptor)) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor + \";\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!descriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertNewArrayCode(mv,size,arrayType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Produce the correct bytecode to build an array. The opcode to use and the\n\t * signature to pass along with the opcode can vary depending on the signature\n\t * of the array type.\n\t * @param mv the method visitor into which code should be inserted\n\t * @param size the size of the array\n\t * @param arrayType the type of the array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "size",
      "arrayType"
    ],
    "position": {
      "column": 1,
      "line": 969
    },
    "return": "void",
    "signature": "public void insertNewArrayCode(MethodVisitor mv, int size, String arrayType)",
    "source_code": "\tpublic static void insertNewArrayCode(MethodVisitor mv, int size, String arrayType) {\n\t\tinsertOptimalLoad(mv, size);\n\t\tif (arrayType.length() == 1) {\n\t\t\tmv.visitIntInsn(NEWARRAY, CodeFlow.arrayCodeFor(arrayType));\n\t\t}\n\t\telse {\n\t\t\tif (arrayType.charAt(0) == '[') {\n\t\t\t\t// Handling the nested array case here.\n\t\t\t\t// If vararg is [[I then we want [I and not [I;\n\t\t\t\tif (CodeFlow.isReferenceTypeArray(arrayType)) {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType + \";\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitTypeInsn(ANEWARRAY, arrayType.substring(1));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertNumericUnboxOrPrimitiveTypeCoercion(mv,stackDescriptor,targetDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * For use in mathematical operators, handles converting from a (possibly boxed)\n\t * number on the stack to a primitive numeric type.\n\t * <p>For example, from an Integer to a double, just need to call 'Number.doubleValue()'\n\t * but from an int to a double, need to use the bytecode 'i2d'.\n\t * @param mv the method visitor when instructions should be appended\n\t * @param stackDescriptor a descriptor of the operand on the stack\n\t * @param targetDescriptor a primitive type descriptor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "stackDescriptor",
      "targetDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 1000
    },
    "return": "void",
    "signature": "public void insertNumericUnboxOrPrimitiveTypeCoercion(MethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor)",
    "source_code": "\tpublic static void insertNumericUnboxOrPrimitiveTypeCoercion(\n\t\t\tMethodVisitor mv, @Nullable String stackDescriptor, char targetDescriptor) {\n\n\t\tif (!CodeFlow.isPrimitive(stackDescriptor)) {\n\t\t\tCodeFlow.insertUnboxNumberInsns(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t\telse {\n\t\t\tCodeFlow.insertAnyNecessaryTypeConversionBytecodes(mv, targetDescriptor, stackDescriptor);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertOptimalLoad(mv,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the optimal instruction for loading a number on the stack.\n\t * @param mv where to insert the bytecode\n\t * @param value the value to be loaded\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 886
    },
    "return": "void",
    "signature": "public void insertOptimalLoad(MethodVisitor mv, int value)",
    "source_code": "\tpublic static void insertOptimalLoad(MethodVisitor mv, int value) {\n\t\tif (value < 6) {\n\t\t\tmv.visitInsn(ICONST_0 + value);\n\t\t}\n\t\telse if (value < Byte.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(BIPUSH, value);\n\t\t}\n\t\telse if (value < Short.MAX_VALUE) {\n\t\t\tmv.visitIntInsn(SIPUSH, value);\n\t\t}\n\t\telse {\n\t\t\tmv.visitLdcInsn(value);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxInsns(mv,ch,stackDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Insert any necessary cast and value call to convert from a boxed type to a\n\t * primitive value.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param ch the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "ch",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "void",
    "signature": "public void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxInsns(MethodVisitor mv, char ch, @Nullable String stackDescriptor) {\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (ch) {\n\t\t\tcase 'Z' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Boolean\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n\t\t\t}\n\t\t\tcase 'B' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Byte\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Byte\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\", false);\n\t\t\t}\n\t\t\tcase 'C' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Character\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Character\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\", false);\n\t\t\t}\n\t\t\tcase 'D' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Double\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Double\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Float\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Float\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Integer\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Integer\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Long\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Long\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'S' -> {\n\t\t\t\tif (!stackDescriptor.equals(\"Ljava/lang/Short\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Short\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\", false);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + ch + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.<unknown>#insertUnboxNumberInsns(mv,targetDescriptor,stackDescriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * For numbers, use the appropriate method on the number to convert it to the primitive type requested.\n\t * @param mv the method visitor into which instructions should be inserted\n\t * @param targetDescriptor the primitive type desired as output\n\t * @param stackDescriptor the descriptor of the type on top of the stack\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "targetDescriptor",
      "stackDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "void",
    "signature": "public void insertUnboxNumberInsns(MethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor)",
    "source_code": "\tpublic static void insertUnboxNumberInsns(\n\t\t\tMethodVisitor mv, char targetDescriptor, @Nullable String stackDescriptor) {\n\n\t\tif (stackDescriptor == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (targetDescriptor) {\n\t\t\tcase 'D' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"doubleValue\", \"()D\", false);\n\t\t\t}\n\t\t\tcase 'F' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"floatValue\", \"()F\", false);\n\t\t\t}\n\t\t\tcase 'J' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"longValue\", \"()J\", false);\n\t\t\t}\n\t\t\tcase 'I' -> {\n\t\t\t\tif (stackDescriptor.equals(\"Ljava/lang/Object\")) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Number\");\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Number\", \"intValue\", \"()I\", false);\n\t\t\t}\n\t\t\t// does not handle Z, B, C, S\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + targetDescriptor + \"'\");\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#checkNumericCompatibility(leftDeclaredDescriptor,rightDeclaredDescriptor,leftActualDescriptor,rightActualDescriptor)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return an object that indicates whether the input descriptors are compatible.\n\t\t * <p>A declared descriptor is what could statically be determined (for example, from looking\n\t\t * at the return value of a property accessor method) whilst an actual descriptor\n\t\t * is the type of an actual object that was returned, which may differ.\n\t\t * <p>For generic types with unbound type variables, the declared descriptor\n\t\t * discovered may be 'Object' but from the actual descriptor it is possible to\n\t\t * observe that the objects are really numeric values (for example, ints).\n\t\t * @param leftDeclaredDescriptor the statically determinable left descriptor\n\t\t * @param rightDeclaredDescriptor the statically determinable right descriptor\n\t\t * @param leftActualDescriptor the dynamic/runtime left object descriptor\n\t\t * @param rightActualDescriptor the dynamic/runtime right object descriptor\n\t\t * @return a DescriptorComparison object indicating the type of compatibility, if any\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "leftDeclaredDescriptor",
      "rightDeclaredDescriptor",
      "leftActualDescriptor",
      "rightActualDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "DescriptorComparison",
    "signature": "public DescriptorComparison checkNumericCompatibility(@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,\n\t\t\t\t@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor)",
    "source_code": "\t\tpublic static DescriptorComparison checkNumericCompatibility(\n\t\t\t\t@Nullable String leftDeclaredDescriptor, @Nullable String rightDeclaredDescriptor,\n\t\t\t\t@Nullable String leftActualDescriptor, @Nullable String rightActualDescriptor) {\n\n\t\t\tString ld = leftDeclaredDescriptor;\n\t\t\tString rd = rightDeclaredDescriptor;\n\n\t\t\tboolean leftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld);\n\t\t\tboolean rightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);\n\n\t\t\t// If the declared descriptors aren't providing the information, try the actual descriptors\n\t\t\tif (!leftNumeric && !ObjectUtils.nullSafeEquals(ld, leftActualDescriptor)) {\n\t\t\t\tld = leftActualDescriptor;\n\t\t\t\tleftNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(ld);\n\t\t\t}\n\t\t\tif (!rightNumeric && !ObjectUtils.nullSafeEquals(rd, rightActualDescriptor)) {\n\t\t\t\trd = rightActualDescriptor;\n\t\t\t\trightNumeric = CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rd);\n\t\t\t}\n\n\t\t\tif (leftNumeric && rightNumeric) {\n\t\t\t\tif (CodeFlow.areBoxingCompatible(ld, rd)) {\n\t\t\t\t\treturn new DescriptorComparison(true, true, CodeFlow.toPrimitiveTargetDesc(ld));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn DescriptorComparison.INCOMPATIBLE_NUMBERS;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn DescriptorComparison.NOT_NUMBERS;\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#equalityCheck(context,left,right)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform an equality check for the given operand values.\n\t * <p>This method is not just used for reflective comparisons in subclasses\n\t * but also from compiled expression code, which is why it needs to be\n\t * declared as {@code public static} here.\n\t * @param context the current evaluation context\n\t * @param left the left-hand operand value\n\t * @param right the right-hand operand value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "boolean",
    "signature": "public boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic static boolean equalityCheck(EvaluationContext context, @Nullable Object left, @Nullable Object right) {\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn (leftBigDecimal.compareTo(rightBigDecimal) == 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn (leftNumber.doubleValue() == rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn (leftNumber.floatValue() == rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn (leftBigInteger.compareTo(rightBigInteger) == 0);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn (leftNumber.longValue() == rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn (leftNumber.intValue() == rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn (leftNumber.shortValue() == rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn (leftNumber.byteValue() == rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtypes -> best guess is double comparison\n\t\t\t\treturn (leftNumber.doubleValue() == rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\tif (left instanceof CharSequence && right instanceof CharSequence) {\n\t\t\treturn left.toString().equals(right.toString());\n\t\t}\n\n\t\tif (left instanceof Boolean && right instanceof Boolean) {\n\t\t\treturn left.equals(right);\n\t\t}\n\n\t\tif (ObjectUtils.nullSafeEquals(left, right)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (context.getTypeComparator().canCompare(left, right)) {\n\t\t\treturn context.getTypeComparator().compare(left, right) == 0;\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCode(mv,cf)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow cf)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor methodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\t\tMethod method = methodExecutor.getMethod();\n\n\t\tClass<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();\n\t\tAssert.state(publicDeclaringClass != null,\n\t\t\t\t() -> \"Failed to find public declaring class for method: \" + method);\n\n\t\tString classDesc = publicDeclaringClass.getName().replace('.', '/');\n\t\tboolean isStatic = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tif (descriptor == null && !isStatic) {\n\t\t\t// Nothing on the stack but something is needed\n\t\t\tcf.loadTarget(mv);\n\t\t}\n\n\t\tLabel skipIfNull = null;\n\t\tif (this.nullSafe && (descriptor != null || !isStatic)) {\n\t\t\tskipIfNull = new Label();\n\t\t\tLabel continueLabel = new Label();\n\t\t\tmv.visitInsn(DUP);\n\t\t\tmv.visitJumpInsn(IFNONNULL, continueLabel);\n\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n\t\t\tmv.visitLabel(continueLabel);\n\t\t}\n\n\t\tif (descriptor != null && isStatic) {\n\t\t\t// A static method call will not consume what is on the stack, so\n\t\t\t// it needs to be popped off.\n\t\t\tmv.visitInsn(POP);\n\t\t}\n\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tif (!isStatic && (descriptor == null || !descriptor.substring(1).equals(classDesc))) {\n\t\t\tCodeFlow.insertCheckCast(mv, \"L\" + classDesc);\n\t\t}\n\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tboolean isInterface = publicDeclaringClass.isInterface();\n\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(), CodeFlow.createSignatureDescriptor(method),\n\t\t\t\tisInterface);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\n\t\tif (this.originalPrimitiveExitTypeDescriptor != null) {\n\t\t\t// The output of the accessor will be a primitive but from the block above it might be null,\n\t\t\t// so to have a 'common stack' element at the skipIfNull target we need to box the primitive.\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, this.originalPrimitiveExitTypeDescriptor);\n\t\t}\n\n\t\tif (skipIfNull != null) {\n\t\t\tif (\"V\".equals(this.exitTypeDescriptor)) {\n\t\t\t\t// If the method return type is 'void', we need to push a null object\n\t\t\t\t// reference onto the stack to satisfy the needs of the skipIfNull target.\n\t\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t\t}\n\t\t\tmv.visitLabel(skipIfNull);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCode(mv,codeflow)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mv",
      "codeflow"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void generateCode(MethodVisitor mv, CodeFlow codeflow)",
    "source_code": "\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n\t\tfinal String constantFieldName = \"inlineList$\" + codeflow.nextFieldId();\n\t\tfinal String className = codeflow.getClassName();\n\n\t\tcodeflow.registerNewField((cw, cflow) ->\n\t\t\t\tcw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, constantFieldName, \"Ljava/util/List;\", null, null));\n\n\t\tcodeflow.registerNewClinit((mVisitor, cflow) ->\n\t\t\t\tgenerateClinitCode(className, constantFieldName, mVisitor, cflow, false));\n\n\t\tmv.visitFieldInsn(GETSTATIC, className, constantFieldName, \"Ljava/util/List;\");\n\t\tcodeflow.pushDescriptor(\"Ljava/util/List\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArgument(mv,cf,argument,paramDesc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate bytecode that loads the supplied argument onto the stack.\n\t * <p>This method also performs any boxing, unboxing, or check-casting\n\t * necessary to ensure that the type of the argument on the stack matches the\n\t * supplied {@code paramDesc}.\n\t * @deprecated As of Spring Framework 6.2, in favor of\n\t * {@link CodeFlow#generateCodeForArgument(MethodVisitor, SpelNode, String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "argument",
      "paramDesc"
    ],
    "position": {
      "column": 1,
      "line": 329
    },
    "return": "void",
    "signature": "protected void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc)",
    "source_code": "\tprotected static void generateCodeForArgument(MethodVisitor mv, CodeFlow cf, SpelNodeImpl argument, String paramDesc) {\n\t\tcf.generateCodeForArgument(mv, argument, paramDesc);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArguments(mv,cf,executable,arguments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified\n\t * {@link Executable} (method or constructor).\n\t * <p>This method takes into account whether the method or constructor was\n\t * declared to accept varargs, and if it was then the argument values will be\n\t * appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current {@link CodeFlow}\n\t * @param executable the {@link Executable} (method or constructor) for which\n\t * arguments are being set up\n\t * @param arguments the expression nodes for the expression supplied argument\n\t * values\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "executable",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments(\n\t\t\tMethodVisitor mv, CodeFlow cf, Executable executable, SpelNodeImpl[] arguments) {\n\n\t\tClass<?>[] parameterTypes = executable.getParameterTypes();\n\t\tString[] parameterDescriptors = CodeFlow.toDescriptors(parameterTypes);\n\t\tint parameterCount = parameterTypes.length;\n\n\t\tif (executable.isVarArgs()) {\n\t\t\t// The final parameter may or may not need packaging into an array, or nothing may\n\t\t\t// have been passed to satisfy the varargs which means something needs to be built.\n\n\t\t\tint varargsIndex = parameterCount - 1;\n\t\t\tint argumentCount = arguments.length;\n\t\t\tint p = 0;  // Current supplied argument being processed\n\n\t\t\t// Fulfill all the parameter requirements except the last one (the varargs array).\n\t\t\tfor (p = 0; p < varargsIndex; p++) {\n\t\t\t\tcf.generateCodeForArgument(mv, arguments[p], parameterDescriptors[p]);\n\t\t\t}\n\n\t\t\tSpelNodeImpl lastArgument = (argumentCount != 0 ? arguments[argumentCount - 1] : null);\n\t\t\tClassLoader classLoader = executable.getDeclaringClass().getClassLoader();\n\t\t\tClass<?> lastArgumentType = (lastArgument != null ?\n\t\t\t\t\tloadClassForExitDescriptor(lastArgument.getExitDescriptor(), classLoader) : null);\n\t\t\tClass<?> lastParameterType = parameterTypes[varargsIndex];\n\n\t\t\t// Determine if the final passed argument is already suitably packaged in array\n\t\t\t// form to be passed to the method.\n\t\t\tif (lastArgument != null && lastArgumentType != null && lastParameterType.isAssignableFrom(lastArgumentType)) {\n\t\t\t\tcf.generateCodeForArgument(mv, lastArgument, parameterDescriptors[p]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString arrayComponentType = parameterDescriptors[varargsIndex];\n\t\t\t\t// Trim the leading '[', potentially leaving other '[' characters.\n\t\t\t\tarrayComponentType = arrayComponentType.substring(1);\n\t\t\t\t// Build array big enough to hold remaining arguments.\n\t\t\t\tCodeFlow.insertNewArrayCode(mv, argumentCount - p, arrayComponentType);\n\t\t\t\t// Package up the remaining arguments into the array.\n\t\t\t\tint arrayIndex = 0;\n\t\t\t\twhile (p < argumentCount) {\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tCodeFlow.insertOptimalLoad(mv, arrayIndex++);\n\t\t\t\t\tcf.generateCodeForArgument(mv, arguments[p++], arrayComponentType);\n\t\t\t\t\tCodeFlow.insertArrayStore(mv, arrayComponentType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < parameterCount; i++) {\n\t\t\t\tcf.generateCodeForArgument(mv, arguments[i], parameterDescriptors[i]);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateCodeForArguments(mv,cf,member,arguments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Generate code that handles building the argument values for the specified\n\t * {@link Member} (method or constructor).\n\t * <p>This method takes into account whether the method or constructor was\n\t * declared to accept varargs, and if it was then the argument values will be\n\t * appropriately packaged into an array.\n\t * @param mv the method visitor where code should be generated\n\t * @param cf the current {@link CodeFlow}\n\t * @param member the method or constructor for which arguments are being set up\n\t * @param arguments the expression nodes for the expression supplied argument values\n\t * @deprecated As of Spring Framework 6.2, in favor of\n\t * {@link #generateCodeForArguments(MethodVisitor, CodeFlow, Executable, SpelNodeImpl[])}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "member",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "protected void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments)",
    "source_code": "\tprotected static void generateCodeForArguments(\n\t\t\tMethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {\n\n\t\tif (member instanceof Executable executable) {\n\t\t\tgenerateCodeForArguments(mv, cf, executable, arguments);\n\t\t}\n\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"The supplied member must be an instance of java.lang.reflect.Executable: \" + member);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#generateComparisonCode(mv,cf,compInstruction1,compInstruction2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Numeric comparison operators share very similar generated code, only differing in\n\t * two comparison instructions.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "cf",
      "compInstruction1",
      "compInstruction2"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "protected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2)",
    "source_code": "\tprotected void generateComparisonCode(MethodVisitor mv, CodeFlow cf, int compInstruction1, int compInstruction2) {\n\t\tSpelNodeImpl left = getLeftOperand();\n\t\tSpelNodeImpl right = getRightOperand();\n\t\tString leftDesc = left.exitTypeDescriptor;\n\t\tString rightDesc = right.exitTypeDescriptor;\n\t\tLabel elseTarget = new Label();\n\t\tLabel endOfIf = new Label();\n\t\tboolean unboxLeft = !CodeFlow.isPrimitive(leftDesc);\n\t\tboolean unboxRight = !CodeFlow.isPrimitive(rightDesc);\n\t\tDescriptorComparison dc = DescriptorComparison.checkNumericCompatibility(\n\t\t\t\tleftDesc, rightDesc, this.leftActualDescriptor, this.rightActualDescriptor);\n\t\tchar targetType = dc.compatibleType;  // CodeFlow.toPrimitiveTargetDesc(leftDesc);\n\n\t\tcf.enterCompilationScope();\n\t\tleft.generateCode(mv, cf);\n\t\tcf.exitCompilationScope();\n\t\tif (CodeFlow.isPrimitive(leftDesc)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, leftDesc);\n\t\t\tunboxLeft = true;\n\t\t}\n\n\t\tcf.enterCompilationScope();\n\t\tright.generateCode(mv, cf);\n\t\tcf.exitCompilationScope();\n\t\tif (CodeFlow.isPrimitive(rightDesc)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, rightDesc);\n\t\t\tunboxRight = true;\n\t\t}\n\n\t\t// This code block checks whether the left or right operand is null and handles\n\t\t// those cases before letting the original code (that only handled actual numbers) run\n\t\tLabel rightIsNonNull = new Label();\n\t\tmv.visitInsn(DUP);  // stack: left/right/right\n\t\tmv.visitJumpInsn(IFNONNULL, rightIsNonNull);  // stack: left/right\n\t\t// here: RIGHT==null LEFT==unknown\n\t\tmv.visitInsn(SWAP);  // right/left\n\t\tLabel leftNotNullRightIsNull = new Label();\n\t\tmv.visitJumpInsn(IFNONNULL, leftNotNullRightIsNull);  // stack: right\n\t\t// here: RIGHT==null LEFT==null\n\t\tmv.visitInsn(POP);  // stack: <nothing>\n\t\t// load 0 or 1 depending on comparison instruction\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFLE: // OpGT\n\t\t\tmv.visitInsn(ICONST_0);  // false - null is not < or > null\n\t\t\tbreak;\n\t\tcase IFGT: // OpLE\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_1);  // true - null is <= or >= null\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\t\tmv.visitLabel(leftNotNullRightIsNull);  // stack: right\n\t\t// RIGHT==null LEFT!=null\n\t\tmv.visitInsn(POP);  // stack: <nothing>\n\t\t// load 0 or 1 depending on comparison instruction\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFGT: // OpLE\n\t\t\tmv.visitInsn(ICONST_0);  // false - something is not < or <= null\n\t\t\tbreak;\n\t\tcase IFLE: // OpGT\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_1);  // true - something is > or >= null\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\n\t\tmv.visitLabel(rightIsNonNull);  // stack: left/right\n\t\t// here: RIGHT!=null LEFT==unknown\n\t\tmv.visitInsn(SWAP);  // stack: right/left\n\t\tmv.visitInsn(DUP);  // stack: right/left/left\n\t\tLabel neitherRightNorLeftAreNull = new Label();\n\t\tmv.visitJumpInsn(IFNONNULL, neitherRightNorLeftAreNull);  // stack: right/left\n\t\t// here: RIGHT!=null LEFT==null\n\t\tmv.visitInsn(POP2);  // stack: <nothing>\n\t\tswitch (compInstruction1) {\n\t\tcase IFGE: // OpLT\n\t\tcase IFGT: // OpLE\n\t\t\tmv.visitInsn(ICONST_1);  // true - null is < or <= something\n\t\t\tbreak;\n\t\tcase IFLE: // OpGT\n\t\tcase IFLT: // OpGE\n\t\t\tmv.visitInsn(ICONST_0);  // false - null is not > or >= something\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Unsupported: \" + compInstruction1);\n\t\t}\n\t\tmv.visitJumpInsn(GOTO, endOfIf);\n\t\tmv.visitLabel(neitherRightNorLeftAreNull);  // stack: right/left\n\t\t// neither were null so unbox and proceed with numeric comparison\n\t\tif (unboxLeft) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, leftDesc);\n\t\t}\n\t\t// What we just unboxed might be a double slot item (long/double)\n\t\t// so can't just use SWAP\n\t\t// stack: right/left(1or2slots)\n\t\tif (targetType == 'D' || targetType == 'J') {\n\t\t\tmv.visitInsn(DUP2_X1);\n\t\t\tmv.visitInsn(POP2);\n\t\t}\n\t\telse {\n\t\t\tmv.visitInsn(SWAP);\n\t\t}\n\t\t// stack: left(1or2)/right\n\t\tif (unboxRight) {\n\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, rightDesc);\n\t\t}\n\n\t\t// assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)\n\t\tif (targetType == 'D') {\n\t\t\tmv.visitInsn(DCMPG);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'F') {\n\t\t\tmv.visitInsn(FCMPG);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'J') {\n\t\t\tmv.visitInsn(LCMP);\n\t\t\tmv.visitJumpInsn(compInstruction1, elseTarget);\n\t\t}\n\t\telse if (targetType == 'I') {\n\t\t\tmv.visitJumpInsn(compInstruction2, elseTarget);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Unexpected descriptor \" + leftDesc);\n\t\t}\n\n\t\t// Other numbers are not yet supported (isCompilable will not have returned true)\n\t\tmv.visitInsn(ICONST_1);\n\t\tmv.visitJumpInsn(GOTO,endOfIf);\n\t\tmv.visitLabel(elseTarget);\n\t\tmv.visitInsn(ICONST_0);\n\t\tmv.visitLabel(endOfIf);\n\t\tcf.pushDescriptor(\"Z\");\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#getValue(state,desiredReturnType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "state",
      "desiredReturnType"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "T",
    "signature": "protected T getValue(ExpressionState state, Class<T> desiredReturnType)",
    "source_code": "\tprotected final <T> T getValue(ExpressionState state, Class<T> desiredReturnType) throws EvaluationException {\n\t\treturn ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isSuitable(value,target,argumentTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "target",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "boolean",
    "signature": "public boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes)",
    "source_code": "\t\tpublic boolean isSuitable(Object value, @Nullable TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n\t\t\treturn ((this.staticClass == null || this.staticClass == value) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.target, target) && this.argumentTypes.equals(argumentTypes));\n\t\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#isWritableProperty(name,contextObject,evalContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "contextObject",
      "evalContext"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "boolean",
    "signature": "public boolean isWritableProperty(String name, TypedValue contextObject, EvaluationContext evalContext)",
    "source_code": "\tpublic boolean isWritableProperty(String name, TypedValue contextObject, EvaluationContext evalContext)\n\t\t\tthrows EvaluationException {\n\n\t\tObject targetObject = contextObject.getValue();\n\t\tif (targetObject != null) {\n\t\t\tList<PropertyAccessor> accessorsToTry =\n\t\t\t\t\tAstUtils.getAccessorsToTry(targetObject, evalContext.getPropertyAccessors());\n\t\t\tfor (PropertyAccessor accessor : accessorsToTry) {\n\t\t\t\ttry {\n\t\t\t\t\tif (accessor.canWrite(evalContext, targetObject, name)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (AccessException ex) {\n\t\t\t\t\t// let others try\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValue(expressionState,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void setValue(ExpressionState expressionState, @Nullable Object newValue)",
    "source_code": "\tpublic void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException {\n\t\tsetValueInternal(expressionState, () -> new TypedValue(newValue));\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValueInternal(expressionState,valueSupplier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the expression to a node and then set the new value created by the\n\t * specified {@link Supplier} on that node.\n\t * <p>For example, if the expression evaluates to a property reference, then the\n\t * property will be set to the new value.\n\t * <p>Favor this method over {@link #setValue(ExpressionState, Object)} when\n\t * the value should be lazily computed.\n\t * <p>By default, this method throws a {@link SpelEvaluationException},\n\t * effectively disabling this feature. Subclasses may override this method to\n\t * provide an actual implementation.\n\t * @param expressionState the current expression state (includes the context)\n\t * @param valueSupplier a supplier of the new value\n\t * @throws EvaluationException if any problem occurs evaluating the expression or\n\t * setting the new value\n\t * @since 5.2.24\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expressionState",
      "valueSupplier"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "TypedValue",
    "signature": "public TypedValue setValueInternal(ExpressionState expressionState, Supplier<TypedValue> valueSupplier)",
    "source_code": "\tpublic TypedValue setValueInternal(ExpressionState expressionState, Supplier<TypedValue> valueSupplier)\n\t\t\tthrows EvaluationException {\n\n\t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass().getName());\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#setValueInternal(state,valueSupplier)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "state",
      "valueSupplier"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "TypedValue",
    "signature": "public TypedValue setValueInternal(ExpressionState state, Supplier<TypedValue> valueSupplier)",
    "source_code": "\tpublic TypedValue setValueInternal(ExpressionState state, Supplier<TypedValue> valueSupplier)\n\t\t\tthrows EvaluationException {\n\n\t\tTypedValue typedValue = valueSupplier.get();\n\t\tgetValueRef(state, AccessMode.WRITE).setValue(typedValue.getValue());\n\t\treturn typedValue;\n\t}"
  },
  "org.springframework.expression.spel.ast.<unknown>#subSequence(start,end)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "start",
      "end"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "CharSequence",
    "signature": "public CharSequence subSequence(int start, int end)",
    "source_code": "\t\tpublic CharSequence subSequence(int start, int end) {\n\t\t\treturn new MatcherInput(this.value.subSequence(start, end), this.access);\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canCompare(left,right)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "boolean",
    "signature": "public boolean canCompare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic boolean canCompare(@Nullable Object left, @Nullable Object right) {\n\t\tif (left == null || right == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Number && right instanceof Number) {\n\t\t\treturn true;\n\t\t}\n\t\tif (left instanceof Comparable && right instanceof Comparable) {\n\t\t\tClass<?> ancestor = ClassUtils.determineCommonAncestor(left.getClass(), right.getClass());\n\t\t\treturn ancestor != null && Comparable.class.isAssignableFrom(ancestor);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canRead(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (target == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\t\tif (type.isArray()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tString getterName = \"get\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tgetterName = \"is\" + StringUtils.capitalize(name);\n\t\t\t\tif (getterName.equals(method.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.member.getName().equals(name);\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#canWrite(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#compare(left,right)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "int",
    "signature": "public int compare(@Nullable Object left, @Nullable Object right)",
    "source_code": "\tpublic int compare(@Nullable Object left, @Nullable Object right) throws SpelEvaluationException {\n\t\t// If one is null, check if the other is\n\t\tif (left == null) {\n\t\t\treturn (right == null ? 0 : -1);\n\t\t}\n\t\telse if (right == null) {\n\t\t\treturn 1;  // left cannot be null at this point\n\t\t}\n\n\t\t// Basic number comparisons\n\t\tif (left instanceof Number leftNumber && right instanceof Number rightNumber) {\n\t\t\tif (leftNumber instanceof BigDecimal || rightNumber instanceof BigDecimal) {\n\t\t\t\tBigDecimal leftBigDecimal = NumberUtils.convertNumberToTargetClass(leftNumber, BigDecimal.class);\n\t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n\t\t\t\treturn leftBigDecimal.compareTo(rightBigDecimal);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Double || rightNumber instanceof Double) {\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n\t\t\t\treturn Float.compare(leftNumber.floatValue(), rightNumber.floatValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof BigInteger || rightNumber instanceof BigInteger) {\n\t\t\t\tBigInteger leftBigInteger = NumberUtils.convertNumberToTargetClass(leftNumber, BigInteger.class);\n\t\t\t\tBigInteger rightBigInteger = NumberUtils.convertNumberToTargetClass(rightNumber, BigInteger.class);\n\t\t\t\treturn leftBigInteger.compareTo(rightBigInteger);\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n\t\t\t\treturn Long.compare(leftNumber.longValue(), rightNumber.longValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n\t\t\t\treturn Integer.compare(leftNumber.intValue(), rightNumber.intValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Short || rightNumber instanceof Short) {\n\t\t\t\treturn Short.compare(leftNumber.shortValue(), rightNumber.shortValue());\n\t\t\t}\n\t\t\telse if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n\t\t\t\treturn Byte.compare(leftNumber.byteValue(), rightNumber.byteValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unknown Number subtype -> best guess is double multiplication\n\t\t\t\treturn Double.compare(leftNumber.doubleValue(), rightNumber.doubleValue());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (left instanceof Comparable comparable) {\n\t\t\t\treturn comparable.compareTo(right);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassCastException ex) {\n\t\t\tthrow new SpelEvaluationException(ex, SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t\t}\n\n\t\tthrow new SpelEvaluationException(SpelMessage.NOT_COMPARABLE, left.getClass(), right.getClass());\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#createOptimalAccessor(context,target,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to create an optimized property accessor tailored for a property\n\t * of a particular name on a particular class.\n\t * <p>The general {@link ReflectivePropertyAccessor} will always work but is\n\t * not optimal due to the need to look up which reflective member (method or\n\t * field) to use each time {@link #read(EvaluationContext, Object, String)}\n\t * is called.\n\t * <p>This method will return this {@code ReflectivePropertyAccessor} instance\n\t * if it is unable to build an optimized accessor.\n\t * <p>Note: An optimized accessor is currently only usable for read attempts.\n\t * Do not call this method if you need a read-write accessor.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "PropertyAccessor",
    "signature": "public PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\tpublic PropertyAccessor createOptimalAccessor(EvaluationContext context, @Nullable Object target, String name) {\n\t\t// Don't be clever for arrays or a null target...\n\t\tif (target == null) {\n\t\t\treturn this;\n\t\t}\n\t\tClass<?> type = (target instanceof Class<?> clazz ? clazz : target.getClass());\n\t\tif (type.isArray()) {\n\t\t\treturn this;\n\t\t}\n\n\t\tPropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invokerPair = this.readerCache.get(cacheKey);\n\n\t\tif (invokerPair == null || invokerPair.member instanceof Method) {\n\t\t\tMethod method = (Method) (invokerPair != null ? invokerPair.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(method, -1));\n\t\t\t\t\tMethod methodToInvoke = ClassUtils.getPubliclyAccessibleMethodIfPossible(method, type);\n\t\t\t\t\tReflectionUtils.makeAccessible(methodToInvoke);\n\t\t\t\t\tinvokerPair = new InvokerPair(methodToInvoke, typeDescriptor);\n\t\t\t\t\tthis.readerCache.put(cacheKey, invokerPair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invokerPair);\n\t\t\t}\n\t\t}\n\n\t\tif (invokerPair == null || invokerPair.member instanceof Field) {\n\t\t\tField field = (invokerPair != null ? (Field) invokerPair.member : null);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target instanceof Class);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tinvokerPair = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tthis.readerCache.put(cacheKey, invokerPair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\treturn new OptimalPropertyAccessor(invokerPair);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findField(name,clazz,mustBeStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a field of a certain name on a specified class.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "Field",
    "signature": "protected Field findField(String name, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Field findField(String name, Class<?> clazz, boolean mustBeStatic) {\n\t\tField[] fields = clazz.getFields();\n\t\tfor (Field field : fields) {\n\t\t\tif (field.getName().equals(name) && (!mustBeStatic || Modifier.isStatic(field.getModifiers()))) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\t// We'll search superclasses and implemented interfaces explicitly,\n\t\t// although it shouldn't be necessary - however, see SPR-10125.\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tField field = findField(name, clazz.getSuperclass(), mustBeStatic);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\tfor (Class<?> implementedInterface : clazz.getInterfaces()) {\n\t\t\tField field = findField(name, implementedInterface, mustBeStatic);\n\t\t\tif (field != null) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findGetterForProperty(propertyName,clazz,mustBeStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a getter method for the specified property.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 378
    },
    "return": "Method",
    "signature": "protected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Method findGetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\tMethod method = findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"get\", clazz, mustBeStatic, 0, ANY_TYPES);\n\t\tif (method == null) {\n\t\t\tmethod = findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\t\"is\", clazz, mustBeStatic, 0, BOOLEAN_TYPES);\n\t\t\tif (method == null) {\n\t\t\t\t// Record-style plain accessor method, for example, name()\n\t\t\t\tmethod = findMethodForProperty(new String[] {propertyName},\n\t\t\t\t\t\t\"\", clazz, mustBeStatic, 0, ANY_TYPES);\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#findSetterForProperty(propertyName,clazz,mustBeStatic)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a setter method for the specified property.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "propertyName",
      "clazz",
      "mustBeStatic"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "Method",
    "signature": "protected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic)",
    "source_code": "\tprotected Method findSetterForProperty(String propertyName, Class<?> clazz, boolean mustBeStatic) {\n\t\treturn findMethodForProperty(getPropertyMethodSuffixes(propertyName),\n\t\t\t\t\"set\", clazz, mustBeStatic, 1, ANY_TYPES);\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#generateCode(propertyName,mv,cf)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertyName",
      "mv",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "void",
    "signature": "public void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf)",
    "source_code": "\t\tpublic void generateCode(String propertyName, MethodVisitor mv, CodeFlow cf) {\n\t\t\tClass<?> publicDeclaringClass = this.member.getDeclaringClass();\n\t\t\tAssert.state(Modifier.isPublic(publicDeclaringClass.getModifiers()),\n\t\t\t\t\t() -> \"Failed to find public declaring class for: \" + this.member);\n\n\t\t\tString classDesc = publicDeclaringClass.getName().replace('.', '/');\n\t\t\tboolean isStatic = Modifier.isStatic(this.member.getModifiers());\n\t\t\tString descriptor = cf.lastDescriptor();\n\n\t\t\tif (!isStatic) {\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tcf.loadTarget(mv);\n\t\t\t\t}\n\t\t\t\tif (descriptor == null || !classDesc.equals(descriptor.substring(1))) {\n\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, classDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (descriptor != null) {\n\t\t\t\t\t// A static field/method call will not consume what is on the stack, so\n\t\t\t\t\t// it needs to be popped off.\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\tboolean isInterface = publicDeclaringClass.isInterface();\n\t\t\t\tint opcode = (isStatic ? INVOKESTATIC : isInterface ? INVOKEINTERFACE : INVOKEVIRTUAL);\n\t\t\t\tmv.visitMethodInsn(opcode, classDesc, method.getName(),\n\t\t\t\t\t\tCodeFlow.createSignatureDescriptor(method), isInterface);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitFieldInsn((isStatic ? GETSTATIC : GETFIELD), classDesc, this.member.getName(),\n\t\t\t\t\t\tCodeFlow.toJvmDescriptor(((Field) this.member).getType()));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isCandidateForInvocation(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for method resolution\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * static methods and non-user-declared methods on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForInvocation(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForInvocation(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isCandidateForProperty(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given {@code Method} is a candidate for property access\n\t * on an instance of the given target class.\n\t * <p>The default implementation considers any method as a candidate, even for\n\t * non-user-declared properties on the {@link Object} base class.\n\t * @param method the Method to evaluate\n\t * @param targetClass the concrete target class that is being introspected\n\t * @since 4.3.15\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "boolean",
    "signature": "protected boolean isCandidateForProperty(Method method, Class<?> targetClass)",
    "source_code": "\tprotected boolean isCandidateForProperty(Method method, Class<?> targetClass) {\n\t\treturn true;\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#isKotlinProperty(method,methodSuffix)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "methodSuffix"
    ],
    "position": {
      "column": 1,
      "line": 745
    },
    "return": "boolean",
    "signature": "public boolean isKotlinProperty(Method method, String methodSuffix)",
    "source_code": "\t\tpublic static boolean isKotlinProperty(Method method, String methodSuffix) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(method.getDeclaringClass());\n\t\t\tfor (KProperty<?> property : KClasses.getMemberProperties(kClass)) {\n\t\t\t\tif (methodSuffix.equalsIgnoreCase(property.getName()) &&\n\t\t\t\t\t\t(method.equals(ReflectJvmMapping.getJavaGetter(property)) ||\n\t\t\t\t\t\t\t\tproperty instanceof KMutableProperty<?> mutableProperty &&\n\t\t\t\t\t\t\t\t\t\tmethod.equals(ReflectJvmMapping.getJavaSetter(mutableProperty)))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#read(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 651
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\t\tif (this.member instanceof Method method) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tField field = (Field) this.member;\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, this.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#registerMethodFilter(type,filter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a filter for methods on the given type.\n\t * @param type the type to filter on\n\t * @param filter the corresponding method filter,\n\t * or {@code null} to clear any filter for the given type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "void",
    "signature": "public void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter)",
    "source_code": "\tpublic void registerMethodFilter(Class<?> type, @Nullable MethodFilter filter) {\n\t\tif (this.filters == null) {\n\t\t\tthis.filters = new HashMap<>();\n\t\t}\n\t\tif (filter != null) {\n\t\t\tthis.filters.put(type, filter);\n\t\t}\n\t\telse {\n\t\t\tthis.filters.remove(type);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#resolve(context,targetObject,name,argumentTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Locate a method on the type.\n\t * <p>There are three kinds of matches that might occur:\n\t * <ol>\n\t * <li>An exact match where the types of the arguments match the types of the\n\t * method.</li>\n\t * <li>An inexact match where the types we are looking for are subtypes of\n\t * those defined on the method.</li>\n\t * <li>A match where we are able to convert the arguments into those expected\n\t * by the method, according to the registered type converter.</li>\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "targetObject",
      "name",
      "argumentTypes"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MethodExecutor",
    "signature": "public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes)",
    "source_code": "\tpublic MethodExecutor resolve(EvaluationContext context, Object targetObject, String name,\n\t\t\tList<TypeDescriptor> argumentTypes) throws AccessException {\n\n\t\ttry {\n\t\t\tTypeConverter typeConverter = context.getTypeConverter();\n\t\t\tClass<?> type = (targetObject instanceof Class<?> clazz ? clazz : targetObject.getClass());\n\t\t\tArrayList<Method> methods = new ArrayList<>(getMethods(type, targetObject));\n\t\t\tmethods.removeIf(method -> !method.getName().equals(name));\n\n\t\t\t// If a filter is registered for this type, call it\n\t\t\tMethodFilter filter = (this.filters != null ? this.filters.get(type) : null);\n\t\t\tif (filter != null) {\n\t\t\t\tList<Method> filtered = filter.filter(methods);\n\t\t\t\tmethods = (filtered instanceof ArrayList<Method> arrayList ? arrayList : new ArrayList<>(filtered));\n\t\t\t}\n\n\t\t\t// Sort methods into a sensible order\n\t\t\tif (methods.size() > 1) {\n\t\t\t\tmethods.sort((m1, m2) -> {\n\t\t\t\t\tint m1pl = m1.getParameterCount();\n\t\t\t\t\tint m2pl = m2.getParameterCount();\n\t\t\t\t\t// vararg methods go last\n\t\t\t\t\tif (m1pl == m2pl) {\n\t\t\t\t\t\tif (!m1.isVarArgs() && m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (m1.isVarArgs() && !m2.isVarArgs()) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Integer.compare(m1pl, m2pl);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Resolve any bridge methods\n\t\t\tfor (int i = 0; i < methods.size(); i++) {\n\t\t\t\tmethods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)));\n\t\t\t}\n\n\t\t\t// Remove duplicate methods (possible due to resolved bridge methods)\n\t\t\tSet<Method> methodsToIterate = new LinkedHashSet<>(methods);\n\n\t\t\tMethod closeMatch = null;\n\t\t\tint closeMatchDistance = Integer.MAX_VALUE;\n\t\t\tMethod matchRequiringConversion = null;\n\t\t\tboolean multipleOptions = false;\n\n\t\t\tfor (Method method : methodsToIterate) {\n\t\t\t\tint paramCount = method.getParameterCount();\n\t\t\t\tList<TypeDescriptor> paramDescriptors = new ArrayList<>(paramCount);\n\t\t\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\t\t\tparamDescriptors.add(new TypeDescriptor(new MethodParameter(method, i)));\n\t\t\t\t}\n\t\t\t\tArgumentsMatchKind matchKind = null;\n\t\t\t\tif (method.isVarArgs() && argumentTypes.size() >= (paramCount - 1)) {\n\t\t\t\t\t// *sigh* complicated\n\t\t\t\t\tmatchKind = ReflectionHelper.compareArgumentsVarargs(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t}\n\t\t\t\telse if (paramCount == argumentTypes.size()) {\n\t\t\t\t\t// Name and parameter number match, check the arguments\n\t\t\t\t\tmatchKind = ReflectionHelper.compareArguments(paramDescriptors, argumentTypes, typeConverter);\n\t\t\t\t}\n\t\t\t\tif (matchKind != null) {\n\t\t\t\t\tif (matchKind.isExactMatch()) {\n\t\t\t\t\t\treturn new ReflectiveMethodExecutor(method, type);\n\t\t\t\t\t}\n\t\t\t\t\telse if (matchKind.isCloseMatch()) {\n\t\t\t\t\t\tif (this.useDistance) {\n\t\t\t\t\t\t\tint matchDistance = ReflectionHelper.getTypeDifferenceWeight(paramDescriptors, argumentTypes);\n\t\t\t\t\t\t\tif (closeMatch == null || matchDistance < closeMatchDistance) {\n\t\t\t\t\t\t\t\t// This is a better match...\n\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t\tcloseMatchDistance = matchDistance;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Take this as a close match if there isn't one already\n\t\t\t\t\t\t\tif (closeMatch == null) {\n\t\t\t\t\t\t\t\tcloseMatch = method;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (matchKind.isMatchRequiringConversion()) {\n\t\t\t\t\t\tif (matchRequiringConversion != null) {\n\t\t\t\t\t\t\tmultipleOptions = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatchRequiringConversion = method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (closeMatch != null) {\n\t\t\t\treturn new ReflectiveMethodExecutor(closeMatch, type);\n\t\t\t}\n\t\t\telse if (matchRequiringConversion != null) {\n\t\t\t\tif (multipleOptions) {\n\t\t\t\t\tthrow new SpelEvaluationException(SpelMessage.MULTIPLE_POSSIBLE_METHODS, name);\n\t\t\t\t}\n\t\t\t\treturn new ReflectiveMethodExecutor(matchRequiringConversion, type);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (EvaluationException ex) {\n\t\t\tthrow new AccessException(\"Failed to resolve method\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.expression.spel.support.<unknown>#write(context,target,name,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue) {\n\t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n\t\t}"
  },
  "org.springframework.format.datetime.<unknown>#parse(text,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "Date",
    "signature": "public Date parse(String text, Locale locale)",
    "source_code": "\tpublic Date parse(String text, Locale locale) throws ParseException {\n\t\ttry {\n\t\t\treturn getDateFormat(locale).parse(text);\n\t\t}\n\t\tcatch (ParseException ex) {\n\t\t\tSet<String> fallbackPatterns = new LinkedHashSet<>();\n\t\t\tString isoPattern = ISO_FALLBACK_PATTERNS.get(this.iso);\n\t\t\tif (isoPattern != null) {\n\t\t\t\tfallbackPatterns.add(isoPattern);\n\t\t\t}\n\t\t\tif (!ObjectUtils.isEmpty(this.fallbackPatterns)) {\n\t\t\t\tCollections.addAll(fallbackPatterns, this.fallbackPatterns);\n\t\t\t}\n\t\t\tif (!fallbackPatterns.isEmpty()) {\n\t\t\t\tfor (String pattern : fallbackPatterns) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDateFormat dateFormat = configureDateFormat(new SimpleDateFormat(pattern, locale));\n\t\t\t\t\t\t// Align timezone for parsing format with printing format if ISO is set.\n\t\t\t\t\t\tif (this.iso != null && this.iso != ISO.NONE) {\n\t\t\t\t\t\t\tdateFormat.setTimeZone(UTC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn dateFormat.parse(text);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ParseException ignoredException) {\n\t\t\t\t\t\t// Ignore fallback parsing exceptions since the exception thrown below\n\t\t\t\t\t\t// will include information from the \"source\" if available -- for example,\n\t\t\t\t\t\t// the toString() of a @DateTimeFormat annotation.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.source != null) {\n\t\t\t\tParseException parseException = new ParseException(\n\t\t\t\t\t\tString.format(\"Unable to parse date time value \\\"%s\\\" using configuration from %s\", text, this.source),\n\t\t\t\t\t\tex.getErrorOffset());\n\t\t\t\tparseException.initCause(ex);\n\t\t\t\tthrow parseException;\n\t\t\t}\n\t\t\t// else rethrow original exception\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.format.datetime.<unknown>#print(date,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "date",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "String",
    "signature": "public String print(Date date, Locale locale)",
    "source_code": "\tpublic String print(Date date, Locale locale) {\n\t\treturn getDateFormat(locale).format(date);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#detectAndParse(value,unit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Detect the style then parse the value to return a duration.\n\t * @param value the value to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return the parsed duration\n\t * @throws IllegalArgumentException if the value is not a known style or cannot be\n\t * parsed\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Duration",
    "signature": "public Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static Duration detectAndParse(String value, @Nullable DurationFormat.Unit unit) {\n\t\treturn parse(value, detect(value), unit);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#parse(value,style)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @return a duration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "Duration",
    "signature": "public Duration parse(String value, DurationFormat.Style style)",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style) {\n\t\treturn parse(value, style, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#parse(value,style,unit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given value to a duration.\n\t * @param value the value to parse\n\t * @param style the style in which to parse\n\t * @param unit the duration unit to use if the value doesn't specify one ({@code null}\n\t * will default to ms)\n\t * @return a duration\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Duration",
    "signature": "public Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static Duration parse(String value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\tAssert.hasText(value, () -> \"Value must not be empty\");\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> parseIso8601(value);\n\t\t\tcase SIMPLE -> parseSimple(value, unit);\n\t\t\tcase COMPOSITE -> parseComposite(value);\n\t\t};\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#print(value,style)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style) {\n\t\treturn print(value, style, null);\n\t}"
  },
  "org.springframework.format.datetime.standard.<unknown>#print(value,style,unit)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Print the specified duration in the specified style using the given unit.\n\t * @param value the value to print\n\t * @param style the style to print in\n\t * @param unit the unit to use for printing, if relevant ({@code null} will default\n\t * to ms)\n\t * @return the printed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "style",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "String",
    "signature": "public String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit)",
    "source_code": "\tpublic static String print(Duration value, DurationFormat.Style style, @Nullable DurationFormat.Unit unit) {\n\t\treturn switch (style) {\n\t\t\tcase ISO8601 -> value.toString();\n\t\t\tcase SIMPLE -> printSimple(value, unit);\n\t\t\tcase COMPOSITE -> printComposite(value);\n\t\t};\n\t}"
  },
  "org.springframework.format.support.<unknown>#addFormatterForFieldType(fieldType,formatter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldType",
      "formatter"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "public void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter)",
    "source_code": "\tpublic void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter) {\n\t\taddConverter(new PrinterConverter(fieldType, formatter, this));\n\t\taddConverter(new ParserConverter(fieldType, formatter, this));\n\t}"
  },
  "org.springframework.format.support.<unknown>#addFormatterForFieldType(fieldType,printer,parser)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fieldType",
      "printer",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "void",
    "signature": "public void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser)",
    "source_code": "\tpublic void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser) {\n\t\taddConverter(new PrinterConverter(fieldType, printer, this));\n\t\taddConverter(new ParserConverter(fieldType, parser, this));\n\t}"
  },
  "org.springframework.format.support.<unknown>#convert(source,sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 324
    },
    "return": "Object",
    "signature": "public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tAnnotation ann = targetType.getAnnotation(this.annotationType);\n\t\t\tif (ann == null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Expected [\" + this.annotationType.getName() + \"] to be present on \" + targetType);\n\t\t\t}\n\t\t\tAnnotationConverterKey converterKey = new AnnotationConverterKey(ann, targetType.getObjectType());\n\t\t\tGenericConverter converter = cachedParsers.get(converterKey);\n\t\t\tif (converter == null) {\n\t\t\t\tParser<?> parser = this.annotationFormatterFactory.getParser(\n\t\t\t\t\t\tconverterKey.getAnnotation(), converterKey.getFieldType());\n\t\t\t\tconverter = new ParserConverter(this.fieldType, parser, FormattingConversionService.this);\n\t\t\t\tcachedParsers.put(converterKey, converter);\n\t\t\t}\n\t\t\treturn converter.convert(source, sourceType, targetType);\n\t\t}"
  },
  "org.springframework.format.support.<unknown>#matches(sourceType,targetType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sourceType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 317
    },
    "return": "boolean",
    "signature": "public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)",
    "source_code": "\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn targetType.hasAnnotation(this.annotationType);\n\t\t}"
  },
  "org.springframework.http.<unknown>#ETag(tag,weak)": {
    "deprecated": false,
    "doc": "/**\n * Represents an ETag for HTTP conditional requests.\n *\n * @author Rossen Stoyanchev\n * @since 5.3.38\n * @param tag the unquoted tag value\n * @param weak whether the entity tag is for weak or strong validation\n * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc7232\">RFC 7232</a>\n */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag",
      "weak"
    ],
    "position": {
      "column": 1,
      "line": 36
    },
    "return": "record",
    "signature": "public record ETag(String tag, boolean weak)",
    "source_code": "public record ETag(String tag, boolean weak) {\n\n\tprivate static final Log logger = LogFactory.getLog(ETag.class);\n\n\tprivate static final ETag WILDCARD = new ETag(\"*\", false);\n\n\n\t/**\n\t * Whether this a wildcard tag matching to any entity tag value.\n\t */\n\tpublic boolean isWildcard() {\n\t\treturn (this == WILDCARD);\n\t}\n\n\t/**\n\t * Perform a strong or weak comparison to another {@link ETag}.\n\t * @param other the ETag to compare to\n\t * @param strong whether to perform strong or weak comparison\n\t * @return whether there is a match or not\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3.2\">RFC 9110, Section 8.8.3.2</a>\n\t */\n\tpublic boolean compare(ETag other, boolean strong) {\n\t\tif (!StringUtils.hasLength(tag()) || !StringUtils.hasLength(other.tag())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strong && (weak() || other.weak())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tag().equals(other.tag());\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\treturn (this == other ||\n\t\t\t\t(other instanceof ETag oet && this.tag.equals(oet.tag) && this.weak == oet.weak));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = this.tag.hashCode();\n\t\tresult = 31 * result + Boolean.hashCode(this.weak);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn formattedTag();\n\t}\n\n\t/**\n\t * Return the fully formatted tag including \"W/\" prefix and quotes.\n\t */\n\tpublic String formattedTag() {\n\t\tif (isWildcard()) {\n\t\t\treturn \"*\";\n\t\t}\n\t\treturn (this.weak ? \"W/\" : \"\") + \"\\\"\" + this.tag + \"\\\"\";\n\t}\n\n\n\t/**\n\t * Create an {@link ETag} instance from a String representation.\n\t * @param rawValue the formatted ETag value\n\t * @return the created instance\n\t * @since 6.2\n\t */\n\tpublic static ETag create(String rawValue) {\n\t\tboolean weak = rawValue.startsWith(\"W/\");\n\t\tif (weak) {\n\t\t\trawValue = rawValue.substring(2);\n\t\t}\n\t\tif (rawValue.length() > 2 && rawValue.startsWith(\"\\\"\") && rawValue.endsWith(\"\\\"\")) {\n\t\t\trawValue = rawValue.substring(1, rawValue.length() - 1);\n\t\t}\n\t\treturn new ETag(rawValue, weak);\n\t}\n\n\t/**\n\t * Parse entity tags from an \"If-Match\" or \"If-None-Match\" header.\n\t * @param source the source string to parse\n\t * @return the parsed ETags\n\t */\n\tpublic static List<ETag> parse(String source) {\n\n\t\tList<ETag> result = new ArrayList<>();\n\t\tState state = State.BEFORE_QUOTES;\n\t\tint startIndex = -1;\n\t\tboolean weak = false;\n\n\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\tchar c = source.charAt(i);\n\n\t\t\tif (state == State.IN_QUOTES) {\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\tString tag = source.substring(startIndex, i);\n\t\t\t\t\tif (StringUtils.hasText(tag)) {\n\t\t\t\t\t\tresult.add(new ETag(tag, weak));\n\t\t\t\t\t}\n\t\t\t\t\tstate = State.AFTER_QUOTES;\n\t\t\t\t\tstartIndex = -1;\n\t\t\t\t\tweak = false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Character.isWhitespace(c)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c == ',') {\n\t\t\t\tstate = State.BEFORE_QUOTES;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == State.BEFORE_QUOTES) {\n\t\t\t\tif (c == '*') {\n\t\t\t\t\tresult.add(WILDCARD);\n\t\t\t\t\tstate = State.AFTER_QUOTES;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c == '\"') {\n\t\t\t\t\tstate = State.IN_QUOTES;\n\t\t\t\t\tstartIndex = i + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c == 'W' && source.length() > i + 2) {\n\t\t\t\t\tif (source.charAt(i + 1) == '/' && source.charAt(i + 2) == '\"') {\n\t\t\t\t\t\tstate = State.IN_QUOTES;\n\t\t\t\t\t\ti = i + 2;\n\t\t\t\t\t\tstartIndex = i + 1;\n\t\t\t\t\t\tweak = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Unexpected char at index \" + i);\n\t\t\t}\n\t\t}\n\n\t\tif (state != State.IN_QUOTES && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Expected closing '\\\"'\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Add quotes around the ETag value if not present already.\n\t * @param tag the ETag value\n\t * @return the resulting, quoted value\n\t * @since 6.2\n\t */\n\tpublic static String quoteETagIfNecessary(String tag) {\n\t\tif (tag.startsWith(\"W/\\\"\")) {\n\t\t\tif (tag.length() > 3 && tag.endsWith(\"\\\"\")) {\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t}\n\t\telse if (tag.startsWith(\"\\\"\")) {\n\t\t\tif (tag.length() > 1 && tag.endsWith(\"\\\"\")) {\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t}\n\t\treturn (\"\\\"\" + tag + \"\\\"\");\n\t}\n\n\n\tprivate enum State {\n\n\t\tBEFORE_QUOTES, IN_QUOTES, AFTER_QUOTES\n\n\t}\n\n}"
  },
  "org.springframework.http.<unknown>#add(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 1734
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.add(headerName, headerValue);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1744
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tthis.headers.addAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1739
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.addAll(key, values);\n\t}"
  },
  "org.springframework.http.<unknown>#body(body,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "RequestEntity<T>",
    "signature": "public RequestEntity<T> body(T body, Type type)",
    "source_code": "\t\tpublic <T> RequestEntity<T> body(T body, Type type) {\n\t\t\treturn buildInternal(body, type);\n\t\t}"
  },
  "org.springframework.http.<unknown>#checkParameters(parameter,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "void",
    "signature": "protected void checkParameters(String parameter, String value)",
    "source_code": "\tprotected void checkParameters(String parameter, String value) {\n\t\tsuper.checkParameters(parameter, value);\n\t\tif (PARAM_QUALITY_FACTOR.equals(parameter)) {\n\t\t\tString unquotedValue = unquote(value);\n\t\t\tdouble d = Double.parseDouble(unquotedValue);\n\t\t\tAssert.isTrue(d >= 0D && d <= 1D,\n\t\t\t\t\t() -> \"Invalid quality value \\\"\" + unquotedValue + \"\\\": should be between 0.0 and 1.0\");\n\t\t}\n\t}"
  },
  "org.springframework.http.<unknown>#compare(other,strong)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a strong or weak comparison to another {@link ETag}.\n\t * @param other the ETag to compare to\n\t * @param strong whether to perform strong or weak comparison\n\t * @return whether there is a match or not\n\t * @since 6.2\n\t * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#section-8.8.3.2\">RFC 9110, Section 8.8.3.2</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "strong"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "boolean",
    "signature": "public boolean compare(ETag other, boolean strong)",
    "source_code": "\tpublic boolean compare(ETag other, boolean strong) {\n\t\tif (!StringUtils.hasLength(tag()) || !StringUtils.hasLength(other.tag())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strong && (weak() || other.weak())) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tag().equals(other.tag());\n\t}"
  },
  "org.springframework.http.<unknown>#compareParameters(mediaType1,mediaType2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mediaType1",
      "mediaType2"
    ],
    "position": {
      "column": 1,
      "line": 972
    },
    "return": "int",
    "signature": "protected int compareParameters(MediaType mediaType1, MediaType mediaType2)",
    "source_code": "\t\tprotected int compareParameters(MediaType mediaType1, MediaType mediaType2) {\n\t\t\tdouble quality1 = mediaType1.getQualityValue();\n\t\t\tdouble quality2 = mediaType2.getQualityValue();\n\t\t\tint qualityComparison = Double.compare(quality2, quality1);\n\t\t\tif (qualityComparison != 0) {\n\t\t\t\treturn qualityComparison;  // audio/*;q=0.7 < audio/*;q=0.3\n\t\t\t}\n\t\t\treturn super.compareParameters(mediaType1, mediaType2);\n\t\t}"
  },
  "org.springframework.http.<unknown>#createByteRange(firstBytePos,lastBytePos)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code HttpRange} from the given fist to last position.\n\t * @param firstBytePos the first byte position\n\t * @param lastBytePos the last byte position\n\t * @return a byte range that ranges from {@code firstPos} till {@code lastPos}\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7233#section-2.1\">Byte Ranges</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "firstBytePos",
      "lastBytePos"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "HttpRange",
    "signature": "public HttpRange createByteRange(long firstBytePos, long lastBytePos)",
    "source_code": "\tpublic static HttpRange createByteRange(long firstBytePos, long lastBytePos) {\n\t\treturn new ByteRange(firstBytePos, lastBytePos);\n\t}"
  },
  "org.springframework.http.<unknown>#encodeBasicAuth(username,password,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Encode the given username and password into Basic Authentication credentials.\n\t * <p>The encoded credentials returned by this method can be supplied to\n\t * {@link #setBasicAuth(String)} to set the Basic Authentication header.\n\t * @param username the username\n\t * @param password the password\n\t * @param charset the charset to use to convert the credentials into an octet\n\t * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.\n\t * @throws IllegalArgumentException if {@code username} or {@code password}\n\t * contains characters that cannot be encoded to the given charset\n\t * @since 5.2\n\t * @see #setBasicAuth(String)\n\t * @see #setBasicAuth(String, String)\n\t * @see #setBasicAuth(String, String, Charset)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7617\">RFC 7617</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 1940
    },
    "return": "String",
    "signature": "public String encodeBasicAuth(String username, String password, @Nullable Charset charset)",
    "source_code": "\tpublic static String encodeBasicAuth(String username, String password, @Nullable Charset charset) {\n\t\tAssert.notNull(username, \"Username must not be null\");\n\t\tAssert.doesNotContain(username, \":\", \"Username must not contain a colon\");\n\t\tAssert.notNull(password, \"Password must not be null\");\n\t\tif (charset == null) {\n\t\t\tcharset = StandardCharsets.ISO_8859_1;\n\t\t}\n\n\t\tCharsetEncoder encoder = charset.newEncoder();\n\t\tif (!encoder.canEncode(username) || !encoder.canEncode(password)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Username or password contains characters that cannot be encoded to \" + charset.displayName());\n\t\t}\n\n\t\tString credentialsString = username + \":\" + password;\n\t\tbyte[] encodedBytes = Base64.getEncoder().encode(credentialsString.getBytes(charset));\n\t\treturn new String(encodedBytes, charset);\n\t}"
  },
  "org.springframework.http.<unknown>#filename(filename,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filename",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "Builder",
    "signature": "public Builder filename(@Nullable String filename, @Nullable Charset charset)",
    "source_code": "\t\tpublic Builder filename(@Nullable String filename, @Nullable Charset charset) {\n\t\t\tthis.filename = filename;\n\t\t\tthis.charset = charset;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#forEach(String,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1840
    },
    "return": "void",
    "signature": "public void forEach(BiConsumer<? super String, ? super List<String>> action)",
    "source_code": "\tpublic void forEach(BiConsumer<? super String, ? super List<String>> action) {\n\t\tthis.headers.forEach(action);\n\t}"
  },
  "org.springframework.http.<unknown>#forStatusAndDetail(status,detail)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@code ProblemDetail} instance with the given status and detail.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "detail"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "ProblemDetail",
    "signature": "public ProblemDetail forStatusAndDetail(HttpStatusCode status, @Nullable String detail)",
    "source_code": "\tpublic static ProblemDetail forStatusAndDetail(HttpStatusCode status, @Nullable String detail) {\n\t\tAssert.notNull(status, \"HttpStatusCode is required\");\n\t\tProblemDetail problemDetail = forStatus(status.value());\n\t\tproblemDetail.setDetail(detail);\n\t\treturn problemDetail;\n\t}"
  },
  "org.springframework.http.<unknown>#formatHeaders(MultiValueMap<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Helps to format HTTP header values, as HTTP header values themselves can\n\t * contain comma-separated values, can become confusing with regular\n\t * {@link Map} formatting that also uses commas between entries.\n\t * @param headers the headers to format\n\t * @return the headers to a String\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1913
    },
    "return": "String",
    "signature": "public String formatHeaders(MultiValueMap<String, String> headers)",
    "source_code": "\tpublic static String formatHeaders(MultiValueMap<String, String> headers) {\n\t\treturn headers.entrySet().stream()\n\t\t\t\t.map(entry -> {\n\t\t\t\t\tList<String> values = entry.getValue();\n\t\t\t\t\treturn entry.getKey() + \":\" + (values.size() == 1 ?\n\t\t\t\t\t\t\t\"\\\"\" + values.get(0) + \"\\\"\" :\n\t\t\t\t\t\t\tvalues.stream().map(s -> \"\\\"\" + s + \"\\\"\").collect(Collectors.joining(\", \")));\n\t\t\t\t})\n\t\t\t\t.collect(Collectors.joining(\", \", \"[\", \"]\"));\n\t}"
  },
  "org.springframework.http.<unknown>#from(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie that starts\n\t * with a name-value pair and may also include attributes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder from(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder from(final String name, final String value) {\n\t\treturn new DefaultResponseCookieBuilder(name, value, false);\n\t}"
  },
  "org.springframework.http.<unknown>#fromClientResponse(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Factory method to obtain a builder for a server-defined cookie. Unlike\n\t * {@link #from(String, String)} this option assumes input from a remote\n\t * server, which can be handled more leniently, for example, ignoring an empty domain\n\t * name with double quotes.\n\t * @param name the cookie name\n\t * @param value the cookie value\n\t * @return a builder to create the cookie with\n\t * @since 5.2.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "ResponseCookieBuilder",
    "signature": "public ResponseCookieBuilder fromClientResponse(final String name, final String value)",
    "source_code": "\tpublic static ResponseCookieBuilder fromClientResponse(final String name, final String value) {\n\t\treturn new DefaultResponseCookieBuilder(name, value, true);\n\t}"
  },
  "org.springframework.http.<unknown>#header(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic BodyBuilder header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tthis.headers.add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.<unknown>#method(method,uriTemplate,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Map<String, ?> uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#method(method,uriTemplate,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given HTTP method, URI template, and variables.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, String uriTemplate, Object... uriVariables) {\n\t\treturn new DefaultBodyBuilder(method, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#method(method,url)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder with the given method and url.\n\t * @param method the HTTP method (GET, POST, etc)\n\t * @param url the URL\n\t * @return the created builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder method(HttpMethod method, URI url)",
    "source_code": "\tpublic static BodyBuilder method(HttpMethod method, URI url) {\n\t\treturn new DefaultBodyBuilder(method, url);\n\t}"
  },
  "org.springframework.http.<unknown>#patch(uriTemplate,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PATCH builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder patch(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder patch(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PATCH, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#post(uriTemplate,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP POST builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder post(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder post(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.POST, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1805
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.http.<unknown>#put(uriTemplate,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an HTTP PUT builder with the given string base uri template.\n\t * @param uriTemplate the uri template to use\n\t * @param uriVariables variables to expand the URI template with\n\t * @return the created builder\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "BodyBuilder",
    "signature": "public BodyBuilder put(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic static BodyBuilder put(String uriTemplate, Object... uriVariables) {\n\t\treturn method(HttpMethod.PUT, uriTemplate, uriVariables);\n\t}"
  },
  "org.springframework.http.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 1815
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.http.<unknown>#putIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1845
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.http.<unknown>#readOnlyHttpHeaders(MultiValueMap<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply a read-only {@code HttpHeaders} wrapper around the given headers, if necessary.\n\t * <p>Also caches the parsed representations of the \"Accept\" and \"Content-Type\" headers.\n\t * @param headers the headers to expose\n\t * @return a read-only variant of the headers, or the original headers as-is\n\t * (in case it happens to be a read-only {@code HttpHeaders} instance already)\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 1874
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders readOnlyHttpHeaders(MultiValueMap<String, String> headers)",
    "source_code": "\tpublic static HttpHeaders readOnlyHttpHeaders(MultiValueMap<String, String> headers) {\n\t\treturn (headers instanceof HttpHeaders httpHeaders ? readOnlyHttpHeaders(httpHeaders) :\n\t\t\t\tnew ReadOnlyHttpHeaders(headers));\n\t}"
  },
  "org.springframework.http.<unknown>#set(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 1757
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.set(headerName, headerValue);\n\t}"
  },
  "org.springframework.http.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1762
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.http.<unknown>#setBasicAuth(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to\n\t * Basic Authentication based on the given username and password.\n\t * <p>Note that this method only supports characters in the\n\t * {@link StandardCharsets#ISO_8859_1 ISO-8859-1} character set.\n\t * @param username the username\n\t * @param password the password\n\t * @throws IllegalArgumentException if either {@code user} or\n\t * {@code password} contain characters that cannot be encoded to ISO-8859-1\n\t * @since 5.1\n\t * @see #setBasicAuth(String)\n\t * @see #setBasicAuth(String, String, Charset)\n\t * @see #encodeBasicAuth(String, String, Charset)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7617\">RFC 7617</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "void",
    "signature": "public void setBasicAuth(String username, String password)",
    "source_code": "\tpublic void setBasicAuth(String username, String password) {\n\t\tsetBasicAuth(username, password, null);\n\t}"
  },
  "org.springframework.http.<unknown>#setBasicAuth(username,password,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value of the {@linkplain #AUTHORIZATION Authorization} header to\n\t * Basic Authentication based on the given username and password.\n\t * @param username the username\n\t * @param password the password\n\t * @param charset the charset to use to convert the credentials into an octet\n\t * sequence. Defaults to {@linkplain StandardCharsets#ISO_8859_1 ISO-8859-1}.\n\t * @throws IllegalArgumentException if {@code username} or {@code password}\n\t * contains characters that cannot be encoded to the given charset\n\t * @since 5.1\n\t * @see #setBasicAuth(String)\n\t * @see #setBasicAuth(String, String)\n\t * @see #encodeBasicAuth(String, String, Charset)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7617\">RFC 7617</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 817
    },
    "return": "void",
    "signature": "public void setBasicAuth(String username, String password, @Nullable Charset charset)",
    "source_code": "\tpublic void setBasicAuth(String username, String password, @Nullable Charset charset) {\n\t\tsetBasicAuth(encodeBasicAuth(username, password, charset));\n\t}"
  },
  "org.springframework.http.<unknown>#setContentDispositionFormData(name,filename)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code Content-Disposition} header when creating a\n\t * {@code \"multipart/form-data\"} request.\n\t * <p>Applications typically would not set this header directly but\n\t * rather prepare a {@code MultiValueMap<String, Object>}, containing an\n\t * Object or a {@link org.springframework.core.io.Resource} for each part,\n\t * and then pass that to the {@code RestTemplate} or {@code WebClient}.\n\t * @param name the control name\n\t * @param filename the filename (may be {@code null})\n\t * @see #getContentDisposition()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "filename"
    ],
    "position": {
      "column": 1,
      "line": 909
    },
    "return": "void",
    "signature": "public void setContentDispositionFormData(String name, @Nullable String filename)",
    "source_code": "\tpublic void setContentDispositionFormData(String name, @Nullable String filename) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tContentDisposition.Builder disposition = ContentDisposition.formData().name(name);\n\t\tif (StringUtils.hasText(filename)) {\n\t\t\tdisposition.filename(filename);\n\t\t}\n\t\tsetContentDisposition(disposition.build());\n\t}"
  },
  "org.springframework.http.<unknown>#setDate(headerName,date)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 3.2.4\n\t * @see #setZonedDateTime(String, ZonedDateTime)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1466
    },
    "return": "void",
    "signature": "public void setDate(String headerName, long date)",
    "source_code": "\tpublic void setDate(String headerName, long date) {\n\t\tsetInstant(headerName, Instant.ofEpochMilli(date));\n\t}"
  },
  "org.springframework.http.<unknown>#setInstant(headerName,date)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 5.1.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1455
    },
    "return": "void",
    "signature": "public void setInstant(String headerName, Instant date)",
    "source_code": "\tpublic void setInstant(String headerName, Instant date) {\n\t\tsetZonedDateTime(headerName, ZonedDateTime.ofInstant(date, GMT));\n\t}"
  },
  "org.springframework.http.<unknown>#setProperties(Map<String,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Setter for the {@link #getProperties() properties map}.\n\t * <p>By default, this is not set.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param properties the properties map\n\t * @since 6.0.14\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void setProperties(@Nullable Map<String, Object> properties)",
    "source_code": "\tpublic void setProperties(@Nullable Map<String, Object> properties) {\n\t\tthis.properties = properties;\n\t}"
  },
  "org.springframework.http.<unknown>#setProperty(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a \"dynamic\" property to be added to a generic {@link #getProperties()\n\t * properties map}.\n\t * <p>When Jackson JSON is present on the classpath, any properties set here\n\t * are rendered as top level key-value pairs in the output JSON. Otherwise,\n\t * they are rendered as a {@code \"properties\"} sub-map.\n\t * @param name the property name\n\t * @param value the property value, possibly {@code null} if the intent is\n\t * to include a property with its value set to \"null\"\n\t * @see org.springframework.http.converter.json.ProblemDetailJacksonMixin\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "public void setProperty(String name, @Nullable Object value)",
    "source_code": "\tpublic void setProperty(String name, @Nullable Object value) {\n\t\tthis.properties = (this.properties != null ? this.properties : new LinkedHashMap<>());\n\t\tthis.properties.put(name, value);\n\t}"
  },
  "org.springframework.http.<unknown>#setZonedDateTime(headerName,date)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given date under the given header name after formatting it as a string\n\t * using the RFC-1123 date-time formatter. The equivalent of\n\t * {@link #set(String, String)} but for date headers.\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 1445
    },
    "return": "void",
    "signature": "public void setZonedDateTime(String headerName, ZonedDateTime date)",
    "source_code": "\tpublic void setZonedDateTime(String headerName, ZonedDateTime date) {\n\t\tset(headerName, DATE_FORMATTER.format(date));\n\t}"
  },
  "org.springframework.http.<unknown>#toResourceRegions(ranges,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert each {@code HttpRange} into a {@code ResourceRegion}, selecting the\n\t * appropriate segment of the given {@code Resource} using HTTP Range information.\n\t * @param ranges the list of ranges\n\t * @param resource the resource to select the regions from\n\t * @return the list of regions for the given resource\n\t * @throws IllegalArgumentException if the sum of all ranges exceeds the resource length\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ranges",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "List<ResourceRegion>",
    "signature": "public List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource)",
    "source_code": "\tpublic static List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource) {\n\t\tif (CollectionUtils.isEmpty(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<ResourceRegion> regions = new ArrayList<>(ranges.size());\n\t\tfor (HttpRange range : ranges) {\n\t\t\tregions.add(range.toResourceRegion(resource));\n\t\t}\n\t\tif (ranges.size() > 1) {\n\t\t\tlong length = getLengthFor(resource);\n\t\t\tlong total = 0;\n\t\t\tfor (ResourceRegion region : regions) {\n\t\t\t\ttotal += region.getCount();\n\t\t\t}\n\t\t\tif (total >= length) {\n\t\t\t\tthrow new IllegalArgumentException(\"The sum of all ranges (\" + total +\n\t\t\t\t\t\t\") should be less than the resource length (\" + length + \")\");\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part from {@link Publisher} content.\n\t * @param name the name of the part to add\n\t * @param publisher a Publisher of content for the part\n\t * @param elementClass the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(String name, P publisher, Class<T> elementClass) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, elementClass);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#asyncPart(name,publisher,typeReference)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #asyncPart(String, Publisher, Class)} with a\n\t * {@link ParameterizedTypeReference} for the element type information.\n\t * @param name the name of the part to add\n\t * @param publisher the part contents\n\t * @param typeReference the type of elements contained in the publisher\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder asyncPart(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic <T, P extends Publisher<T>> PartBuilder asyncPart(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(typeReference, \"'typeReference' must not be null\");\n\n\t\tPublisherPartBuilder<T, P> builder = new PublisherPartBuilder<>(name, null, publisher, typeReference);\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#createHttpContext(httpMethod,uri)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template methods that creates a {@link HttpContext} for the given HTTP method and URI.\n\t * <p>The default implementation returns {@code null}.\n\t * @param httpMethod the HTTP method\n\t * @param uri the URI\n\t * @return the http context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpMethod",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "HttpContext",
    "signature": "protected HttpContext createHttpContext(HttpMethod httpMethod, URI uri)",
    "source_code": "\tprotected HttpContext createHttpContext(HttpMethod httpMethod, URI uri) {\n\t\treturn (this.httpContextFactory != null ? this.httpContextFactory.apply(httpMethod, uri) : null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#createHttpUriRequest(httpMethod,uri)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Commons HttpMethodBase object for the given HTTP method and URI specification.\n\t * @param httpMethod the HTTP method\n\t * @param uri the URI\n\t * @return the Commons HttpMethodBase object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpMethod",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "ClassicHttpRequest",
    "signature": "protected ClassicHttpRequest createHttpUriRequest(HttpMethod httpMethod, URI uri)",
    "source_code": "\tprotected ClassicHttpRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {\n\t\tif (HttpMethod.GET.equals(httpMethod)) {\n\t\t\treturn new HttpGet(uri);\n\t\t}\n\t\telse if (HttpMethod.HEAD.equals(httpMethod)) {\n\t\t\treturn new HttpHead(uri);\n\t\t}\n\t\telse if (HttpMethod.POST.equals(httpMethod)) {\n\t\t\treturn new HttpPost(uri);\n\t\t}\n\t\telse if (HttpMethod.PUT.equals(httpMethod)) {\n\t\t\treturn new HttpPut(uri);\n\t\t}\n\t\telse if (HttpMethod.PATCH.equals(httpMethod)) {\n\t\t\treturn new HttpPatch(uri);\n\t\t}\n\t\telse if (HttpMethod.DELETE.equals(httpMethod)) {\n\t\t\treturn new HttpDelete(uri);\n\t\t}\n\t\telse if (HttpMethod.OPTIONS.equals(httpMethod)) {\n\t\t\treturn new HttpOptions(uri);\n\t\t}\n\t\telse if (HttpMethod.TRACE.equals(httpMethod)) {\n\t\t\treturn new HttpTrace(uri);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid HTTP method: \" + httpMethod);\n\t}"
  },
  "org.springframework.http.client.<unknown>#createRequest(uri,httpMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 241
    },
    "return": "ClientHttpRequest",
    "signature": "public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod)",
    "source_code": "\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpClient client = getHttpClient();\n\n\t\tClassicHttpRequest httpRequest = createHttpUriRequest(httpMethod, uri);\n\t\tpostProcessHttpRequest(httpRequest);\n\t\tHttpContext context = createHttpContext(httpMethod, uri);\n\t\tif (context == null) {\n\t\t\tcontext = HttpClientContext.create();\n\t\t}\n\n\t\t// Request configuration not set in the context\n\t\tif (context.getAttribute(HttpClientContext.REQUEST_CONFIG) == null) {\n\t\t\t// Use request configuration given by the user, when available\n\t\t\tRequestConfig config = null;\n\t\t\tif (httpRequest instanceof Configurable configurable) {\n\t\t\t\tconfig = configurable.getConfig();\n\t\t\t}\n\t\t\tif (config == null) {\n\t\t\t\tconfig = createRequestConfig(client);\n\t\t\t}\n\t\t\tif (config != null) {\n\t\t\t\tcontext.setAttribute(HttpClientContext.REQUEST_CONFIG, config);\n\t\t\t}\n\t\t}\n\t\treturn new HttpComponentsClientHttpRequest(client, httpRequest, context);\n\t}"
  },
  "org.springframework.http.client.<unknown>#execute(request,body)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "ClientHttpResponse",
    "signature": "public ClientHttpResponse execute(HttpRequest request, byte[] body)",
    "source_code": "\t\tpublic ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {\n\t\t\tif (this.iterator.hasNext()) {\n\t\t\t\tClientHttpRequestInterceptor nextInterceptor = this.iterator.next();\n\t\t\t\treturn nextInterceptor.intercept(request, body, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpMethod method = request.getMethod();\n\t\t\t\tClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);\n\t\t\t\trequest.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));\n\t\t\t\trequest.getAttributes().forEach((key, value) -> delegate.getAttributes().put(key, value));\n\t\t\t\tif (body.length > 0) {\n\t\t\t\t\tlong contentLength = delegate.getHeaders().getContentLength();\n\t\t\t\t\tif (contentLength > -1 && contentLength != body.length) {\n\t\t\t\t\t\tdelegate.getHeaders().setContentLength(body.length);\n\t\t\t\t\t}\n\t\t\t\t\tif (delegate instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\t\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\t\t\tStreamUtils.copy(body, outputStream);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tStreamUtils.copy(body, delegate.getBody());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn delegate.execute();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,body)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "body"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {\n\t\tCompletableFuture<HttpResponse<InputStream>> responseFuture = null;\n\t\ttry {\n\t\t\tHttpRequest request = buildRequest(headers, body);\n\t\t\tresponseFuture = this.httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofInputStream());\n\n\t\t\tif (this.timeout != null) {\n\t\t\t\tTimeoutHandler timeoutHandler = new TimeoutHandler(responseFuture, this.timeout);\n\t\t\t\tHttpResponse<InputStream> response = responseFuture.get();\n\t\t\t\tInputStream inputStream = timeoutHandler.wrapInputStream(response);\n\t\t\t\treturn new JdkClientHttpResponse(response, inputStream);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tHttpResponse<InputStream> response = responseFuture.get();\n\t\t\t\treturn new JdkClientHttpResponse(response, response.body());\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t\tresponseFuture.cancel(true);\n\t\t\tthrow new IOException(\"Request was interrupted: \" + ex.getMessage(), ex);\n\t\t}\n\t\tcatch (ExecutionException ex) {\n\t\t\tThrowable cause = ex.getCause();\n\n\t\t\tif (cause instanceof CancellationException caEx) {\n\t\t\t\tthrow new HttpTimeoutException(\"Request timed out\");\n\t\t\t}\n\t\t\tif (cause instanceof UncheckedIOException uioEx) {\n\t\t\t\tthrow uioEx.getCause();\n\t\t\t}\n\t\t\tif (cause instanceof RuntimeException rtEx) {\n\t\t\t\tthrow rtEx;\n\t\t\t}\n\t\t\telse if (cause instanceof IOException ioEx) {\n\t\t\t\tthrow ioEx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IOException(cause.getMessage(), cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.client.<unknown>#executeInternal(headers,bufferedOutput)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "bufferedOutput"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "ClientHttpResponse",
    "signature": "protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput)",
    "source_code": "\tprotected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {\n\t\tthis.request.getHeaders().putAll(headers);\n\n\t\tif (bufferedOutput.length > 0) {\n\t\t\tif (this.request instanceof StreamingHttpOutputMessage streamingHttpOutputMessage) {\n\t\t\t\tstreamingHttpOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\t\tStreamUtils.copy(bufferedOutput, outputStream);\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStreamUtils.copy(bufferedOutput, this.request.getBody());\n\t\t\t}\n\t\t}\n\n\t\tClientHttpResponse response = this.request.execute();\n\t\treturn new BufferingClientHttpResponseWrapper(response);\n\t}"
  },
  "org.springframework.http.client.<unknown>#header(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic PartBuilder header(String headerName, String... headerValues) {\n\t\t\tinitHeadersIfNecessary().addAll(headerName, Arrays.asList(headerValues));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#map(b,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer map(byte[] b, int off, int len)",
    "source_code": "\t\tpublic ByteBuffer map(byte[] b, int off, int len) {\n\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(len);\n\t\t\tbyteBuffer.put(b, off, len);\n\t\t\tbyteBuffer.flip();\n\t\t\treturn byteBuffer;\n\t\t}"
  },
  "org.springframework.http.client.<unknown>#openConnection(url,proxy)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Opens and returns a connection to the given URL.\n\t * <p>The default implementation uses the given {@linkplain #setProxy(java.net.Proxy) proxy} -\n\t * if any - to open a connection.\n\t * @param url the URL to open a connection to\n\t * @param proxy the proxy to use, may be {@code null}\n\t * @return the opened connection\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "HttpURLConnection",
    "signature": "protected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy)",
    "source_code": "\tprotected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy) throws IOException {\n\t\tURLConnection urlConnection = (proxy != null ? url.openConnection(proxy) : url.openConnection());\n\t\tif (!(urlConnection instanceof HttpURLConnection httpUrlConnection)) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"HttpURLConnection required for [\" + url + \"] but got: \" + urlConnection);\n\t\t}\n\t\treturn httpUrlConnection;\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a part where the Object may be:\n\t * <ul>\n\t * <li>String -- form field\n\t * <li>{@link org.springframework.core.io.Resource Resource} -- file part\n\t * <li>Object -- content to be encoded (for example, to JSON).\n\t * <li>{@link HttpEntity} -- part content and headers although generally it's\n\t * easier to add headers through the returned builder\n\t * <li>{@link Part} -- a part from a server request\n\t * </ul>\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part)",
    "source_code": "\tpublic PartBuilder part(String name, Object part) {\n\t\treturn part(name, part, null);\n\t}"
  },
  "org.springframework.http.client.<unknown>#part(name,part,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #part(String, Object)} that also accepts a MediaType.\n\t * @param name the name of the part to add\n\t * @param part the part data\n\t * @param contentType the media type to help with encoding the part\n\t * @return builder that allows for further customization of part headers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "part",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "PartBuilder",
    "signature": "public PartBuilder part(String name, Object part, @Nullable MediaType contentType)",
    "source_code": "\tpublic PartBuilder part(String name, Object part, @Nullable MediaType contentType) {\n\t\tAssert.hasLength(name, \"'name' must not be empty\");\n\t\tAssert.notNull(part, \"'part' must not be null\");\n\n\t\tif (part instanceof Part partObject) {\n\t\t\tPartBuilder builder = asyncPart(name, partObject.content(), DataBuffer.class);\n\t\t\tif (!partObject.headers().isEmpty()) {\n\t\t\t\tbuilder.headers(headers -> {\n\t\t\t\t\theaders.putAll(partObject.headers());\n\t\t\t\t\tString filename = headers.getContentDisposition().getFilename();\n\t\t\t\t\t// reset to parameter name\n\t\t\t\t\theaders.setContentDispositionFormData(name, filename);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\n\t\tif (part instanceof PublisherEntity<?,?> publisherEntity) {\n\t\t\tPublisherPartBuilder<?, ?> builder = new PublisherPartBuilder<>(name, publisherEntity);\n\t\t\tif (contentType != null) {\n\t\t\t\tbuilder.contentType(contentType);\n\t\t\t}\n\t\t\tthis.parts.add(name, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tObject partBody;\n\t\tHttpHeaders partHeaders = null;\n\t\tif (part instanceof HttpEntity<?> httpEntity) {\n\t\t\tpartBody = httpEntity.getBody();\n\t\t\tpartHeaders = new HttpHeaders();\n\t\t\tpartHeaders.putAll(httpEntity.getHeaders());\n\t\t}\n\t\telse {\n\t\t\tpartBody = part;\n\t\t}\n\n\t\tif (partBody instanceof Publisher) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tUse asyncPart(String, Publisher, Class) \\\n\t\t\t\t\tor asyncPart(String, Publisher, ParameterizedTypeReference) \\\n\t\t\t\t\tor MultipartBodyBuilder.PublisherEntity\"\"\");\n\t\t}\n\n\t\tDefaultPartBuilder builder = new DefaultPartBuilder(name, partHeaders, partBody);\n\t\tif (contentType != null) {\n\t\t\tbuilder.contentType(contentType);\n\t\t}\n\t\tthis.parts.add(name, builder);\n\t\treturn builder;\n\t}"
  },
  "org.springframework.http.client.<unknown>#prepareConnection(connection,httpMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for preparing the given {@link HttpURLConnection}.\n\t * <p>The default implementation prepares the connection for input and output, and sets the HTTP method.\n\t * @param connection the connection to prepare\n\t * @param httpMethod the HTTP request method ({@code GET}, {@code POST}, etc.)\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "connection",
      "httpMethod"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "void",
    "signature": "protected void prepareConnection(HttpURLConnection connection, String httpMethod)",
    "source_code": "\tprotected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\t\tif (this.connectTimeout >= 0) {\n\t\t\tconnection.setConnectTimeout(this.connectTimeout);\n\t\t}\n\t\tif (this.readTimeout >= 0) {\n\t\t\tconnection.setReadTimeout(this.readTimeout);\n\t\t}\n\n\t\tboolean mayWrite =\n\t\t\t\t(\"POST\".equals(httpMethod) || \"PUT\".equals(httpMethod) ||\n\t\t\t\t\t\t\"PATCH\".equals(httpMethod) || \"DELETE\".equals(httpMethod));\n\n\t\tconnection.setDoInput(true);\n\t\tconnection.setInstanceFollowRedirects(\"GET\".equals(httpMethod));\n\t\tconnection.setDoOutput(mayWrite);\n\t\tconnection.setRequestMethod(httpMethod);\n\t}"
  },
  "org.springframework.http.client.<unknown>#setHttpContextFactory(BiFunction<HttpMethod,URI,httpContextFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a factory to pre-create the {@link HttpContext} for each request.\n\t * <p>This may be useful for example in mutual TLS authentication where a\n\t * different {@code RestTemplate} for each client certificate such that\n\t * all calls made through a given {@code RestTemplate} instance as associated\n\t * for the same client identity. {@link HttpClientContext#setUserToken(Object)}\n\t * can be used to specify a fixed user token for all requests.\n\t * @param httpContextFactory the context factory to use\n\t * @since 5.2.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<HttpMethod",
      "URI",
      "httpContextFactory"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "void",
    "signature": "public void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory)",
    "source_code": "\tpublic void setHttpContextFactory(BiFunction<HttpMethod, URI, HttpContext> httpContextFactory) {\n\t\tthis.httpContextFactory = httpContextFactory;\n\t}"
  },
  "org.springframework.http.codec.<unknown>#addDefaultHeaders(message,resource,contentType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adds the default headers for the given resource to the given message.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "resource",
      "contentType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> addDefaultHeaders(ReactiveHttpOutputMessage message, Resource resource, @Nullable MediaType contentType, Map<String, Object> hints) {\n\t\treturn Mono.defer(() -> {\n\t\t\tHttpHeaders headers = message.getHeaders();\n\t\t\tMediaType resourceMediaType = getResourceMediaType(contentType, resource, hints);\n\t\t\theaders.setContentType(resourceMediaType);\n\t\t\tif (message instanceof ServerHttpResponse) {\n\t\t\t\t// server side\n\t\t\t\theaders.set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t}\n\n\t\t\tif (headers.getContentLength() < 0) {\n\t\t\t\treturn lengthOf(resource)\n\t\t\t\t\t\t.flatMap(contentLength -> {\n\t\t\t\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t\t\t\t\treturn Mono.empty();\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canEncode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\treturn canSerialize(elementType, mimeType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canRead(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.decoder.canDecode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canSerialize(type,mimeType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether the given type can be serialized using Kotlin\n\t * serialization.\n\t * @param type the type to be serialized\n\t * @param mimeType the mimetype to use (can be {@code null})\n\t * @return {@code true} if {@code type} can be serialized; false otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "boolean",
    "signature": "protected boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType)",
    "source_code": "\tprotected final boolean canSerialize(ResolvableType type, @Nullable MimeType mimeType) {\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn (supports(mimeType) && !String.class.isAssignableFrom(type.toClass()) &&\n\t\t\t\t\t!ServerSentEvent.class.isAssignableFrom(type.toClass()));\n\t\t}\n\n\t}"
  },
  "org.springframework.http.codec.<unknown>#canWrite(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn this.encoder.canEncode(elementType, mediaType);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 94
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (inputStream instanceof Mono<?> mono) {\n\t\t\treturn mono\n\t\t\t\t\t.map(value -> encodeValue(value, bufferFactory, elementType, mimeType, hints))\n\t\t\t\t\t.flux();\n\t\t}\n\t\tif (mimeType != null && this.streamingMediaTypes.contains(mimeType)) {\n\t\t\treturn Flux.from(inputStream)\n\t\t\t\t\t.map(value -> encodeStreamingValue(value, bufferFactory, elementType, mimeType, hints, EMPTY_BYTES,\n\t\t\t\t\t\t\tNEWLINE_SEPARATOR));\n\t\t}\n\t\treturn encodeNonStream(inputStream, bufferFactory, elementType, mimeType, hints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encodeNonStream(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encodeNonStream(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encodeNonStream(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\n\t\treturn Flux.from(inputStream)\n\t\t\t\t.collectList()\n\t\t\t\t.map(list -> encodeValue(list, bufferFactory, listType, mimeType, hints))\n\t\t\t\t.flux();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encodeStreamingValue(value,bufferFactory,valueType,mimeType,Map<String,hints,prefix,suffix)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints",
      "prefix",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "DataBuffer",
    "signature": "protected DataBuffer encodeStreamingValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints, byte[] prefix, byte[] suffix)",
    "source_code": "\tprotected DataBuffer encodeStreamingValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints, byte[] prefix, byte[] suffix) {\n\n\t\tList<DataBuffer> buffers = new ArrayList<>(3);\n\t\tif (prefix.length > 0) {\n\t\t\tbuffers.add(bufferFactory.allocateBuffer(prefix.length).write(prefix));\n\t\t}\n\t\tbuffers.add(encodeValue(value, bufferFactory, valueType, mimeType, hints));\n\t\tif (suffix.length > 0) {\n\t\t\tbuffers.add(bufferFactory.allocateBuffer(suffix.length).write(suffix));\n\t\t}\n\t\treturn bufferFactory.join(buffers);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\tKSerializer<Object> serializer = serializer(valueType);\n\t\tif (serializer == null) {\n\t\t\tthrow new EncodingException(\"Could not find KSerializer for \" + valueType);\n\t\t}\n\t\tString string = format().encodeToString(serializer, value);\n\t\treturn this.charSequenceEncoder.encodeValue(string, bufferFactory, valueType, mimeType, null);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getReadHints(actualType,elementType,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the decoder if it is an instance of {@link HttpMessageDecoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType actualType,\n\t\t\tResolvableType elementType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.decoder instanceof HttpMessageDecoder<?> httpMessageDecoder) {\n\t\t\treturn httpMessageDecoder.getDecodeHints(actualType, elementType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getReadHints(elementType,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for decoding based on the input HTTP message.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "elementType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Object>",
    "signature": "protected Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message)",
    "source_code": "\tprotected Map<String, Object> getReadHints(ResolvableType elementType, ReactiveHttpInputMessage message) {\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#getWriteHints(streamType,elementType,mediaType,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get additional hints for encoding for example based on the server request\n\t * or annotations from controller method parameters. By default, delegate to\n\t * the encoder if it is an instance of {@link HttpMessageEncoder}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "streamType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Object>",
    "signature": "protected Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected Map<String, Object> getWriteHints(ResolvableType streamType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (this.encoder instanceof HttpMessageEncoder<?> httpMessageEncoder) {\n\t\t\treturn httpMessageEncoder.getEncodeHints(streamType, elementType, mediaType, request, response);\n\t\t}\n\t\treturn Hints.none();\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(actualType,elementType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn read(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#read(elementType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<T> read(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decode(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(actualType,elementType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetReadHints(actualType, elementType, request, response));\n\n\t\treturn readMono(elementType, request, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#readMono(elementType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<T> readMono(ResolvableType elementType, ReactiveHttpInputMessage message, Map<String, Object> hints) {\n\t\tMediaType contentType = getContentType(message);\n\t\tMap<String, Object> allHints = Hints.merge(hints, getReadHints(elementType, message));\n\t\treturn this.decoder.decodeToMono(message.getBody(), elementType, contentType, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tMap<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetEncodeHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(input, elementType, mediaType, response, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(input,elementType,mediaType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<?> input, ResolvableType elementType, @Nullable MediaType mediaType,\n\t\t\tReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tmediaType = (mediaType != null && mediaType.getCharset() != null ? mediaType : DEFAULT_MEDIA_TYPE);\n\t\tDataBufferFactory bufferFactory = message.bufferFactory();\n\n\t\tmessage.getHeaders().setContentType(mediaType);\n\t\treturn message.writeAndFlushWith(encode(input, elementType, mediaType, bufferFactory, hints));\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,actualType,elementType,mediaType,request,response,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType actualType,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ServerHttpRequest request,\n\t\t\tServerHttpResponse response, Map<String, Object> hints) {\n\n\t\tMap<String, Object> allHints = Hints.merge(hints,\n\t\t\t\tgetWriteHints(actualType, elementType, mediaType, request, response));\n\n\t\treturn write(inputStream, elementType, mediaType, response, allHints);\n\t}"
  },
  "org.springframework.http.codec.<unknown>#write(inputStream,elementType,mediaType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "elementType",
      "mediaType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends T> inputStream, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ReactiveHttpOutputMessage message, Map<String, Object> hints) {\n\n\t\tMediaType contentType = updateContentType(message, mediaType);\n\n\t\tFlux<DataBuffer> body = this.encoder.encode(\n\t\t\t\tinputStream, message.bufferFactory(), elementType, contentType, hints);\n\n\t\tif (inputStream instanceof Mono) {\n\t\t\treturn body\n\t\t\t\t\t.singleOrEmpty()\n\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> {\n\t\t\t\t\t\tmessage.getHeaders().setContentType(null);\n\t\t\t\t\t\tmessage.getHeaders().setContentLength(0);\n\t\t\t\t\t\treturn message.setComplete().then(Mono.empty());\n\t\t\t\t\t}))\n\t\t\t\t\t.flatMap(buffer -> {\n\t\t\t\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\t\t\t\t\t\tmessage.getHeaders().setContentLength(buffer.readableByteCount());\n\t\t\t\t\t\treturn message.writeWith(Mono.just(buffer)\n\t\t\t\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release));\n\t\t\t\t\t})\n\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t}\n\n\t\tif (isStreamingMediaType(contentType)) {\n\t\t\treturn message.writeAndFlushWith(body.map(buffer -> {\n\t\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\t\t\t\treturn Mono.just(buffer).doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\t\t\t}));\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\t\treturn message.writeWith(body);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#canDecode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "boolean",
    "signature": "public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (!supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (CharSequence.class.isAssignableFrom(elementType.toClass())) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = mapper.constructType(elementType.getType());\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canDeserialize(javaType);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canDeserialize(javaType, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#canEncode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (!supportsMimeType(mimeType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mimeType != null && mimeType.getCharset() != null) {\n\t\t\tCharset charset = mimeType.getCharset();\n\t\t\tif (!ENCODINGS.containsKey(charset.name())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> clazz = elementType.toClass();\n\t\tif (String.class.isAssignableFrom(elementType.resolve(clazz))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Object.class == clazz) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!logger.isDebugEnabled()) {\n\t\t\treturn mapper.canSerialize(clazz);\n\t\t}\n\t\telse {\n\t\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\t\tif (mapper.canSerialize(clazz, causeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeReader(reader,elementType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param elementType the target type of element values to read to\n\t * @param hints a map with serialization hints;\n\t * the Reactor Context, when available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectReader} to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectReader customizeReader(\n\t\t\tObjectReader reader, ResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn reader;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#customizeWriter(writer,mimeType,elementType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize the {@link ObjectWriter} used\n\t * for writing values.\n\t * @param writer the writer instance to customize\n\t * @param mimeType the selected MIME type\n\t * @param elementType the type of element values to write\n\t * @param hints a map with serialization hints; the Reactor Context, when\n\t * available, may be accessed under the key\n\t * {@code ContextView.class.getName()}\n\t * @return the customized {@code ObjectWriter} to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "writer",
      "mimeType",
      "elementType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "ObjectWriter",
    "signature": "protected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable MimeType mimeType,\n\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable MimeType mimeType,\n\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n\n\t\treturn writer;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decode(dataBuffer,targetType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffer",
      "targetType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "Object",
    "signature": "public Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Object decode(DataBuffer dataBuffer, ResolvableType targetType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {\n\n\t\tObjectMapper mapper = selectObjectMapper(targetType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + targetType);\n\t\t}\n\n\t\ttry {\n\t\t\tObjectReader objectReader = createObjectReader(mapper, targetType, hints);\n\t\t\tObject value = objectReader.readValue(dataBuffer.asInputStream());\n\t\t\tlogValue(value, hints);\n\t\t\treturn value;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow processException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decode(input,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Flux<Object>",
    "signature": "public Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<Object> decode(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\tif (mapper == null) {\n\t\t\treturn Flux.error(new IllegalStateException(\"No ObjectMapper for \" + elementType));\n\t\t}\n\n\t\tboolean forceUseOfBigDecimal = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n\t\tif (BigDecimal.class.equals(elementType.getType())) {\n\t\t\tforceUseOfBigDecimal = true;\n\t\t}\n\n\t\tboolean tokenizeArrays = (!elementType.isArray() &&\n\t\t\t\t!Collection.class.isAssignableFrom(elementType.resolve(Object.class)));\n\n\t\tFlux<DataBuffer> processed = processInput(input, elementType, mimeType, hints);\n\t\tFlux<TokenBuffer> tokens = Jackson2Tokenizer.tokenize(processed, mapper.getFactory(), mapper,\n\t\t\t\ttokenizeArrays, forceUseOfBigDecimal, getMaxInMemorySize());\n\n\t\treturn Flux.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\tObjectReader reader = createObjectReader(mapper, elementType, hintsToUse);\n\n\t\t\treturn tokens.handle((tokenBuffer, sink) -> {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = reader.readValue(tokenBuffer.asParser(mapper));\n\t\t\t\t\tlogValue(value, hints);\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tsink.next(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tsink.error(processException(ex));\n\t\t\t\t}\n\t\t\t})\n\t\t\t.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#decodeToMono(input,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Mono<Object> decodeToMono(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Mono.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\treturn DataBufferUtils.join(input, this.maxInMemorySize).flatMap(dataBuffer ->\n\t\t\t\t\tMono.justOrEmpty(decode(dataBuffer, elementType, mimeType, hintsToUse)));\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encode(inputStream,bufferFactory,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "bufferFactory",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic Flux<DataBuffer> encode(Publisher<?> inputStream, DataBufferFactory bufferFactory,\n\t\t\tResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tAssert.notNull(inputStream, \"'inputStream' must not be null\");\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.notNull(elementType, \"'elementType' must not be null\");\n\n\t\treturn Flux.deferContextual(contextView -> {\n\n\t\t\tMap<String, Object> hintsToUse = contextView.isEmpty() ? hints :\n\t\t\t\t\tHints.merge(hints, ContextView.class.getName(), contextView);\n\n\t\t\tif (inputStream instanceof Mono) {\n\t\t\t\treturn Mono.from(inputStream)\n\t\t\t\t\t\t.map(value -> encodeValue(value, bufferFactory, elementType, mimeType, hintsToUse))\n\t\t\t\t\t\t.flux();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tObjectMapper mapper = selectObjectMapper(elementType, mimeType);\n\t\t\t\tif (mapper == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + elementType);\n\t\t\t\t}\n\n\t\t\t\tObjectWriter writer = createObjectWriter(mapper, elementType, mimeType, null, hintsToUse);\n\t\t\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\t\t\t\tJsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding);\n\t\t\t\tSequenceWriter sequenceWriter = writer.writeValues(generator);\n\n\t\t\t\tbyte[] separator = getStreamingMediaTypeSeparator(mimeType);\n\t\t\t\tFlux<DataBuffer> dataBufferFlux;\n\n\t\t\t\tif (separator != null) {\n\t\t\t\t\tdataBufferFlux = Flux.from(inputStream).map(value -> encodeStreamingValue(\n\t\t\t\t\t\t\tvalue, bufferFactory, hintsToUse, sequenceWriter, byteBuilder, EMPTY_BYTES, separator));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tJsonArrayJoinHelper helper = new JsonArrayJoinHelper();\n\n\t\t\t\t\t// Do not prepend JSON array prefix until first signal is known, onNext vs onError\n\t\t\t\t\t// Keeps response not committed for error handling\n\n\t\t\t\t\tdataBufferFlux = Flux.from(inputStream)\n\t\t\t\t\t\t\t.map(value -> {\n\t\t\t\t\t\t\t\tbyte[] prefix = helper.getPrefix();\n\t\t\t\t\t\t\t\tbyte[] delimiter = helper.getDelimiter();\n\n\t\t\t\t\t\t\t\tDataBuffer dataBuffer = encodeStreamingValue(\n\t\t\t\t\t\t\t\t\t\tvalue, bufferFactory, hintsToUse, sequenceWriter, byteBuilder,\n\t\t\t\t\t\t\t\t\t\tdelimiter, EMPTY_BYTES);\n\n\t\t\t\t\t\t\t\treturn (prefix.length > 0 ?\n\t\t\t\t\t\t\t\t\t\tbufferFactory.join(List.of(bufferFactory.wrap(prefix), dataBuffer)) :\n\t\t\t\t\t\t\t\t\t\tdataBuffer);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.fromCallable(() -> bufferFactory.wrap(helper.getPrefix())))\n\t\t\t\t\t\t\t.concatWith(Mono.fromCallable(() -> bufferFactory.wrap(helper.getSuffix())));\n\t\t\t\t}\n\n\t\t\t\treturn dataBufferFlux\n\t\t\t\t\t\t.doOnNext(dataBuffer -> Hints.touchDataBuffer(dataBuffer, hintsToUse, logger))\n\t\t\t\t\t\t.doAfterTerminate(() -> {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tgenerator.close();\n\t\t\t\t\t\t\t\tbyteBuilder.release();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\t\t\tlogger.error(\"Could not close Encoder resources\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn Flux.error(ex);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tClass<?> jsonView = null;\n\t\tFilterProvider filters = null;\n\t\tif (value instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\tvalueType = ResolvableType.forInstance(value);\n\t\t\tjsonView = mappingJacksonValue.getSerializationView();\n\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t}\n\n\t\tObjectMapper mapper = selectObjectMapper(valueType, mimeType);\n\t\tif (mapper == null) {\n\t\t\tthrow new IllegalStateException(\"No ObjectMapper for \" + valueType);\n\t\t}\n\n\t\tObjectWriter writer = createObjectWriter(mapper, valueType, mimeType, jsonView, hints);\n\t\tif (filters != null) {\n\t\t\twriter = writer.with(filters);\n\t\t}\n\n\t\tByteArrayBuilder byteBuilder = new ByteArrayBuilder(writer.getFactory()._getBufferRecycler());\n\t\ttry {\n\t\t\tJsonEncoding encoding = getJsonEncoding(mimeType);\n\n\t\t\tlogValue(hints, value);\n\n\t\t\ttry (JsonGenerator generator = mapper.getFactory().createGenerator(byteBuilder, encoding)) {\n\t\t\t\twriter.writeValue(generator, value);\n\t\t\t\tgenerator.flush();\n\t\t\t}\n\t\t\tcatch (InvalidDefinitionException ex) {\n\t\t\t\tthrow new CodecException(\"Type definition error: \" + ex.getType(), ex);\n\t\t\t}\n\t\t\tcatch (JsonProcessingException ex) {\n\t\t\t\tthrow new EncodingException(\"JSON encoding error: \" + ex.getOriginalMessage(), ex);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Unexpected I/O error while writing to byte array builder\", ex);\n\t\t\t}\n\n\t\t\tbyte[] bytes = byteBuilder.toByteArray();\n\t\t\tDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\t\tbuffer.write(bytes);\n\t\t\tHints.touchDataBuffer(buffer, hints, logger);\n\n\t\t\treturn buffer;\n\t\t}\n\t\tfinally {\n\t\t\tbyteBuilder.release();\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getAnnotation(parameter,annotType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "annotType"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "A",
    "signature": "protected A getAnnotation(MethodParameter parameter, Class<A> annotType)",
    "source_code": "\tprotected <A extends Annotation> A getAnnotation(MethodParameter parameter, Class<A> annotType) {\n\t\treturn parameter.getMethodAnnotation(annotType);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getDecodeHints(actualType,elementType,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Object>",
    "signature": "public Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getDecodeHints(ResolvableType actualType, ResolvableType elementType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn getHints(actualType);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getEncodeHints(actualType,elementType,mediaType,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "actualType",
      "elementType",
      "mediaType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Object>",
    "signature": "public Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Map<String, Object> getEncodeHints(@Nullable ResolvableType actualType, ResolvableType elementType,\n\t\t\t@Nullable MediaType mediaType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn (actualType != null ? getHints(actualType) : Hints.none());\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#getJavaType(type,contextClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 5.3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tlogger.debug(msg, cause);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#processInput(input,elementType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the input publisher into a flux. Default implementation returns\n\t * {@link Flux#from(Publisher)}, but subclasses can choose to customize\n\t * this behavior.\n\t * @param input the {@code DataBuffer} input stream to process\n\t * @param elementType the expected type of elements in the output stream\n\t * @param mimeType the MIME type associated with the input stream (optional)\n\t * @param hints additional information about how to do encode\n\t * @return the processed flux\n\t * @since 5.1.14\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "elementType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> processInput(Publisher<DataBuffer> input, ResolvableType elementType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\treturn Flux.from(input);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MimeType,registrar)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and supported\n\t * {@link #getMimeTypes() MimeTypes} for the given class. Therefore it is\n\t * important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MimeType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MimeType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MimeType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#selectObjectMapper(targetType,targetMimeType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Select an ObjectMapper to use, either the main ObjectMapper or another\n\t * if the handling for the given Class has been customized through\n\t * {@link #registerObjectMappersForType(Class, Consumer)}.\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetType",
      "targetMimeType"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "ObjectMapper",
    "signature": "protected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType)",
    "source_code": "\tprotected ObjectMapper selectObjectMapper(ResolvableType targetType, @Nullable MimeType targetMimeType) {\n\t\tif (targetMimeType == null || CollectionUtils.isEmpty(this.objectMapperRegistrations)) {\n\t\t\treturn this.defaultObjectMapper;\n\t\t}\n\t\tClass<?> targetClass = targetType.toClass();\n\t\tfor (Map.Entry<Class<?>, Map<MimeType, ObjectMapper>> typeEntry : getObjectMapperRegistrations().entrySet()) {\n\t\t\tif (typeEntry.getKey().isAssignableFrom(targetClass)) {\n\t\t\t\tfor (Map.Entry<MimeType, ObjectMapper> objectMapperEntry : typeEntry.getValue().entrySet()) {\n\t\t\t\t\tif (objectMapperEntry.getKey().includes(targetMimeType)) {\n\t\t\t\t\t\treturn objectMapperEntry.getValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// No matching registrations\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// No registrations\n\t\treturn this.defaultObjectMapper;\n\t}"
  },
  "org.springframework.http.codec.json.<unknown>#tokenize(dataBuffers,jsonFactory,objectMapper,tokenizeArrays,forceUseOfBigDecimal,maxInMemorySize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code Flux<DataBuffer>} into {@code Flux<TokenBuffer>}.\n\t * @param dataBuffers the source data buffers\n\t * @param jsonFactory the factory to use\n\t * @param objectMapper the current mapper instance\n\t * @param tokenizeArrays if {@code true} and the \"top level\" JSON object is\n\t * an array, each element is returned individually immediately after it is received\n\t * @param forceUseOfBigDecimal if {@code true}, any floating point values encountered\n\t * in source will use {@link java.math.BigDecimal}\n\t * @param maxInMemorySize maximum memory size\n\t * @return the resulting token buffers\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataBuffers",
      "jsonFactory",
      "objectMapper",
      "tokenizeArrays",
      "forceUseOfBigDecimal",
      "maxInMemorySize"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Flux<TokenBuffer>",
    "signature": "public Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,\n\t\t\tObjectMapper objectMapper, boolean tokenizeArrays, boolean forceUseOfBigDecimal, int maxInMemorySize)",
    "source_code": "\tpublic static Flux<TokenBuffer> tokenize(Flux<DataBuffer> dataBuffers, JsonFactory jsonFactory,\n\t\t\tObjectMapper objectMapper, boolean tokenizeArrays, boolean forceUseOfBigDecimal, int maxInMemorySize) {\n\n\t\ttry {\n\t\t\tJsonParser parser;\n\t\t\tif (jsonFactory.getFormatName().equals(SmileFactory.FORMAT_NAME_SMILE)) {\n\t\t\t\t// ByteBufferFeeder is not supported for Smile\n\t\t\t\tparser = jsonFactory.createNonBlockingByteArrayParser();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparser = jsonFactory.createNonBlockingByteBufferParser();\n\t\t\t}\n\t\t\tDeserializationContext context = objectMapper.getDeserializationContext();\n\t\t\tif (context instanceof DefaultDeserializationContext ddc) {\n\t\t\t\tcontext = ddc.createInstance(objectMapper.getDeserializationConfig(),\n\t\t\t\t\t\tparser, objectMapper.getInjectableValues());\n\t\t\t}\n\t\t\tJackson2Tokenizer tokenizer =\n\t\t\t\t\tnew Jackson2Tokenizer(parser, context, tokenizeArrays, forceUseOfBigDecimal, maxInMemorySize);\n\t\t\treturn dataBuffers.concatMapIterable(tokenizer::tokenize).concatWith(tokenizer.endOfInput());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\treturn Flux.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#canRead(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\treturn supportsMediaType(mediaType) && MULTIPART_VALUE_TYPE.isAssignableFrom(elementType);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#canWrite(elementType,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(ResolvableType elementType, @Nullable MediaType mediaType) {\n\t\tif (Part.class.isAssignableFrom(elementType.toClass())) {\n\t\t\tif (mediaType == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (MediaType supportedMediaType : getWritableMediaTypes()) {\n\t\t\t\tif (supportedMediaType.isCompatibleWith(mediaType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#read(elementType,message,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "message",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Part>>",
    "signature": "public Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints)",
    "source_code": "\tpublic Flux<MultiValueMap<String, Part>> read(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage message, Map<String, Object> hints) {\n\n\t\treturn Flux.from(readMono(elementType, message, hints));\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#readMono(elementType,inputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Part>>",
    "signature": "public Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints)",
    "source_code": "\tpublic Mono<MultiValueMap<String, Part>> readMono(ResolvableType elementType,\n\t\t\tReactiveHttpInputMessage inputMessage, Map<String, Object> hints) {\n\n\n\t\tMap<String, Object> allHints = Hints.merge(hints, Hints.SUPPRESS_LOGGING_HINT, true);\n\n\t\treturn this.partReader.read(elementType, inputMessage, allHints)\n\t\t\t\t.collectMultimap(Part::name)\n\t\t\t\t.doOnNext(map ->\n\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> Hints.getLogPrefix(hints) + \"Parsed \" +\n\t\t\t\t\t\t\t(isEnableLoggingRequestDetails() ?\n\t\t\t\t\t\t\t\t\tLogFormatUtils.formatValue(map, !traceOn) :\n\t\t\t\t\t\t\t\t\t\"parts \" + map.keySet() + \" (content masked)\"))\n\t\t\t\t)\n\t\t\t\t.map(this::toMultiValueMap);\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#write(MultiValueMap<String,inputStream,elementType,mediaType,outputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "inputStream",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends MultiValueMap<String, ?>> inputStream,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\treturn Mono.from(inputStream)\n\t\t\t\t.flatMap(map -> {\n\t\t\t\t\tif (this.formWriter == null || isMultipart(map, mediaType)) {\n\t\t\t\t\t\treturn writeMultipart(map, outputMessage, mediaType, hints);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tMono<MultiValueMap<String, String>> input = Mono.just((MultiValueMap<String, String>) map);\n\t\t\t\t\t\treturn this.formWriter.write(input, elementType, mediaType, outputMessage, hints);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.http.codec.multipart.<unknown>#write(parts,elementType,mediaType,outputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parts",
      "elementType",
      "mediaType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints)",
    "source_code": "\tpublic Mono<Void> write(Publisher<? extends Part> parts,\n\t\t\tResolvableType elementType, @Nullable MediaType mediaType, ReactiveHttpOutputMessage outputMessage,\n\t\t\tMap<String, Object> hints) {\n\n\t\tbyte[] boundary = generateMultipartBoundary();\n\n\t\tmediaType = getMultipartMediaType(mediaType, boundary);\n\t\toutputMessage.getHeaders().setContentType(mediaType);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(Hints.getLogPrefix(hints) + \"Encoding Publisher<Part>\");\n\t\t}\n\n\t\tFlux<DataBuffer> body = Flux.from(parts)\n\t\t\t\t.concatMap(part -> encodePart(boundary, part, outputMessage.bufferFactory()))\n\t\t\t\t.concatWith(generateLastLine(boundary, outputMessage.bufferFactory()))\n\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tbody = body.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\n\t\t}\n\n\t\treturn outputMessage.writeWith(body);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#addCodec(codecs,codec)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize a codec and add it to the List.\n\t * @since 5.1.13\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "codecs",
      "codec"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "protected void addCodec(List<T> codecs, T codec)",
    "source_code": "\tprotected <T> void addCodec(List<T> codecs, T codec) {\n\t\tinitCodec(codec);\n\t\tcodecs.add(codec);\n\t}"
  },
  "org.springframework.http.codec.support.<unknown>#registerWithDefaultConfig(codec,configConsumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "configConsumer"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer)",
    "source_code": "\t\tpublic void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer) {\n\t\t\taddCodec(codec, false);\n\t\t\tthis.defaultConfigConsumers.add(configConsumer);\n\t\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#canEncode(elementType,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elementType",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType)",
    "source_code": "\tpublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\n\t\tif (super.canEncode(elementType, mimeType)) {\n\t\t\tClass<?> outputClass = elementType.toClass();\n\t\t\treturn (outputClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\t\toutputClass.isAnnotationPresent(XmlType.class) ||\n\t\t\t\t\tJAXBElement.class.isAssignableFrom(outputClass));\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#encode(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Flux<DataBuffer>",
    "signature": "protected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tprotected Flux<DataBuffer> encode(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\t// we're relying on doOnDiscard in base class\n\t\treturn Mono.fromCallable(() -> encodeValue(value, bufferFactory, valueType, mimeType, hints)).flux();\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#encodeValue(value,bufferFactory,valueType,mimeType,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "bufferFactory",
      "valueType",
      "mimeType",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic DataBuffer encodeValue(Object value, DataBufferFactory bufferFactory,\n\t\t\tResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tif (!Hints.isLoggingSuppressed(hints)) {\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(value, !traceOn);\n\t\t\t\treturn Hints.getLogPrefix(hints) + \"Encoding [\" + formatted + \"]\";\n\t\t\t});\n\t\t}\n\n\t\tboolean release = true;\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(1024);\n\t\ttry {\n\t\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = initMarshaller(clazz);\n\t\t\tmarshaller.marshal(value, outputStream);\n\t\t\trelease = false;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow new EncodingException(\"Could not marshal \" + value.getClass() + \" to XML\", ex);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new CodecException(\"Invalid JAXB configuration\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (release) {\n\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.codec.xml.<unknown>#setMarshallerProcessor(Function<Marshaller,processor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a processor function to customize Marshaller instances.\n\t * @param processor the function to use\n\t * @since 5.1.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Marshaller",
      "processor"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void setMarshallerProcessor(Function<Marshaller, Marshaller> processor)",
    "source_code": "\tpublic void setMarshallerProcessor(Function<Marshaller, Marshaller> processor) {\n\t\tthis.marshallerProcessor = this.marshallerProcessor.andThen(processor);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#addDefaultHeaders(headers,t,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add default headers to the output message.\n\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a\n\t * content type was not provided, set if necessary the default character set, calls\n\t * {@link #getContentLength}, and sets the corresponding headers.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headers",
      "t",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "void",
    "signature": "protected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType)",
    "source_code": "\tprotected void addDefaultHeaders(HttpHeaders headers, T t, @Nullable MediaType contentType) throws IOException {\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || !contentType.isConcrete()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType mediaType = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\tif (contentTypeToUse.getCharset() == null) {\n\t\t\t\t\tCharset defaultCharset = getDefaultCharset();\n\t\t\t\t\tif (defaultCharset != null) {\n\t\t\t\t\t\tcontentTypeToUse = new MediaType(contentTypeToUse, defaultCharset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() < 0 && !headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn (BufferedImage.class == clazz && isReadable(mediaType));\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(type,contextClass,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\treturn (type instanceof Class<?> clazz ? canRead(clazz, mediaType) : canRead(mediaType));\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canRead(type,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "boolean",
    "signature": "public boolean canRead(ResolvableType type, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(ResolvableType type, @Nullable MediaType mediaType) {\n\t\tClass<?> clazz = type.resolve();\n\t\treturn (clazz != null ? canRead(clazz, mediaType) : canRead(mediaType));\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn (BufferedImage.class == clazz && isWritable(mediaType));\n\t}"
  },
  "org.springframework.http.converter.<unknown>#canWrite(type,clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canWrite(clazz, mediaType);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#getContentLength(t,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the content length for the given type.\n\t * <p>By default, this returns {@code null}, meaning that the content length is unknown.\n\t * Can be overridden in subclasses.\n\t * @param t the type to return the content length for\n\t * @return the content length, or {@code null} if not known\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "Long",
    "signature": "protected Long getContentLength(T t, @Nullable MediaType contentType)",
    "source_code": "\tprotected Long getContentLength(T t, @Nullable MediaType contentType) throws IOException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(MultiValueMap<String,clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 343
    },
    "return": "String>",
    "signature": "public String> read(@Nullable Class<? extends MultiValueMap<String, ?>> clazz,\n\t\t\tHttpInputMessage inputMessage)",
    "source_code": "\tpublic MultiValueMap<String, String> read(@Nullable Class<? extends MultiValueMap<String, ?>> clazz,\n\t\t\tHttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tCharset charset = (contentType != null && contentType.getCharset() != null ?\n\t\t\t\tcontentType.getCharset() : this.charset);\n\t\tString body = StreamUtils.copyToString(inputMessage.getBody(), charset);\n\n\t\tString[] pairs = StringUtils.tokenizeToStringArray(body, \"&\");\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(pairs.length);\n\t\tfor (String pair : pairs) {\n\t\t\tint idx = pair.indexOf('=');\n\t\t\tif (idx == -1) {\n\t\t\t\tresult.add(URLDecoder.decode(pair, charset), null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = URLDecoder.decode(pair.substring(0, idx), charset);\n\t\t\t\tString value = URLDecoder.decode(pair.substring(idx + 1), charset);\n\t\t\t\tresult.add(name, value);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "BufferedImage",
    "signature": "public BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tpublic BufferedImage read(@Nullable Class<? extends BufferedImage> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tImageInputStream imageInputStream = null;\n\t\tImageReader imageReader = null;\n\t\t// We cannot use try-with-resources here for the ImageInputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\timageInputStream = createImageInputStream(inputMessage.getBody());\n\t\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\t\tif (contentType == null) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"No Content-Type header\", inputMessage);\n\t\t\t}\n\t\t\tIterator<ImageReader> imageReaders = ImageIO.getImageReadersByMIMEType(contentType.toString());\n\t\t\tif (imageReaders.hasNext()) {\n\t\t\t\timageReader = imageReaders.next();\n\t\t\t\tImageReadParam irp = imageReader.getDefaultReadParam();\n\t\t\t\tprocess(irp);\n\t\t\t\timageReader.setInput(imageInputStream, true);\n\t\t\t\treturn imageReader.read(0, irp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\"Could not find javax.imageio.ImageReader for Content-Type [\" + contentType + \"]\",\n\t\t\t\t\t\tinputMessage);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (imageReader != null) {\n\t\t\t\timageReader.dispose();\n\t\t\t}\n\t\t\tif (imageInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\timageInputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(type,contextClass,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#read(type,inputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "inputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "Object",
    "signature": "public Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic final Object read(ResolvableType type, HttpInputMessage inputMessage, @Nullable Map<String, Object> hints)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tKSerializer<Object> serializer = serializer(type);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Could not find KSerializer for \" + type, inputMessage);\n\t\t}\n\t\treturn readInternal(serializer, this.format, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "T",
    "signature": "protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn read(ResolvableType.forClass(clazz), inputMessage, null);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#readInternal(serializer,format,inputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reads the given input message with the given serializer and format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serializer",
      "format",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "Object",
    "signature": "protected Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)",
    "source_code": "\tprotected abstract Object readInternal(KSerializer<Object> serializer, T format, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t@Override\n\tprotected final void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException {\n\n\t\tResolvableType resolvableType = (ResolvableType.NONE.equals(type) ? ResolvableType.forInstance(object) : type);\n\t\tKSerializer<Object> serializer = serializer(resolvableType);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not find KSerializer for \" + resolvableType);\n\t\t}\n\t\twriteInternal(object, serializer, this.format, outputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#serializeForm(MultiValueMap<String,formData,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "MultiValueMap<String",
      "formData",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "String",
    "signature": "protected String serializeForm(MultiValueMap<String, Object> formData, Charset charset)",
    "source_code": "\tprotected String serializeForm(MultiValueMap<String, Object> formData, Charset charset) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tformData.forEach((name, values) -> {\n\t\t\t\tif (name == null) {\n\t\t\t\t\tAssert.isTrue(CollectionUtils.isEmpty(values), () -> \"Null name in form data: \" + formData);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvalues.forEach(value -> {\n\t\t\t\t\tif (builder.length() != 0) {\n\t\t\t\t\t\tbuilder.append('&');\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.append(URLEncoder.encode(name, charset));\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tbuilder.append('=');\n\t\t\t\t\t\tbuilder.append(URLEncoder.encode(String.valueOf(value), charset));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\n\t\treturn builder.toString();\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(MultiValueMap<String,map,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "map",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "void",
    "signature": "public void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tif (isMultipart(map, contentType)) {\n\t\t\twriteMultipart((MultiValueMap<String, Object>) map, contentType, outputMessage);\n\t\t}\n\t\telse {\n\t\t\twriteForm((MultiValueMap<String, Object>) map, contentType, outputMessage);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(b,off,let)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "let"
    ],
    "position": {
      "column": 1,
      "line": 682
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int let)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int let) throws IOException {\n\t\t\tthis.out.write(b, off, let);\n\t\t}"
  },
  "org.springframework.http.converter.<unknown>#write(image,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "image",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void write(final BufferedImage image, @Nullable final MediaType contentType,\n\t\t\tfinal HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(final BufferedImage image, @Nullable final MediaType contentType,\n\t\t\tfinal HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal MediaType selectedContentType = getContentType(contentType);\n\t\toutputMessage.getHeaders().setContentType(selectedContentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\tBufferedImageHttpMessageConverter.this.writeInternal(image, selectedContentType, outputStream);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(image, selectedContentType, outputMessage.getBody());\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,contentType,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "public void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic final void write(final T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,type,contentType,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void write(final T t, @Nullable final Type type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage)",
    "source_code": "\tpublic final void write(final T t, @Nullable final Type type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, type, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#write(t,type,contentType,outputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void write(T t, ResolvableType type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)",
    "source_code": "\tpublic final void write(T t, ResolvableType type, @Nullable MediaType contentType,\n\t\t\tHttpOutputMessage outputMessage, @Nullable Map<String, Object> hints)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tHttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage streamingOutputMessage) {\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, type, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, hints);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean repeatable() {\n\t\t\t\t\treturn supportsRepeatableWrites(t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, type, outputMessage, hints);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,serializer,format,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the given object to the output message with the given serializer and format.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "serializer",
      "format",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, KSerializer<Object> serializer, T format,\n\t\t\tHttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(Object object, KSerializer<Object> serializer, T format,\n\t\t\tHttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;\n\n\t/**\n\t * Tries to find a serializer that can marshall or unmarshall instances of the given type\n\t * using kotlinx.serialization. If no serializer can be found, {@code null} is returned."
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,type,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tif (object instanceof ResourceRegion resourceRegion) {\n\t\t\twriteResourceRegion(resourceRegion, outputMessage);\n\t\t}\n\t\telse {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tCollection<ResourceRegion> regions = (Collection<ResourceRegion>) object;\n\t\t\tif (regions.size() == 1) {\n\t\t\t\twriteResourceRegion(regions.iterator().next(), outputMessage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteResourceRegionCollection(regions, outputMessage);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(object,type,outputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tprotected final void writeInternal(Object object, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException {\n\n\t\tResolvableType resolvableType = (ResolvableType.NONE.equals(type) ? ResolvableType.forInstance(object) : type);\n\t\tKSerializer<Object> serializer = serializer(resolvableType);\n\t\tif (serializer == null) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not find KSerializer for \" + resolvableType);\n\t\t}\n\t\twriteInternal(object, serializer, this.format, outputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(T t, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\twriteInternal(t, null, outputMessage);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,type,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from {@link #write}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write (may be {@code null})\n\t * @param outputMessage the HTTP output message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected abstract void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException;\n\n}"
  },
  "org.springframework.http.converter.<unknown>#writeInternal(t,type,outputMessage,Map<String,hints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method that writes the actual body. Invoked from\n\t * {@link #write(Object, ResolvableType, MediaType, HttpOutputMessage, Map)}.\n\t * @param t the object to write to the output message\n\t * @param type the type of object to write\n\t * @param outputMessage the HTTP output message to write to\n\t * @param hints additional information about how to encode\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "type",
      "outputMessage",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "protected void writeInternal(T t, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints)",
    "source_code": "\tprotected abstract void writeInternal(T t, ResolvableType type, HttpOutputMessage outputMessage,\n\t\t\t@Nullable Map<String, Object> hints) throws IOException, HttpMessageNotWritableException;\n\n\t@Override\n\tprotected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\treturn read(ResolvableType.forClass(clazz), inputMessage, null);\n\t}"
  },
  "org.springframework.http.converter.<unknown>#writeResourceRegion(region,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "region",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "protected void writeResourceRegion(ResourceRegion region, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeResourceRegion(ResourceRegion region, HttpOutputMessage outputMessage) throws IOException {\n\t\tAssert.notNull(region, \"ResourceRegion must not be null\");\n\t\tHttpHeaders responseHeaders = outputMessage.getHeaders();\n\n\t\tlong start = region.getPosition();\n\t\tlong end = start + region.getCount() - 1;\n\t\tlong resourceLength = region.getResource().contentLength();\n\t\tend = Math.min(end, resourceLength - 1);\n\t\tlong rangeLength = end - start + 1;\n\t\tresponseHeaders.add(\"Content-Range\", \"bytes \" + start + '-' + end + '/' + resourceLength);\n\t\tresponseHeaders.setContentLength(rangeLength);\n\n\t\tInputStream in = region.getResource().getInputStream();\n\t\t// We cannot use try-with-resources here for the InputStream, since we have\n\t\t// custom handling of the close() method in a finally-block.\n\t\ttry {\n\t\t\tStreamUtils.copyRange(in, outputMessage.getBody(), start, end);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#annotationIntrospector(Function<AnnotationIntrospector,pairingFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Alternative to {@link #annotationIntrospector(AnnotationIntrospector)}\n\t * that allows combining with rather than replacing the currently set\n\t * introspector, for example, via\n\t * {@link AnnotationIntrospectorPair#pair(AnnotationIntrospector, AnnotationIntrospector)}.\n\t * @param pairingFunction a function to apply to the currently set\n\t * introspector (possibly {@code null}); the result of the function becomes\n\t * the new introspector.\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<AnnotationIntrospector",
      "pairingFunction"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder annotationIntrospector(Function<AnnotationIntrospector, AnnotationIntrospector> pairingFunction)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder annotationIntrospector(\n\t\t\tFunction<AnnotationIntrospector, AnnotationIntrospector> pairingFunction) {\n\n\t\tthis.annotationIntrospector = pairingFunction.apply(this.annotationIntrospector);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn canRead(clazz, null, mediaType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canRead(type,contextClass,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\tif (!canRead(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\tObjectMapper objectMapper = selectObjectMapper(javaType.getRawClass(), mediaType);\n\t\tif (objectMapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (objectMapper.canDeserialize(javaType, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(javaType, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\tif (!canWrite(mediaType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mediaType != null && mediaType.getCharset() != null) {\n\t\t\tCharset charset = mediaType.getCharset();\n\t\t\tif (!ENCODINGS.containsKey(charset.name())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, mediaType);\n\t\tif (objectMapper == null) {\n\t\t\treturn false;\n\t\t}\n\t\tAtomicReference<Throwable> causeRef = new AtomicReference<>();\n\t\tif (objectMapper.canSerialize(clazz, causeRef)) {\n\t\t\treturn true;\n\t\t}\n\t\tlogWarningIfNecessary(clazz, causeRef.get());\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#create(defaultUseWrapper,factory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "defaultUseWrapper",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 962
    },
    "return": "ObjectMapper",
    "signature": "public ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory)",
    "source_code": "\t\tpublic ObjectMapper create(boolean defaultUseWrapper, @Nullable JsonFactory factory) {\n\t\t\tJacksonXmlModule module = new JacksonXmlModule();\n\t\t\tmodule.setDefaultUseWrapper(defaultUseWrapper);\n\t\t\tif (factory != null) {\n\t\t\t\treturn new XmlMapper((XmlFactory) factory, module);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new XmlMapper(new XmlFactory(StaxUtils.createDefensiveInputFactory()), module);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.http.converter.json.<unknown>#customizeReader(reader,javaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectReader} used\n\t * for reading values.\n\t * @param reader the reader instance to customize\n\t * @param javaType the target type of element values to read to\n\t * @return the customized {@link ObjectReader}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "javaType"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "ObjectReader",
    "signature": "protected ObjectReader customizeReader(ObjectReader reader, JavaType javaType)",
    "source_code": "\tprotected ObjectReader customizeReader(ObjectReader reader, JavaType javaType) {\n\t\treturn reader;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#customizeWriter(writer,javaType,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can use this method to customize {@link ObjectWriter} used\n\t * for writing values.\n\t * @param writer the writer instance to customize\n\t * @param javaType the type of element values to write\n\t * @param contentType the selected media type\n\t * @return the customized {@link ObjectWriter}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "writer",
      "javaType",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "ObjectWriter",
    "signature": "protected ObjectWriter customizeWriter(ObjectWriter writer, @Nullable JavaType javaType, @Nullable MediaType contentType)",
    "source_code": "\tprotected ObjectWriter customizeWriter(\n\t\t\tObjectWriter writer, @Nullable JavaType javaType, @Nullable MediaType contentType) {\n\n\t\treturn writer;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializerByType(type,deserializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom deserializer for the given type.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "deserializer"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializerByType(Class<?> type, JsonDeserializer<?> deserializer) {\n\t\tthis.deserializers.put(type, deserializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#deserializersByType(Map<Class<?>,deserializers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom deserializers for the given types.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "deserializers"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder deserializersByType(Map<Class<?>, JsonDeserializer<?>> deserializers) {\n\t\tthis.deserializers.putAll(deserializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#getContentLength(object,contentType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Long",
    "signature": "protected Long getContentLength(Object object, @Nullable MediaType contentType)",
    "source_code": "\tprotected Long getContentLength(Object object, @Nullable MediaType contentType) throws IOException {\n\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\tobject = mappingJacksonValue.getValue();\n\t\t}\n\t\treturn super.getContentLength(object, contentType);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#getJavaType(type,contextClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the Jackson {@link JavaType} for the specified type and context class.\n\t * @param type the generic type to return the Jackson JavaType for\n\t * @param contextClass a context class for the target type, for example a class\n\t * in which the target type appears in a method signature (can be {@code null})\n\t * @return the Jackson JavaType\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "contextClass"
    ],
    "position": {
      "column": 1,
      "line": 537
    },
    "return": "JavaType",
    "signature": "protected JavaType getJavaType(Type type, @Nullable Class<?> contextClass)",
    "source_code": "\tprotected JavaType getJavaType(Type type, @Nullable Class<?> contextClass) {\n\t\treturn this.defaultObjectMapper.constructType(GenericTypeResolver.resolveType(type, contextClass));\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#logWarningIfNecessary(type,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not log warning for serializer not found (note: different message wording on Jackson 2.9)\n\t\tboolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage() != null &&\n\t\t\t\tcause.getMessage().startsWith(\"Cannot find\"));\n\n\t\tif (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tif (debugLevel) {\n\t\t\t\tlogger.debug(msg, cause);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIn(target,mixinSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param target class (or interface) whose annotations to effectively override\n\t * @param mixinSource class (or interface) whose annotations are to be \"added\"\n\t * to target's annotations as value\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "mixinSource"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIn(Class<?> target, Class<?> mixinSource) {\n\t\tthis.mixIns.put(target, mixinSource);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#mixIns(Map<Class<?>,mixIns)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mix-in annotations to use for augmenting specified class or interface.\n\t * @param mixIns a Map of entries with target classes (or interface) whose annotations\n\t * to effectively override as key and mix-in classes (or interface) whose\n\t * annotations are to be \"added\" to target's annotations as value.\n\t * @since 4.1.2\n\t * @see com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "mixIns"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder mixIns(Map<Class<?>, Class<?>> mixIns) {\n\t\tthis.mixIns.putAll(mixIns);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#read(type,contextClass,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "Object",
    "signature": "public Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic Object read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(type, contextClass);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#readInternal(clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "Object",
    "signature": "protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)",
    "source_code": "\tprotected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tJavaType javaType = getJavaType(clazz, null);\n\t\treturn readJavaType(javaType, inputMessage);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#registerObjectMappersForType(clazz,Consumer<Map<MediaType,registrar)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the {@link ObjectMapper} instances to use for the given\n\t * {@link Class}. This is useful when you want to deviate from the\n\t * {@link #getObjectMapper() default} ObjectMapper or have the\n\t * {@code ObjectMapper} vary by {@code MediaType}.\n\t * <p><strong>Note:</strong> Use of this method effectively turns off use of\n\t * the default {@link #getObjectMapper() ObjectMapper} and\n\t * {@link #setSupportedMediaTypes(List) supportedMediaTypes} for the given\n\t * class. Therefore it is important for the mappings configured here to\n\t * {@link MediaType#includes(MediaType) include} every MediaType that must\n\t * be supported for the given class.\n\t * @param clazz the type of Object to register ObjectMapper instances for\n\t * @param registrar a consumer to populate or otherwise update the\n\t * MediaType-to-ObjectMapper associations for the given Class\n\t * @since 5.3.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "Consumer<Map<MediaType",
      "registrar"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MediaType, ObjectMapper>> registrar)",
    "source_code": "\tpublic void registerObjectMappersForType(Class<?> clazz, Consumer<Map<MediaType, ObjectMapper>> registrar) {\n\t\tif (this.objectMapperRegistrations == null) {\n\t\t\tthis.objectMapperRegistrations = new LinkedHashMap<>();\n\t\t}\n\t\tMap<MediaType, ObjectMapper> registrations =\n\t\t\t\tthis.objectMapperRegistrations.computeIfAbsent(clazz, c -> new LinkedHashMap<>());\n\t\tregistrar.accept(registrations);\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#serializerByType(type,serializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a custom serializer for the given type.\n\t * @since 4.1.2\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "serializer"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializerByType(Class<?> type, JsonSerializer<?> serializer) {\n\t\tthis.serializers.put(type, serializer);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#serializersByType(Map<Class<?>,serializers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure custom serializers for the given types.\n\t * @see #serializers(JsonSerializer...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "serializers"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder serializersByType(Map<Class<?>, JsonSerializer<?>> serializers) {\n\t\tthis.serializers.putAll(serializers);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#visibility(accessor,visibility)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify visibility to limit what kind of properties are auto-detected.\n\t * @since 5.1\n\t * @see com.fasterxml.jackson.annotation.PropertyAccessor\n\t * @see com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "accessor",
      "visibility"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "Jackson2ObjectMapperBuilder",
    "signature": "public Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility)",
    "source_code": "\tpublic Jackson2ObjectMapperBuilder visibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {\n\t\tthis.visibilities.put(accessor, visibility);\n\t\treturn this;\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeInternal(object,type,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "type",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "void",
    "signature": "protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)",
    "source_code": "\tprotected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tJsonEncoding encoding = getJsonEncoding(contentType);\n\n\t\tClass<?> clazz = (object instanceof MappingJacksonValue mappingJacksonValue ?\n\t\t\t\tmappingJacksonValue.getValue().getClass() : object.getClass());\n\t\tObjectMapper objectMapper = selectObjectMapper(clazz, contentType);\n\t\tAssert.state(objectMapper != null, () -> \"No ObjectMapper for \" + clazz.getName());\n\n\t\tOutputStream outputStream = StreamUtils.nonClosing(outputMessage.getBody());\n\t\ttry (JsonGenerator generator = objectMapper.getFactory().createGenerator(outputStream, encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\t\t\tJavaType javaType = null;\n\n\t\t\tif (object instanceof MappingJacksonValue mappingJacksonValue) {\n\t\t\t\tvalue = mappingJacksonValue.getValue();\n\t\t\t\tserializationView = mappingJacksonValue.getSerializationView();\n\t\t\t\tfilters = mappingJacksonValue.getFilters();\n\t\t\t}\n\t\t\tif (type != null && TypeUtils.isAssignable(type, value.getClass())) {\n\t\t\t\tjavaType = getJavaType(type, null);\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tobjectMapper.writerWithView(serializationView) : objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tif (javaType != null && (javaType.isContainerType() || javaType.isTypeOrSubTypeOf(Optional.class))) {\n\t\t\t\tobjectWriter = objectWriter.forType(javaType);\n\t\t\t}\n\t\t\tSerializationConfig config = objectWriter.getConfig();\n\t\t\tif (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &&\n\t\t\t\t\tconfig.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n\t\t\t\tobjectWriter = objectWriter.with(this.ssePrettyPrinter);\n\t\t\t}\n\t\t\tobjectWriter = customizeWriter(objectWriter, javaType, contentType);\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t\tcatch (InvalidDefinitionException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Type definition error: \" + ex.getType(), ex);\n\t\t}\n\t\tcatch (JsonProcessingException ex) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not write JSON: \" + ex.getOriginalMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writePrefix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a prefix before the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 519
    },
    "return": "void",
    "signature": "protected void writePrefix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.http.converter.json.<unknown>#writeSuffix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a suffix after the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "protected void writeSuffix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writeSuffix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * required generic type information in order to read a Collection.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 78
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canRead(type,contextClass,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>Jaxb2CollectionHttpMessageConverter can read a generic\n\t * {@link Collection} where the generic type is a JAXB type annotated with\n\t * {@link XmlRootElement} or {@link XmlType}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canRead(Type type, @Nullable Class<?> contextClass, @Nullable MediaType mediaType) {\n\t\tif (!(type instanceof ParameterizedType parameterizedType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(parameterizedType.getRawType() instanceof Class<?> rawType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Collection.class.isAssignableFrom(rawType))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterizedType.getActualTypeArguments().length != 1) {\n\t\t\treturn false;\n\t\t}\n\t\tType typeArgument = parameterizedType.getActualTypeArguments()[0];\n\t\tif (!(typeArgument instanceof Class<?> typeArgumentClass)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (typeArgumentClass.isAnnotationPresent(XmlRootElement.class) ||\n\t\t\t\ttypeArgumentClass.isAnnotationPresent(XmlType.class)) && canRead(mediaType);\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * does not convert collections to XML.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#canWrite(type,clazz,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n\t * does not convert collections to XML.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "boolean",
    "signature": "public boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\tpublic boolean canWrite(@Nullable Type type, @Nullable Class<?> clazz, @Nullable MediaType mediaType) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#read(type,contextClass,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "contextClass",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "T",
    "signature": "public T read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)",
    "source_code": "\tpublic T read(Type type, @Nullable Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\tT result = createCollection((Class<?>) parameterizedType.getRawType());\n\t\tClass<?> elementClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = createUnmarshaller(elementClass);\n\t\t\tXMLStreamReader streamReader = this.inputFactory.createXMLStreamReader(inputMessage.getBody());\n\t\t\tint event = moveToFirstChildOfRootElement(streamReader);\n\n\t\t\twhile (event != XMLStreamReader.END_DOCUMENT) {\n\t\t\t\tif (elementClass.isAnnotationPresent(XmlRootElement.class)) {\n\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader));\n\t\t\t\t}\n\t\t\t\telse if (elementClass.isAnnotationPresent(XmlType.class)) {\n\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader, elementClass).getValue());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should not happen, since we check in canRead(Type)\n\t\t\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\t\t\"Cannot unmarshal to [\" + elementClass + \"]\", inputMessage);\n\t\t\t\t}\n\t\t\t\tevent = moveToNextElement(streamReader);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tcatch (XMLStreamException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\"Failed to read XML stream: \" + ex.getMessage(), ex, inputMessage);\n\t\t}\n\t\tcatch (UnmarshalException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\n\t\t\t\t\t\"Could not unmarshal to [\" + elementClass + \"]: \" + ex, ex, inputMessage);\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#readFromSource(clazz,headers,source)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "headers",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "T",
    "signature": "protected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source)",
    "source_code": "\tprotected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source) throws Exception {\n\t\t// should not be called, since we return false for canRead(Class)\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#write(t,type,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "type",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "void",
    "signature": "public void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\tpublic void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(o,headers,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "o",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "protected void writeToResult(Object o, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object o, HttpHeaders headers, Result result) throws Exception {\n\t\tAssert.state(this.marshaller != null, \"Property 'marshaller' is required\");\n\t\tthis.marshaller.marshal(o, result);\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(t,headers,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "void",
    "signature": "protected void writeToResult(T t, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(T t, HttpHeaders headers, Result result) throws Exception {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.http.converter.xml.<unknown>#writeToResult(value,headers,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "headers",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "protected void writeToResult(Object value, HttpHeaders headers, Result result)",
    "source_code": "\tprotected void writeToResult(Object value, HttpHeaders headers, Result result) throws Exception {\n\t\ttry {\n\t\t\tClass<?> clazz = getMarshallerType(value);\n\t\t\tMarshaller marshaller = createMarshaller(clazz);\n\t\t\tsetCharset(headers.getContentType(), marshaller);\n\t\t\tmarshaller.marshal(value, result);\n\t\t}\n\t\tcatch (MarshalException ex) {\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow new HttpMessageConversionException(\"Invalid JAXB setup: \" + ex.getMessage(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.http.server.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject old = get(key);\n\t\t\tservletRequest.setAttribute(key, value);\n\t\t\treturn old;\n\t\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#add(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tthis.headers.add(HttpString.tryFromString(key), value);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach((key, list) -> this.headers.addAll(HttpString.tryFromString(key), list));\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tthis.headers.addAll(HttpString.tryFromString(key), (List<String>) values);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createRequest(request,asyncContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "asyncContext"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "ServletServerHttpRequest",
    "signature": "protected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext asyncContext)",
    "source_code": "\tprotected ServletServerHttpRequest createRequest(HttpServletRequest request, AsyncContext asyncContext)\n\t\t\tthrows IOException, URISyntaxException {\n\n\t\tAssert.state(getServletPath() != null, \"Servlet path is not initialized\");\n\t\treturn new TomcatServerHttpRequest(\n\t\t\t\trequest, asyncContext, getServletPath(), getDataBufferFactory(), getBufferSize());\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,asyncContext,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "asyncContext",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext asyncContext, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext asyncContext, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new TomcatServerHttpResponse(\n\t\t\t\tresponse, asyncContext, getDataBufferFactory(), getBufferSize(), request);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#createResponse(response,context,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "context",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ServletServerHttpResponse",
    "signature": "protected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request)",
    "source_code": "\tprotected ServletServerHttpResponse createResponse(HttpServletResponse response,\n\t\t\tAsyncContext context, ServletServerHttpRequest request) throws IOException {\n\n\t\treturn new Jetty12ServerHttpResponse(\n\t\t\t\tresponse, context, getDataBufferFactory(), getBufferSize(), request);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tHeaderValues previousValues = this.headers.get(key);\n\t\tthis.headers.putAll(HttpString.tryFromString(key), value);\n\t\treturn previousValues;\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach((key, values) ->\n\t\t\t\tthis.headers.putAll(HttpString.tryFromString(key), values));\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#set(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tthis.headers.put(HttpString.tryFromString(key), value);\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach((key, list) -> this.headers.put(HttpString.tryFromString(key), list));\n\t}"
  },
  "org.springframework.http.server.reactive.<unknown>#writeWith(file,position,count)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "file",
      "position",
      "count"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeWith(Path file, long position, long count)",
    "source_code": "\tpublic Mono<Void> writeWith(Path file, long position, long count) {\n\t\tCallback.Completable callback = new Callback.Completable();\n\t\tMono<Void> mono = Mono.fromFuture(callback);\n\t\ttry {\n\t\t\tContent.copy(Content.Source.from(null, file, position, count), this.response, callback);\n\t\t}\n\t\tcatch (Throwable th) {\n\t\t\tcallback.failed(th);\n\t\t}\n\t\treturn doCommit(() -> mono);\n\t}"
  },
  "org.springframework.http.support.<unknown>#add(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void add(String key, @Nullable String value)",
    "source_code": "\tpublic void add(String key, @Nullable String value) {\n\t\tif (value != null) {\n\t\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\t\tmutableHttpFields.add(key, value);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.http.support.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void addAll(String key, List<? extends String> values)",
    "source_code": "\tpublic void addAll(String key, List<? extends String> values) {\n\t\tvalues.forEach(value -> add(key, value));\n\t}"
  },
  "org.springframework.http.support.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tList<String> oldValues = get(key);\n\n\t\tif (oldValues == null) {\n\t\t\tswitch (value.size()) {\n\t\t\t\tcase 0 -> {}\n\t\t\t\tcase 1 -> mutableHttpFields.add(key, value.get(0));\n\t\t\t\tdefault -> mutableHttpFields.add(key, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tswitch (value.size()) {\n\t\t\t\tcase 0 -> mutableHttpFields.remove(key);\n\t\t\t\tcase 1 -> mutableHttpFields.put(key, value.get(0));\n\t\t\t\tdefault -> mutableHttpFields.put(key, value);\n\t\t\t}\n\t\t}\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.<unknown>#put(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> values)",
    "source_code": "\tpublic List<String> put(String key, List<String> values) {\n\t\tList<String> oldValues = remove(key);\n\t\tvalues.forEach(value -> add(key, value));\n\t\treturn oldValues;\n\t}"
  },
  "org.springframework.http.support.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.http.support.<unknown>#set(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void set(String key, @Nullable String value)",
    "source_code": "\tpublic void set(String key, @Nullable String value) {\n\t\tHttpFields.Mutable mutableHttpFields = mutableFields();\n\t\tif (value != null) {\n\t\t\tmutableHttpFields.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tmutableHttpFields.remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.http.support.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.jca.endpoint.<unknown>#createEndpoint(xaResource,timeout)": {
    "deprecated": false,
    "doc": "\t/**\n\t * The alternative JCA 1.6 version of {@code createEndpoint}.\n\t * <p>This implementation delegates to {@link #createEndpointInternal()},\n\t * ignoring the specified timeout. It is only here for JCA 1.6 compliance.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "xaResource",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "MessageEndpoint",
    "signature": "public MessageEndpoint createEndpoint(XAResource xaResource, long timeout)",
    "source_code": "\tpublic MessageEndpoint createEndpoint(XAResource xaResource, long timeout) throws UnavailableException {\n\t\tAbstractMessageEndpoint endpoint = createEndpointInternal();\n\t\tendpoint.initXAResource(xaResource);\n\t\treturn endpoint;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(psc,pss,generatedKeyHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 1030
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,\n\t\t\tfinal KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,\n\t\t\tfinal KeyHolder generatedKeyHolder) throws DataAccessException {\n\n\t\tint[] result = execute(psc, getPreparedStatementCallback(pss, generatedKeyHolder));\n\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs"
    ],
    "position": {
      "column": 1,
      "line": 1055
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs) throws DataAccessException {\n\t\treturn batchUpdate(sql, batchArgs, new int[0]);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1060
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes)",
    "source_code": "\tpublic int[] batchUpdate(String sql, List<Object[]> batchArgs, final int[] argTypes) throws DataAccessException {\n\t\tif (batchArgs.isEmpty()) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\treturn batchUpdate(\n\t\t\t\tsql,\n\t\t\t\tnew BatchPreparedStatementSetter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int getBatchSize() {\n\t\t\t\t\t\treturn batchArgs.size();\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,batchArgs,batchSize,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "batchArgs",
      "batchSize",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1097
    },
    "return": "int[][]",
    "signature": "public int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n\t\t\tfinal ParameterizedPreparedStatementSetter<T> pss)",
    "source_code": "\tpublic <T> int[][] batchUpdate(String sql, final Collection<T> batchArgs, final int batchSize,\n\t\t\tfinal ParameterizedPreparedStatementSetter<T> pss) throws DataAccessException {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL batch update [\" + sql + \"] with a batch size of \" + batchSize);\n\t\t}\n\t\tint[][] result = execute(sql, (PreparedStatementCallback<int[][]>) ps -> {\n\t\t\tList<int[]> rowsAffected = new ArrayList<>();\n\t\t\ttry {\n\t\t\t\tboolean batchSupported = JdbcUtils.supportsBatchUpdates(ps.getConnection());\n\t\t\t\tint n = 0;\n\t\t\t\tfor (T obj : batchArgs) {\n\t\t\t\t\tpss.setValues(ps, obj);\n\t\t\t\t\tn++;\n\t\t\t\t\tif (batchSupported) {\n\t\t\t\t\t\tps.addBatch();\n\t\t\t\t\t\tif (n % batchSize == 0 || n == batchArgs.size()) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tint batchIdx = (n % batchSize == 0) ? n / batchSize : (n / batchSize) + 1;\n\t\t\t\t\t\t\t\tint items = n - ((n % batchSize == 0) ? n / batchSize - 1 : (n / batchSize)) * batchSize;\n\t\t\t\t\t\t\t\tlogger.trace(\"Sending SQL batch update #\" + batchIdx + \" with \" + items + \" items\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tint[] updateCounts = ps.executeBatch();\n\t\t\t\t\t\t\t\trowsAffected.add(updateCounts);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (BatchUpdateException ex) {\n\t\t\t\t\t\t\t\tthrow new AggregatedBatchUpdateException(rowsAffected.toArray(int[][]::new), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint i = ps.executeUpdate();\n\t\t\t\t\t\trowsAffected.add(new int[] {i});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint[][] result1 = new int[rowsAffected.size()][];\n\t\t\t\tfor (int i = 0; i < result1.length; i++) {\n\t\t\t\t\tresult1[i] = rowsAffected.get(i);\n\t\t\t\t}\n\t\t\t\treturn result1;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#batchUpdate(sql,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1040
    },
    "return": "int[]",
    "signature": "public int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss)",
    "source_code": "\tpublic int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss) throws DataAccessException {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL batch update [\" + sql + \"]\");\n\t\t}\n\t\tint batchSize = pss.getBatchSize();\n\t\tif (batchSize == 0) {\n\t\t\treturn new int[0];\n\t\t}\n\n\t\tint[] result = execute(sql, getPreparedStatementCallback(pss, null));\n\t\tAssert.state(result != null, \"No result array\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#call(csc,declaredParameters)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "declaredParameters"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "Object>",
    "signature": "public Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)",
    "source_code": "\tpublic Map<String, Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)\n\t\t\tthrows DataAccessException {\n\n\t\tfinal List<SqlParameter> updateCountParameters = new ArrayList<>();\n\t\tfinal List<SqlParameter> resultSetParameters = new ArrayList<>();\n\t\tfinal List<SqlParameter> callParameters = new ArrayList<>();\n\n\t\tfor (SqlParameter parameter : declaredParameters) {\n\t\t\tif (parameter.isResultsParameter()) {\n\t\t\t\tif (parameter instanceof SqlReturnResultSet) {\n\t\t\t\t\tresultSetParameters.add(parameter);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateCountParameters.add(parameter);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcallParameters.add(parameter);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> result = execute(csc, cs -> {\n\t\t\tboolean retVal = cs.execute();\n\t\t\tint updateCount = cs.getUpdateCount();\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"CallableStatement.execute() returned '\" + retVal + \"'\");\n\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t}\n\t\t\tMap<String, Object> resultsMap = createResultsMap();\n\t\t\tif (retVal || updateCount != -1) {\n\t\t\t\tresultsMap.putAll(extractReturnedResults(cs, updateCountParameters, resultSetParameters, updateCount));\n\t\t\t}\n\t\t\tresultsMap.putAll(extractOutputParameters(cs, callParameters));\n\t\t\treturn resultsMap;\n\t\t});\n\n\t\tAssert.state(result != null, \"No result map\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#constructMappedInstance(rs,tc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current row.\n\t * @param rs the ResultSet to map (pre-initialized for the current row)\n\t * @param tc a TypeConverter with this RowMapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t * @throws SQLException if an SQLException is encountered\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(ResultSet rs, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(ResultSet rs, TypeConverter tc) throws SQLException {\n\t\tAssert.state(this.mappedClass != null, \"Mapped class was not specified\");\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#convertValueToRequiredType(value,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given column value to the specified required type.\n\t * Only called if the extracted column value does not match already.\n\t * <p>If the required type is String, the value will simply get stringified\n\t * via {@code toString()}. In case of a Number, the value will be\n\t * converted into a Number, either through number conversion or through\n\t * String parsing (depending on the value type). Otherwise, the value will\n\t * be converted to a required type using the {@link ConversionService}.\n\t * @param value the column value as extracted from {@code getColumnValue()}\n\t * (never {@code null})\n\t * @param requiredType the type that each result object is expected to match\n\t * (never {@code null})\n\t * @return the converted value\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "Object",
    "signature": "protected Object convertValueToRequiredType(Object value, Class<?> requiredType)",
    "source_code": "\tprotected Object convertValueToRequiredType(Object value, Class<?> requiredType) {\n\t\tif (String.class == requiredType) {\n\t\t\treturn value.toString();\n\t\t}\n\t\telse if (Number.class.isAssignableFrom(requiredType)) {\n\t\t\tif (value instanceof Number number) {\n\t\t\t\t// Convert original Number to target Number class.\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, (Class<Number>) requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Convert stringified value to target Number class.\n\t\t\t\treturn NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType);\n\t\t\t}\n\t\t}\n\t\telse if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {\n\t\t\treturn this.conversionService.convert(value, requiredType);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Value [\" + value + \"] is of type [\" + value.getClass().getName() +\n\t\t\t\t\t\"] and cannot be converted to required type [\" + requiredType.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#doSetValue(ps,parameterPosition,argType,argValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the prepared statement's specified parameter position\n\t * using the supplied value and type.\n\t * <p>This method can be overridden by subclasses if needed.\n\t * @param ps the PreparedStatement\n\t * @param parameterPosition index of the parameter position\n\t * @param argType the argument type\n\t * @param argValue the argument value\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ps",
      "parameterPosition",
      "argType",
      "argValue"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "protected void doSetValue(PreparedStatement ps, int parameterPosition, int argType, @Nullable Object argValue)",
    "source_code": "\tprotected void doSetValue(PreparedStatement ps, int parameterPosition, int argType, @Nullable Object argValue)\n\t\t\tthrows SQLException {\n\n\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, argType, argValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#doSetValue(ps,parameterPosition,argValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the prepared statement's specified parameter position\n\t * using the supplied value.\n\t * <p>This method can be overridden by subclasses if needed.\n\t * @param ps the PreparedStatement\n\t * @param parameterPosition index of the parameter position\n\t * @param argValue the value to set\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ps",
      "parameterPosition",
      "argValue"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "protected void doSetValue(PreparedStatement ps, int parameterPosition, @Nullable Object argValue)",
    "source_code": "\tprotected void doSetValue(PreparedStatement ps, int parameterPosition, @Nullable Object argValue)\n\t\t\tthrows SQLException {\n\n\t\tif (argValue instanceof SqlParameterValue paramValue) {\n\t\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, paramValue, paramValue.getValue());\n\t\t}\n\t\telse {\n\t\t\tStatementCreatorUtils.setParameterValue(ps, parameterPosition, SqlTypeValue.TYPE_UNKNOWN, argValue);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(callString,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "callString",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1204
    },
    "return": "T",
    "signature": "public T execute(String callString, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String callString, CallableStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimpleCallableStatementCreator(callString), action);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(csc,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "csc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1157
    },
    "return": "T",
    "signature": "public T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(csc, \"CallableStatementCreator must not be null\");\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString sql = getSql(csc);\n\t\t\tlogger.debug(\"Calling stored procedure\" + (sql != null ? \" [\" + sql + \"]\" : \"\"));\n\t\t}\n\n\t\tConnection con = DataSourceUtils.getConnection(obtainDataSource());\n\t\tCallableStatement cs = null;\n\t\ttry {\n\t\t\tcs = csc.createCallableStatement(con);\n\t\t\tapplyStatementSettings(cs);\n\t\t\tT result = action.doInCallableStatement(cs);\n\t\t\thandleWarnings(cs);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\t// Release Connection early, to avoid potential connection pool deadlock\n\t\t\t// in the case when the exception translator hasn't been initialized yet.\n\t\t\tif (csc instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t}\n\t\t\tif (cs != null) {\n\t\t\t\thandleWarnings(cs, ex);\n\t\t\t}\n\t\t\tString sql = getSql(csc);\n\t\t\tcsc = null;\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tcs = null;\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\tcon = null;\n\t\t\tthrow translateException(\"CallableStatementCallback\", sql, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (csc instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t}\n\t\t\tJdbcUtils.closeStatement(cs);\n\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(psc,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 692
    },
    "return": "T",
    "signature": "public T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action)\n\t\t\tthrows DataAccessException {\n\n\t\treturn execute(psc, action, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#execute(sql,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "T",
    "signature": "public T execute(String sql, PreparedStatementCallback<T> action)",
    "source_code": "\tpublic <T> T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {\n\t\treturn execute(new SimplePreparedStatementCreator(sql), action, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractOutputParameters(cs,parameters)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract output parameters from the completed stored procedure.\n\t * @param cs the JDBC wrapper for the stored procedure\n\t * @param parameters parameter list for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 1319
    },
    "return": "Object>",
    "signature": "protected Object> extractOutputParameters(CallableStatement cs, List<SqlParameter> parameters)",
    "source_code": "\tprotected Map<String, Object> extractOutputParameters(CallableStatement cs, List<SqlParameter> parameters)\n\t\t\tthrows SQLException {\n\n\t\tMap<String, Object> results = CollectionUtils.newLinkedHashMap(parameters.size());\n\t\tint sqlColIndex = 1;\n\t\tfor (SqlParameter param : parameters) {\n\t\t\tif (param instanceof SqlOutParameter outParam) {\n\t\t\t\tAssert.state(outParam.getName() != null, \"Anonymous parameters not allowed\");\n\t\t\t\tSqlReturnType returnType = outParam.getSqlReturnType();\n\t\t\t\tif (returnType != null) {\n\t\t\t\t\tObject out = returnType.getTypeValue(cs, sqlColIndex, outParam.getSqlType(), outParam.getTypeName());\n\t\t\t\t\tresults.put(outParam.getName(), out);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject out = cs.getObject(sqlColIndex);\n\t\t\t\t\tif (out instanceof ResultSet resultSet) {\n\t\t\t\t\t\tif (outParam.isResultSetSupported()) {\n\t\t\t\t\t\t\tresults.putAll(processResultSet(resultSet, outParam));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tString rsName = outParam.getName();\n\t\t\t\t\t\t\tSqlReturnResultSet rsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tresults.putAll(processResultSet(resultSet, rsParam));\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults.put(outParam.getName(), out);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!param.isResultsParameter()) {\n\t\t\t\tsqlColIndex++;\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#extractReturnedResults(cs,updateCountParameters,resultSetParameters,updateCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract returned ResultSets from the completed stored procedure.\n\t * @param cs a JDBC wrapper for the stored procedure\n\t * @param updateCountParameters the parameter list of declared update count parameters for the stored procedure\n\t * @param resultSetParameters the parameter list of declared resultSet parameters for the stored procedure\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "updateCountParameters",
      "resultSetParameters",
      "updateCount"
    ],
    "position": {
      "column": 1,
      "line": 1256
    },
    "return": "Object>",
    "signature": "protected Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount)",
    "source_code": "\tprotected Map<String, Object> extractReturnedResults(CallableStatement cs,\n\t\t\t@Nullable List<SqlParameter> updateCountParameters, @Nullable List<SqlParameter> resultSetParameters,\n\t\t\tint updateCount) throws SQLException {\n\n\t\tMap<String, Object> results = new LinkedHashMap<>(4);\n\t\tint rsIndex = 0;\n\t\tint updateIndex = 0;\n\t\tboolean moreResults;\n\t\tif (!this.skipResultsProcessing) {\n\t\t\tdo {\n\t\t\t\tif (updateCount == -1) {\n\t\t\t\t\tif (resultSetParameters != null && resultSetParameters.size() > rsIndex) {\n\t\t\t\t\t\tSqlReturnResultSet declaredRsParam = (SqlReturnResultSet) resultSetParameters.get(rsIndex);\n\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), declaredRsParam));\n\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString rsName = RETURN_RESULT_SET_PREFIX + (rsIndex + 1);\n\t\t\t\t\t\t\tSqlReturnResultSet undeclaredRsParam = new SqlReturnResultSet(rsName, getColumnMapRowMapper());\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.putAll(processResultSet(cs.getResultSet(), undeclaredRsParam));\n\t\t\t\t\t\t\trsIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (updateCountParameters != null && updateCountParameters.size() > updateIndex) {\n\t\t\t\t\t\tSqlReturnUpdateCount ucParam = (SqlReturnUpdateCount) updateCountParameters.get(updateIndex);\n\t\t\t\t\t\tString declaredUcName = ucParam.getName();\n\t\t\t\t\t\tresults.put(declaredUcName, updateCount);\n\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!this.skipUndeclaredResults) {\n\t\t\t\t\t\t\tString undeclaredName = RETURN_UPDATE_COUNT_PREFIX + (updateIndex + 1);\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Added default SqlReturnUpdateCount parameter named '\" + undeclaredName + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults.put(undeclaredName, updateCount);\n\t\t\t\t\t\t\tupdateIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmoreResults = cs.getMoreResults();\n\t\t\t\tupdateCount = cs.getUpdateCount();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"CallableStatement.getUpdateCount() returned \" + updateCount);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (moreResults || updateCount != -1);\n\t\t}\n\t\treturn results;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column, using the most\n\t * appropriate value type. Called if no required type has been specified.\n\t * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},\n\t * which uses the {@code ResultSet.getObject(index)} method. Additionally,\n\t * it includes a \"hack\" to get around Oracle returning a non-standard object for\n\t * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}\n\t * javadoc for details.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,paramType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * <p>Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code getResultSetValue}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @since 5.3\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, Class<?> paramType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, Class<?> paramType) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, paramType);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,pd)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}\n\t * using the type of the specified {@link PropertyDescriptor}.\n\t * <p>Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code getResultSetValue}.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param pd the bean property that each result object is expected to match\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see #getColumnValue(ResultSet, int, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "pd"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd) throws SQLException {\n\t\treturn JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#getColumnValue(rs,index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC object value for the specified column.\n\t * <p>The default implementation calls\n\t * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.\n\t * If no required type has been specified, this method delegates to\n\t * {@code getColumnValue(rs, index)}, which basically calls\n\t * {@code ResultSet.getObject(index)} but applies some additional\n\t * default conversion to appropriate value types.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the type that each result object is expected to match\n\t * (or {@code null} if none specified)\n\t * @return the Object value\n\t * @throws SQLException in case of extraction failure\n\t * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)\n\t * @see #getColumnValue(java.sql.ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Object",
    "signature": "protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tprotected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType != null) {\n\t\t\treturn JdbcUtils.getResultSetValue(rs, index, requiredType);\n\t\t}\n\t\telse {\n\t\t\t// No required type specified -> perform default extraction.\n\t\t\treturn getColumnValue(rs, index);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#handleWarnings(stmt,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle warnings before propagating a primary {@code SQLException}\n\t * from executing the given statement.\n\t * <p>Calls regular {@link #handleWarnings(Statement)} but catches\n\t * {@link SQLWarningException} in order to chain the {@link SQLWarning}\n\t * into the primary exception instead.\n\t * @param stmt the current JDBC statement\n\t * @param ex the primary exception after failed statement execution\n\t * @since 5.3.29\n\t * @see #handleWarnings(Statement)\n\t * @see SQLException#setNextException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "stmt",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1492
    },
    "return": "void",
    "signature": "protected void handleWarnings(Statement stmt, SQLException ex)",
    "source_code": "\tprotected void handleWarnings(Statement stmt, SQLException ex) {\n\t\ttry {\n\t\t\thandleWarnings(stmt);\n\t\t}\n\t\tcatch (SQLWarningException nonIgnoredWarning) {\n\t\t\tex.setNextException(nonIgnoredWarning.getSQLWarning());\n\t\t}\n\t\tcatch (SQLException warningsEx) {\n\t\t\tlogger.debug(\"Failed to retrieve warnings\", warningsEx);\n\t\t}\n\t\tcatch (Throwable warningsEx) {\n\t\t\tlogger.debug(\"Failed to process warnings\", warningsEx);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1666
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> (proxy == args[0]);\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> null;\n\t\t\t\tcase \"isClosed\" -> false;\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\tcase \"getTargetConnection\" -> this.target;\n\t\t\t\tcase \"unwrap\" ->\n\t\t\t\t\t\t(((Class<?>) args[0]).isInstance(proxy) ? proxy : this.target.unwrap((Class<?>) args[0]));\n\t\t\t\tcase \"isWrapperFor\" ->\n\t\t\t\t\t\t(((Class<?>) args[0]).isInstance(proxy) || this.target.isWrapperFor((Class<?>) args[0]));\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tObject retVal = method.invoke(this.target, args);\n\n\t\t\t\t\t\t// If return value is a JDBC Statement, apply statement settings\n\t\t\t\t\t\t// (fetch size, max rows, transaction timeout).\n\t\t\t\t\t\tif (retVal instanceof Statement statement) {\n\t\t\t\t\t\t\tapplyStatementSettings(statement);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tyield retVal;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.jdbc.core.<unknown>#mapRow(rs,rowNum)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract a value for the single column in the current row.\n\t * <p>Validates that there is only one column selected,\n\t * then delegates to {@code getColumnValue()} and also\n\t * {@code convertValueToRequiredType}, if necessary.\n\t * @see java.sql.ResultSetMetaData#getColumnCount()\n\t * @see #getColumnValue(java.sql.ResultSet, int, Class)\n\t * @see #convertValueToRequiredType(Object, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t// Validate column count.\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint nrOfColumns = rsmd.getColumnCount();\n\t\tif (nrOfColumns != 1) {\n\t\t\tthrow new IncorrectResultSetColumnCountException(1, nrOfColumns);\n\t\t}\n\n\t\t// Extract column value from JDBC ResultSet.\n\t\tObject result = getColumnValue(rs, 1, this.requiredType);\n\t\tif (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {\n\t\t\t// Extracted value does not match already: try to convert it.\n\t\t\ttry {\n\t\t\t\treturn (T) convertValueToRequiredType(result, this.requiredType);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new TypeMismatchDataAccessException(\n\t\t\t\t\t\t\"Type mismatch affecting row number \" + rowNum + \" and column type '\" +\n\t\t\t\t\t\trsmd.getColumnTypeName(1) + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn (T) result;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#mapRow(rs,rowNumber)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "rowNumber"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "T",
    "signature": "public T mapRow(ResultSet rs, int rowNumber)",
    "source_code": "\tpublic T mapRow(ResultSet rs, int rowNumber) throws SQLException {\n\t\tObject[] args = new Object[this.constructorParameterNames.length];\n\t\tSet<Integer> usedIndex = new HashSet<>();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tString name = this.constructorParameterNames[i];\n\t\t\tint index;\n\t\t\ttry {\n\t\t\t\t// Try direct name match first\n\t\t\t\tindex = rs.findColumn(name);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\t// Try underscored name match instead\n\t\t\t\tindex = rs.findColumn(JdbcUtils.convertPropertyNameToUnderscoreName(name));\n\t\t\t}\n\t\t\tTypeDescriptor td = this.constructorParameterTypes[i];\n\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, td.getType());\n\t\t\tusedIndex.add(index);\n\t\t\targs[i] = this.conversionService.convert(value, td);\n\t\t}\n\t\tT mappedObject = BeanUtils.instantiateClass(this.mappedConstructor, args);\n\n\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\tint columnCount = rsmd.getColumnCount();\n\t\tfor (int index = 1; index <= columnCount; index++) {\n\t\t\tif (!usedIndex.contains(index)) {\n\t\t\t\tObject desc = getDescriptor(JdbcUtils.lookupColumnName(rsmd, index));\n\t\t\t\tif (desc instanceof MethodParameter mp) {\n\t\t\t\t\tMethod method = mp.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, mp.getParameterType());\n\t\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(mp));\n\t\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\t\tReflectionUtils.invokeMethod(method, mappedObject, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (desc instanceof Field field) {\n\t\t\t\t\tObject value = JdbcUtils.getResultSetValue(rs, index, field.getType());\n\t\t\t\t\tvalue = this.conversionService.convert(value, new TypeDescriptor(field));\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tReflectionUtils.setField(field, mappedObject, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappedObject;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newArgTypePreparedStatementSetter(args,argTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new arg-type-based PreparedStatementSetter using the args and types passed in.\n\t * <p>By default, we'll create an {@link ArgumentTypePreparedStatementSetter}.\n\t * This method allows for the creation to be overridden by subclasses.\n\t * @param args object array with arguments\n\t * @param argTypes int array of SQLTypes for the associated arguments\n\t * @return the new PreparedStatementSetter to use\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1476
    },
    "return": "PreparedStatementSetter",
    "signature": "protected PreparedStatementSetter newArgTypePreparedStatementSetter(Object[] args, int[] argTypes)",
    "source_code": "\tprotected PreparedStatementSetter newArgTypePreparedStatementSetter(Object[] args, int[] argTypes) {\n\t\treturn new ArgumentTypePreparedStatementSetter(args, argTypes);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(mappedClass,conversionService)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code BeanPropertyRowMapper}.\n\t * @param mappedClass the class that each row should be mapped to\n\t * @param conversionService the {@link ConversionService} for binding\n\t * JDBC values to bean properties, or {@code null} for none\n\t * @since 5.2.3\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mappedClass",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 472
    },
    "return": "BeanPropertyRowMapper<T>",
    "signature": "public BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> BeanPropertyRowMapper<T> newInstance(\n\t\t\tClass<T> mappedClass, @Nullable ConversionService conversionService) {\n\n\t\tBeanPropertyRowMapper<T> rowMapper = newInstance(mappedClass);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newInstance(requiredType,conversionService)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a new {@code SingleColumnRowMapper}.\n\t * @param requiredType the type that each result object is expected to match\n\t * @param conversionService the {@link ConversionService} for converting a\n\t * fetched value, or {@code null} for none\n\t * @since 5.0.4\n\t * @see #newInstance(Class)\n\t * @see #setConversionService\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "SingleColumnRowMapper<T>",
    "signature": "public SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService)",
    "source_code": "\tpublic static <T> SingleColumnRowMapper<T> newInstance(\n\t\t\tClass<T> requiredType, @Nullable ConversionService conversionService) {\n\n\t\tSingleColumnRowMapper<T> rowMapper = newInstance(requiredType);\n\t\trowMapper.setConversionService(conversionService);\n\t\treturn rowMapper;\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#newPreparedStatementCreator(sqlToUse,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a new PreparedStatementCreator for the given parameters.\n\t * @param sqlToUse the actual SQL statement to use (if different from\n\t * the factory's, for example because of named parameter expanding)\n\t * @param params the parameter array (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sqlToUse",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "PreparedStatementCreator",
    "signature": "public PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params)",
    "source_code": "\tpublic PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params) {\n\t\treturn new PreparedStatementCreatorImpl(\n\t\t\t\tsqlToUse, (params != null ? Arrays.asList(params) : Collections.emptyList()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#processResultSet(rs,param)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given ResultSet from a stored procedure.\n\t * @param rs the ResultSet to process\n\t * @param param the corresponding stored procedure parameter\n\t * @return a Map that contains returned results\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "param"
    ],
    "position": {
      "column": 1,
      "line": 1365
    },
    "return": "Object>",
    "signature": "protected Object> processResultSet(@Nullable ResultSet rs, ResultSetSupportingSqlParameter param)",
    "source_code": "\tprotected Map<String, Object> processResultSet(\n\t\t\t@Nullable ResultSet rs, ResultSetSupportingSqlParameter param) throws SQLException {\n\n\t\tif (rs != null) {\n\t\t\ttry {\n\t\t\t\tif (param.getRowMapper() != null) {\n\t\t\t\t\tRowMapper<?> rowMapper = param.getRowMapper();\n\t\t\t\t\tObject data = (new RowMapperResultSetExtractor<>(rowMapper)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t\telse if (param.getRowCallbackHandler() != null) {\n\t\t\t\t\tRowCallbackHandler rch = param.getRowCallbackHandler();\n\t\t\t\t\t(new RowCallbackHandlerResultSetExtractor(rch)).extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(),\n\t\t\t\t\t\t\t\"ResultSet returned from stored procedure was processed\");\n\t\t\t\t}\n\t\t\t\telse if (param.getResultSetExtractor() != null) {\n\t\t\t\t\tObject data = param.getResultSetExtractor().extractData(rs);\n\t\t\t\t\treturn Collections.singletonMap(param.getName(), data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyMap();\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,pss,rse)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rse a callback that will extract results\n\t * @return an arbitrary result object, as returned by the ResultSetExtractor\n\t * @throws DataAccessException if there is any problem\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 716
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(\n\t\t\tPreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor<T> rse)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tlogger.debug(\"Executing prepared SQL query\");\n\n\t\treturn execute(psc, new PreparedStatementCallback<>() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInPreparedStatement(PreparedStatement ps) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\tif (pss != null) {\n\t\t\t\t\t\tpss.setValues(ps);\n\t\t\t\t\t}\n\t\t\t\t\trs = ps.executeQuery();\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 777
    },
    "return": "void",
    "signature": "public void query(PreparedStatementCreator psc, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(PreparedStatementCreator psc, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(psc, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "List<T>",
    "signature": "public List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(psc, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(psc,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 747
    },
    "return": "T",
    "signature": "public T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(psc, null, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 787
    },
    "return": "void",
    "signature": "public void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, newArgTypePreparedStatementSetter(args, argTypes), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 813
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, args, argTypes, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,argTypes,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "T",
    "signature": "public T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, newArgTypePreparedStatementSetter(args, argTypes), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 793
    },
    "return": "void",
    "signature": "public void query(String sql, @Nullable Object[] args, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, @Nullable Object[] args, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, newArgPreparedStatementSetter(args), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 819
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, @Nullable Object[] args, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, args, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,args,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 766
    },
    "return": "T",
    "signature": "public T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, @Nullable Object[] args, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(sql, newArgPreparedStatementSetter(args), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 782
    },
    "return": "void",
    "signature": "public void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, pss, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 808
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, pss, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,pss,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 753
    },
    "return": "T",
    "signature": "public T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse) throws DataAccessException {\n\t\treturn query(new SimplePreparedStatementCreator(sql), pss, rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch) throws DataAccessException {\n\t\tquery(sql, new RowCallbackHandlerResultSetExtractor(rch));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rch,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rch",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 798
    },
    "return": "void",
    "signature": "public void query(String sql, RowCallbackHandler rch, @Nullable Object... args)",
    "source_code": "\tpublic void query(String sql, RowCallbackHandler rch, @Nullable Object... args) throws DataAccessException {\n\t\tquery(sql, newArgPreparedStatementSetter(args), rch);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn result(query(sql, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rowMapper,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 824
    },
    "return": "List<T>",
    "signature": "public List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(query(sql, args, new RowMapperResultSetExtractor<>(rowMapper)));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "T",
    "signature": "public T query(final String sql, final ResultSetExtractor<T> rse)",
    "source_code": "\tpublic <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {\n\t\tAssert.notNull(sql, \"SQL must not be null\");\n\t\tAssert.notNull(rse, \"ResultSetExtractor must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Executing SQL query [\" + sql + \"]\");\n\t\t}\n\n\t\t// Callback to execute the query.\n\t\tclass QueryStatementCallback implements StatementCallback<T>, SqlProvider {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = null;\n\t\t\t\ttry {\n\t\t\t\t\trs = stmt.executeQuery(sql);\n\t\t\t\t\treturn rse.extractData(rs);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn execute(new QueryStatementCallback(), true);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#query(sql,rse,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rse",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 772
    },
    "return": "T",
    "signature": "public T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args)",
    "source_code": "\tpublic <T> T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, newArgPreparedStatementSetter(args), rse);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 953
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, @Nullable Object... args)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 948
    },
    "return": "Object>>",
    "signature": "public Object>> queryForList(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic List<Map<String, Object>> queryForList(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn query(sql, args, argTypes, getColumnMapRowMapper());\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,argTypes,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 932
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, args, argTypes, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,args,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 938
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, @Nullable Object[] args, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType"
    ],
    "position": {
      "column": 1,
      "line": 530
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType) throws DataAccessException {\n\t\treturn query(sql, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForList(sql,elementType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "elementType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 943
    },
    "return": "List<T>",
    "signature": "public List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args)",
    "source_code": "\tpublic <T> List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args) throws DataAccessException {\n\t\treturn query(sql, args, getSingleColumnRowMapper(elementType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 927
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, @Nullable Object... args)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForMap(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "Object>",
    "signature": "public Object> queryForMap(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(queryForObject(sql, args, argTypes, getColumnMapRowMapper()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 902
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)\n\t\t\tthrows DataAccessException {\n\n\t\treturn queryForObject(sql, args, argTypes, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,argTypes,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 878
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)\n\t\t\tthrows DataAccessException {\n\n\t\tList<T> results = query(sql, args, argTypes, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,args,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 888
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tList<T> results = query(sql, args, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 525
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType) throws DataAccessException {\n\t\treturn queryForObject(sql, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 917
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForObject(sql, args, getSingleColumnRowMapper(requiredType));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 518
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> T queryForObject(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tList<T> results = query(sql, rowMapper);\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForObject(sql,rowMapper,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 895
    },
    "return": "T",
    "signature": "public T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\tList<T> results = query(sql, args, new RowMapperResultSetExtractor<>(rowMapper, 1));\n\t\treturn DataAccessUtils.nullableSingleResult(results);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForRowSet(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 963
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, @Nullable Object... args)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn result(query(sql, args, new SqlRowSetResultSetExtractor()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForRowSet(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 958
    },
    "return": "SqlRowSet",
    "signature": "public SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn result(query(sql, args, argTypes, new SqlRowSetResultSetExtractor()));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,pss,rowMapper)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Query using a prepared statement, allowing for a PreparedStatementCreator\n\t * and a PreparedStatementSetter. Most other query methods use this method,\n\t * but application code will always work with either a creator or a setter.\n\t * @param psc a callback that creates a PreparedStatement given a Connection\n\t * @param pss a callback that knows how to set values on the prepared statement.\n\t * If this is {@code null}, the SQL will be assumed to contain no bind parameters.\n\t * @param rowMapper a callback that will map one object per row\n\t * @return the result Stream, containing mapped objects, needing to be\n\t * closed once fully processed (for example, through a try-with-resources clause)\n\t * @throws DataAccessException if the query fails\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 841
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, @Nullable PreparedStatementSetter pss,\n\t\t\tRowMapper<T> rowMapper) throws DataAccessException {\n\n\t\treturn result(execute(psc, ps -> {\n\t\t\tif (pss != null) {\n\t\t\t\tpss.setValues(ps);\n\t\t\t}\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tConnection con = ps.getConnection();\n\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t\tJdbcUtils.closeStatement(ps);\n\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t});\n\t\t}, false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(psc,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 862
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn queryForStream(psc, null, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,pss,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 867
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), pss, rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 490
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n\t\tclass StreamStatementCallback implements StatementCallback<Stream<T>>, SqlProvider {\n\t\t\t@Override\n\t\t\tpublic Stream<T> doInStatement(Statement stmt) throws SQLException {\n\t\t\t\tResultSet rs = stmt.executeQuery(sql);\n\t\t\t\tConnection con = stmt.getConnection();\n\t\t\t\treturn new ResultSetSpliterator<>(rs, rowMapper).stream().onClose(() -> {\n\t\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\t\t\t});\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSql() {\n\t\t\t\treturn sql;\n\t\t\t}\n\t\t}\n\n\t\treturn result(execute(new StreamStatementCallback(), false));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#queryForStream(sql,rowMapper,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "rowMapper",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 872
    },
    "return": "Stream<T>",
    "signature": "public Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args)",
    "source_code": "\tpublic <T> Stream<T> queryForStream(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {\n\t\treturn queryForStream(new SimplePreparedStatementCreator(sql), newArgPreparedStatementSetter(args), rowMapper);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,param,inValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param param the parameter as it is declared including type\n\t * @param inValue the value to set\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "param",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,inValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setParameterValue(ps,paramIndex,sqlType,typeName,inValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for a parameter. The method used is based on the SQL type\n\t * of the parameter and we can handle complex types like arrays and LOBs.\n\t * @param ps the prepared statement or callable statement\n\t * @param paramIndex index of the parameter we are setting\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * (optional, only used for SQL NULL and SqlTypeValue)\n\t * @param inValue the value to set (plain value or an SqlTypeValue)\n\t * @throws SQLException if thrown by PreparedStatement methods\n\t * @see SqlTypeValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName",
      "inValue"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue)",
    "source_code": "\tpublic static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,\n\t\t\t@Nullable Object inValue) throws SQLException {\n\n\t\tsetParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue);\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#setValues(ps,i)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "i"
    ],
    "position": {
      "column": 1,
      "line": 1069
    },
    "return": "void",
    "signature": "public void setValues(PreparedStatement ps, int i)",
    "source_code": "\t\t\t\t\tpublic void setValues(PreparedStatement ps, int i) throws SQLException {\n\t\t\t\t\t\tObject[] values = batchArgs.get(i);\n\t\t\t\t\t\tint colIndex = 0;\n\t\t\t\t\t\tfor (Object value : values) {\n\t\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t\t\tif (value instanceof SqlParameterValue paramValue) {\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, paramValue, paramValue.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint colType;\n\t\t\t\t\t\t\t\tif (argTypes.length < colIndex) {\n\t\t\t\t\t\t\t\t\tcolType = SqlTypeValue.TYPE_UNKNOWN;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcolType = argTypes[colIndex - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatementCreatorUtils.setParameterValue(ps, colIndex, colType, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}"
  },
  "org.springframework.jdbc.core.<unknown>#translateException(task,sql,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given {@link SQLException} into a generic {@link DataAccessException}.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param ex the offending {@code SQLException}\n\t * @return a DataAccessException wrapping the {@code SQLException} (never {@code null})\n\t * @since 5.0\n\t * @see #getExceptionTranslator()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1555
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException translateException(String task, @Nullable String sql, SQLException ex)",
    "source_code": "\tprotected DataAccessException translateException(String task, @Nullable String sql, SQLException ex) {\n\t\tDataAccessException dae = getExceptionTranslator().translate(task, sql, ex);\n\t\treturn (dae != null ? dae : new UncategorizedSQLException(task, sql, ex));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,generatedKeyHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "psc",
      "generatedKeyHolder"
    ],
    "position": {
      "column": 1,
      "line": 997
    },
    "return": "int",
    "signature": "public int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)",
    "source_code": "\tpublic int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(generatedKeyHolder, \"KeyHolder must not be null\");\n\t\tlogger.debug(\"Executing SQL update and returning generated keys\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\tint rows = ps.executeUpdate();\n\t\t\tgeneratedKeyHolder.getKeyList().clear();\n\t\t\tstoreGeneratedKeys(generatedKeyHolder, ps, 1);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows and returned \" + generatedKeyHolder.getKeyList().size() + \" keys\");\n\t\t\t}\n\t\t\treturn rows;\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(psc,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "psc",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 967
    },
    "return": "int",
    "signature": "protected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss)",
    "source_code": "\tprotected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss)\n\t\t\tthrows DataAccessException {\n\n\t\tlogger.debug(\"Executing prepared SQL update\");\n\n\t\treturn updateCount(execute(psc, ps -> {\n\t\t\ttry {\n\t\t\t\tif (pss != null) {\n\t\t\t\t\tpss.setValues(ps);\n\t\t\t\t}\n\t\t\t\tint rows = ps.executeUpdate();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"SQL update affected \" + rows + \" rows\");\n\t\t\t\t}\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (pss instanceof ParameterDisposer parameterDisposer) {\n\t\t\t\t\tparameterDisposer.cleanupParameters();\n\t\t\t\t}\n\t\t\t}\n\t\t}, true));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "int",
    "signature": "public int update(String sql, @Nullable Object... args)",
    "source_code": "\tpublic int update(String sql, @Nullable Object... args) throws DataAccessException {\n\t\treturn update(sql, newArgPreparedStatementSetter(args));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,args,argTypes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "args",
      "argTypes"
    ],
    "position": {
      "column": 1,
      "line": 1020
    },
    "return": "int",
    "signature": "public int update(String sql, Object[] args, int[] argTypes)",
    "source_code": "\tpublic int update(String sql, Object[] args, int[] argTypes) throws DataAccessException {\n\t\treturn update(sql, newArgTypePreparedStatementSetter(args, argTypes));\n\t}"
  },
  "org.springframework.jdbc.core.<unknown>#update(sql,pss)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "pss"
    ],
    "position": {
      "column": 1,
      "line": 1015
    },
    "return": "int",
    "signature": "public int update(String sql, @Nullable PreparedStatementSetter pss)",
    "source_code": "\tpublic int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException {\n\t\treturn update(new SimplePreparedStatementCreator(sql), pss);\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createDefaultInOutParameter(parameterName,meta)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "meta"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createDefaultInOutParameter(String parameterName, CallParameterMetaData meta)",
    "source_code": "\tpublic SqlParameter createDefaultInOutParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlInOutParameter(parameterName, meta.getSqlType());\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createDefaultInParameter(parameterName,meta)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "meta"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createDefaultInParameter(String parameterName, CallParameterMetaData meta)",
    "source_code": "\tpublic SqlParameter createDefaultInParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlParameter(parameterName, meta.getSqlType());\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createDefaultOutParameter(parameterName,meta)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "meta"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createDefaultOutParameter(String parameterName, CallParameterMetaData meta)",
    "source_code": "\tpublic SqlParameter createDefaultOutParameter(String parameterName, CallParameterMetaData meta) {\n\t\treturn new SqlOutParameter(parameterName, meta.getSqlType());\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createMetaDataProvider(dataSource,context)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CallMetaDataProvider} based on the database meta-data.\n\t * @param dataSource the JDBC DataSource to use for retrieving meta-data\n\t * @param context the class that holds configuration and meta-data\n\t * @return instance of the CallMetaDataProvider implementation to be used\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "CallMetaDataProvider",
    "signature": "public CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context)",
    "source_code": "\tpublic static CallMetaDataProvider createMetaDataProvider(DataSource dataSource, final CallMetaDataContext context) {\n\t\ttry {\n\t\t\treturn JdbcUtils.extractDatabaseMetaData(dataSource, databaseMetaData -> {\n\t\t\t\tString databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\n\t\t\t\tif (databaseProductName == null) {\n\t\t\t\t\tdatabaseProductName = \"\";\n\t\t\t\t}\n\n\t\t\t\tboolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\n\t\t\t\tif (context.isFunction()) {\n\t\t\t\t\tif (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for function calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForFunctions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(databaseProductName + \" is not one of the databases fully supported for procedure calls \" +\n\t\t\t\t\t\t\t\t\t\"-- supported are: \" + supportedDatabaseProductsForProcedures);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\t\t\tlogger.info(\"Metadata processing disabled - you must specify all parameters explicitly\");\n\t\t\t\t\t\t\taccessProcedureColumnMetaData = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tCallMetaDataProvider provider = switch (databaseProductName) {\n\t\t\t\t\tcase ORACLE -> new OracleCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase POSTGRES -> new PostgresCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DERBY -> new DerbyCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase DB2 -> new Db2CallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase HANA -> new HanaCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase MS_SQL_SERVER -> new SqlServerCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tcase SYBASE -> new SybaseCallMetaDataProvider(databaseMetaData);\n\t\t\t\t\tdefault -> new GenericCallMetaDataProvider(databaseMetaData);\n\t\t\t\t};\n\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Using \" + provider.getClass().getName());\n\t\t\t\t}\n\t\t\t\tprovider.initializeWithMetaData(databaseMetaData);\n\t\t\t\tif (accessProcedureColumnMetaData) {\n\t\t\t\t\tprovider.initializeWithProcedureColumnMetaData(databaseMetaData,\n\t\t\t\t\t\t\tcontext.getCatalogName(), context.getSchemaName(), context.getProcedureName());\n\t\t\t\t}\n\t\t\t\treturn provider;\n\t\t\t});\n\t\t}\n\t\tcatch (MetaDataAccessException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Error retrieving database meta-data\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#createReturnResultSetParameter(parameterName,rowMapper)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a ReturnResultSetParameter/SqlOutParameter depending on the support provided\n\t * by the JDBC driver used for the database in use.\n\t * @param parameterName the name of the parameter (also used as the name of the List returned in the output)\n\t * @param rowMapper a RowMapper implementation used to map the data returned in the result set\n\t * @return the appropriate SqlParameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterName",
      "rowMapper"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "SqlParameter",
    "signature": "public SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper)",
    "source_code": "\tpublic SqlParameter createReturnResultSetParameter(String parameterName, RowMapper<?> rowMapper) {\n\t\tCallMetaDataProvider provider = obtainMetaDataProvider();\n\t\tif (provider.isReturnResultSetSupported()) {\n\t\t\treturn new SqlReturnResultSet(parameterName, rowMapper);\n\t\t}\n\t\telse {\n\t\t\tif (provider.isRefCursorSupported()) {\n\t\t\t\treturn new SqlOutParameter(parameterName, provider.getRefCursorSqlType(), rowMapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"Return of a ResultSet from a stored procedure is not supported\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.metadata.<unknown>#initializeWithProcedureColumnMetaData(databaseMetaData,catalogName,schemaName,procedureName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "databaseMetaData",
      "catalogName",
      "schemaName",
      "procedureName"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void initializeWithProcedureColumnMetaData(DatabaseMetaData databaseMetaData, @Nullable String catalogName,\n\t\t\t@Nullable String schemaName, @Nullable String procedureName)",
    "source_code": "\tpublic void initializeWithProcedureColumnMetaData(DatabaseMetaData databaseMetaData, @Nullable String catalogName,\n\t\t\t@Nullable String schemaName, @Nullable String procedureName) throws SQLException {\n\n\t\tthis.procedureColumnMetaDataUsed = true;\n\t\tprocessProcedureColumns(databaseMetaData, catalogName, schemaName, procedureName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\tregisterSqlType(paramName, sqlParameterValue.getSqlType());\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value,sqlType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValue(paramName,value,sqlType,typeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a parameter to this parameter source.\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t * @param typeName the type name of the parameter\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "value",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName)",
    "source_code": "\tpublic MapSqlParameterSource addValue(String paramName, @Nullable Object value, int sqlType, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.values.put(paramName, value);\n\t\tregisterSqlType(paramName, sqlType);\n\t\tregisterTypeName(paramName, typeName);\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#addValues(Map<String,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Map of parameters to this parameter source.\n\t * @param values a Map holding existing parameter values (can be {@code null})\n\t * @return a reference to this parameter source,\n\t * so it's possible to chain several calls together\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "MapSqlParameterSource",
    "signature": "public MapSqlParameterSource addValues(@Nullable Map<String, ?> values)",
    "source_code": "\tpublic MapSqlParameterSource addValues(@Nullable Map<String, ?> values) {\n\t\tif (values != null) {\n\t\t\tvalues.forEach((key, value) -> {\n\t\t\t\tthis.values.put(key, value);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tregisterSqlType(key, sqlParameterValue.getSqlType());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildSqlParameterList(parsedSql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters.\n\t * This is necessary in order to reuse existing methods on JdbcTemplate.\n\t * The SqlParameter for a named parameter is placed in the correct position in the\n\t * resulting list based on the parsed SQL statement info.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 447
    },
    "return": "List<SqlParameter>",
    "signature": "public List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tList<SqlParameter> params = new ArrayList<>(paramNames.size());\n\t\tfor (String paramName : paramNames) {\n\t\t\tparams.add(new SqlParameter(\n\t\t\t\t\tparamName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)));\n\t\t}\n\t\treturn params;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildSqlTypeArray(parsedSql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert parameter types from an SqlParameterSource into a corresponding int array.\n\t * This is necessary in order to reuse existing methods on JdbcTemplate.\n\t * Any named parameter types are placed in the correct position in the\n\t * Object array based on the parsed SQL statement info.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "int[]",
    "signature": "public int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {\n\t\tint[] sqlTypes = new int[parsedSql.getTotalParameterCount()];\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tsqlTypes[i] = paramSource.getSqlType(paramName);\n\t\t}\n\t\treturn sqlTypes;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(parsedSql,paramSource,declaredParams)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * @param parsedSql the parsed SQL statement\n\t * @param paramSource the source for named parameters\n\t * @param declaredParams the List of declared SqlParameter objects\n\t * (may be {@code null}). If specified, the parameter metadata will\n\t * be built into the value array in the form of SqlParameterValue objects.\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource",
      "declaredParams"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams)",
    "source_code": "\tpublic static Object[] buildValueArray(\n\t\t\tParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {\n\n\t\tObject[] paramArray = new Object[parsedSql.getTotalParameterCount()];\n\t\tif (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {\n\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\"Not allowed to mix named and traditional ? placeholders. You have \" +\n\t\t\t\t\tparsedSql.getNamedParameterCount() + \" named parameter(s) and \" +\n\t\t\t\t\tparsedSql.getUnnamedParameterCount() + \" traditional placeholder(s) in statement: \" +\n\t\t\t\t\tparsedSql.getOriginalSql());\n\t\t}\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\ttry {\n\t\t\t\tSqlParameter param = findParameter(declaredParams, paramName, i);\n\t\t\t\tObject paramValue = paramSource.getValue(paramName);\n\t\t\t\tif (paramValue instanceof SqlParameterValue) {\n\t\t\t\t\tparamArray[i] = paramValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparamArray[i] = (param != null ? new SqlParameterValue(param, paramValue) :\n\t\t\t\t\t\t\tSqlParameterSourceUtils.getTypedValue(paramSource, paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tthrow new InvalidDataAccessApiUsageException(\n\t\t\t\t\t\t\"No value supplied for the SQL parameter '\" + paramName + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn paramArray;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#buildValueArray(sql,Map<String,paramMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Map of named parameter values to a corresponding array.\n\t * <p>This is a shortcut version of\n\t * {@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}.\n\t * @param sql the SQL statement\n\t * @param paramMap the Map of parameters\n\t * @return the array of values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "Object[]",
    "signature": "public Object[] buildValueArray(String sql, Map<String, ?> paramMap)",
    "source_code": "\tpublic static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#createBatch(Map<String,valueMaps)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an array of {@link MapSqlParameterSource} objects populated with data from\n\t * the values passed in. This will define what is included in a batch operation.\n\t * @param valueMaps array of {@link Map} instances containing the values to be used\n\t * @return an array of {@link SqlParameterSource}\n\t * @see MapSqlParameterSource\n\t * @see NamedParameterJdbcTemplate#batchUpdate(String, Map[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "valueMaps"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "SqlParameterSource[]",
    "signature": "public SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps)",
    "source_code": "\tpublic static SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps) {\n\t\tSqlParameterSource[] batch = new SqlParameterSource[valueMaps.length];\n\t\tfor (int i = 0; i < valueMaps.length; i++) {\n\t\t\tbatch[i] = new MapSqlParameterSource(valueMaps[i]);\n\t\t}\n\t\treturn batch;\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#getTypedValue(source,parameterName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a wrapped value if parameter has type information, plain object if not.\n\t * @param source the source of parameter values and type information\n\t * @param parameterName the name of the parameter\n\t * @return the value object\n\t * @see SqlParameterValue\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "parameterName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object",
    "signature": "public Object getTypedValue(SqlParameterSource source, String parameterName)",
    "source_code": "\tpublic static Object getTypedValue(SqlParameterSource source, String parameterName) {\n\t\tint sqlType = source.getSqlType(parameterName);\n\t\tif (sqlType != SqlParameterSource.TYPE_UNKNOWN) {\n\t\t\treturn new SqlParameterValue(sqlType, source.getTypeName(parameterName), source.getValue(parameterName));\n\t\t}\n\t\telse {\n\t\t\treturn source.getValue(parameterName);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#registerSqlType(paramName,sqlType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param sqlType the SQL type of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void registerSqlType(String paramName, int sqlType)",
    "source_code": "\tpublic void registerSqlType(String paramName, int sqlType) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.sqlTypes.put(paramName, sqlType);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#registerTypeName(paramName,typeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an SQL type for the given parameter.\n\t * @param paramName the name of the parameter\n\t * @param typeName the type name of the parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "paramName",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void registerTypeName(String paramName, String typeName)",
    "source_code": "\tpublic void registerTypeName(String paramName, String typeName) {\n\t\tAssert.notNull(paramName, \"Parameter name must not be null\");\n\t\tthis.typeNames.put(paramName, typeName);\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(parsedSql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters. Named\n\t * parameters are substituted for a JDBC placeholder, and any select list is expanded\n\t * to the required number of placeholders. Select lists may contain an array of\n\t * objects, and in that case the placeholders will be grouped and enclosed with\n\t * parentheses. This allows for the use of \"expression lists\" in the SQL statement\n\t * like: <br /><br />\n\t * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}\n\t * <p>The parameter values passed in are used to determine the number of\n\t * placeholders to be used for a select list. Select lists should not be empty\n\t * and should be limited to 100 or fewer elements. An empty list or a larger\n\t * number of elements is not guaranteed to be supported by the database and\n\t * is strictly vendor-dependent.\n\t * @param parsedSql the parsed representation of the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t * @see #parseSqlStatement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {\n\t\tString originalSql = parsedSql.getOriginalSql();\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tif (paramNames.isEmpty()) {\n\t\t\treturn originalSql;\n\t\t}\n\n\t\tStringBuilder actualSql = new StringBuilder(originalSql.length());\n\t\tint lastIndex = 0;\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tint[] indexes = parsedSql.getParameterIndexes(i);\n\t\t\tint startIndex = indexes[0];\n\t\t\tint endIndex = indexes[1];\n\t\t\tactualSql.append(originalSql, lastIndex, startIndex);\n\t\t\tif (paramSource != null && paramSource.hasValue(paramName)) {\n\t\t\t\tObject value = paramSource.getValue(paramName);\n\t\t\t\tif (value instanceof SqlParameterValue sqlParameterValue) {\n\t\t\t\t\tvalue = sqlParameterValue.getValue();\n\t\t\t\t}\n\t\t\t\tif (value instanceof Iterable<?> iterable) {\n\t\t\t\t\tint k = 0;\n\t\t\t\t\tfor (Object entryItem : iterable) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif (entryItem instanceof Object[] expressionList) {\n\t\t\t\t\t\t\tactualSql.append('(');\n\t\t\t\t\t\t\tfor (int m = 0; m < expressionList.length; m++) {\n\t\t\t\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactualSql.append('?');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactualSql.append(')');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactualSql.append('?');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactualSql.append('?');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactualSql.append('?');\n\t\t\t}\n\t\t\tlastIndex = endIndex;\n\t\t}\n\t\tactualSql.append(originalSql, lastIndex, originalSql.length());\n\t\treturn actualSql.toString();\n\t}"
  },
  "org.springframework.jdbc.core.namedparam.<unknown>#substituteNamedParameters(sql,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * <p>Named parameters are substituted for a JDBC placeholder, and any select\n\t * list is expanded to the required number of placeholders.\n\t * <p>This is a shortcut version of\n\t * {@link #parseSqlStatement(String)} in combination with\n\t * {@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}.\n\t * @param sql the SQL statement\n\t * @param paramSource the source for named parameters\n\t * @return the SQL statement with substituted parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "String",
    "signature": "public String substituteNamedParameters(String sql, SqlParameterSource paramSource)",
    "source_code": "\tpublic static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, paramSource);\n\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value) {\n\t\t\tif (jdbcIndex < 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid JDBC index: needs to start at 1\");\n\t\t\t}\n\t\t\tvalidateIndexedParamValue(value);\n\t\t\tint index = jdbcIndex - 1;\n\t\t\tint size = this.indexedParams.size();\n\t\t\tif (index < size) {\n\t\t\t\tthis.indexedParams.set(index, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = size; i < index; i++) {\n\t\t\t\t\tthis.indexedParams.add(null);\n\t\t\t\t}\n\t\t\t\tthis.indexedParams.add(value);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(jdbcIndex,value,sqlType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jdbcIndex",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(int jdbcIndex, @Nullable Object value, int sqlType) {\n\t\t\treturn param(jdbcIndex, new SqlParameterValue(sqlType, value));\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value) {\n\t\t\tthis.namedParams.addValue(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#param(name,value,sqlType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "sqlType"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec param(String name, @Nullable Object value, int sqlType)",
    "source_code": "\t\tpublic StatementSpec param(String name, @Nullable Object value, int sqlType) {\n\t\t\tthis.namedParams.addValue(name, value, sqlType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#params(Map<String,paramMap)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "paramMap"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "StatementSpec",
    "signature": "public StatementSpec params(Map<String, ?> paramMap)",
    "source_code": "\t\tpublic StatementSpec params(Map<String, ?> paramMap) {\n\t\t\tthis.namedParams.addValues(paramMap);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.jdbc.core.simple.<unknown>#update(generatedKeyHolder,keyColumnNames)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generatedKeyHolder",
      "keyColumnNames"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "int",
    "signature": "public int update(KeyHolder generatedKeyHolder, String... keyColumnNames)",
    "source_code": "\t\tpublic int update(KeyHolder generatedKeyHolder, String... keyColumnNames) {\n\t\t\treturn (useNamedParams() ?\n\t\t\t\t\tnamedParamOps.update(this.sql, this.namedParamSource, generatedKeyHolder, keyColumnNames) :\n\t\t\t\t\tclassicOps.update(statementCreatorForIndexedParamsWithKeys(keyColumnNames), generatedKeyHolder));\n\t\t}"
  },
  "org.springframework.jdbc.core.support.<unknown>#setTypeValue(ps,paramIndex,sqlType,typeName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the specified content via the LobCreator.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ps",
      "paramIndex",
      "sqlType",
      "typeName"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)",
    "source_code": "\tpublic void setTypeValue(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n\t\t\tthrows SQLException {\n\n\t\tif (sqlType == Types.BLOB) {\n\t\t\tif (this.content instanceof byte[] || this.content == null) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, (byte[]) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof String string) {\n\t\t\t\tthis.lobCreator.setBlobAsBytes(ps, paramIndex, string.getBytes());\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setBlobAsBinaryStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for BLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse if (sqlType == Types.CLOB) {\n\t\t\tif (this.content instanceof String || this.content == null) {\n\t\t\t\tthis.lobCreator.setClobAsString(ps, paramIndex, (String) this.content);\n\t\t\t}\n\t\t\telse if (this.content instanceof InputStream inputStream) {\n\t\t\t\tthis.lobCreator.setClobAsAsciiStream(ps, paramIndex, inputStream, this.length);\n\t\t\t}\n\t\t\telse if (this.content instanceof Reader reader) {\n\t\t\t\tthis.lobCreator.setClobAsCharacterStream(ps, paramIndex, reader, this.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Content type [\" + this.content.getClass().getName() + \"] not supported for CLOB columns\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"SqlLobValue only supports SQL types BLOB and CLOB\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#applyTimeout(stmt,dataSource,timeout)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the specified timeout - overridden by the current transaction timeout,\n\t * if any - to the given JDBC Statement object.\n\t * @param stmt the JDBC Statement object\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @param timeout the timeout to apply (or 0 for no timeout outside of a transaction)\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.Statement#setQueryTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stmt",
      "dataSource",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "public void applyTimeout(Statement stmt, @Nullable DataSource dataSource, int timeout)",
    "source_code": "\tpublic static void applyTimeout(Statement stmt, @Nullable DataSource dataSource, int timeout) throws SQLException {\n\t\tAssert.notNull(stmt, \"No Statement specified\");\n\t\tConnectionHolder holder = null;\n\t\tif (dataSource != null) {\n\t\t\tholder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\t}\n\t\tif (holder != null && holder.hasTimeout()) {\n\t\t\t// Remaining transaction timeout overrides specified value.\n\t\t\tstmt.setQueryTimeout(holder.getTimeToLiveInSeconds());\n\t\t}\n\t\telse if (timeout >= 0) {\n\t\t\t// No current transaction timeout -> apply specified value.\n\t\t\tstmt.setQueryTimeout(timeout);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#applyTransactionTimeout(stmt,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the current transaction timeout, if any, to the given JDBC Statement object.\n\t * @param stmt the JDBC Statement object\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see java.sql.Statement#setQueryTimeout\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stmt",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "void",
    "signature": "public void applyTransactionTimeout(Statement stmt, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void applyTransactionTimeout(Statement stmt, @Nullable DataSource dataSource) throws SQLException {\n\t\tapplyTimeout(stmt, dataSource, -1);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tDataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n\t\tConnection con = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasConnectionHolder() ||\n\t\t\t\t\ttxObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tConnection newCon = obtainDataSource().getConnection();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n\t\t\t}\n\n\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\tcon = txObject.getConnectionHolder().getConnection();\n\n\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n\t\t\t// so we don't want to do it unnecessarily (for example if we've explicitly\n\t\t\t// configured the connection pool to set it already).\n\t\t\tif (con.getAutoCommit()) {\n\t\t\t\ttxObject.setMustRestoreAutoCommit(true);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\n\t\t\t\t}\n\t\t\t\tcon.setAutoCommit(false);\n\t\t\t}\n\n\t\t\tprepareTransactionalConnection(con, definition);\n\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n\t\t\t}\n\n\t\t\t// Bind the connection holder to the thread.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\n\t\t\t}\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tDataSourceUtils.releaseConnection(con, obtainDataSource());\n\t\t\t\ttxObject.setConnectionHolder(null, false);\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doCloseConnection(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the Connection, unless a {@link SmartDataSource} doesn't want us to.\n\t * @param con the Connection to close if necessary\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see Connection#close()\n\t * @see SmartDataSource#shouldClose(Connection)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "void",
    "signature": "public void doCloseConnection(Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void doCloseConnection(Connection con, @Nullable DataSource dataSource) throws SQLException {\n\t\tif (!(dataSource instanceof SmartDataSource smartDataSource) || smartDataSource.shouldClose(con)) {\n\t\t\tcon.close();\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doReleaseConnection(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually close the given Connection, obtained from the given DataSource.\n\t * Same as {@link #releaseConnection}, but throwing the original SQLException.\n\t * <p>Directly accessed by {@link TransactionAwareDataSourceProxy}.\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see #doGetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) throws SQLException {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (dataSource != null) {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, con)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdoCloseConnection(con, dataSource);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#getConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specifying a custom username and password doesn't make sense\n\t * with a single Connection. Returns the single Connection if given\n\t * the same username and password; throws an SQLException else.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 211
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\tif (ObjectUtils.nullSafeEquals(username, getUsername()) &&\n\t\t\t\tObjectUtils.nullSafeEquals(password, getPassword())) {\n\t\t\treturn getConnection();\n\t\t}\n\t\telse {\n\t\t\tthrow new SQLException(\"SingleConnectionDataSource does not support custom username and password\");\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on ConnectionProxy interface coming in...\n\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> (proxy == args[0]);\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\t// Handle close method: don't pass the call on.\n\t\t\t\tcase \"close\" -> null;\n\t\t\t\tcase \"isClosed\" -> this.target.isClosed();\n\t\t\t\t// Handle getTargetConnection method: return underlying Connection.\n\t\t\t\tcase \"getTargetConnection\" -> this.target;\n\t\t\t\tcase \"unwrap\" -> (((Class<?>) args[0]).isInstance(proxy) ? proxy : this.target.unwrap((Class<?>) args[0]));\n\t\t\t\tcase \"isWrapperFor\" -> (((Class<?>) args[0]).isInstance(proxy) || this.target.isWrapperFor((Class<?>) args[0]));\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.target, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#isConnectionTransactional(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given JDBC Connection is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param con the Connection to check\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @return whether the Connection is transactional\n\t * @see #getConnection(DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "boolean",
    "signature": "public boolean isConnectionTransactional(Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static boolean isConnectionTransactional(Connection con, @Nullable DataSource dataSource) {\n\t\tif (dataSource == null) {\n\t\t\treturn false;\n\t\t}\n\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n\t\treturn (conHolder != null && connectionEquals(conHolder, con));\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#prepareConnectionForTransaction(con,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the given Connection with the given transaction semantics.\n\t * @param con the Connection to prepare\n\t * @param definition the transaction definition to apply\n\t * @return the previous isolation level, if any\n\t * @throws SQLException if thrown by JDBC methods\n\t * @see #resetConnectionAfterTransaction\n\t * @see Connection#setTransactionIsolation\n\t * @see Connection#setReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "Integer",
    "signature": "public Integer prepareConnectionForTransaction(Connection con, @Nullable TransactionDefinition definition)",
    "source_code": "\tpublic static Integer prepareConnectionForTransaction(Connection con, @Nullable TransactionDefinition definition)\n\t\t\tthrows SQLException {\n\n\t\tAssert.notNull(con, \"No Connection specified\");\n\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\t// Set read-only flag.\n\t\tif (definition != null && definition.isReadOnly()) {\n\t\t\ttry {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Setting JDBC Connection [\" + con + \"] read-only\");\n\t\t\t\t}\n\t\t\t\tcon.setReadOnly(true);\n\t\t\t}\n\t\t\tcatch (SQLException | RuntimeException ex) {\n\t\t\t\tThrowable exToCheck = ex;\n\t\t\t\twhile (exToCheck != null) {\n\t\t\t\t\tif (exToCheck.getClass().getSimpleName().contains(\"Timeout\")) {\n\t\t\t\t\t\t// Assume it's a connection timeout that would otherwise get lost: for example, from JDBC 4.0\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\texToCheck = exToCheck.getCause();\n\t\t\t\t}\n\t\t\t\t// \"read-only not supported\" SQLException -> ignore, it's just a hint anyway\n\t\t\t\tlogger.debug(\"Could not set JDBC Connection read-only\", ex);\n\t\t\t}\n\t\t}\n\n\t\t// Apply specific isolation level, if any.\n\t\tInteger previousIsolationLevel = null;\n\t\tif (definition != null && definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Changing isolation level of JDBC Connection [\" + con + \"] to \" +\n\t\t\t\t\t\tdefinition.getIsolationLevel());\n\t\t\t}\n\t\t\tint currentIsolation = con.getTransactionIsolation();\n\t\t\tif (currentIsolation != definition.getIsolationLevel()) {\n\t\t\t\tpreviousIsolationLevel = currentIsolation;\n\t\t\t\tcon.setTransactionIsolation(definition.getIsolationLevel());\n\t\t\t}\n\t\t}\n\n\t\treturn previousIsolationLevel;\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#prepareTransactionalConnection(con,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@code Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement\n\t * if the {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true}\n\t * and the transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional JDBC Connection\n\t * @param definition the current transaction definition\n\t * @throws SQLException if thrown by JDBC API\n\t * @since 4.3.7\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 416
    },
    "return": "void",
    "signature": "protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)",
    "source_code": "\tprotected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)\n\t\t\tthrows SQLException {\n\n\t\tif (isEnforceReadOnly() && definition.isReadOnly()) {\n\t\t\ttry (Statement stmt = con.createStatement()) {\n\t\t\t\tstmt.executeUpdate(\"SET TRANSACTION READ ONLY\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#releaseConnection(con,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given Connection, obtained from the given DataSource,\n\t * if it is not managed externally (that is, not bound to the thread).\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param dataSource the DataSource that the Connection was obtained from\n\t * (may be {@code null})\n\t * @see #getConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "void",
    "signature": "public void releaseConnection(@Nullable Connection con, @Nullable DataSource dataSource)",
    "source_code": "\tpublic static void releaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) {\n\t\ttry {\n\t\t\tdoReleaseConnection(con, dataSource);\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tlogger.debug(\"Could not close JDBC Connection\", ex);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Unexpected exception on closing JDBC Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#resetConnectionAfterTransaction(con,previousIsolationLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the given Connection after a transaction,\n\t * regarding read-only flag and isolation level.\n\t * @param con the Connection to reset\n\t * @param previousIsolationLevel the isolation level to restore, if any\n\t * @deprecated as of 5.1.11, in favor of\n\t * {@link #resetConnectionAfterTransaction(Connection, Integer, boolean)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "previousIsolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "public void resetConnectionAfterTransaction(Connection con, @Nullable Integer previousIsolationLevel)",
    "source_code": "\tpublic static void resetConnectionAfterTransaction(Connection con, @Nullable Integer previousIsolationLevel) {\n\t\tAssert.notNull(con, \"No Connection specified\");\n\t\ttry {\n\t\t\t// Reset transaction isolation to previous value, if changed for the transaction.\n\t\t\tif (previousIsolationLevel != null) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Resetting isolation level of JDBC Connection [\" +\n\t\t\t\t\t\t\tcon + \"] to \" + previousIsolationLevel);\n\t\t\t\t}\n\t\t\t\tcon.setTransactionIsolation(previousIsolationLevel);\n\t\t\t}\n\n\t\t\t// Reset read-only flag.\n\t\t\tif (con.isReadOnly()) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Resetting read-only flag of JDBC Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tcon.setReadOnly(false);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not reset JDBC Connection after transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#resetConnectionAfterTransaction(con,previousIsolationLevel,resetReadOnly)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reset the given Connection after a transaction,\n\t * regarding read-only flag and isolation level.\n\t * @param con the Connection to reset\n\t * @param previousIsolationLevel the isolation level to restore, if any\n\t * @param resetReadOnly whether to reset the connection's read-only flag\n\t * @since 5.2.1\n\t * @see #prepareConnectionForTransaction\n\t * @see Connection#setTransactionIsolation\n\t * @see Connection#setReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "previousIsolationLevel",
      "resetReadOnly"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "void",
    "signature": "public void resetConnectionAfterTransaction(Connection con, @Nullable Integer previousIsolationLevel, boolean resetReadOnly)",
    "source_code": "\tpublic static void resetConnectionAfterTransaction(\n\t\t\tConnection con, @Nullable Integer previousIsolationLevel, boolean resetReadOnly) {\n\n\t\tAssert.notNull(con, \"No Connection specified\");\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\ttry {\n\t\t\t// Reset transaction isolation to previous value, if changed for the transaction.\n\t\t\tif (previousIsolationLevel != null) {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Resetting isolation level of JDBC Connection [\" +\n\t\t\t\t\t\t\tcon + \"] to \" + previousIsolationLevel);\n\t\t\t\t}\n\t\t\t\tcon.setTransactionIsolation(previousIsolationLevel);\n\t\t\t}\n\n\t\t\t// Reset read-only flag if we originally switched it to true on transaction begin.\n\t\t\tif (resetReadOnly) {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Resetting read-only flag of JDBC Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tcon.setReadOnly(false);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not reset JDBC Connection after transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#setConnectionHolder(connectionHolder,newConnectionHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionHolder",
      "newConnectionHolder"
    ],
    "position": {
      "column": 1,
      "line": 453
    },
    "return": "void",
    "signature": "public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder)",
    "source_code": "\t\tpublic void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder) {\n\t\t\tsuper.setConnectionHolder(connectionHolder);\n\t\t\tthis.newConnectionHolder = newConnectionHolder;\n\t\t}"
  },
  "org.springframework.jdbc.datasource.<unknown>#translateException(task,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given JDBC commit/rollback exception to a common Spring\n\t * exception to propagate from the {@link #commit}/{@link #rollback} call.\n\t * <p>The default implementation throws a {@link TransactionSystemException}.\n\t * Subclasses may specifically identify concurrency failures etc.\n\t * @param task the task description (commit or rollback)\n\t * @param ex the SQLException thrown from commit/rollback\n\t * @return the translated exception to throw, either a\n\t * {@link org.springframework.dao.DataAccessException} or a\n\t * {@link org.springframework.transaction.TransactionException}\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 438
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, SQLException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, SQLException ex) {\n\t\treturn new TransactionSystemException(task + \" failed\", ex);\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#customizeConfigurer(type,customizer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the default configurer for the given embedded database type.\n\t * <p>The {@code customizer} typically uses\n\t * {@link EmbeddedDatabaseConfigurerDelegate} to customize things as necessary.\n\t * @param type the {@linkplain EmbeddedDatabaseType embedded database type}\n\t * @param customizer the customizer to return based on the default\n\t * @return the customized configurer instance\n\t * @throws IllegalStateException if the driver for the specified database type is not available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "customizer"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "EmbeddedDatabaseConfigurer",
    "signature": "public EmbeddedDatabaseConfigurer customizeConfigurer(EmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer)",
    "source_code": "\tpublic static EmbeddedDatabaseConfigurer customizeConfigurer(\n\t\t\tEmbeddedDatabaseType type, UnaryOperator<EmbeddedDatabaseConfigurer> customizer) {\n\n\t\tEmbeddedDatabaseConfigurer defaultConfigurer = getConfigurer(type);\n\t\treturn customizer.apply(defaultConfigurer);\n\t}"
  },
  "org.springframework.jdbc.datasource.embedded.<unknown>#getConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\t\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\t\treturn this.dataSource.getConnection(username, password);\n\t\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script using default settings for statement\n\t * separators, comment delimiters, and exception handling flags.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #executeSqlScript(Connection, EncodedResource, boolean, boolean, String, String, String, String)\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #DEFAULT_COMMENT_PREFIX\n\t * @see #DEFAULT_BLOCK_COMMENT_START_DELIMITER\n\t * @see #DEFAULT_BLOCK_COMMENT_END_DELIMITER\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource) throws ScriptException {\n\t\texecuteSqlScript(connection, resource, false, false, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefix,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefix the prefix that identifies single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefix",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\texecuteSqlScript(connection, resource, continueOnError, ignoreFailedDrops,\n\t\t\t\tnew String[] { commentPrefix }, separator, blockCommentStartDelimiter,\n\t\t\t\tblockCommentEndDelimiter);\n\t}"
  },
  "org.springframework.jdbc.datasource.init.<unknown>#executeSqlScript(connection,resource,continueOnError,ignoreFailedDrops,commentPrefixes,separator,blockCommentStartDelimiter,blockCommentEndDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><strong>Warning</strong>: this method does <em>not</em> release the\n\t * provided {@link Connection}.\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefixes the prefixes that identify single-line comments in the\n\t * SQL script (typically \"--\")\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified and falls back to\n\t * {@value #FALLBACK_STATEMENT_SEPARATOR} as a last resort; may be set to\n\t * {@value #EOF_STATEMENT_SEPARATOR} to signal that the script contains a\n\t * single statement without a separator\n\t * @param blockCommentStartDelimiter the <em>start</em> block comment delimiter\n\t * @param blockCommentEndDelimiter the <em>end</em> block comment delimiter\n\t * @throws ScriptException if an error occurred while executing the SQL script\n\t * @since 5.2\n\t * @see #DEFAULT_STATEMENT_SEPARATOR\n\t * @see #FALLBACK_STATEMENT_SEPARATOR\n\t * @see #EOF_STATEMENT_SEPARATOR\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#getConnection\n\t * @see org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "resource",
      "continueOnError",
      "ignoreFailedDrops",
      "commentPrefixes",
      "separator",
      "blockCommentStartDelimiter",
      "blockCommentEndDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter)",
    "source_code": "\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String[] commentPrefixes, @Nullable String separator,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter) throws ScriptException {\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing SQL script from \" + resource);\n\t\t\t}\n\t\t\tlong startTime = System.currentTimeMillis();\n\n\t\t\tString script;\n\t\t\ttry {\n\t\t\t\tscript = readScript(resource, separator, commentPrefixes, blockCommentEndDelimiter);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new CannotReadScriptException(resource, ex);\n\t\t\t}\n\n\t\t\tif (separator == null) {\n\t\t\t\tseparator = DEFAULT_STATEMENT_SEPARATOR;\n\t\t\t}\n\t\t\tif (!EOF_STATEMENT_SEPARATOR.equals(separator) &&\n\t\t\t\t\t!containsStatementSeparator(resource, script, separator, commentPrefixes,\n\t\t\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter)) {\n\t\t\t\tseparator = FALLBACK_STATEMENT_SEPARATOR;\n\t\t\t}\n\n\t\t\tList<String> statements = new ArrayList<>();\n\t\t\tsplitSqlScript(resource, script, separator, commentPrefixes, blockCommentStartDelimiter,\n\t\t\t\t\tblockCommentEndDelimiter, statements);\n\n\t\t\tint stmtNumber = 0;\n\t\t\tStatement stmt = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tfor (String statement : statements) {\n\t\t\t\t\tstmtNumber++;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstmt.execute(statement);\n\t\t\t\t\t\tint rowsAffected = stmt.getUpdateCount();\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(rowsAffected + \" returned as update count for SQL: \" + statement);\n\t\t\t\t\t\t\tSQLWarning warningToLog = stmt.getWarnings();\n\t\t\t\t\t\t\twhile (warningToLog != null) {\n\t\t\t\t\t\t\t\tlogger.debug(\"SQLWarning ignored: SQL state '\" + warningToLog.getSQLState() +\n\t\t\t\t\t\t\t\t\t\t\"', error code '\" + warningToLog.getErrorCode() +\n\t\t\t\t\t\t\t\t\t\t\"', message [\" + warningToLog.getMessage() + \"]\");\n\t\t\t\t\t\t\t\twarningToLog = warningToLog.getNextWarning();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t\tboolean dropStatement = StringUtils.startsWithIgnoreCase(statement.trim(), \"drop\");\n\t\t\t\t\t\tif (continueOnError || (dropStatement && ignoreFailedDrops)) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(ScriptStatementFailedException.buildErrorMessage(statement, stmtNumber, resource), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new ScriptStatementFailedException(statement, stmtNumber, resource, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.trace(\"Could not close JDBC Statement\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executed SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (ex instanceof ScriptException scriptException) {\n\t\t\t\tthrow scriptException;\n\t\t\t}\n\t\t\tthrow new UncategorizedScriptException(\n\t\t\t\t\"Failed to execute database script from resource [\" + resource + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#getConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Connection",
    "signature": "public Connection getConnection(String username, String password)",
    "source_code": "\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\treturn determineTargetDataSource().getConnection(username, password);\n\t}"
  },
  "org.springframework.jdbc.datasource.lookup.<unknown>#setTargetDataSources(Map<Object,targetDataSources)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target DataSources, with the lookup key as key.\n\t * <p>The mapped value can either be a corresponding {@link javax.sql.DataSource}\n\t * instance or a data source name String (to be resolved via a\n\t * {@link #setDataSourceLookup DataSourceLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the\n\t * generic lookup process only. The concrete key representation will\n\t * be handled by {@link #resolveSpecifiedLookupKey(Object)} and\n\t * {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Object",
      "targetDataSources"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void setTargetDataSources(Map<Object, Object> targetDataSources)",
    "source_code": "\tpublic void setTargetDataSources(Map<Object, Object> targetDataSources) {\n\t\tthis.targetDataSources = targetDataSources;\n\t}"
  },
  "org.springframework.jdbc.object.<unknown>#mapRow(rs,rowNum)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation of this method extracts a single value from the\n\t * single row returned by the function. If there are a different number\n\t * of rows returned, this is treated as an error.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rs",
      "rowNum"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "T",
    "signature": "protected T mapRow(ResultSet rs, int rowNum)",
    "source_code": "\tprotected T mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\treturn this.rowMapper.mapRow(rs, rowNum);\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#createCustomException(task,sql,sqlEx,exceptionClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a custom {@link DataAccessException}, based on a given exception\n\t * class from a {@link CustomSQLErrorCodesTranslation} definition.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param sqlEx the offending SQLException\n\t * @param exceptionClass the exception class to use, as defined in the\n\t * {@link CustomSQLErrorCodesTranslation} definition\n\t * @return {@code null} if the custom exception could not be created, otherwise\n\t * the resulting {@link DataAccessException}. This exception should include the\n\t * {@code sqlEx} parameter as a nested root cause.\n\t * @see CustomSQLErrorCodesTranslation#setExceptionClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "sqlEx",
      "exceptionClass"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException createCustomException(String task, @Nullable String sql, SQLException sqlEx, Class<?> exceptionClass)",
    "source_code": "\tprotected DataAccessException createCustomException(\n\t\t\tString task, @Nullable String sql, SQLException sqlEx, Class<?> exceptionClass) {\n\n\t\t// Find appropriate constructor for the given exception class\n\t\ttry {\n\t\t\tint constructorType = 0;\n\t\t\tConstructor<?>[] constructors = exceptionClass.getConstructors();\n\t\t\tfor (Constructor<?> constructor : constructors) {\n\t\t\t\tClass<?>[] parameterTypes = constructor.getParameterTypes();\n\t\t\t\tif (parameterTypes.length == 1 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_ONLY_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_ONLY_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 2 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tThrowable.class == parameterTypes[1] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_THROWABLE_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_THROWABLE_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 2 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tSQLException.class == parameterTypes[1] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQLEX_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQLEX_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 3 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tString.class == parameterTypes[1] && Throwable.class == parameterTypes[2] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQL_THROWABLE_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQL_THROWABLE_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t\tif (parameterTypes.length == 3 && String.class == parameterTypes[0] &&\n\t\t\t\t\t\tString.class == parameterTypes[1] && SQLException.class == parameterTypes[2] &&\n\t\t\t\t\t\tconstructorType < MESSAGE_SQL_SQLEX_CONSTRUCTOR) {\n\t\t\t\t\tconstructorType = MESSAGE_SQL_SQLEX_CONSTRUCTOR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// invoke constructor\n\t\t\tConstructor<?> exceptionConstructor;\n\t\t\treturn switch (constructorType) {\n\t\t\t\tcase MESSAGE_SQL_SQLEX_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlAndSqlExArgsClass = new Class<?>[] {String.class, String.class, SQLException.class};\n\t\t\t\t\tObject[] messageAndSqlAndSqlExArgs = new Object[] {task, sql, sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndSqlExArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndSqlExArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_SQL_THROWABLE_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlAndThrowableArgsClass = new Class<?>[] {String.class, String.class, Throwable.class};\n\t\t\t\t\tObject[] messageAndSqlAndThrowableArgs = new Object[] {task, sql, sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndThrowableArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndThrowableArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_SQLEX_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndSqlExArgsClass = new Class<?>[] {String.class, SQLException.class};\n\t\t\t\t\tObject[] messageAndSqlExArgs = new Object[] {task + \": \" + sqlEx.getMessage(), sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndSqlExArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageAndSqlExArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_THROWABLE_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageAndThrowableArgsClass = new Class<?>[] {String.class, Throwable.class};\n\t\t\t\t\tObject[] messageAndThrowableArgs = new Object[] {task + \": \" + sqlEx.getMessage(), sqlEx};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageAndThrowableArgsClass);\n\t\t\t\t\tyield (DataAccessException)exceptionConstructor.newInstance(messageAndThrowableArgs);\n\t\t\t\t}\n\t\t\t\tcase MESSAGE_ONLY_CONSTRUCTOR -> {\n\t\t\t\t\tClass<?>[] messageOnlyArgsClass = new Class<?>[] {String.class};\n\t\t\t\t\tObject[] messageOnlyArgs = new Object[] {task + \": \" + sqlEx.getMessage()};\n\t\t\t\t\texceptionConstructor = exceptionClass.getConstructor(messageOnlyArgsClass);\n\t\t\t\t\tyield (DataAccessException) exceptionConstructor.newInstance(messageOnlyArgs);\n\t\t\t\t}\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Unable to find appropriate constructor of custom exception class [\" +\n\t\t\t\t\t\t\t\texceptionClass.getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tyield null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Unable to instantiate custom exception class [\" + exceptionClass.getName() + \"]\", ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#customTranslate(task,sql,sqlEx)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can override this method to attempt a custom mapping from\n\t * {@link SQLException} to {@link DataAccessException}.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (may be {@code null})\n\t * @param sqlEx the offending SQLException\n\t * @return {@code null} if no custom translation applies, otherwise a {@link DataAccessException}\n\t * resulting from custom translation. This exception should include the {@code sqlEx} parameter\n\t * as a nested root cause. This implementation always returns {@code null}, meaning that the\n\t * translator always falls back to the default error codes.\n\t * @deprecated as of 6.1, in favor of {@link #setCustomTranslator}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "sqlEx"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlEx)",
    "source_code": "\tprotected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlEx) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#doTranslate(task,sql,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "DataAccessException",
    "signature": "protected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex)",
    "source_code": "\tprotected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex) {\n\t\tSQLException sqlEx = ex;\n\t\tif (sqlEx instanceof BatchUpdateException && sqlEx.getNextException() != null) {\n\t\t\tSQLException nestedSqlEx = sqlEx.getNextException();\n\t\t\tif (nestedSqlEx.getErrorCode() > 0 || nestedSqlEx.getSQLState() != null) {\n\t\t\t\tsqlEx = nestedSqlEx;\n\t\t\t}\n\t\t}\n\n\t\t// First, try custom translation from overridden method.\n\t\tDataAccessException dae = customTranslate(task, sql, sqlEx);\n\t\tif (dae != null) {\n\t\t\treturn dae;\n\t\t}\n\n\t\t// Next, try the custom SQLException translator, if available.\n\t\tSQLErrorCodes sqlErrorCodes = getSqlErrorCodes();\n\t\tif (sqlErrorCodes != null) {\n\t\t\tSQLExceptionTranslator customTranslator = sqlErrorCodes.getCustomSqlExceptionTranslator();\n\t\t\tif (customTranslator != null) {\n\t\t\t\tdae = customTranslator.translate(task, sql, sqlEx);\n\t\t\t\tif (dae != null) {\n\t\t\t\t\treturn dae;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check SQLErrorCodes with corresponding error code, if available.\n\t\tif (sqlErrorCodes != null) {\n\t\t\tString errorCode;\n\t\t\tif (sqlErrorCodes.isUseSqlStateForTranslation()) {\n\t\t\t\terrorCode = sqlEx.getSQLState();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try to find SQLException with actual error code, looping through the causes.\n\t\t\t\t// For example, applicable to java.sql.DataTruncation as of JDK 1.6.\n\t\t\t\tSQLException current = sqlEx;\n\t\t\t\twhile (current.getErrorCode() == 0 && current.getCause() instanceof SQLException sqlException) {\n\t\t\t\t\tcurrent = sqlException;\n\t\t\t\t}\n\t\t\t\terrorCode = Integer.toString(current.getErrorCode());\n\t\t\t}\n\n\t\t\tif (errorCode != null) {\n\t\t\t\t// Look for defined custom translations first.\n\t\t\t\tCustomSQLErrorCodesTranslation[] customTranslations = sqlErrorCodes.getCustomTranslations();\n\t\t\t\tif (customTranslations != null) {\n\t\t\t\t\tfor (CustomSQLErrorCodesTranslation customTranslation : customTranslations) {\n\t\t\t\t\t\tif (Arrays.binarySearch(customTranslation.getErrorCodes(), errorCode) >= 0 &&\n\t\t\t\t\t\t\t\tcustomTranslation.getExceptionClass() != null) {\n\t\t\t\t\t\t\tdae = createCustomException(task, sql, sqlEx, customTranslation.getExceptionClass());\n\t\t\t\t\t\t\tif (dae != null) {\n\t\t\t\t\t\t\t\tlogTranslation(task, sql, sqlEx, true);\n\t\t\t\t\t\t\t\treturn dae;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Next, look for grouped error codes.\n\t\t\t\tif (Arrays.binarySearch(sqlErrorCodes.getBadSqlGrammarCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getInvalidResultSetAccessCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new InvalidResultSetAccessException(task, (sql != null ? sql : \"\"), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDuplicateKeyCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDataIntegrityViolationCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getPermissionDeniedCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDataAccessResourceFailureCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getTransientDataAccessResourceCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getCannotAcquireLockCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getDeadlockLoserCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new org.springframework.dao.DeadlockLoserDataAccessException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t\telse if (Arrays.binarySearch(sqlErrorCodes.getCannotSerializeTransactionCodes(), errorCode) >= 0) {\n\t\t\t\t\tlogTranslation(task, sql, sqlEx, false);\n\t\t\t\t\treturn new org.springframework.dao.CannotSerializeTransactionException(buildMessage(task, sql, sqlEx), sqlEx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// We couldn't identify it more precisely - let's hand it over to the SQLState fallback translator.\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tString codes;\n\t\t\tif (sqlErrorCodes != null && sqlErrorCodes.isUseSqlStateForTranslation()) {\n\t\t\t\tcodes = \"SQL state '\" + sqlEx.getSQLState() + \"', error code '\" + sqlEx.getErrorCode();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcodes = \"Error code '\" + sqlEx.getErrorCode() + \"'\";\n\t\t\t}\n\t\t\tlogger.debug(\"Unable to translate SQLException with \" + codes + \", will now try the fallback translator\");\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,action)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract database meta-data via the given DatabaseMetaDataCallback.\n\t * <p>This method will open a connection to the database and retrieve its meta-data.\n\t * Since this method is called before the exception translation feature is configured\n\t * for a DataSource, this method can not rely on SQLException translation itself.\n\t * <p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked\n\t * exception and any calling code should catch and handle this exception. You can just\n\t * log the error and hope for the best, but there is probably a more serious error that\n\t * will reappear when you try to access the database again.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param action callback that will do the actual work\n\t * @return object containing the extracted information, as returned by\n\t * the DatabaseMetaDataCallback's {@code processMetaData} method\n\t * @throws MetaDataAccessException if meta-data access failed\n\t * @see java.sql.DatabaseMetaData\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback<T> action)\n\t\t\tthrows MetaDataAccessException {\n\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = DataSourceUtils.getConnection(dataSource);\n\t\t\tDatabaseMetaData metaData;\n\t\t\ttry {\n\t\t\t\tmetaData = con.getMetaData();\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tif (DataSourceUtils.isConnectionTransactional(con, dataSource)) {\n\t\t\t\t\t// Probably a closed thread-bound Connection - retry against fresh Connection\n\t\t\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t\t\t\tcon = null;\n\t\t\t\t\tlogger.debug(\"Failed to obtain DatabaseMetaData from transactional Connection - \" +\n\t\t\t\t\t\t\t\"retrying against fresh Connection\", ex);\n\t\t\t\t\tcon = dataSource.getConnection();\n\t\t\t\t\tmetaData = con.getMetaData();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metaData == null) {\n\t\t\t\t// should only happen in test environments\n\t\t\t\tthrow new MetaDataAccessException(\"DatabaseMetaData returned by Connection [\" + con + \"] was null\");\n\t\t\t}\n\t\t\treturn action.processMetaData(metaData);\n\t\t}\n\t\tcatch (CannotGetJdbcConnectionException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Could not get Connection for extracting meta-data\", ex);\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new MetaDataAccessException(\"Error while extracting DatabaseMetaData\", ex);\n\t\t}\n\t\tcatch (AbstractMethodError err) {\n\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver\", err);\n\t\t}\n\t\tfinally {\n\t\t\tDataSourceUtils.releaseConnection(con, dataSource);\n\t\t}\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#extractDatabaseMetaData(dataSource,metaDataMethodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Call the specified method on DatabaseMetaData for the given DataSource,\n\t * and extract the invocation result.\n\t * @param dataSource the DataSource to extract meta-data for\n\t * @param metaDataMethodName the name of the DatabaseMetaData method to call\n\t * @return the object returned by the specified DatabaseMetaData method\n\t * @throws MetaDataAccessException if we couldn't access the DatabaseMetaData\n\t * or failed to invoke the specified method\n\t * @see java.sql.DatabaseMetaData\n\t * @deprecated as of 5.2.9, in favor of\n\t * {@link #extractDatabaseMetaData(DataSource, DatabaseMetaDataCallback)}\n\t * with a lambda expression or method reference and a generically typed result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataSource",
      "metaDataMethodName"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "T",
    "signature": "public T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)",
    "source_code": "\tpublic static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)\n\t\t\tthrows MetaDataAccessException {\n\n\t\treturn (T) extractDatabaseMetaData(dataSource,\n\t\t\t\tdbmd -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\"No method named '\" + metaDataMethodName +\n\t\t\t\t\t\t\t\t\"' found on DatabaseMetaData instance [\" + dbmd + \"]\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Could not access DatabaseMetaData method '\" + metaDataMethodName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tif (ex.getTargetException() instanceof SQLException sqlException) {\n\t\t\t\t\t\t\tthrow sqlException;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new MetaDataAccessException(\n\t\t\t\t\t\t\t\t\"Invocation of DatabaseMetaData method '\" + metaDataMethodName + \"' failed\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#getResultSetValue(rs,index)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC column value from a ResultSet, using the most appropriate\n\t * value type. The returned value should be a detached value object, not having\n\t * any ties to the active ResultSet: in particular, it should not be a Blob or\n\t * Clob object but rather a byte array or String representation, respectively.\n\t * <p>Uses the {@code getObject(index)} method, but includes additional \"hacks\"\n\t * to get around Oracle 10g returning a non-standard object for its TIMESTAMP\n\t * datatype and a {@code java.sql.Date} for DATE columns leaving out the\n\t * time portion: These columns will explicitly be extracted as standard\n\t * {@code java.sql.Timestamp} object.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @return the value object\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see java.sql.Blob\n\t * @see java.sql.Clob\n\t * @see java.sql.Timestamp\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "index"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "Object",
    "signature": "public Object getResultSetValue(ResultSet rs, int index)",
    "source_code": "\tpublic static Object getResultSetValue(ResultSet rs, int index) throws SQLException {\n\t\tObject obj = rs.getObject(index);\n\t\tString className = null;\n\t\tif (obj != null) {\n\t\t\tclassName = obj.getClass().getName();\n\t\t}\n\t\tif (obj instanceof Blob blob) {\n\t\t\tobj = blob.getBytes(1, (int) blob.length());\n\t\t}\n\t\telse if (obj instanceof Clob clob) {\n\t\t\tobj = clob.getSubString(1, (int) clob.length());\n\t\t}\n\t\telse if (\"oracle.sql.TIMESTAMP\".equals(className) || \"oracle.sql.TIMESTAMPTZ\".equals(className)) {\n\t\t\tobj = rs.getTimestamp(index);\n\t\t}\n\t\telse if (className != null && className.startsWith(\"oracle.sql.DATE\")) {\n\t\t\tString metaDataClassName = rs.getMetaData().getColumnClassName(index);\n\t\t\tif (\"java.sql.Timestamp\".equals(metaDataClassName) || \"oracle.sql.TIMESTAMP\".equals(metaDataClassName)) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = rs.getDate(index);\n\t\t\t}\n\t\t}\n\t\telse if (obj instanceof java.sql.Date) {\n\t\t\tif (\"java.sql.Timestamp\".equals(rs.getMetaData().getColumnClassName(index))) {\n\t\t\t\tobj = rs.getTimestamp(index);\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#getResultSetValue(rs,index,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a JDBC column value from a ResultSet, using the specified value type.\n\t * <p>Uses the specifically typed ResultSet accessor methods, falling back to\n\t * {@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types.\n\t * <p>Note that the returned value may not be assignable to the specified\n\t * required type, in case of an unknown type. Calling code needs to deal\n\t * with this case appropriately, for example, throwing a corresponding exception.\n\t * @param rs is the ResultSet holding the data\n\t * @param index is the column index\n\t * @param requiredType the required value type (may be {@code null})\n\t * @return the value object (possibly not of the specified required type,\n\t * with further conversion steps necessary)\n\t * @throws SQLException if thrown by the JDBC API\n\t * @see #getResultSetValue(ResultSet, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rs",
      "index",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Object",
    "signature": "public Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType)",
    "source_code": "\tpublic static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {\n\t\tif (requiredType == null) {\n\t\t\treturn getResultSetValue(rs, index);\n\t\t}\n\n\t\tObject value;\n\n\t\t// Explicitly extract typed value, as far as possible.\n\t\tif (String.class == requiredType) {\n\t\t\treturn rs.getString(index);\n\t\t}\n\t\telse if (boolean.class == requiredType || Boolean.class == requiredType) {\n\t\t\tvalue = rs.getBoolean(index);\n\t\t}\n\t\telse if (byte.class == requiredType || Byte.class == requiredType) {\n\t\t\tvalue = rs.getByte(index);\n\t\t}\n\t\telse if (short.class == requiredType || Short.class == requiredType) {\n\t\t\tvalue = rs.getShort(index);\n\t\t}\n\t\telse if (int.class == requiredType || Integer.class == requiredType) {\n\t\t\tvalue = rs.getInt(index);\n\t\t}\n\t\telse if (long.class == requiredType || Long.class == requiredType) {\n\t\t\tvalue = rs.getLong(index);\n\t\t}\n\t\telse if (float.class == requiredType || Float.class == requiredType) {\n\t\t\tvalue = rs.getFloat(index);\n\t\t}\n\t\telse if (double.class == requiredType || Double.class == requiredType ||\n\t\t\t\tNumber.class == requiredType) {\n\t\t\tvalue = rs.getDouble(index);\n\t\t}\n\t\telse if (BigDecimal.class == requiredType) {\n\t\t\treturn rs.getBigDecimal(index);\n\t\t}\n\t\telse if (java.sql.Date.class == requiredType) {\n\t\t\treturn rs.getDate(index);\n\t\t}\n\t\telse if (java.sql.Time.class == requiredType) {\n\t\t\treturn rs.getTime(index);\n\t\t}\n\t\telse if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {\n\t\t\treturn rs.getTimestamp(index);\n\t\t}\n\t\telse if (byte[].class == requiredType) {\n\t\t\treturn rs.getBytes(index);\n\t\t}\n\t\telse if (Blob.class == requiredType) {\n\t\t\treturn rs.getBlob(index);\n\t\t}\n\t\telse if (Clob.class == requiredType) {\n\t\t\treturn rs.getClob(index);\n\t\t}\n\t\telse if (requiredType.isEnum()) {\n\t\t\t// Enums can either be represented through a String or an enum index value:\n\t\t\t// leave enum type conversion up to the caller (for example, a ConversionService)\n\t\t\t// but make sure that we return nothing other than a String or an Integer.\n\t\t\tObject obj = rs.getObject(index);\n\t\t\tif (obj instanceof String) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\telse if (obj instanceof Number number) {\n\t\t\t\t// Defensively convert any Number to an Integer (as needed by our\n\t\t\t\t// ConversionService's IntegerToEnumConverterFactory) for use as index\n\t\t\t\treturn NumberUtils.convertNumberToTargetClass(number, Integer.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// for example, on Postgres: getObject returns a PGObject, but we need a String\n\t\t\t\treturn rs.getString(index);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// Some unknown type desired -> rely on getObject.\n\t\t\ttry {\n\t\t\t\treturn rs.getObject(index, requiredType);\n\t\t\t}\n\t\t\tcatch (SQLFeatureNotSupportedException | AbstractMethodError ex) {\n\t\t\t\tlogger.debug(\"JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method\", ex);\n\t\t\t}\n\t\t\tcatch (SQLException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"JDBC driver has limited support for 'getObject(int, Class)' with column type: \" +\n\t\t\t\t\t\t\trequiredType.getName(), ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Corresponding SQL types for JSR-310 / Joda-Time types, left up\n\t\t\t// to the caller to convert them (for example, through a ConversionService).\n\t\t\tString typeName = requiredType.getSimpleName();\n\t\t\treturn switch (typeName) {\n\t\t\t\tcase \"LocalDate\" -> rs.getDate(index);\n\t\t\t\tcase \"LocalTime\" -> rs.getTime(index);\n\t\t\t\tcase \"LocalDateTime\" -> rs.getTimestamp(index);\n\t\t\t\t// Fall back to getObject without type specification, again\n\t\t\t\t// left up to the caller to convert the value if necessary.\n\t\t\t\tdefault -> getResultSetValue(rs, index);\n\t\t\t};\n\t\t}\n\n\t\t// Perform was-null check if necessary (for results that the JDBC driver returns as primitives).\n\t\treturn (rs.wasNull() ? null : value);\n\t}"
  },
  "org.springframework.jdbc.support.<unknown>#lookupColumnName(resultSetMetaData,columnIndex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the column name to use. The column name is determined based on a\n\t * lookup using ResultSetMetaData.\n\t * <p>This method's implementation takes into account clarifications expressed\n\t * in the JDBC 4.0 specification:\n\t * <p><i>columnLabel - the label for the column specified with the SQL AS clause.\n\t * If the SQL AS clause was not specified, then the label is the name of the column</i>.\n\t * @param resultSetMetaData the current meta-data to use\n\t * @param columnIndex the index of the column for the lookup\n\t * @return the column name to use\n\t * @throws SQLException in case of lookup failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resultSetMetaData",
      "columnIndex"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "String",
    "signature": "public String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex)",
    "source_code": "\tpublic static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {\n\t\tString name = resultSetMetaData.getColumnLabel(columnIndex);\n\t\tif (!StringUtils.hasLength(name)) {\n\t\t\tname = resultSetMetaData.getColumnName(columnIndex);\n\t\t}\n\t\treturn name;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#createInvocableHandlerMethod(bean,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\t\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\t\treturn getMessageHandlerMethodFactory().createInvocableHandlerMethod(bean, method);\n\t\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory ||\n\t\t\t\tbean instanceof JmsListenerEndpointRegistry) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, JmsListener.class)) {\n\t\t\tMap<Method, Set<JmsListener>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<JmsListener>>) method -> {\n\t\t\t\t\t\tSet<JmsListener> listenerMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, JmsListener.class, JmsListeners.class);\n\t\t\t\t\t\treturn (!listenerMethods.isEmpty() ? listenerMethods : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @JmsListener annotations found on bean type: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, listeners) ->\n\t\t\t\t\t\tlisteners.forEach(listener -> processJmsListener(listener, method, bean)));\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(annotatedMethods.size() + \" @JmsListener methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.jms.annotation.<unknown>#processJmsListener(jmsListener,mostSpecificMethod,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@link JmsListener} annotation on the given method,\n\t * registering a corresponding endpoint for the given bean instance.\n\t * @param jmsListener the annotation to process\n\t * @param mostSpecificMethod the annotated method\n\t * @param bean the instance to invoke the method on\n\t * @see #createMethodJmsListenerEndpoint()\n\t * @see JmsListenerEndpointRegistrar#registerEndpoint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jmsListener",
      "mostSpecificMethod",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean)",
    "source_code": "\tprotected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean) {\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(mostSpecificMethod, bean.getClass());\n\n\t\tMethodJmsListenerEndpoint endpoint = createMethodJmsListenerEndpoint();\n\t\tendpoint.setBean(bean);\n\t\tendpoint.setMethod(invocableMethod);\n\t\tendpoint.setMostSpecificMethod(mostSpecificMethod);\n\t\tendpoint.setMessageHandlerMethodFactory(this.messageHandlerMethodFactory);\n\t\tendpoint.setEmbeddedValueResolver(this.embeddedValueResolver);\n\t\tendpoint.setBeanFactory(this.beanFactory);\n\t\tendpoint.setId(getEndpointId(jmsListener));\n\t\tendpoint.setDestination(resolve(jmsListener.destination()));\n\t\tif (StringUtils.hasText(jmsListener.selector())) {\n\t\t\tendpoint.setSelector(resolve(jmsListener.selector()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.subscription())) {\n\t\t\tendpoint.setSubscription(resolve(jmsListener.subscription()));\n\t\t}\n\t\tif (StringUtils.hasText(jmsListener.concurrency())) {\n\t\t\tendpoint.setConcurrency(resolve(jmsListener.concurrency()));\n\t\t}\n\n\t\tJmsListenerContainerFactory<?> factory = null;\n\t\tString containerFactoryBeanName = resolve(jmsListener.containerFactory());\n\t\tif (StringUtils.hasText(containerFactoryBeanName)) {\n\t\t\tAssert.state(this.beanFactory != null, \"BeanFactory must be set to obtain container factory by bean name\");\n\t\t\ttry {\n\t\t\t\tfactory = this.beanFactory.getBean(containerFactoryBeanName, JmsListenerContainerFactory.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Could not register JMS listener endpoint on [\" +\n\t\t\t\t\t\tmostSpecificMethod + \"], no \" + JmsListenerContainerFactory.class.getSimpleName() +\n\t\t\t\t\t\t\" with id '\" + containerFactoryBeanName + \"' was found in the application context\", ex);\n\t\t\t}\n\t\t}\n\n\t\tthis.registrar.registerEndpoint(endpoint, factory);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#createListenerContainer(endpoint,factory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create and start a new container using the specified factory.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "MessageListenerContainer",
    "signature": "protected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory)",
    "source_code": "\tprotected MessageListenerContainer createListenerContainer(JmsListenerEndpoint endpoint,\n\t\t\tJmsListenerContainerFactory<?> factory) {\n\n\t\tMessageListenerContainer listenerContainer = factory.createListenerContainer(endpoint);\n\n\t\tif (listenerContainer instanceof InitializingBean initializingBean) {\n\t\t\ttry {\n\t\t\t\tinitializingBean.afterPropertiesSet();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Failed to initialize message listener container\", ex);\n\t\t\t}\n\t\t}\n\n\t\tint containerPhase = listenerContainer.getPhase();\n\t\tif (containerPhase < Integer.MAX_VALUE) {  // a custom phase value\n\t\t\tif (this.phase < Integer.MAX_VALUE && this.phase != containerPhase) {\n\t\t\t\tthrow new IllegalStateException(\"Encountered phase mismatch between container factory definitions: \" +\n\t\t\t\t\t\tthis.phase + \" vs \" + containerPhase);\n\t\t\t}\n\t\t\tthis.phase = listenerContainer.getPhase();\n\t\t}\n\n\t\treturn listenerContainer;\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @see #registerListenerContainer(JmsListenerEndpoint, JmsListenerContainerFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory) {\n\t\tregisterListenerContainer(endpoint, factory, false);\n\t}"
  },
  "org.springframework.jms.config.<unknown>#registerListenerContainer(endpoint,factory,startImmediately)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a message listener container for the given {@link JmsListenerEndpoint}.\n\t * <p>This create the necessary infrastructure to honor that endpoint\n\t * with regard to its configuration.\n\t * <p>The {@code startImmediately} flag determines if the container should be\n\t * started immediately.\n\t * @param endpoint the endpoint to add\n\t * @param factory the listener factory to use\n\t * @param startImmediately start the container immediately if necessary\n\t * @see #getListenerContainers()\n\t * @see #getListenerContainer(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "endpoint",
      "factory",
      "startImmediately"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately)",
    "source_code": "\tpublic void registerListenerContainer(JmsListenerEndpoint endpoint, JmsListenerContainerFactory<?> factory,\n\t\t\tboolean startImmediately) {\n\n\t\tAssert.notNull(endpoint, \"Endpoint must not be null\");\n\t\tAssert.notNull(factory, \"Factory must not be null\");\n\t\tString id = endpoint.getId();\n\t\tAssert.hasText(id, \"Endpoint id must be set\");\n\n\t\tsynchronized (this.listenerContainers) {\n\t\t\tif (this.listenerContainers.containsKey(id)) {\n\t\t\t\tthrow new IllegalStateException(\"Another endpoint is already registered with id '\" + id + \"'\");\n\t\t\t}\n\t\t\tMessageListenerContainer container = createListenerContainer(endpoint, factory);\n\t\t\tthis.listenerContainers.put(id, container);\n\t\t\tif (startImmediately) {\n\t\t\t\tstartIfNecessary(container);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "Connection",
    "signature": "public Connection createConnection(String username, String password)",
    "source_code": "\tpublic Connection createConnection(String username, String password) throws JMSException {\n\t\treturn obtainTargetConnectionFactory().createConnection(username, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createContext(userName,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createContext(userName,password,sessionMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userName",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "JMSContext",
    "signature": "public JMSContext createContext(String userName, String password, int sessionMode)",
    "source_code": "\tpublic JMSContext createContext(String userName, String password, int sessionMode) {\n\t\treturn obtainTargetConnectionFactory().createContext(userName, password, sessionMode);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createQueueConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "QueueConnection",
    "signature": "public QueueConnection createQueueConnection(String username, String password)",
    "source_code": "\tpublic QueueConnection createQueueConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof QueueConnectionFactory queueFactory) {\n\t\t\treturn queueFactory.createQueueConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection(username, password);\n\t\t\tif (!(con instanceof QueueConnection queueConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t\t}\n\t\t\treturn queueConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createSession(con,mode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default Session for this ConnectionFactory,\n\t * adapting to JMS 1.0.2 style queue/topic mode if necessary.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the newly created Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 536
    },
    "return": "Session",
    "signature": "protected Session createSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session createSession(Connection con, Integer mode) throws JMSException {\n\t\t// Determine JMS API arguments...\n\t\tboolean transacted = (mode == Session.SESSION_TRANSACTED);\n\t\tint ackMode = (transacted ? Session.AUTO_ACKNOWLEDGE : mode);\n\t\t// Now actually call the appropriate JMS factory method...\n\t\tif (Boolean.FALSE.equals(this.pubSubMode) && con instanceof QueueConnection queueConnection) {\n\t\t\treturn queueConnection.createQueueSession(transacted, ackMode);\n\t\t}\n\t\telse if (Boolean.TRUE.equals(this.pubSubMode) && con instanceof TopicConnection topicConnection) {\n\t\t\treturn topicConnection.createTopicSession(transacted, ackMode);\n\t\t}\n\t\telse {\n\t\t\treturn con.createSession(transacted, ackMode);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#createTopicConnection(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "TopicConnection",
    "signature": "public TopicConnection createTopicConnection(String username, String password)",
    "source_code": "\tpublic TopicConnection createTopicConnection(String username, String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (target instanceof TopicConnectionFactory topicFactory) {\n\t\t\treturn topicFactory.createTopicConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\tConnection con = target.createConnection(username, password);\n\t\t\tif (!(con instanceof TopicConnection topicConnection)) {\n\t\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t\t}\n\t\t\treturn topicConnection;\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tthrow new InvalidIsolationLevelException(\"JMS does not support an isolation level concept\");\n\t\t}\n\n\t\tConnectionFactory connectionFactory = obtainConnectionFactory();\n\t\tJmsTransactionObject txObject = (JmsTransactionObject) transaction;\n\t\tConnection con = null;\n\t\tSession session = null;\n\t\ttry {\n\t\t\tJmsResourceHolder resourceHolder;\n\t\t\tif (this.lazyResourceRetrieval) {\n\t\t\t\tresourceHolder = new LazyJmsResourceHolder(connectionFactory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon = createConnection();\n\t\t\t\tsession = createSession(con);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Created JMS transaction on Session [\" + session + \"] from Connection [\" + con + \"]\");\n\t\t\t\t}\n\t\t\t\tresourceHolder = new JmsResourceHolder(connectionFactory, con, session);\n\t\t\t}\n\t\t\tresourceHolder.setSynchronizedWithTransaction(true);\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\tresourceHolder.setTimeoutInSeconds(timeout);\n\t\t\t}\n\t\t\ttxObject.setResourceHolder(resourceHolder);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolder);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not create JMS transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createConnection(username, password)}\n\t * method of the target ConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.ConnectionFactory#createConnection(String, String)\n\t * @see jakarta.jms.ConnectionFactory#createConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "Connection",
    "signature": "protected Connection doCreateConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected Connection doCreateConnection(@Nullable String username, @Nullable String password) throws JMSException {\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn target.createConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn target.createConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateContext(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "JMSContext",
    "signature": "protected JMSContext doCreateContext(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected JMSContext doCreateContext(@Nullable String username, @Nullable String password) {\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn obtainTargetConnectionFactory().createContext(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createContext();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateContext(username,password,sessionMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password",
      "sessionMode"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "JMSContext",
    "signature": "protected JMSContext doCreateContext(@Nullable String username, @Nullable String password, int sessionMode)",
    "source_code": "\tprotected JMSContext doCreateContext(@Nullable String username, @Nullable String password, int sessionMode) {\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn obtainTargetConnectionFactory().createContext(username, password, sessionMode);\n\t\t}\n\t\telse {\n\t\t\treturn obtainTargetConnectionFactory().createContext(sessionMode);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateQueueConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createQueueConnection(username, password)}\n\t * method of the target QueueConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createQueueConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.QueueConnectionFactory#createQueueConnection(String, String)\n\t * @see jakarta.jms.QueueConnectionFactory#createQueueConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "QueueConnection",
    "signature": "protected QueueConnection doCreateQueueConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected QueueConnection doCreateQueueConnection(\n\t\t\t@Nullable String username, @Nullable String password) throws JMSException {\n\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (!(target instanceof QueueConnectionFactory queueFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a QueueConnectionFactory\");\n\t\t}\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn queueFactory.createQueueConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn queueFactory.createQueueConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doCreateTopicConnection(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the {@code createTopicConnection(username, password)}\n\t * method of the target TopicConnectionFactory, passing in the specified user credentials.\n\t * If the specified username is empty, it will simply delegate to the standard\n\t * {@code createTopicConnection()} method of the target ConnectionFactory.\n\t * @param username the username to use\n\t * @param password the password to use\n\t * @return the Connection\n\t * @see jakarta.jms.TopicConnectionFactory#createTopicConnection(String, String)\n\t * @see jakarta.jms.TopicConnectionFactory#createTopicConnection()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "TopicConnection",
    "signature": "protected TopicConnection doCreateTopicConnection(@Nullable String username, @Nullable String password)",
    "source_code": "\tprotected TopicConnection doCreateTopicConnection(\n\t\t\t@Nullable String username, @Nullable String password) throws JMSException {\n\n\t\tConnectionFactory target = obtainTargetConnectionFactory();\n\t\tif (!(target instanceof TopicConnectionFactory topicFactory)) {\n\t\t\tthrow new jakarta.jms.IllegalStateException(\"'targetConnectionFactory' is not a TopicConnectionFactory\");\n\t\t}\n\t\tif (StringUtils.hasLength(username)) {\n\t\t\treturn topicFactory.createTopicConnection(username, password);\n\t\t}\n\t\telse {\n\t\t\treturn topicFactory.createTopicConnection();\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doGetTransactionalSession(connectionFactory,resourceFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * <p>This {@code doGetTransactionalSession} variant always starts the underlying\n\t * JMS Connection, assuming that the Session will be used for receiving messages.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t * @see #doGetTransactionalSession(jakarta.jms.ConnectionFactory, ResourceFactory, boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory)",
    "source_code": "\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {\n\n\t\treturn doGetTransactionalSession(connectionFactory, resourceFactory, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doGetTransactionalSession(connectionFactory,resourceFactory,startConnection)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param connectionFactory the JMS ConnectionFactory to bind for\n\t * (used as TransactionSynchronizationManager key)\n\t * @param resourceFactory the ResourceFactory to use for extracting or creating\n\t * JMS resources\n\t * @param startConnection whether the underlying JMS Connection approach should be\n\t * started in order to allow for receiving messages. Note that a reused Connection\n\t * may already have been started before, even if this flag is {@code false}.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connectionFactory",
      "resourceFactory",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Session",
    "signature": "public Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)",
    "source_code": "\tpublic static Session doGetTransactionalSession(\n\t\t\tConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\tAssert.notNull(resourceFactory, \"ResourceFactory must not be null\");\n\n\t\tJmsResourceHolder resourceHolder =\n\t\t\t\t(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\tif (resourceHolder != null) {\n\t\t\tSession session = resourceFactory.getSession(resourceHolder);\n\t\t\tif (session != null) {\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tConnection con = resourceFactory.getConnection(resourceHolder);\n\t\t\t\t\tif (con != null) {\n\t\t\t\t\t\tcon.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn session;\n\t\t\t}\n\t\t\tif (resourceHolder.isFrozen()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\treturn null;\n\t\t}\n\t\tJmsResourceHolder resourceHolderToUse = resourceHolder;\n\t\tif (resourceHolderToUse == null) {\n\t\t\tresourceHolderToUse = new JmsResourceHolder(connectionFactory);\n\t\t}\n\t\tConnection con = resourceFactory.getConnection(resourceHolderToUse);\n\t\tSession session = null;\n\t\ttry {\n\t\t\tboolean isExistingCon = (con != null);\n\t\t\tif (!isExistingCon) {\n\t\t\t\tcon = resourceFactory.createConnection();\n\t\t\t\tresourceHolderToUse.addConnection(con);\n\t\t\t}\n\t\t\tsession = resourceFactory.createSession(con);\n\t\t\tresourceHolderToUse.addSession(session, con);\n\t\t\tif (startConnection) {\n\t\t\t\tcon.start();\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tif (session != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tif (resourceHolderToUse != resourceHolder) {\n\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\tnew JmsResourceSynchronization(resourceHolderToUse, connectionFactory,\n\t\t\t\t\t\t\tresourceFactory.isSynchedLocalTransactionAllowed()));\n\t\t\tresourceHolderToUse.setSynchronizedWithTransaction(true);\n\t\t\tTransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse);\n\t\t}\n\t\treturn session;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 267
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tTransactionSynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getCachedSessionProxy(target,sessionList)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Wrap the given Session with a proxy that delegates every method call to it\n\t * but adapts close calls. This is useful for allowing application code to\n\t * handle a special framework Session just like an ordinary Session.\n\t * @param target the original Session to wrap\n\t * @param sessionList the List of cached Sessions that the given Session belongs to\n\t * @return the wrapped Session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "sessionList"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "Session",
    "signature": "protected Session getCachedSessionProxy(Session target, Deque<Session> sessionList)",
    "source_code": "\tprotected Session getCachedSessionProxy(Session target, Deque<Session> sessionList) {\n\t\tList<Class<?>> classes = new ArrayList<>(3);\n\t\tclasses.add(SessionProxy.class);\n\t\tif (target instanceof QueueSession) {\n\t\t\tclasses.add(QueueSession.class);\n\t\t}\n\t\tif (target instanceof TopicSession) {\n\t\t\tclasses.add(TopicSession.class);\n\t\t}\n\t\treturn (Session) Proxy.newProxyInstance(SessionProxy.class.getClassLoader(),\n\t\t\t\tClassUtils.toClassArray(classes), new CachedSessionInvocationHandler(target, sessionList));\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getSession(con,mode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for obtaining a (potentially cached) Session.\n\t * <p>The default implementation always returns {@code null}.\n\t * Subclasses may override this for exposing specific Session handles,\n\t * possibly delegating to {@link #createSession} for the creation of raw\n\t * Session objects that will then get wrapped and returned from here.\n\t * @param con the JMS Connection to operate on\n\t * @param mode the Session acknowledgement mode\n\t * ({@code Session.TRANSACTED} or one of the common modes)\n\t * @return the Session to use, or {@code null} to indicate\n\t * creation of a raw standard Session\n\t * @throws JMSException if thrown by the JMS API\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "mode"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "Session",
    "signature": "protected Session getSession(Connection con, Integer mode)",
    "source_code": "\tprotected Session getSession(Connection con, Integer mode) throws JMSException {\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getSession(sessionType,connection)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionType",
      "connection"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "S",
    "signature": "public S getSession(Class<S> sessionType, @Nullable Connection connection)",
    "source_code": "\t\tpublic <S extends Session> S getSession(Class<S> sessionType, @Nullable Connection connection) {\n\t\t\tinitializeSession();\n\t\t\treturn super.getSession(sessionType, connection);\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalQueueSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "QueueSession",
    "signature": "public QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,\n\t\t\t@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(QueueSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createQueueConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS Session that is synchronized with the current transaction, if any.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "Session",
    "signature": "public Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static Session getTransactionalSession(final ConnectionFactory cf,\n\t\t\t@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(Session.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#getTransactionalTopicSession(cf,existingCon,synchedLocalTransactionAllowed)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.\n\t * <p>Mainly intended for use with the JMS 1.0.2 API.\n\t * @param cf the ConnectionFactory to obtain a Session for\n\t * @param existingCon the existing JMS Connection to obtain a Session for\n\t * (may be {@code null})\n\t * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction\n\t * that is synchronized with a Spring-managed transaction (where the main transaction\n\t * might be a JDBC-based one for a specific DataSource, for example), with the JMS\n\t * transaction committing right after the main transaction. If not allowed, the given\n\t * ConnectionFactory needs to handle transaction enlistment underneath the covers.\n\t * @return the transactional Session, or {@code null} if none found\n\t * @throws JMSException in case of JMS failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cf",
      "existingCon",
      "synchedLocalTransactionAllowed"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "TopicSession",
    "signature": "public TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)",
    "source_code": "\tpublic static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,\n\t\t\t@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)\n\t\t\tthrows JMSException {\n\n\t\treturn (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Session getSession(JmsResourceHolder holder) {\n\t\t\t\treturn holder.getSession(TopicSession.class, existingCon);\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Connection getConnection(JmsResourceHolder holder) {\n\t\t\t\treturn (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Connection createConnection() throws JMSException {\n\t\t\t\treturn cf.createTopicConnection();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Session createSession(Connection con) throws JMSException {\n\t\t\t\treturn ((TopicConnection) con).createTopicSession(\n\t\t\t\t\t\tsynchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isSynchedLocalTransactionAllowed() {\n\t\t\t\treturn synchedLocalTransactionAllowed;\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\tObject other = args[0];\n\t\t\t\t\tif (proxy == other) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (other == null || !Proxy.isProxyClass(other.getClass())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tInvocationHandler otherHandler = Proxy.getInvocationHandler(other);\n\t\t\t\t\treturn (otherHandler instanceof SharedConnectionInvocationHandler sharedHandler &&\n\t\t\t\t\t\t\tfactory() == sharedHandler.factory());\n\t\t\t\t}\n\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\t// Use hashCode of containing SingleConnectionFactory.\n\t\t\t\t\treturn System.identityHashCode(factory());\n\t\t\t\t}\n\t\t\t\tcase \"toString\" -> {\n\t\t\t\t\treturn \"Shared JMS Connection: \" + getConnection();\n\t\t\t\t}\n\t\t\t\tcase \"setClientID\" -> {\n\t\t\t\t\t// Handle setClientID method: throw exception if not compatible.\n\t\t\t\t\tString currentClientId = getConnection().getClientID();\n\t\t\t\t\tif (currentClientId != null && currentClientId.equals(args[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\t\t\t\"setClientID call not supported on proxy for shared Connection. \" +\n\t\t\t\t\t\t\t\t\"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase \"setExceptionListener\" -> {\n\t\t\t\t\t// Handle setExceptionListener method: add to the chain.\n\t\t\t\t\tconnectionLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (aggregatedExceptionListener != null) {\n\t\t\t\t\t\t\tExceptionListener listener = (ExceptionListener) args[0];\n\t\t\t\t\t\t\tif (listener != this.localExceptionListener) {\n\t\t\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (listener != null) {\n\t\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.add(listener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.localExceptionListener = listener;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"setExceptionListener call not supported on proxy for shared Connection. \" +\n\t\t\t\t\t\t\t\t\t\"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" +\n\t\t\t\t\t\t\t\t\t\"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \" +\n\t\t\t\t\t\t\t\t\t\"which will allow for registering further ExceptionListeners to the recovery chain.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tconnectionLock.unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase \"getExceptionListener\" -> {\n\t\t\t\t\tconnectionLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\treturn this.localExceptionListener;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn getExceptionListener();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tconnectionLock.unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase \"start\" -> {\n\t\t\t\t\tlocalStart();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcase \"stop\" -> {\n\t\t\t\t\tlocalStop();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcase \"close\" -> {\n\t\t\t\t\tlocalStop();\n\t\t\t\t\tconnectionLock.lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (this.localExceptionListener != null) {\n\t\t\t\t\t\t\tif (aggregatedExceptionListener != null) {\n\t\t\t\t\t\t\t\taggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.localExceptionListener = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tconnectionLock.unlock();\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcase \"createSession\", \"createQueueSession\", \"createTopicSession\" -> {\n\t\t\t\t\t// Default: JMS 2.0 createSession() method\n\t\t\t\t\tInteger mode = Session.AUTO_ACKNOWLEDGE;\n\t\t\t\t\tif (!ObjectUtils.isEmpty(args)) {\n\t\t\t\t\t\tif (args.length == 1) {\n\t\t\t\t\t\t\t// JMS 2.0 createSession(int) method\n\t\t\t\t\t\t\tmode = (Integer) args[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (args.length == 2) {\n\t\t\t\t\t\t\t// JMS 1.1 createSession(boolean, int) method\n\t\t\t\t\t\t\tboolean transacted = (Boolean) args[0];\n\t\t\t\t\t\t\tInteger ackMode = (Integer) args[1];\n\t\t\t\t\t\t\tmode = (transacted ? Session.SESSION_TRANSACTED : ackMode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSession session = getSession(getConnection(), mode);\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tif (!method.getReturnType().isInstance(session)) {\n\t\t\t\t\t\t\tString msg = \"JMS Session does not implement specific domain: \" + session;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Failed to close newly obtained JMS Session\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new jakarta.jms.IllegalStateException(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn session;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn method.invoke(getConnection(), args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#isSessionTransactional(session,cf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given JMS Session is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param session the JMS Session to check\n\t * @param cf the JMS ConnectionFactory that the Session originated from\n\t * @return whether the Session is transactional\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "cf"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "boolean",
    "signature": "public boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf)",
    "source_code": "\tpublic static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {\n\t\tif (session == null || cf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tJmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf);\n\t\treturn (resourceHolder != null && resourceHolder.containsSession(session));\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#releaseConnection(con,cf,started)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Release the given Connection, stopping it (if necessary) and eventually closing it.\n\t * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.\n\t * This is essentially a more sophisticated version of\n\t * {@link org.springframework.jms.support.JmsUtils#closeConnection}.\n\t * @param con the Connection to release\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (may be {@code null})\n\t * @param started whether the Connection might have been started by the application\n\t * @see SmartConnectionFactory#shouldStop\n\t * @see org.springframework.jms.support.JmsUtils#closeConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "cf",
      "started"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started)",
    "source_code": "\tpublic static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {\n\t\tif (con == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (started && cf instanceof SmartConnectionFactory smartFactory && smartFactory.shouldStop(con)) {\n\t\t\ttry {\n\t\t\t\tcon.stop();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not stop JMS Connection before closing it\", ex);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tcon.close();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.connection.<unknown>#releaseResource(resourceHolder,resourceKey)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "void",
    "signature": "protected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey)",
    "source_code": "\t\tprotected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey) {\n\t\t\tresourceHolder.closeAll();\n\t\t}"
  },
  "org.springframework.jms.connection.<unknown>#setCredentialsForCurrentThread(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set user credentials for this proxy and the current thread.\n\t * The given username and password will be applied to all subsequent\n\t * {@code createConnection()} calls on this ConnectionFactory proxy.\n\t * <p>This will override any statically specified user credentials,\n\t * that is, values of the \"username\" and \"password\" bean properties.\n\t * @param username the username to apply\n\t * @param password the password to apply\n\t * @see #removeCredentialsFromCurrentThread\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void setCredentialsForCurrentThread(String username, String password)",
    "source_code": "\tpublic void setCredentialsForCurrentThread(String username, String password) {\n\t\tthis.threadBoundCredentials.set(new JmsUserCredentials(username, password));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queue,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1013
    },
    "return": "T",
    "signature": "public T browse(Queue queue, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(Queue queue, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queue, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browse(queueName,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1019
    },
    "return": "T",
    "signature": "public T browse(String queueName, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browse(String queueName, BrowserCallback<T> action) throws JmsException {\n\t\treturn browseSelected(queueName, null, action);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(messageSelector,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1025
    },
    "return": "T",
    "signature": "public T browseSelected(String messageSelector, BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(String messageSelector, BrowserCallback<T> action) throws JmsException {\n\t\tQueue defaultQueue = getDefaultQueue();\n\t\tif (defaultQueue != null) {\n\t\t\treturn browseSelected(defaultQueue, messageSelector, action);\n\t\t}\n\t\telse {\n\t\t\treturn browseSelected(getRequiredDefaultDestinationName(), messageSelector, action);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queue,messageSelector,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queue",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1037
    },
    "return": "T",
    "signature": "public T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final Queue queue, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#browseSelected(queueName,messageSelector,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queueName",
      "messageSelector",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 1054
    },
    "return": "T",
    "signature": "public T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)",
    "source_code": "\tpublic <T> T browseSelected(final String queueName, @Nullable final String messageSelector, final BrowserCallback<T> action)\n\t\t\tthrows JmsException {\n\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tQueue queue = (Queue) getDestinationResolver().resolveDestinationName(session, queueName, false);\n\t\t\tQueueBrowser browser = createBrowser(session, queue, messageSelector);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, browser);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeQueueBrowser(browser);\n\t\t\t}\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message)",
    "source_code": "\tpublic void convertAndSend(Destination destination, final Object message) throws JmsException {\n\t\tsend(destination, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destination,message,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 702
    },
    "return": "void",
    "signature": "public void convertAndSend(Destination destination, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tDestination destination, final Object message, final MessagePostProcessor postProcessor)\n\t\t\tthrows JmsException {\n\n\t\tsend(destination, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 686
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message)",
    "source_code": "\tpublic void convertAndSend(String destinationName, final Object message) throws JmsException {\n\t\tsend(destinationName, session -> getRequiredMessageConverter().toMessage(message, session));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(destinationName,message,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "void",
    "signature": "public void convertAndSend(String destinationName, final Object message, final MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(\n\t\t\tString destinationName, final Object message, final MessagePostProcessor postProcessor)\n\t\tthrows JmsException {\n\n\t\tsend(destinationName, session -> {\n\t\t\tMessage msg = getRequiredMessageConverter().toMessage(message, session);\n\t\t\treturn postProcessor.postProcessMessage(msg);\n\t\t});\n\t}"
  },
  "org.springframework.jms.core.<unknown>#convertAndSend(message,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 691
    },
    "return": "void",
    "signature": "public void convertAndSend(Object message, MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object message, MessagePostProcessor postProcessor) throws JmsException {\n\t\tDestination defaultDestination = getDefaultDestination();\n\t\tif (defaultDestination != null) {\n\t\t\tconvertAndSend(defaultDestination, message, postProcessor);\n\t\t}\n\t\telse {\n\t\t\tconvertAndSend(getRequiredDefaultDestinationName(), message, postProcessor);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createBrowser(session,queue,messageSelector)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a QueueBrowser for\n\t * @param queue the JMS Queue to create a QueueBrowser for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS QueueBrowser\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "queue",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1183
    },
    "return": "QueueBrowser",
    "signature": "protected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)",
    "source_code": "\tprotected QueueBrowser createBrowser(Session session, Queue queue, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn session.createBrowser(queue, messageSelector);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createConsumer(session,destination,messageSelector)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the new JMS MessageConsumer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 1156
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\t// Only pass in the NoLocal flag in case of a Topic:\n\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\tif (isPubSubDomain()) {\n\t\t\treturn session.createConsumer(destination, messageSelector, isPubSubNoLocal());\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, messageSelector);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#createProducer(session,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageProducer for the given Session and Destination,\n\t * configuring it to disable message ids and/or timestamps (if necessary).\n\t * <p>Delegates to {@link #doCreateProducer} for creation of the raw\n\t * JMS MessageProducer.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageIdEnabled\n\t * @see #setMessageTimestampEnabled\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1124
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer createProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer createProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\tMessageProducer producer = doCreateProducer(session, destination);\n\t\tif (!isMessageIdEnabled()) {\n\t\t\tproducer.setDisableMessageID(true);\n\t\t}\n\t\tif (!isMessageTimestampEnabled()) {\n\t\t\tproducer.setDisableMessageTimestamp(true);\n\t\t}\n\t\treturn producer;\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doCreateProducer(session,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a raw JMS MessageProducer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageProducer for\n\t * @param destination the JMS Destination to create a MessageProducer for\n\t * @return the new JMS MessageProducer\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 1143
    },
    "return": "MessageProducer",
    "signature": "protected MessageProducer doCreateProducer(Session session, @Nullable Destination destination)",
    "source_code": "\tprotected MessageProducer doCreateProducer(Session session, @Nullable Destination destination) throws JMSException {\n\t\treturn session.createProducer(destination);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doReceive(session,consumer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param consumer the JMS MessageConsumer to receive with\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 802
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, MessageConsumer consumer)",
    "source_code": "\tprotected Message doReceive(Session session, MessageConsumer consumer) throws JMSException {\n\t\ttry {\n\t\t\t// Use transaction timeout (if available).\n\t\t\tlong timeout = getReceiveTimeout();\n\t\t\tConnectionFactory connectionFactory = getConnectionFactory();\n\t\t\tJmsResourceHolder resourceHolder = null;\n\t\t\tif (connectionFactory != null) {\n\t\t\t\tresourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);\n\t\t\t}\n\t\t\tif (resourceHolder != null && resourceHolder.hasTimeout()) {\n\t\t\t\ttimeout = Math.min(timeout, resourceHolder.getTimeToLiveInMillis());\n\t\t\t}\n\t\t\tMessage message = receiveFromConsumer(consumer, timeout);\n\t\t\tif (session.getTransacted()) {\n\t\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\t// Manually acknowledge message, if any.\n\t\t\t\tif (message != null) {\n\t\t\t\t\tmessage.acknowledge();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn message;\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doReceive(session,destination,messageSelector)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Receive a JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to receive from\n\t * @param messageSelector the message selector for this consumer (can be {@code null})\n\t * @return the JMS Message received, or {@code null} if none\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "Message",
    "signature": "protected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)",
    "source_code": "\tprotected Message doReceive(Session session, Destination destination, @Nullable String messageSelector)\n\t\t\tthrows JMSException {\n\n\t\treturn doReceive(session, createConsumer(session, destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(producer,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually send the given JMS message.\n\t * @param producer the JMS MessageProducer to send with\n\t * @param message the JMS Message to send\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 652
    },
    "return": "void",
    "signature": "protected void doSend(MessageProducer producer, Message message)",
    "source_code": "\tprotected void doSend(MessageProducer producer, Message message) throws JMSException {\n\t\tif (this.deliveryDelay >= 0) {\n\t\t\tproducer.setDeliveryDelay(this.deliveryDelay);\n\t\t}\n\t\tif (isExplicitQosEnabled()) {\n\t\t\tproducer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());\n\t\t}\n\t\telse {\n\t\t\tproducer.send(message);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSend(session,destination,messageCreator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given JMS message.\n\t * @param session the JMS Session to operate on\n\t * @param destination the JMS Destination to send to\n\t * @param messageCreator callback to create a JMS Message\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "void",
    "signature": "protected void doSend(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected void doSend(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tMessageProducer producer = createProducer(session, destination);\n\t\ttry {\n\t\t\tMessage message = messageCreator.createMessage(session);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + message);\n\t\t\t}\n\t\t\tdoSend(producer, message);\n\t\t\t// Check commit - avoid commit call within a JTA transaction.\n\t\t\tif (session.getTransacted() && isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this template -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#doSendAndReceive(session,destination,messageCreator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send a request message to the given {@link Destination} and block until\n\t * a reply has been received on a temporary queue created on-the-fly.\n\t * <p>Return the response message or {@code null} if no message has\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 933
    },
    "return": "Message",
    "signature": "protected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)",
    "source_code": "\tprotected Message doSendAndReceive(Session session, Destination destination, MessageCreator messageCreator)\n\t\t\tthrows JMSException {\n\n\t\tAssert.notNull(messageCreator, \"MessageCreator must not be null\");\n\t\tTemporaryQueue responseQueue = null;\n\t\tMessageProducer producer = null;\n\t\tMessageConsumer consumer = null;\n\t\ttry {\n\t\t\tMessage requestMessage = messageCreator.createMessage(session);\n\t\t\tresponseQueue = session.createTemporaryQueue();\n\t\t\tproducer = session.createProducer(destination);\n\t\t\tconsumer = session.createConsumer(responseQueue);\n\t\t\trequestMessage.setJMSReplyTo(responseQueue);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Sending created message: \" + requestMessage);\n\t\t\t}\n\t\t\tdoSend(producer, requestMessage);\n\t\t\treturn receiveFromConsumer(consumer, getReceiveTimeout());\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumer);\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\tif (responseQueue != null) {\n\t\t\t\tresponseQueue.delete();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(action,startConnection)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a\n\t * JMS Session. Generalized version of {@code execute(SessionCallback)},\n\t * allowing the JMS Connection to be started on the fly.\n\t * <p>Use {@code execute(SessionCallback)} for the general case.\n\t * Starting the JMS Connection is just necessary for receiving messages,\n\t * which is preferably achieved through the {@code receive} methods.\n\t * @param action callback object that exposes the Session\n\t * @param startConnection whether to start the Connection\n\t * @return the result object from working with the Session\n\t * @throws JmsException if there is any problem\n\t * @see #execute(SessionCallback)\n\t * @see #receive\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "action",
      "startConnection"
    ],
    "position": {
      "column": 1,
      "line": 509
    },
    "return": "T",
    "signature": "public T execute(SessionCallback<T> action, boolean startConnection)",
    "source_code": "\tpublic <T> T execute(SessionCallback<T> action, boolean startConnection) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, startConnection);\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tif (startConnection) {\n\t\t\t\t\tconToClose.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Executing callback on JMS Session: \" + sessionToUse);\n\t\t\t}\n\t\t\tif (micrometerJakartaPresent && this.observationRegistry != null) {\n\t\t\t\tsessionToUse = MicrometerInstrumentation.instrumentSession(sessionToUse, this.observationRegistry);\n\t\t\t}\n\t\t\treturn action.doInJms(sessionToUse);\n\t\t}\n\t\tcatch (JMSException ex) {\n\t\t\tthrow convertJmsAccessException(ex);\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);\n\t\t}\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destination,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "T",
    "signature": "public T execute(final @Nullable Destination destination, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final @Nullable Destination destination, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#execute(destinationName,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 570
    },
    "return": "T",
    "signature": "public T execute(final String destinationName, final ProducerCallback<T> action)",
    "source_code": "\tpublic <T> T execute(final String destinationName, final ProducerCallback<T> action) throws JmsException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tMessageProducer producer = createProducer(session, destination);\n\t\t\ttry {\n\t\t\t\treturn action.doInJms(session, producer);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t\t}\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destination,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 766
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final Destination destination, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final Destination destination, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> doReceive(session, destination, messageSelector), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelected(destinationName,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 772
    },
    "return": "Message",
    "signature": "public Message receiveSelected(final String destinationName, @Nullable final String messageSelector)",
    "source_code": "\tpublic Message receiveSelected(final String destinationName, @Nullable final String messageSelector) throws JmsException {\n\t\treturn execute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doReceive(session, destination, messageSelector);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destination,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 866
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(Destination destination, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(Destination destination, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destination, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#receiveSelectedAndConvert(destinationName,messageSelector)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageSelector"
    ],
    "position": {
      "column": 1,
      "line": 872
    },
    "return": "Object",
    "signature": "public Object receiveSelectedAndConvert(String destinationName, String messageSelector)",
    "source_code": "\tpublic Object receiveSelectedAndConvert(String destinationName, String messageSelector) throws JmsException {\n\t\treturn doConvertFromMessage(receiveSelected(destinationName, messageSelector));\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destination,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void send(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#send(destinationName,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 609
    },
    "return": "void",
    "signature": "public void send(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic void send(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\texecute(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\tdoSend(session, destination, messageCreator);\n\t\t\treturn null;\n\t\t}, false);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destination,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 913
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final Destination destination, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final Destination destination, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> doSendAndReceive(session, destination, messageCreator), true);\n\t}"
  },
  "org.springframework.jms.core.<unknown>#sendAndReceive(destinationName,messageCreator)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationName",
      "messageCreator"
    ],
    "position": {
      "column": 1,
      "line": 919
    },
    "return": "Message",
    "signature": "public Message sendAndReceive(final String destinationName, final MessageCreator messageCreator)",
    "source_code": "\tpublic Message sendAndReceive(final String destinationName, final MessageCreator messageCreator) throws JmsException {\n\t\treturn executeLocal(session -> {\n\t\t\tDestination destination = resolveDestinationName(session, destinationName);\n\t\t\treturn doSendAndReceive(session, destination, messageCreator);\n\t\t}, true);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#commitIfNecessary(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a commit or message acknowledgement, as appropriate.\n\t * @param session the JMS {@link Session} to commit\n\t * @param message the {@link Message} to acknowledge\n\t * @throws jakarta.jms.JMSException in case of commit failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 827
    },
    "return": "void",
    "signature": "protected void commitIfNecessary(Session session, @Nullable Message message)",
    "source_code": "\tprotected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {\n\t\t// Commit session or acknowledge message.\n\t\tif (session.getTransacted()) {\n\t\t\t// Commit necessary - but avoid commit call within a JTA transaction.\n\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\tJmsUtils.commitIfNecessary(session);\n\t\t\t}\n\t\t}\n\t\telse if (message != null && isClientAcknowledge(session)) {\n\t\t\tmessage.acknowledge();\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#createConsumer(session,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MessageConsumer for the given Session and Destination.\n\t * <p>This implementation uses JMS 1.1 API.\n\t * @param session the JMS Session to create a MessageConsumer for\n\t * @param destination the JMS Destination to create a MessageConsumer for\n\t * @return the new JMS MessageConsumer\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 912
    },
    "return": "MessageConsumer",
    "signature": "protected MessageConsumer createConsumer(Session session, Destination destination)",
    "source_code": "\tprotected MessageConsumer createConsumer(Session session, Destination destination) throws JMSException {\n\t\tif (isPubSubDomain() && destination instanceof Topic topic) {\n\t\t\tif (isSubscriptionShared()) {\n\t\t\t\treturn (isSubscriptionDurable() ?\n\t\t\t\t\t\tsession.createSharedDurableConsumer(topic, getSubscriptionName(), getMessageSelector()) :\n\t\t\t\t\t\tsession.createSharedConsumer(topic, getSubscriptionName(), getMessageSelector()));\n\t\t\t}\n\t\t\telse if (isSubscriptionDurable()) {\n\t\t\t\treturn session.createDurableSubscriber(\n\t\t\t\t\t\ttopic, getSubscriptionName(), getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Only pass in the NoLocal flag in case of a Topic (pub-sub mode):\n\t\t\t\t// Some JMS providers, such as WebSphere MQ 6.0, throw IllegalStateException\n\t\t\t\t// in case of the NoLocal flag being specified for a Queue.\n\t\t\t\treturn session.createConsumer(destination, getMessageSelector(), isPubSubNoLocal());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn session.createConsumer(destination, getMessageSelector());\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doExecuteListener(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS {@link Message}\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #convertJmsAccessException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 714
    },
    "return": "void",
    "signature": "protected void doExecuteListener(Session session, Message message)",
    "source_code": "\tprotected void doExecuteListener(Session session, Message message) throws JMSException {\n\t\tif (!isAcceptMessagesWhileStopping() && !isRunning()) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Rejecting received message because of the listener container \" +\n\t\t\t\t\t\t\"having been stopped in the meantime: \" + message);\n\t\t\t}\n\t\t\trollbackIfNecessary(session);\n\t\t\tthrow new MessageRejectedWhileStoppingException();\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeListener(session, message);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\trollbackOnExceptionIfNecessary(session, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcommitIfNecessary(session, message);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doInvokeListener(listener,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as standard JMS {@link MessageListener}.\n\t * <p>Default implementation performs a plain invocation of the\n\t * {@code onMessage} method.\n\t * @param listener the JMS {@code MessageListener} to invoke\n\t * @param message the received JMS {@link Message}\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.MessageListener#onMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 817
    },
    "return": "void",
    "signature": "protected void doInvokeListener(MessageListener listener, Message message)",
    "source_code": "\tprotected void doInvokeListener(MessageListener listener, Message message) throws JMSException {\n\t\tlistener.onMessage(message);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doInvokeListener(listener,session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener as Spring SessionAwareMessageListener,\n\t * exposing a new JMS Session (potentially with its own transaction)\n\t * to the listener if demanded.\n\t * @param listener the Spring SessionAwareMessageListener to invoke\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS {@link Message}\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see SessionAwareMessageListener\n\t * @see #setExposeListenerSession\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "listener",
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 773
    },
    "return": "void",
    "signature": "protected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)",
    "source_code": "\tprotected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message)\n\t\t\tthrows JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tif (micrometerJakartaPresent && this.observationRegistry != null) {\n\t\t\t\tsessionToUse = MicrometerInstrumentation.instrumentSession(sessionToUse, this.observationRegistry);\n\t\t\t}\n\t\t\tif (!isExposeListenerSession()) {\n\t\t\t\t// We need to expose a separate Session.\n\t\t\t\tconToClose = createConnection();\n\t\t\t\tsessionToClose = createSession(conToClose);\n\t\t\t\tsessionToUse = sessionToClose;\n\t\t\t}\n\t\t\t// Actually invoke the message listener...\n\t\t\tlistener.onMessage(message, sessionToUse);\n\t\t\t// Clean up specially exposed Session, if any.\n\t\t\tif (sessionToUse != session) {\n\t\t\t\tif (sessionToUse.getTransacted() && isSessionLocallyTransacted(sessionToUse)) {\n\t\t\t\t\t// Transacted session created by this container -> commit.\n\t\t\t\t\tJmsUtils.commitIfNecessary(sessionToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JMSException exc) {\n\t\t\tthrow exc;\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tJmsUtils.closeConnection(conToClose);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#doReceiveAndExecute(invoker,session,consumer,status)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually execute the listener for a message received from the given consumer,\n\t * fetching all requires resources and invoking the listener.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @param status the TransactionStatus (may be {@code null})\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doExecuteListener(jakarta.jms.Session, jakarta.jms.Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "boolean",
    "signature": "protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status)",
    "source_code": "\tprotected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,\n\t\t\t@Nullable MessageConsumer consumer, @Nullable TransactionStatus status) throws JMSException {\n\n\t\tConnection conToClose = null;\n\t\tSession sessionToClose = null;\n\t\tMessageConsumer consumerToClose = null;\n\t\ttry {\n\t\t\tSession sessionToUse = session;\n\t\t\tboolean transactional = false;\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tsessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(\n\t\t\t\t\t\tobtainConnectionFactory(), this.transactionalResourceFactory, true);\n\t\t\t\ttransactional = (sessionToUse != null);\n\t\t\t}\n\t\t\tif (sessionToUse == null) {\n\t\t\t\tConnection conToUse;\n\t\t\t\tif (sharedConnectionEnabled()) {\n\t\t\t\t\tconToUse = getSharedConnection();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconToUse = createConnection();\n\t\t\t\t\tconToClose = conToUse;\n\t\t\t\t\tconToUse.start();\n\t\t\t\t}\n\t\t\t\tsessionToUse = createSession(conToUse);\n\t\t\t\tsessionToClose = sessionToUse;\n\t\t\t}\n\t\t\tMessageConsumer consumerToUse = consumer;\n\t\t\tif (consumerToUse == null) {\n\t\t\t\tconsumerToUse = createListenerConsumer(sessionToUse);\n\t\t\t\tconsumerToClose = consumerToUse;\n\t\t\t}\n\t\t\tMessage message = receiveMessage(consumerToUse);\n\t\t\tif (message != null) {\n\t\t\t\tboolean exposeResource = (!transactional && isExposeListenerSession() &&\n\t\t\t\t\t\t!TransactionSynchronizationManager.hasResource(obtainConnectionFactory()));\n\t\t\t\tObservation observation = createObservation(message).start();\n\t\t\t\tObservation.Scope scope = observation.openScope();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Received message of type [\" + message.getClass() + \"] from consumer [\" +\n\t\t\t\t\t\t\tconsumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") + \"session [\" +\n\t\t\t\t\t\t\tsessionToUse + \"]\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmessageReceived(invoker, sessionToUse);\n\t\t\t\t\tif (exposeResource) {\n\t\t\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\t\t\tobtainConnectionFactory(), new LocallyExposedJmsResourceHolder(sessionToUse));\n\t\t\t\t\t}\n\t\t\t\t\tdoExecuteListener(sessionToUse, message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Rolling back transaction because of listener exception thrown: \" + ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\thandleListenerException(ex);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\t\tobservation.error(throwable);\n\t\t\t\t\t\tthrow throwable;\n\t\t\t\t\t}\n\t\t\t\t\t// Rethrow JMSException to indicate an infrastructure problem\n\t\t\t\t\t// that may have to trigger recovery...\n\t\t\t\t\tif (ex instanceof JMSException jmsException) {\n\t\t\t\t\t\tthrow jmsException;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (exposeResource) {\n\t\t\t\t\t\tTransactionSynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t\t\t}\n\t\t\t\t\tobservation.stop();\n\t\t\t\t\tscope.close();\n\t\t\t\t}\n\t\t\t\t// Indicate that a message has been received.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Consumer [\" + consumerToUse + \"] of \" + (transactional ? \"transactional \" : \"\") +\n\t\t\t\t\t\t\t\"session [\" + sessionToUse + \"] did not receive a message\");\n\t\t\t\t}\n\t\t\t\tnoMessageReceived(invoker, sessionToUse);\n\t\t\t\t// Nevertheless call commit, in order to reset the transaction timeout (if any).\n\t\t\t\tif (shouldCommitAfterNoMessageReceived(sessionToUse)) {\n\t\t\t\t\tcommitIfNecessary(sessionToUse, null);\n\t\t\t\t}\n\t\t\t\t// Indicate that no message has been received.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageConsumer(consumerToClose);\n\t\t\tJmsUtils.closeSession(sessionToClose);\n\t\t\tConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), true);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#executeListener(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the specified listener,\n\t * committing or rolling back the transaction afterwards (if necessary).\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS {@link Message}\n\t * @see #invokeListener\n\t * @see #commitIfNecessary\n\t * @see #rollbackOnExceptionIfNecessary\n\t * @see #handleListenerException\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 678
    },
    "return": "void",
    "signature": "protected void executeListener(Session session, Message message)",
    "source_code": "\tprotected void executeListener(Session session, Message message) {\n\t\ttry {\n\t\t\tdoExecuteListener(session, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleListenerException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#handleListenerSetupFailure(ex,alreadyRecovered)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given exception that arose during setup of a listener.\n\t * Called for every such exception in every concurrent listener.\n\t * <p>The default implementation logs the exception at warn level\n\t * if not recovered yet, and at debug level if already recovered.\n\t * Can be overridden in subclasses.\n\t * @param ex the exception to handle\n\t * @param alreadyRecovered whether a previously executing listener\n\t * already recovered from the present listener setup failure\n\t * (this usually indicates a follow-up failure than can be ignored\n\t * other than for debug log purposes)\n\t * @see #recoverAfterListenerSetupFailure()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "alreadyRecovered"
    ],
    "position": {
      "column": 1,
      "line": 1071
    },
    "return": "void",
    "signature": "protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered)",
    "source_code": "\tprotected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered) {\n\t\tif (ex instanceof JMSException jmsException) {\n\t\t\tinvokeExceptionListener(jmsException);\n\t\t}\n\t\tif (ex instanceof SharedConnectionNotInitializedException) {\n\t\t\tif (!alreadyRecovered) {\n\t\t\t\tlogger.debug(\"JMS message listener invoker needs to establish shared Connection\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Recovery during active operation..\n\t\t\tif (alreadyRecovered) {\n\t\t\t\tlogger.debug(\"Setup of JMS message listener invoker failed - already recovered by other invoker\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBuilder msg = new StringBuilder();\n\t\t\t\tmsg.append(\"Setup of JMS message listener invoker failed for destination '\");\n\t\t\t\tmsg.append(getDestinationDescription()).append(\"' - trying to recover. Cause: \");\n\t\t\t\tmsg.append(ex instanceof JMSException jmsException ? JmsUtils.buildExceptionMessage(jmsException) :\n\t\t\t\t\t\tex.getMessage());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.warn(msg, ex);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.warn(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#invokeListener(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener: either as standard JMS MessageListener\n\t * or (preferably) as Spring SessionAwareMessageListener.\n\t * @param session the JMS Session to operate on\n\t * @param message the received JMS {@link Message}\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageListener\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 743
    },
    "return": "void",
    "signature": "protected void invokeListener(Session session, Message message)",
    "source_code": "\tprotected void invokeListener(Session session, Message message) throws JMSException {\n\t\tObject listener = getMessageListener();\n\n\t\tif (listener instanceof SessionAwareMessageListener sessionAwareMessageListener) {\n\t\t\tdoInvokeListener(sessionAwareMessageListener, session, message);\n\t\t}\n\t\telse if (listener instanceof MessageListener msgListener) {\n\t\t\tdoInvokeListener(msgListener, message);\n\t\t}\n\t\telse if (listener != null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Only MessageListener and SessionAwareMessageListener supported: \" + listener);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"No message listener specified - see property 'messageListener'\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#messageReceived(invoker,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Tries scheduling a new invoker, since we know messages are coming in...\n\t * @see #scheduleNewInvokerIfAppropriate()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 938
    },
    "return": "void",
    "signature": "protected void messageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void messageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(false);\n\t\tscheduleNewInvokerIfAppropriate();\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#noMessageReceived(invoker,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marks the affected invoker as idle.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 947
    },
    "return": "void",
    "signature": "protected void noMessageReceived(Object invoker, Session session)",
    "source_code": "\tprotected void noMessageReceived(Object invoker, Session session) {\n\t\t((AsyncMessageListenerInvoker) invoker).setIdle(true);\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#receiveAndExecute(invoker,session,consumer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the listener for a message received from the given consumer,\n\t * wrapping the entire operation in an external transaction if demanded.\n\t * @param session the JMS Session to work on\n\t * @param consumer the MessageConsumer to work on\n\t * @return whether a message has been received\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #doReceiveAndExecute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invoker",
      "session",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "boolean",
    "signature": "protected boolean receiveAndExecute(Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer)",
    "source_code": "\tprotected boolean receiveAndExecute(\n\t\t\tObject invoker, @Nullable Session session, @Nullable MessageConsumer consumer)\n\t\t\tthrows JMSException {\n\n\t\tif (this.transactionManager != null) {\n\t\t\t// Execute receive within transaction.\n\t\t\tTransactionStatus status = this.transactionManager.getTransaction(this.transactionDefinition);\n\t\t\tboolean messageReceived;\n\t\t\ttry {\n\t\t\t\tmessageReceived = doReceiveAndExecute(invoker, session, consumer, status);\n\t\t\t}\n\t\t\tcatch (JMSException | RuntimeException | Error ex) {\n\t\t\t\trollbackOnException(this.transactionManager, status, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.transactionManager.commit(status);\n\t\t\t}\n\t\t\tcatch (TransactionException ex) {\n\t\t\t\t// Propagate transaction system exceptions as infrastructure problems.\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t// Typically a late persistence exception from a listener-used resource\n\t\t\t\t// -> handle it as listener exception, not as an infrastructure problem.\n\t\t\t\t// For example, a database locking failure should not lead to listener shutdown.\n\t\t\t\thandleListenerException(ex);\n\t\t\t}\n\t\t\treturn messageReceived;\n\t\t}\n\n\t\telse {\n\t\t\t// Execute receive outside of transaction.\n\t\t\treturn doReceiveAndExecute(invoker, session, consumer, null);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.<unknown>#rollbackOnExceptionIfNecessary(session,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a rollback, handling rollback exceptions properly.\n\t * @param session the JMS Session to rollback\n\t * @param ex the thrown application exception or error\n\t * @throws jakarta.jms.JMSException in case of a rollback error\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 864
    },
    "return": "void",
    "signature": "protected void rollbackOnExceptionIfNecessary(Session session, Throwable ex)",
    "source_code": "\tprotected void rollbackOnExceptionIfNecessary(Session session, Throwable ex) throws JMSException {\n\t\ttry {\n\t\t\tif (session.getTransacted()) {\n\t\t\t\tif (isSessionLocallyTransacted(session)) {\n\t\t\t\t\t// Transacted session created by this container -> rollback.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Initiating transaction rollback on application exception\", ex);\n\t\t\t\t\t}\n\t\t\t\t\tJmsUtils.rollbackIfNecessary(session);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isClientAcknowledge(session)) {\n\t\t\t\tsession.recover();\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalStateException ex2) {\n\t\t\tlogger.debug(\"Could not roll back because Session already closed\", ex2);\n\t\t}\n\t\tcatch (JMSException | RuntimeException | Error ex2) {\n\t\t\tlogger.error(\"Application exception overridden by rollback error\", ex);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#buildMessage(session,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a JMS message to be sent as response based on the given result object.\n\t * @param session the JMS Session to operate on\n\t * @param result the content of the message, as returned from the listener method\n\t * @return the JMS {@code Message} (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setMessageConverter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "Message",
    "signature": "protected Message buildMessage(Session session, Object result)",
    "source_code": "\tprotected Message buildMessage(Session session, Object result) throws JMSException {\n\t\tObject content = preProcessResponse(result instanceof JmsResponse<?> jmsResponse ?\n\t\t\t\tjmsResponse.getResponse() : result);\n\n\t\tMessageConverter converter = getMessageConverter();\n\t\tif (converter != null) {\n\t\t\tif (content instanceof org.springframework.messaging.Message) {\n\t\t\t\treturn this.messagingMessageConverter.toMessage(content, session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn converter.toMessage(content, session);\n\t\t\t}\n\t\t}\n\n\t\tif (!(content instanceof Message message)) {\n\t\t\tthrow new MessageConversionException(\n\t\t\t\t\t\"No MessageConverter specified - cannot handle message [\" + content + \"]\");\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#createMessageForPayload(payload,session,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "Message",
    "signature": "protected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)",
    "source_code": "\t\tprotected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)\n\t\t\t\tthrows JMSException {\n\n\t\t\tMessageConverter converter = getMessageConverter();\n\t\t\tif (converter == null) {\n\t\t\t\tthrow new IllegalStateException(\"No message converter, cannot handle '\" + payload + \"'\");\n\t\t\t}\n\t\t\tif (converter instanceof SmartMessageConverter smartMessageConverter) {\n\t\t\t\treturn smartMessageConverter.toMessage(payload, session, conversionHint);\n\n\t\t\t}\n\t\t\treturn converter.toMessage(payload, session);\n\t\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forDestination(result,destination)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the specified {@link Destination}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forDestination(T result, Destination destination)",
    "source_code": "\tpublic static <T> JmsResponse<T> forDestination(T result, Destination destination) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\t\treturn new JmsResponse<>(result, destination);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forQueue(result,queueName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the queue with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "queueName"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forQueue(T result, String queueName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forQueue(T result, String queueName) {\n\t\tAssert.notNull(queueName, \"Queue name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(queueName, false));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#forTopic(result,topicName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link JmsResponse} targeting the topic with the specified name.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "topicName"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "JmsResponse<T>",
    "signature": "public JmsResponse<T> forTopic(T result, String topicName)",
    "source_code": "\tpublic static <T> JmsResponse<T> forTopic(T result, String topicName) {\n\t\tAssert.notNull(topicName, \"Topic name must not be null\");\n\t\treturn new JmsResponse<>(result, new DestinationNameHolder(topicName, true));\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getListenerMethodName(originalMessage,extractedMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the name of the listener method that is supposed to\n\t * handle the given message.\n\t * <p>The default implementation simply returns the configured\n\t * default listener method, if any.\n\t * @param originalMessage the JMS request message\n\t * @param extractedMessage the converted JMS request message,\n\t * to be passed into the listener method as argument\n\t * @return the name of the listener method (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #setDefaultListenerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "originalMessage",
      "extractedMessage"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "String",
    "signature": "protected String getListenerMethodName(Message originalMessage, Object extractedMessage)",
    "source_code": "\tprotected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws JMSException {\n\t\treturn getDefaultListenerMethod();\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#getResponseDestination(request,response,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a response destination for the given message.\n\t * <p>The default implementation first checks the JMS Reply-To\n\t * {@link Destination} of the supplied request; if that is not {@code null}\n\t * it is returned; if it is {@code null}, then the configured\n\t * {@link #resolveDefaultResponseDestination default response destination}\n\t * is returned; if this too is {@code null}, then an\n\t * {@link jakarta.jms.InvalidDestinationException} is thrown.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @param session the JMS Session to operate on\n\t * @return the response destination (never {@code null})\n\t * @throws JMSException if thrown by JMS API methods\n\t * @throws jakarta.jms.InvalidDestinationException if no {@link Destination} can be determined\n\t * @see #setDefaultResponseDestination\n\t * @see jakarta.jms.Message#getJMSReplyTo()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Destination",
    "signature": "protected Destination getResponseDestination(Message request, Message response, Session session)",
    "source_code": "\tprotected Destination getResponseDestination(Message request, Message response, Session session)\n\t\t\tthrows JMSException {\n\n\t\tDestination replyTo = request.getJMSReplyTo();\n\t\tif (replyTo == null) {\n\t\t\treplyTo = resolveDefaultResponseDestination(session);\n\t\t\tif (replyTo == null) {\n\t\t\t\tthrow new InvalidDestinationException(\"Cannot determine response destination: \" +\n\t\t\t\t\t\t\"Request message does not contain reply-to destination, and no default response destination set.\");\n\t\t\t}\n\t\t}\n\t\treturn replyTo;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#handleResult(result,request,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given result object returned from the listener method,\n\t * sending a response message back.\n\t * @param result the result object to handle (never {@code null})\n\t * @param request the original request message\n\t * @param session the JMS Session to operate on (may be {@code null})\n\t * @throws ReplyFailureException if the response message could not be sent\n\t * @see #buildMessage\n\t * @see #postProcessResponse\n\t * @see #getResponseDestination\n\t * @see #sendResponse\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result",
      "request",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "protected void handleResult(Object result, Message request, @Nullable Session session)",
    "source_code": "\tprotected void handleResult(Object result, Message request, @Nullable Session session) {\n\t\tif (session != null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Listener method returned result [\" + result +\n\t\t\t\t\t\t\"] - generating response message for it\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tMessage response = buildMessage(session, result);\n\t\t\t\tpostProcessResponse(request, response);\n\t\t\t\tDestination destination = getResponseDestination(request, response, session, result);\n\t\t\t\tsendResponse(session, destination, response);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new ReplyFailureException(\"Failed to send reply with payload [\" + result + \"]\", ex);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\t// No JMS Session available\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Listener method returned result [\" + result +\n\t\t\t\t\t\t\"]: not generating response message for it because of no JMS Session given\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#invokeListenerMethod(methodName,arguments)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified listener method.\n\t * @param methodName the name of the listener method\n\t * @param arguments the message arguments to be passed in\n\t * @return the result returned from the listener method\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #getListenerMethodName\n\t * @see #buildListenerArguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "Object",
    "signature": "protected Object invokeListenerMethod(String methodName, Object[] arguments)",
    "source_code": "\tprotected Object invokeListenerMethod(String methodName, Object[] arguments) throws JMSException {\n\t\ttry {\n\t\t\tMethodInvoker methodInvoker = new MethodInvoker();\n\t\t\tmethodInvoker.setTargetObject(getDelegate());\n\t\t\tmethodInvoker.setTargetMethod(methodName);\n\t\t\tmethodInvoker.setArguments(arguments);\n\t\t\tmethodInvoker.prepare();\n\t\t\treturn methodInvoker.invoke();\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tThrowable targetEx = ex.getTargetException();\n\t\t\tif (targetEx instanceof JMSException jmsException) {\n\t\t\t\tthrow jmsException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new ListenerExecutionFailedException(\n\t\t\t\t\t\t\"Listener method '\" + methodName + \"' threw exception\", targetEx);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new ListenerExecutionFailedException(\"Failed to invoke target method '\" + methodName +\n\t\t\t\t\t\"' with arguments \" + ObjectUtils.nullSafeToString(arguments), ex);\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#onMessage(jmsMessage,session)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jmsMessage",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session)",
    "source_code": "\tpublic void onMessage(jakarta.jms.Message jmsMessage, @Nullable Session session) throws JMSException {\n\t\tMessage<?> message = toMessagingMessage(jmsMessage);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing [\" + message + \"]\");\n\t\t}\n\t\tObject result = invokeHandler(jmsMessage, session, message);\n\t\tif (result != null) {\n\t\t\thandleResult(result, jmsMessage, session);\n\t\t}\n\t\telse {\n\t\t\tlogger.trace(\"No result object given - no result to handle\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#onMessage(message,session)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void onMessage(Message message, @Nullable Session session)",
    "source_code": "\tpublic abstract void onMessage(Message message, @Nullable Session session) throws JMSException;"
  },
  "org.springframework.jms.listener.adapter.<unknown>#postProcessProducer(producer,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given message producer before using it to send the response.\n\t * <p>The default implementation is empty.\n\t * @param producer the JMS message producer that will be used to send the message\n\t * @param response the outgoing JMS message about to be sent\n\t * @throws JMSException if thrown by JMS API methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "producer",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "void",
    "signature": "protected void postProcessProducer(MessageProducer producer, Message response)",
    "source_code": "\tprotected void postProcessProducer(MessageProducer producer, Message response) throws JMSException {\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#postProcessResponse(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Post-process the given response message before it will be sent.\n\t * <p>The default implementation sets the response's correlation id\n\t * to the request message's correlation id, if any; otherwise to the\n\t * request message id.\n\t * @param request the original incoming JMS message\n\t * @param response the outgoing JMS message about to be sent\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see jakarta.jms.Message#setJMSCorrelationID\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "void",
    "signature": "protected void postProcessResponse(Message request, Message response)",
    "source_code": "\tprotected void postProcessResponse(Message request, Message response) throws JMSException {\n\t\tString correlation = request.getJMSCorrelationID();\n\t\tif (correlation == null) {\n\t\t\tcorrelation = request.getJMSMessageID();\n\t\t}\n\t\tresponse.setJMSCorrelationID(correlation);\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#resolveDestination(destinationResolver,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link Destination} to use for this instance. The {@link DestinationResolver}\n\t * and {@link Session} can be used to resolve a destination at runtime.\n\t * @param destinationResolver the destination resolver to use if necessary\n\t * @param session the session to use, if necessary\n\t * @return the {@link Destination} to use\n\t * @throws JMSException if the DestinationResolver failed to resolve the destination\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destinationResolver",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "Destination",
    "signature": "public Destination resolveDestination(DestinationResolver destinationResolver, Session session)",
    "source_code": "\tpublic Destination resolveDestination(DestinationResolver destinationResolver, Session session)\n\t\t\tthrows JMSException {\n\n\t\tif (this.destination instanceof Destination dest) {\n\t\t\treturn dest;\n\t\t}\n\t\tif (this.destination instanceof DestinationNameHolder nameHolder) {\n\t\t\treturn destinationResolver.resolveDestinationName(session,\n\t\t\t\t\tnameHolder.destinationName, nameHolder.pubSubDomain);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.jms.listener.adapter.<unknown>#sendResponse(session,destination,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send the given response message to the given destination.\n\t * @param response the JMS message to send\n\t * @param destination the JMS destination to send to\n\t * @param session the JMS session to operate on\n\t * @throws JMSException if thrown by JMS API methods\n\t * @see #postProcessProducer\n\t * @see jakarta.jms.Session#createProducer\n\t * @see jakarta.jms.MessageProducer#send\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "destination",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "protected void sendResponse(Session session, Destination destination, Message response)",
    "source_code": "\tprotected void sendResponse(Session session, Destination destination, Message response) throws JMSException {\n\t\tMessageProducer producer = session.createProducer(destination);\n\t\ttry {\n\t\t\tpostProcessProducer(producer, response);\n\t\t\tQosSettings settings = getResponseQosSettings();\n\t\t\tif (settings != null) {\n\t\t\t\tproducer.send(response, settings.getDeliveryMode(), settings.getPriority(),\n\t\t\t\t\t\tsettings.getTimeToLive());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproducer.send(response);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tJmsUtils.closeMessageProducer(producer);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#closeConnection(con,stop)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given JMS Connection and ignore any thrown exception.\n\t * <p>This is useful for typical {@code finally} blocks in manual JMS code.\n\t * @param con the JMS Connection to close (may be {@code null})\n\t * @param stop whether to call {@code stop()} before closing\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "stop"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "void",
    "signature": "public void closeConnection(@Nullable Connection con, boolean stop)",
    "source_code": "\tpublic static void closeConnection(@Nullable Connection con, boolean stop) {\n\t\tif (con != null) {\n\t\t\ttry {\n\t\t\t\tif (stop) {\n\t\t\t\t\ttry (con) {\n\t\t\t\t\t\tcon.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcon.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (jakarta.jms.IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Ignoring Connection state exception - assuming already closed: \" + ex);\n\t\t\t}\n\t\t\tcatch (JMSException ex) {\n\t\t\t\tlogger.debug(\"Could not close JMS Connection\", ex);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// We don't trust the JMS provider: It might throw RuntimeException or Error.\n\t\t\t\tlogger.debug(\"Unexpected exception on closing JMS Connection\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.<unknown>#fromHeaders(headers,jmsMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headers",
      "jmsMessage"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage)",
    "source_code": "\tpublic void fromHeaders(MessageHeaders headers, jakarta.jms.Message jmsMessage) {\n\t\ttry {\n\t\t\tObject jmsCorrelationId = headers.get(JmsHeaders.CORRELATION_ID);\n\t\t\tif (jmsCorrelationId instanceof Number) {\n\t\t\t\tjmsCorrelationId = jmsCorrelationId.toString();\n\t\t\t}\n\t\t\tif (jmsCorrelationId instanceof String correlationId) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSCorrelationID(correlationId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSCorrelationID - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDestination jmsReplyTo = getHeaderIfAvailable(headers, JmsHeaders.REPLY_TO, Destination.class);\n\t\t\tif (jmsReplyTo != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSReplyTo(jmsReplyTo);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSReplyTo - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString jmsType = getHeaderIfAvailable(headers, JmsHeaders.TYPE, String.class);\n\t\t\tif (jmsType != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjmsMessage.setJMSType(jmsType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Failed to set JMSType - skipping\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString headerName = entry.getKey();\n\t\t\t\tif (StringUtils.hasText(headerName) && !headerName.startsWith(JmsHeaders.PREFIX)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value != null && SUPPORTED_PROPERTY_TYPES.contains(value.getClass())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString propertyName = fromHeaderName(headerName);\n\t\t\t\t\t\t\tjmsMessage.setObjectProperty(propertyName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (headerName.startsWith(\"JMSX\")) {\n\t\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.trace(\"Skipping reserved header '\" + headerName +\n\t\t\t\t\t\t\t\t\t\t\t\"' since it cannot be set by client\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to map message header '\" + headerName + \"' to JMS property\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error occurred while mapping from MessageHeaders to JMS properties\", ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromBytesMessage(message,targetJavaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a BytesMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "Object",
    "signature": "protected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tString encoding = this.encoding;\n\t\tif (this.encodingPropertyName != null && message.propertyExists(this.encodingPropertyName)) {\n\t\t\tencoding = message.getStringProperty(this.encodingPropertyName);\n\t\t}\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\tif (encoding != null) {\n\t\t\ttry {\n\t\t\t\tString body = new String(bytes, encoding);\n\t\t\t\treturn this.objectMapper.readValue(body, targetJavaType);\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert bytes to String\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Jackson internally performs encoding detection, falling back to UTF-8.\n\t\t\treturn this.objectMapper.readValue(bytes, targetJavaType);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromMessage(message,targetJavaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message mapping.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "Object",
    "signature": "protected Object convertFromMessage(Message message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromMessage(Message message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + message.getClass() +\n\t\t\t\t\"]. MappingJacksonMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#convertFromTextMessage(message,targetJavaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a TextMessage to a Java Object with the specified type.\n\t * @param message the input message\n\t * @param targetJavaType the target type\n\t * @return the message converted to an object\n\t * @throws JMSException if thrown by JMS\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetJavaType"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "Object",
    "signature": "protected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)",
    "source_code": "\tprotected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tString body = message.getText();\n\t\treturn this.objectMapper.readValue(body, targetJavaType);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForByteArray(bytes,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS BytesMessage for the given byte array.\n\t * @param bytes the byte array to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bytes",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage createMessageForByteArray(byte[] bytes, Session session)",
    "source_code": "\tprotected BytesMessage createMessageForByteArray(byte[] bytes, Session session) throws JMSException {\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bytes);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForMap(Map<?,map,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS MapMessage for the given Map.\n\t * @param map the Map to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createMapMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<?",
      "map",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "MapMessage",
    "signature": "protected MapMessage createMessageForMap(Map<?, ?> map, Session session)",
    "source_code": "\tprotected MapMessage createMessageForMap(Map<?, ?> map, Session session) throws JMSException {\n\t\tMapMessage message = session.createMapMessage();\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tif (!(key instanceof String str)) {\n\t\t\t\tthrow new MessageConversionException(\"Cannot convert non-String key of type [\" +\n\t\t\t\t\t\tObjectUtils.nullSafeClassName(key) + \"] to JMS MapMessage entry\");\n\t\t\t}\n\t\t\tmessage.setObject(str, entry.getValue());\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForSerializable(object,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS ObjectMessage for the given Serializable object.\n\t * @param object the Serializable object to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createObjectMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "ObjectMessage",
    "signature": "protected ObjectMessage createMessageForSerializable(Serializable object, Session session)",
    "source_code": "\tprotected ObjectMessage createMessageForSerializable(Serializable object, Session session) throws JMSException {\n\t\treturn session.createObjectMessage(object);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#createMessageForString(text,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a JMS TextMessage for the given String.\n\t * @param text the String to convert\n\t * @param session current JMS session\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @see jakarta.jms.Session#createTextMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "TextMessage",
    "signature": "protected TextMessage createMessageForString(String text, Session session)",
    "source_code": "\tprotected TextMessage createMessageForString(String text, Session session) throws JMSException {\n\t\treturn session.createTextMessage(text);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToBytesMessage(object,session,objectWriter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Map the given object to a {@link BytesMessage}.\n\t * @param object the object to be mapped\n\t * @param session current JMS session\n\t * @param objectWriter the writer to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, IOException {\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n\t\tif (this.encoding != null) {\n\t\t\tOutputStreamWriter writer = new OutputStreamWriter(bos, this.encoding);\n\t\t\tobjectWriter.writeValue(writer, object);\n\t\t}\n\t\telse {\n\t\t\t// Jackson usually defaults to UTF-8 but can also go straight to bytes, for example, for Smile.\n\t\t\t// We use a direct byte array argument for the latter case to work as well.\n\t\t\tobjectWriter.writeValue(bos, object);\n\t\t}\n\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bos.toByteArray());\n\t\tif (this.encodingPropertyName != null) {\n\t\t\tmessage.setStringProperty(this.encodingPropertyName,\n\t\t\t\t\t(this.encoding != null ? this.encoding : DEFAULT_ENCODING));\n\t\t}\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToMessage(object,session,objectWriter,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message mapping.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS Session\n\t * @param objectWriter the writer to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Message",
    "signature": "protected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)",
    "source_code": "\tprotected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)\n\t\t\tthrows JMSException, IOException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + targetType +\n\t\t\t\t\"]. MappingJackson2MessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#mapToTextMessage(object,session,objectWriter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Map the given object to a {@link TextMessage}.\n\t * @param object the object to be mapped\n\t * @param session current JMS session\n\t * @param objectWriter the writer to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see Session#createBytesMessage\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "TextMessage",
    "signature": "protected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, IOException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tobjectWriter.writeValue(writer, object);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToBytesMessage(object,session,marshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link BytesMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createBytesMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "BytesMessage",
    "signature": "protected BytesMessage marshalToBytesMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected BytesMessage marshalToBytesMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n\t\tStreamResult streamResult = new StreamResult(bos);\n\t\tmarshaller.marshal(object, streamResult);\n\t\tBytesMessage message = session.createBytesMessage();\n\t\tmessage.writeBytes(bos.toByteArray());\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToMessage(object,session,marshaller,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message marshalling.\n\t * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or\n\t * {@link MessageType#BYTES}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param object the object to marshal\n\t * @param session the JMS session\n\t * @param marshaller the marshaller to use\n\t * @param targetType the target message type (other than TEXT or BYTES)\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Message",
    "signature": "protected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)",
    "source_code": "\tprotected Message marshalToMessage(Object object, Session session, Marshaller marshaller, MessageType targetType)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + targetType +\n\t\t\t\t\"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#marshalToTextMessage(object,session,marshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the given object to a {@link TextMessage}.\n\t * @param object the object to be marshalled\n\t * @param session current JMS session\n\t * @param marshaller the marshaller to use\n\t * @return the resulting message\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Session#createTextMessage\n\t * @see Marshaller#marshal(Object, Result)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "marshaller"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "TextMessage",
    "signature": "protected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)",
    "source_code": "\tprotected TextMessage marshalToTextMessage(Object object, Session session, Marshaller marshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tStringWriter writer = new StringWriter(1024);\n\t\tResult result = new StreamResult(writer);\n\t\tmarshaller.marshal(object, result);\n\t\treturn session.createTextMessage(writer.toString());\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#setTypeIdMappings(Map<String,typeIdMappings)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify mappings from type ids to Java classes, if desired.\n\t * This allows for synthetic ids in the type id message property,\n\t * instead of transferring Java class names.\n\t * <p>Default is no custom mappings, i.e. transferring raw Java class names.\n\t * @param typeIdMappings a Map with type id values as keys and Java classes as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "typeIdMappings"
    ],
    "position": {
      "column": 1,
      "line": 178
    },
    "return": "void",
    "signature": "public void setTypeIdMappings(Map<String, Class<?>> typeIdMappings)",
    "source_code": "\tpublic void setTypeIdMappings(Map<String, Class<?>> typeIdMappings) {\n\t\tthis.idClassMappings = new HashMap<>();\n\t\ttypeIdMappings.forEach((id, clazz) -> {\n\t\t\tthis.idClassMappings.put(id, clazz);\n\t\t\tthis.classIdMappings.put(clazz, id);\n\t\t});\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#setTypeIdOnMessage(object,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a type id for the given payload object on the given JMS Message.\n\t * <p>The default implementation consults the configured type id mapping and\n\t * sets the resulting value (either a mapped id or the raw Java class name)\n\t * into the configured type id message property.\n\t * @param object the payload object to set a type id for\n\t * @param message the JMS Message on which to set the type id property\n\t * @throws JMSException if thrown by JMS methods\n\t * @see #getJavaTypeForMessage(jakarta.jms.Message)\n\t * @see #setTypeIdPropertyName(String)\n\t * @see #setTypeIdMappings(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "protected void setTypeIdOnMessage(Object object, Message message)",
    "source_code": "\tprotected void setTypeIdOnMessage(Object object, Message message) throws JMSException {\n\t\tif (this.typeIdPropertyName != null) {\n\t\t\tString typeId = this.classIdMappings.get(object.getClass());\n\t\t\tif (typeId == null) {\n\t\t\t\ttypeId = object.getClass().getName();\n\t\t\t}\n\t\t\tmessage.setStringProperty(this.typeIdPropertyName, typeId);\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation creates a TextMessage for a String, a\n\t * BytesMessage for a byte array, a MapMessage for a Map,\n\t * and an ObjectMessage for a Serializable object.\n\t * @see #createMessageForString\n\t * @see #createMessageForByteArray\n\t * @see #createMessageForMap\n\t * @see #createMessageForSerializable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session)",
    "source_code": "\tpublic Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {\n\t\tif (object instanceof Message message) {\n\t\t\treturn message;\n\t\t}\n\t\telse if (object instanceof String text) {\n\t\t\treturn createMessageForString(text, session);\n\t\t}\n\t\telse if (object instanceof byte[] bytes) {\n\t\t\treturn createMessageForByteArray(bytes, session);\n\t\t}\n\t\telse if (object instanceof Map<?, ?> map) {\n\t\t\treturn createMessageForMap(map, session);\n\t\t}\n\t\telse if (object instanceof Serializable serializable) {\n\t\t\treturn createMessageForSerializable(serializable, session);\n\t\t}\n\t\telse {\n\t\t\tthrow new MessageConversionException(\"Cannot convert object of type [\" +\n\t\t\t\t\tObjectUtils.nullSafeClassName(object) + \"] to JMS message. Supported message \" +\n\t\t\t\t\t\"payloads are: String, byte array, Map<String,?>, Serializable object.\");\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Object conversionHint)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Object conversionHint)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\treturn toMessage(object, session, getSerializationView(conversionHint));\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,jsonView)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a Java object to a JMS Message using the specified json view\n\t * and the supplied session  to create the message object.\n\t * @param object the object to convert\n\t * @param session the Session to use for creating a JMS Message\n\t * @param jsonView the view to use to filter the content\n\t * @return the JMS Message\n\t * @throws jakarta.jms.JMSException if thrown by JMS API methods\n\t * @throws MessageConversionException in case of conversion failure\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "session",
      "jsonView"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "Message",
    "signature": "public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)",
    "source_code": "\tpublic Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tif (jsonView != null) {\n\t\t\treturn toMessage(object, session, this.objectMapper.writerWithView(jsonView));\n\t\t}\n\t\telse {\n\t\t\treturn toMessage(object, session, this.objectMapper.writer());\n\t\t}\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#toMessage(object,session,objectWriter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "object",
      "session",
      "objectWriter"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "Message",
    "signature": "protected Message toMessage(Object object, Session session, ObjectWriter objectWriter)",
    "source_code": "\tprotected Message toMessage(Object object, Session session, ObjectWriter objectWriter)\n\t\t\tthrows JMSException, MessageConversionException {\n\n\t\tMessage message;\n\t\ttry {\n\t\t\tmessage = switch (this.targetType) {\n\t\t\t\tcase TEXT -> mapToTextMessage(object, session, objectWriter);\n\t\t\t\tcase BYTES -> mapToBytesMessage(object, session, objectWriter);\n\t\t\t\tdefault -> mapToMessage(object, session, objectWriter, this.targetType);\n\t\t\t};\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new MessageConversionException(\"Could not map JSON object [\" + object + \"]\", ex);\n\t\t}\n\t\tsetTypeIdOnMessage(object, message);\n\t\treturn message;\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromBytesMessage(message,unmarshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshal the given {@link BytesMessage} into an object.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Unmarshaller#unmarshal(Source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromBytesMessage(BytesMessage message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tbyte[] bytes = new byte[(int) message.getBodyLength()];\n\t\tmessage.readBytes(bytes);\n\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\tStreamSource source = new StreamSource(bis);\n\t\treturn unmarshaller.unmarshal(source);\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromMessage(message,unmarshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that allows for custom message unmarshalling.\n\t * Invoked when {@link #fromMessage(Message)} is invoked with a message\n\t * that is not a {@link TextMessage} or {@link BytesMessage}.\n\t * <p>The default implementation throws an {@link IllegalArgumentException}.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 312
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromMessage(Message message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromMessage(Message message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tthrow new IllegalArgumentException(\"Unsupported message type [\" + message.getClass() +\n\t\t\t\t\"]. MarshallingMessageConverter by default only supports TextMessages and BytesMessages.\");\n\t}"
  },
  "org.springframework.jms.support.converter.<unknown>#unmarshalFromTextMessage(message,unmarshaller)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Unmarshal the given {@link TextMessage} into an object.\n\t * @param message the message\n\t * @param unmarshaller the unmarshaller to use\n\t * @return the unmarshalled object\n\t * @throws JMSException if thrown by JMS methods\n\t * @throws IOException in case of I/O errors\n\t * @throws XmlMappingException in case of OXM mapping errors\n\t * @see Unmarshaller#unmarshal(Source)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "unmarshaller"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "protected Object unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)",
    "source_code": "\tprotected Object unmarshalFromTextMessage(TextMessage message, Unmarshaller unmarshaller)\n\t\t\tthrows JMSException, IOException, XmlMappingException {\n\n\t\tSource source = new StreamSource(new StringReader(message.getText()));\n\t\treturn unmarshaller.unmarshal(source);\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#convertResultValueIfNecessary(result,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given result object (from attribute access or operation invocation)\n\t * to the specified target class for returning from the proxy method.\n\t * @param result the result object as returned by the {@code MBeanServer}\n\t * @param parameter the method parameter of the proxy method that's been invoked\n\t * @return the converted result object, or the passed-in object if no conversion\n\t * is necessary\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "result",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "Object",
    "signature": "protected Object convertResultValueIfNecessary(@Nullable Object result, MethodParameter parameter)",
    "source_code": "\tprotected Object convertResultValueIfNecessary(@Nullable Object result, MethodParameter parameter) {\n\t\tClass<?> targetClass = parameter.getParameterType();\n\t\ttry {\n\t\t\tif (result == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (ClassUtils.isAssignableValue(targetClass, result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (result instanceof CompositeData) {\n\t\t\t\tMethod fromMethod = targetClass.getMethod(\"from\", CompositeData.class);\n\t\t\t\treturn ReflectionUtils.invokeMethod(fromMethod, null, result);\n\t\t\t}\n\t\t\telse if (result instanceof CompositeData[] array) {\n\t\t\t\tif (targetClass.isArray()) {\n\t\t\t\t\treturn convertDataArrayToTargetArray(array, targetClass);\n\t\t\t\t}\n\t\t\t\telse if (Collection.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\tClass<?> elementType =\n\t\t\t\t\t\t\tResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\t\t\tif (elementType != null) {\n\t\t\t\t\t\treturn convertDataArrayToTargetCollection(array, targetClass, elementType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result instanceof TabularData) {\n\t\t\t\tMethod fromMethod = targetClass.getMethod(\"from\", TabularData.class);\n\t\t\t\treturn ReflectionUtils.invokeMethod(fromMethod, null, result);\n\t\t\t}\n\t\t\telse if (result instanceof TabularData[] array) {\n\t\t\t\tif (targetClass.isArray()) {\n\t\t\t\t\treturn convertDataArrayToTargetArray(array, targetClass);\n\t\t\t\t}\n\t\t\t\telse if (Collection.class.isAssignableFrom(targetClass)) {\n\t\t\t\t\tClass<?> elementType =\n\t\t\t\t\t\t\tResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\t\t\tif (elementType != null) {\n\t\t\t\t\t\treturn convertDataArrayToTargetCollection(array, targetClass, elementType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new InvocationFailureException(\n\t\t\t\t\t\"Incompatible result value [\" + result + \"] for target type [\" + targetClass.getName() + \"]\");\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new InvocationFailureException(\n\t\t\t\t\t\"Could not obtain 'from(CompositeData)' / 'from(TabularData)' method on target type [\" +\n\t\t\t\t\t\t\ttargetClass.getName() + \"] for conversion of MXBean data structure [\" + result + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#handleConnectFailure(invocation,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Refresh the connection and retry the MBean invocation if possible.\n\t * <p>If not configured to refresh on connect failure, this method\n\t * simply rethrows the original exception.\n\t * @param invocation the invocation that failed\n\t * @param ex the exception raised on remote invocation\n\t * @return the result value of the new invocation, if succeeded\n\t * @throws Throwable an exception raised by the new invocation,\n\t * if it failed as well\n\t * @see #setRefreshOnConnectFailure\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "invocation",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Object",
    "signature": "protected Object handleConnectFailure(MethodInvocation invocation, Exception ex)",
    "source_code": "\tprotected Object handleConnectFailure(MethodInvocation invocation, Exception ex) throws Throwable {\n\t\tif (this.refreshOnConnectFailure) {\n\t\t\tString msg = \"Could not connect to JMX server - retrying\";\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, ex);\n\t\t\t}\n\t\t\telse if (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(msg);\n\t\t\t}\n\t\t\tprepare();\n\t\t\treturn doInvoke(invocation);\n\t\t}\n\t\telse {\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.jmx.access.<unknown>#setEnvironment(Map<String,environment)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the environment for the JMX connector.\n\t * @see javax.management.remote.JMXConnectorFactory#connect(javax.management.remote.JMXServiceURL, java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "environment"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setEnvironment(@Nullable Map<String, ?> environment)",
    "source_code": "\tpublic void setEnvironment(@Nullable Map<String, ?> environment) {\n\t\tthis.environment = environment;\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#createAndConfigureMBean(managedResource,beanKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Creates an MBean that is configured with the appropriate management\n\t * interface for the supplied managed resource.\n\t * @param managedResource the resource that is to be exported as an MBean\n\t * @param beanKey the key associated with the managed bean\n\t * @see #createModelMBean()\n\t * @see #getMBeanInfo(Object, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedResource",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "ModelMBean",
    "signature": "protected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)",
    "source_code": "\tprotected ModelMBean createAndConfigureMBean(Object managedResource, String beanKey)\n\t\t\tthrows MBeanExportException {\n\t\ttry {\n\t\t\tModelMBean mbean = createModelMBean();\n\t\t\tmbean.setModelMBeanInfo(getMBeanInfo(managedResource, beanKey));\n\t\t\tmbean.setManagedResource(managedResource, MR_TYPE_OBJECT_REFERENCE);\n\t\t\treturn mbean;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new MBeanExportException(\"Could not create ModelMBean for managed resource [\" +\n\t\t\t\t\tmanagedResource + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#getObjectName(bean,beanKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@code ObjectName} for a bean.\n\t * <p>If the bean implements the {@code SelfNaming} interface, then the\n\t * {@code ObjectName} will be retrieved using {@code SelfNaming.getObjectName()}.\n\t * Otherwise, the configured {@code ObjectNamingStrategy} is used.\n\t * @param bean the name of the bean in the {@code BeanFactory}\n\t * @param beanKey the key associated with the bean in the beans map\n\t * @return the {@code ObjectName} for the supplied bean\n\t * @throws javax.management.MalformedObjectNameException\n\t * if the retrieved {@code ObjectName} is malformed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 765
    },
    "return": "ObjectName",
    "signature": "protected ObjectName getObjectName(Object bean, @Nullable String beanKey)",
    "source_code": "\tprotected ObjectName getObjectName(Object bean, @Nullable String beanKey) throws MalformedObjectNameException {\n\t\tif (bean instanceof SelfNaming selfNaming) {\n\t\t\treturn selfNaming.getObjectName();\n\t\t}\n\t\telse {\n\t\t\treturn this.namingStrategy.getObjectName(bean, beanKey);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#isBeanDefinitionLazyInit(beanFactory,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the specified bean definition should be considered as lazy-init.\n\t * @param beanFactory the bean factory that is supposed to contain the bean definition\n\t * @param beanName the name of the bean to check\n\t * @see org.springframework.beans.factory.config.ConfigurableListableBeanFactory#getBeanDefinition\n\t * @see org.springframework.beans.factory.config.BeanDefinition#isLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "boolean",
    "signature": "protected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName)",
    "source_code": "\tprotected boolean isBeanDefinitionLazyInit(ListableBeanFactory beanFactory, String beanName) {\n\t\treturn (beanFactory instanceof ConfigurableListableBeanFactory clbf && beanFactory.containsBeanDefinition(beanName) &&\n\t\t\t\tclbf.getBeanDefinition(beanName).isLazyInit());\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerBeanNameOrInstance(mapValue,beanKey)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register an individual bean with the {@link #setServer MBeanServer}.\n\t * <p>This method is responsible for deciding <strong>how</strong> a bean\n\t * should be exposed to the {@code MBeanServer}. Specifically, if the\n\t * supplied {@code mapValue} is the name of a bean that is configured\n\t * for lazy initialization, then a proxy to the resource is registered with\n\t * the {@code MBeanServer} so that the lazy load behavior is\n\t * honored. If the bean is already an MBean then it will be registered\n\t * directly with the {@code MBeanServer} without any intervention. For\n\t * all other beans or bean names, the resource itself is registered with\n\t * the {@code MBeanServer} directly.\n\t * @param mapValue the value configured for this bean in the beans map;\n\t * may be either the {@code String} name of a bean, or the bean itself\n\t * @param beanKey the key associated with this bean in the beans map\n\t * @return the {@code ObjectName} under which the resource was registered\n\t * @throws MBeanExportException if the export failed\n\t * @see #setBeans\n\t * @see #registerBeanInstance\n\t * @see #registerLazyInit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapValue",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "ObjectName",
    "signature": "protected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey)",
    "source_code": "\tprotected ObjectName registerBeanNameOrInstance(Object mapValue, String beanKey) throws MBeanExportException {\n\t\ttry {\n\t\t\tif (mapValue instanceof String beanName) {\n\t\t\t\t// Bean name pointing to a potentially lazy-init bean in the factory.\n\t\t\t\tif (this.beanFactory == null) {\n\t\t\t\t\tthrow new MBeanExportException(\"Cannot resolve bean names if not running in a BeanFactory\");\n\t\t\t\t}\n\t\t\t\tif (isBeanDefinitionLazyInit(this.beanFactory, beanName)) {\n\t\t\t\t\tObjectName objectName = registerLazyInit(beanName, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject bean = this.beanFactory.getBean(beanName);\n\t\t\t\t\tObjectName objectName = registerBeanInstance(bean, beanKey);\n\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\treturn objectName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Plain bean instance -> register it directly.\n\t\t\t\tif (this.beanFactory != null) {\n\t\t\t\t\tMap<String, ?> beansOfSameType =\n\t\t\t\t\t\t\tthis.beanFactory.getBeansOfType(mapValue.getClass(), false, this.allowEagerInit);\n\t\t\t\t\tfor (Map.Entry<String, ?> entry : beansOfSameType.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue() == mapValue) {\n\t\t\t\t\t\t\tString beanName = entry.getKey();\n\t\t\t\t\t\t\tObjectName objectName = registerBeanInstance(mapValue, beanKey);\n\t\t\t\t\t\t\treplaceNotificationListenerBeanNameKeysIfNecessary(beanName, objectName);\n\t\t\t\t\t\t\treturn objectName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn registerBeanInstance(mapValue, beanKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + mapValue + \"] with key '\" + beanKey + \"'\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#registerManagedResource(managedResource,objectName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "managedResource",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 495
    },
    "return": "void",
    "signature": "public void registerManagedResource(Object managedResource, ObjectName objectName)",
    "source_code": "\tpublic void registerManagedResource(Object managedResource, ObjectName objectName) throws MBeanExportException {\n\t\tAssert.notNull(managedResource, \"Managed resource must not be null\");\n\t\tAssert.notNull(objectName, \"ObjectName must not be null\");\n\t\ttry {\n\t\t\tif (isMBean(managedResource.getClass())) {\n\t\t\t\tdoRegister(managedResource, objectName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tModelMBean mbean = createAndConfigureMBean(managedResource, managedResource.getClass().getName());\n\t\t\t\tdoRegister(mbean, objectName);\n\t\t\t\tinjectNotificationPublisherIfNecessary(managedResource, mbean, objectName);\n\t\t\t}\n\t\t}\n\t\tcatch (JMException ex) {\n\t\t\tthrow new UnableToRegisterMBeanException(\n\t\t\t\t\t\"Unable to register MBean [\" + managedResource + \"] with object name [\" + objectName + \"]\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#setBeans(Map<String,beans)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Supply a {@code Map} of beans to be registered with the JMX\n\t * {@code MBeanServer}.\n\t * <p>The String keys are the basis for the creation of JMX object names.\n\t * By default, a JMX {@code ObjectName} will be created straight\n\t * from the given key. This can be customized through specifying a\n\t * custom {@code NamingStrategy}.\n\t * <p>Both bean instances and bean names are allowed as values.\n\t * Bean instances are typically linked in through bean references.\n\t * Bean names will be resolved as beans in the current factory, respecting\n\t * lazy-init markers (that is, not triggering initialization of such beans).\n\t * @param beans a Map with JMX names as keys and bean instances or bean names\n\t * as values\n\t * @see #setNamingStrategy\n\t * @see org.springframework.jmx.export.naming.KeyNamingStrategy\n\t * @see javax.management.ObjectName#ObjectName(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "beans"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "void",
    "signature": "public void setBeans(Map<String, Object> beans)",
    "source_code": "\tpublic void setBeans(Map<String, Object> beans) {\n\t\tthis.beans = beans;\n\t}"
  },
  "org.springframework.jmx.export.<unknown>#setNotificationListenerMappings(Map<?,listeners)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@link NotificationListener NotificationListeners} to register\n\t * with the {@link javax.management.MBeanServer}.\n\t * <P>The key of each entry in the {@code Map} is a {@link String}\n\t * representation of the {@link javax.management.ObjectName} or the bean\n\t * name of the MBean the listener should be registered for. Specifying an\n\t * asterisk ({@code *}) for a key will cause the listener to be\n\t * associated with all MBeans registered by this class at startup time.\n\t * <p>The value of each entry is the\n\t * {@link javax.management.NotificationListener} to register. For more\n\t * advanced options such as registering\n\t * {@link javax.management.NotificationFilter NotificationFilters} and\n\t * handback objects see {@link #setNotificationListeners(NotificationListenerBean[])}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "listeners"
    ],
    "position": {
      "column": 1,
      "line": 386
    },
    "return": "void",
    "signature": "public void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners)",
    "source_code": "\tpublic void setNotificationListenerMappings(Map<?, ? extends NotificationListener> listeners) {\n\t\tAssert.notNull(listeners, \"'listeners' must not be null\");\n\t\tList<NotificationListenerBean> notificationListeners =\n\t\t\t\tnew ArrayList<>(listeners.size());\n\n\t\tlisteners.forEach((key, listener) -> {\n\t\t\t// Get the listener from the map value.\n\t\t\tNotificationListenerBean bean = new NotificationListenerBean(listener);\n\t\t\t// Get the ObjectName from the map key.\n\t\t\tif (key != null && !WILDCARD.equals(key)) {\n\t\t\t\t// This listener is mapped to a specific ObjectName.\n\t\t\t\tbean.setMappedObjectName(key);\n\t\t\t}\n\t\t\tnotificationListeners.add(bean);\n\t\t});\n\n\t\tthis.notificationListeners = notificationListeners.toArray(new NotificationListenerBean[0]);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#getNotificationInfo(managedBean,beanKey)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "managedBean",
      "beanKey"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "ModelMBeanNotificationInfo[]",
    "signature": "protected ModelMBeanNotificationInfo[] getNotificationInfo(Object managedBean, String beanKey)",
    "source_code": "\tprotected ModelMBeanNotificationInfo[] getNotificationInfo(Object managedBean, String beanKey) {\n\t\tModelMBeanNotificationInfo[] result = null;\n\t\tif (StringUtils.hasText(beanKey)) {\n\t\t\tresult = this.notificationInfoMappings.get(beanKey);\n\t\t}\n\t\tif (result == null) {\n\t\t\tresult = this.notificationInfos;\n\t\t}\n\t\treturn (result != null ? result : new ModelMBeanNotificationInfo[0]);\n\t}"
  },
  "org.springframework.jmx.export.assembler.<unknown>#setNotificationInfoMappings(Map<String,notificationInfoMappings)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "notificationInfoMappings"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void setNotificationInfoMappings(Map<String, Object> notificationInfoMappings)",
    "source_code": "\tpublic void setNotificationInfoMappings(Map<String, Object> notificationInfoMappings) {\n\t\tnotificationInfoMappings.forEach((beanKey, result) ->\n\t\t\t\tthis.notificationInfoMappings.put(beanKey, extractNotificationMetadata(result)));\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#getInstance(domainName,Hashtable<String,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an {@code ObjectName} instance with the specified domain name\n\t * and the supplied key/name properties.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param properties the properties for the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, java.util.Hashtable)\n\t * @see ObjectName#getInstance(String, java.util.Hashtable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "domainName",
      "Hashtable<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String domainName, Hashtable<String, String> properties)",
    "source_code": "\tpublic static ObjectName getInstance(String domainName, Hashtable<String, String> properties)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\treturn ObjectName.getInstance(domainName, properties);\n\t}"
  },
  "org.springframework.jmx.support.<unknown>#getInstance(domainName,key,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an {@code ObjectName} instance for the specified domain and a\n\t * single property with the supplied key and value.\n\t * @param domainName the domain name for the {@code ObjectName}\n\t * @param key the key for the single property in the {@code ObjectName}\n\t * @param value the value for the single property in the {@code ObjectName}\n\t * @return the {@code ObjectName} instance\n\t * @throws MalformedObjectNameException in case of an invalid object name specification\n\t * @see ObjectName#ObjectName(String, String, String)\n\t * @see ObjectName#getInstance(String, String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "domainName",
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "ObjectName",
    "signature": "public ObjectName getInstance(String domainName, String key, String value)",
    "source_code": "\tpublic static ObjectName getInstance(String domainName, String key, String value)\n\t\t\tthrows MalformedObjectNameException {\n\n\t\treturn ObjectName.getInstance(domainName, key, value);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail (the content type will be determined by this)\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)\n\t * @see #addAttachment(String, java.io.File)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 1114
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, DataSource dataSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, DataSource dataSource) throws MessagingException {\n\t\tAssert.notNull(attachmentFilename, \"Attachment filename must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\ttry {\n\t\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\t\tmimeBodyPart.setDisposition(Part.ATTACHMENT);\n\t\t\tmimeBodyPart.setFileName(isEncodeFilenames() ?\n\t\t\t\t\tMimeUtility.encodeText(attachmentFilename) : attachmentFilename);\n\t\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\t\tgetRootMimeMultipart().addBodyPart(mimeBodyPart);\n\t\t}\n\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\tthrow new MessagingException(\"Failed to encode attachment filename\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,file)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, org.springframework.core.io.InputStreamSource)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 1143
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, File file)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddAttachment(attachmentFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>The content type will be determined by the given filename for\n\t * the attachment. Thus, any content source will be fine, including\n\t * temporary files with arbitrary filenames.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1168
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)\n\t\t\tthrows MessagingException {\n\n\t\tString contentType = getFileTypeMap().getContentType(attachmentFilename);\n\t\taddAttachment(attachmentFilename, inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addAttachment(attachmentFilename,inputStreamSource,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attachment to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.io.InputStreamResource}.\n\t * <p>Note that the InputStream returned by the InputStreamSource\n\t * implementation needs to be a <i>fresh one on each call</i>, as\n\t * JavaMail will invoke {@code getInputStream()} multiple times.\n\t * @param attachmentFilename the name of the attachment as it will\n\t * appear in the mail\n\t * @param inputStreamSource the resource to take the content from\n\t * (all of Spring's Resource implementations can be passed in here)\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @see #addAttachment(String, java.io.File)\n\t * @see #addAttachment(String, jakarta.activation.DataSource)\n\t * @see org.springframework.core.io.Resource\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attachmentFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1191
    },
    "return": "void",
    "signature": "public void addAttachment(String attachmentFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addAttachment(\n\t\t\tString attachmentFilename, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, attachmentFilename);\n\t\taddAttachment(attachmentFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addBcc(bcc,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bcc",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "void",
    "signature": "public void addBcc(String bcc, String personal)",
    "source_code": "\tpublic void addBcc(String bcc, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(bcc, \"Bcc address must not be null\");\n\t\taddBcc(getEncoding() != null ?\n\t\t\tnew InternetAddress(bcc, personal, getEncoding()) :\n\t\t\tnew InternetAddress(bcc, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addCc(cc,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cc",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 683
    },
    "return": "void",
    "signature": "public void addCc(String cc, String personal)",
    "source_code": "\tpublic void addCc(String cc, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(cc, \"Cc address must not be null\");\n\t\taddCc(getEncoding() != null ?\n\t\t\tnew InternetAddress(cc, personal, getEncoding()) :\n\t\t\tnew InternetAddress(cc, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource}.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 908
    },
    "return": "void",
    "signature": "public void addInline(String contentId, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, DataSource dataSource) throws MessagingException {\n\t\taddInline(contentId, null, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,file)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code java.io.File}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param file the File resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "file"
    ],
    "position": {
      "column": 1,
      "line": 970
    },
    "return": "void",
    "signature": "public void addInline(String contentId, File file)",
    "source_code": "\tpublic void addInline(String contentId, File file) throws MessagingException {\n\t\tAssert.notNull(file, \"File must not be null\");\n\t\tFileDataSource dataSource = new FileDataSource(file);\n\t\tdataSource.setFileTypeMap(getFileTypeMap());\n\t\taddInline(contentId, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,dataSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code jakarta.activation.DataSource} and assigning the provided\n\t * {@code inlineFileName} to the element.\n\t * <p>Note that the InputStream returned by the DataSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param dataSource the {@code jakarta.activation.DataSource} to take\n\t * the content from, determining the InputStream and the content type\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "dataSource"
    ],
    "position": {
      "column": 1,
      "line": 932
    },
    "return": "void",
    "signature": "public void addInline(String contentId, @Nullable String inlineFilename, DataSource dataSource)",
    "source_code": "\tpublic void addInline(String contentId, @Nullable String inlineFilename, DataSource dataSource)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(contentId, \"Content ID must not be null\");\n\t\tAssert.notNull(dataSource, \"DataSource must not be null\");\n\t\tMimeBodyPart mimeBodyPart = new MimeBodyPart();\n\t\tmimeBodyPart.setDisposition(Part.INLINE);\n\t\tmimeBodyPart.setContentID(\"<\" + contentId + \">\");\n\t\tmimeBodyPart.setDataHandler(new DataHandler(dataSource));\n\t\tif (inlineFilename != null) {\n\t\t\ttry {\n\t\t\tmimeBodyPart.setFileName(isEncodeFilenames() ?\n\t\t\t\t\tMimeUtility.encodeText(inlineFilename) : inlineFilename);\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\tthrow new MessagingException(\"Failed to encode inline filename\", ex);\n\t\t\t}\n\t\t}\n\t\tgetMimeMultipart().addBodyPart(mimeBodyPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,inputStreamSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName explicitly.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the file name to use for the inline element\n\t * @param inputStreamSource the resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText(String)\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource"
    ],
    "position": {
      "column": 1,
      "line": 1056
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource)\n\t\t\tthrows MessagingException {\n\n\t\tString contentType = getFileTypeMap().getContentType(inlineFilename);\n\t\taddInline(contentId, inlineFilename, inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inlineFilename,inputStreamSource,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the inline fileName and content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inlineFilename the fileName to use for the inline element's part\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @since 6.2\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inlineFilename",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1087
    },
    "return": "void",
    "signature": "public void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, String inlineFilename, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\n\t\tif (inputStreamSource instanceof Resource resource && resource.isOpen()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Passed-in Resource contains an open stream: invalid argument. \" +\n\t\t\t\t\t\"JavaMail requires an InputStreamSource that creates a fresh stream for every call.\");\n\t\t}\n\t\tDataSource dataSource = createDataSource(inputStreamSource, contentType, inlineFilename);\n\t\taddInline(contentId, inlineFilename, dataSource);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,inputStreamSource,contentType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from an\n\t * {@code org.springframework.core.InputStreamResource}, and\n\t * specifying the content type explicitly.\n\t * <p>You can determine the content type for any given filename via a Java\n\t * Activation Framework's FileTypeMap, for example the one held by this helper.\n\t * <p>Note that the InputStream returned by the InputStreamSource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param inputStreamSource the resource to take the content from\n\t * @param contentType the content type to use for the element\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #getFileTypeMap\n\t * @see #addInline(String, org.springframework.core.io.Resource)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "inputStreamSource",
      "contentType"
    ],
    "position": {
      "column": 1,
      "line": 1026
    },
    "return": "void",
    "signature": "public void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)",
    "source_code": "\tpublic void addInline(String contentId, InputStreamSource inputStreamSource, String contentType)\n\t\t\tthrows MessagingException {\n\n\t\taddInline(contentId, \"inline\", inputStreamSource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addInline(contentId,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an inline element to the MimeMessage, taking the content from a\n\t * {@code org.springframework.core.io.Resource}.\n\t * <p>The content type will be determined by the name of the given\n\t * content file. Do not use this for temporary files with arbitrary\n\t * filenames (possibly ending in \".tmp\" or the like)!\n\t * <p>Note that the InputStream returned by the Resource implementation\n\t * needs to be a <i>fresh one on each call</i>, as JavaMail will invoke\n\t * {@code getInputStream()} multiple times.\n\t * <p><b>NOTE:</b> Invoke {@code addInline} <i>after</i> {@link #setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param contentId the content ID to use. Will end up as \"Content-ID\" header\n\t * in the body part, surrounded by angle brackets: for example, \"myId\" &rarr; \"&lt;myId&gt;\".\n\t * Can be referenced in HTML source via src=\"cid:myId\" expressions.\n\t * @param resource the resource to take the content from\n\t * @throws MessagingException in case of errors\n\t * @see #setText\n\t * @see #addInline(String, java.io.File)\n\t * @see #addInline(String, jakarta.activation.DataSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "contentId",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 997
    },
    "return": "void",
    "signature": "public void addInline(String contentId, Resource resource)",
    "source_code": "\tpublic void addInline(String contentId, Resource resource) throws MessagingException {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tString contentType = (resource.getFilename() != null ?\n\t\t\t\tgetFileTypeMap().getContentType(resource.getFilename()) : MimeTypeUtils.APPLICATION_OCTET_STREAM_VALUE);\n\t\taddInline(contentId, resource, contentType);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#addTo(to,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "to",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 638
    },
    "return": "void",
    "signature": "public void addTo(String to, String personal)",
    "source_code": "\tpublic void addTo(String to, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(to, \"To address must not be null\");\n\t\taddTo(getEncoding() != null ?\n\t\t\tnew InternetAddress(to, personal, getEncoding()) :\n\t\t\tnew InternetAddress(to, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createDataSource(inputStreamSource,contentType,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an Activation Framework DataSource for the given InputStreamSource.\n\t * @param inputStreamSource the InputStreamSource (typically a Spring Resource)\n\t * @param contentType the content type\n\t * @param name the name of the DataSource\n\t * @return the Activation Framework DataSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputStreamSource",
      "contentType",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 1212
    },
    "return": "DataSource",
    "signature": "protected DataSource createDataSource(final InputStreamSource inputStreamSource, final String contentType, final String name)",
    "source_code": "\tprotected DataSource createDataSource(\n\t\tfinal InputStreamSource inputStreamSource, final String contentType, final String name) {\n\n\t\treturn new DataSource() {\n\t\t\t@Override\n\t\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\t\treturn inputStreamSource.getInputStream();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic OutputStream getOutputStream() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Read-only jakarta.activation.DataSource\");\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getContentType() {\n\t\t\t\treturn contentType;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#createMimeMultiparts(mimeMessage,multipartMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the MimeMultipart objects to use, which will be used\n\t * to store attachments on the one hand and text(s) and inline elements\n\t * on the other hand.\n\t * <p>Texts and inline elements can either be stored in the root element\n\t * itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED) or in a nested element\n\t * rather than the root element directly (MULTIPART_MODE_MIXED_RELATED).\n\t * <p>By default, the root MimeMultipart element will be of type \"mixed\"\n\t * (MULTIPART_MODE_MIXED) or \"related\" (MULTIPART_MODE_RELATED).\n\t * The main multipart element will either be added as nested element of\n\t * type \"related\" (MULTIPART_MODE_MIXED_RELATED) or be identical to the root\n\t * element itself (MULTIPART_MODE_MIXED, MULTIPART_MODE_RELATED).\n\t * @param mimeMessage the MimeMessage object to add the root MimeMultipart\n\t * object to\n\t * @param multipartMode the multipart mode, as passed into the constructor\n\t * (MIXED, RELATED, MIXED_RELATED, or NO)\n\t * @throws MessagingException if multipart creation failed\n\t * @see #setMimeMultiparts\n\t * @see #MULTIPART_MODE_NO\n\t * @see #MULTIPART_MODE_MIXED\n\t * @see #MULTIPART_MODE_RELATED\n\t * @see #MULTIPART_MODE_MIXED_RELATED\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeMessage",
      "multipartMode"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "void",
    "signature": "protected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode)",
    "source_code": "\tprotected void createMimeMultiparts(MimeMessage mimeMessage, int multipartMode) throws MessagingException {\n\t\tswitch (multipartMode) {\n\t\t\tcase MULTIPART_MODE_NO -> setMimeMultiparts(null, null);\n\t\t\tcase MULTIPART_MODE_MIXED -> {\n\t\t\t\tMimeMultipart mixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);\n\t\t\t\tmimeMessage.setContent(mixedMultipart);\n\t\t\t\tsetMimeMultiparts(mixedMultipart, mixedMultipart);\n\t\t\t}\n\t\t\tcase MULTIPART_MODE_RELATED -> {\n\t\t\t\tMimeMultipart relatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);\n\t\t\t\tmimeMessage.setContent(relatedMultipart);\n\t\t\t\tsetMimeMultiparts(relatedMultipart, relatedMultipart);\n\t\t\t}\n\t\t\tcase MULTIPART_MODE_MIXED_RELATED -> {\n\t\t\t\tMimeMultipart rootMixedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_MIXED);\n\t\t\t\tmimeMessage.setContent(rootMixedMultipart);\n\t\t\t\tMimeMultipart nestedRelatedMultipart = new MimeMultipart(MULTIPART_SUBTYPE_RELATED);\n\t\t\t\tMimeBodyPart relatedBodyPart = new MimeBodyPart();\n\t\t\t\trelatedBodyPart.setContent(nestedRelatedMultipart);\n\t\t\t\trootMixedMultipart.addBodyPart(relatedBodyPart);\n\t\t\t\tsetMimeMultiparts(rootMixedMultipart, nestedRelatedMultipart);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\tthrow new IllegalArgumentException(\"Only multipart modes MIXED_RELATED, RELATED and NO supported\");\n\t\t}\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setFrom(from,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "from",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "void",
    "signature": "public void setFrom(String from, String personal)",
    "source_code": "\tpublic void setFrom(String from, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(from, \"From address must not be null\");\n\t\tsetFrom(getEncoding() != null ?\n\t\t\tnew InternetAddress(from, personal, getEncoding()) : new InternetAddress(from, personal));\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setMimeMultiparts(root,main)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given MimeMultipart objects for use by this MimeMessageHelper.\n\t * @param root the root MimeMultipart object, which attachments will be added to;\n\t * or {@code null} to indicate no multipart at all\n\t * @param main the main MimeMultipart object, which text(s) and inline elements\n\t * will be added to (can be the same as the root multipart object, or an element\n\t * nested underneath the root multipart element)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "root",
      "main"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "protected void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main)",
    "source_code": "\tprotected final void setMimeMultiparts(@Nullable MimeMultipart root, @Nullable MimeMultipart main) {\n\t\tthis.rootMimeMultipart = root;\n\t\tthis.mimeMultipart = main;\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setReplyTo(replyTo,personal)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "replyTo",
      "personal"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void setReplyTo(String replyTo, String personal)",
    "source_code": "\tpublic void setReplyTo(String replyTo, String personal) throws MessagingException, UnsupportedEncodingException {\n\t\tAssert.notNull(replyTo, \"Reply-to address must not be null\");\n\t\tInternetAddress replyToAddress = (getEncoding() != null) ?\n\t\t\t\tnew InternetAddress(replyTo, personal, getEncoding()) : new InternetAddress(replyTo, personal);\n\t\tsetReplyTo(replyToAddress);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setText(plainText,htmlText)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given plain text and HTML text as alternatives, offering\n\t * both options to the email client. Requires multipart mode.\n\t * <p><b>NOTE:</b> Invoke {@link #addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param plainText the plain text for the message\n\t * @param htmlText the HTML text for the message\n\t * @throws MessagingException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "plainText",
      "htmlText"
    ],
    "position": {
      "column": 1,
      "line": 837
    },
    "return": "void",
    "signature": "public void setText(String plainText, String htmlText)",
    "source_code": "\tpublic void setText(String plainText, String htmlText) throws MessagingException {\n\t\tAssert.notNull(plainText, \"Plain text must not be null\");\n\t\tAssert.notNull(htmlText, \"HTML text must not be null\");\n\n\t\tMimeMultipart messageBody = new MimeMultipart(MULTIPART_SUBTYPE_ALTERNATIVE);\n\t\tgetMainPart().setContent(messageBody, CONTENT_TYPE_ALTERNATIVE);\n\n\t\t// Create the plain text part of the message.\n\t\tMimeBodyPart plainTextPart = new MimeBodyPart();\n\t\tsetPlainTextToMimePart(plainTextPart, plainText);\n\t\tmessageBody.addBodyPart(plainTextPart);\n\n\t\t// Create the HTML text part of the message.\n\t\tMimeBodyPart htmlTextPart = new MimeBodyPart();\n\t\tsetHtmlTextToMimePart(htmlTextPart, htmlText);\n\t\tmessageBody.addBodyPart(htmlTextPart);\n\t}"
  },
  "org.springframework.mail.javamail.<unknown>#setText(text,html)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given text directly as content in non-multipart mode\n\t * or as default body part in multipart mode.\n\t * The \"html\" flag determines the content type to apply.\n\t * <p><b>NOTE:</b> Invoke {@link #addInline} <i>after</i> {@code setText};\n\t * else, mail readers might not be able to resolve inline references correctly.\n\t * @param text the text for the message\n\t * @param html whether to apply content type \"text/html\" for an\n\t * HTML mail, using default content type (\"text/plain\") else\n\t * @throws MessagingException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "html"
    ],
    "position": {
      "column": 1,
      "line": 811
    },
    "return": "void",
    "signature": "public void setText(String text, boolean html)",
    "source_code": "\tpublic void setText(String text, boolean html) throws MessagingException {\n\t\tAssert.notNull(text, \"Text must not be null\");\n\t\tMimePart partToUse;\n\t\tif (isMultipart()) {\n\t\t\tpartToUse = getMainPart();\n\t\t}\n\t\telse {\n\t\t\tpartToUse = this.mimeMessage;\n\t\t}\n\t\tif (html) {\n\t\t\tsetHtmlTextToMimePart(partToUse, text);\n\t\t}\n\t\telse {\n\t\t\tsetPlainTextToMimePart(partToUse, text);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.<unknown>#get(key,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "T",
    "signature": "public T get(Object key, Class<T> type)",
    "source_code": "\tpublic <T> T get(Object key, Class<T> type) {\n\t\tObject value = this.headers.get(key);\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!type.isAssignableFrom(value.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Incorrect type specified for header '\" +\n\t\t\t\t\tkey + \"'. Expected [\" + type + \"] but actual type is [\" + value.getClass() + \"]\");\n\t\t}\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.messaging.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\tpublic Object put(String key, Object value) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Since MessageHeaders are immutable, the call to this method\n\t * will result in {@link UnsupportedOperationException}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends Object> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends Object> map) {\n\t\tthrow new UnsupportedOperationException(\"MessageHeaders is immutable\");\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertFrom(message,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "boolean",
    "signature": "protected boolean canConvertFrom(Message<?> message, Class<?> targetClass)",
    "source_code": "\tprotected boolean canConvertFrom(Message<?> message, Class<?> targetClass) {\n\t\treturn (supports(targetClass) && supportsMimeType(message.getHeaders()));\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#canConvertTo(payload,headers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "boolean",
    "signature": "protected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers)",
    "source_code": "\tprotected boolean canConvertTo(Object payload, @Nullable MessageHeaders headers) {\n\t\treturn (supports(payload.getClass()) && supportsMimeType(headers));\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#convertFromInternal(message,targetClass,conversionHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the message payload from serialized form to an Object.\n\t * @param message the input message\n\t * @param targetClass the target class for the conversion\n\t * @param conversionHint an extra object passed to the {@link MessageConverter},\n\t * for example, the associated {@code MethodParameter} (may be {@code null}}\n\t * @return the result of the conversion, or {@code null} if the converter cannot\n\t * perform the conversion\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "Object",
    "signature": "protected Object convertFromInternal(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertFromInternal(\n\t\t\tMessage<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#convertToInternal(payload,headers,conversionHint)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the payload object to serialized form.\n\t * @param payload the Object to convert\n\t * @param headers optional headers for the message (may be {@code null})\n\t * @param conversionHint an extra object passed to the {@link MessageConverter},\n\t * for example, the associated {@code MethodParameter} (may be {@code null}}\n\t * @return the resulting payload for the message, or {@code null} if the converter\n\t * cannot perform the conversion\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "headers",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "Object",
    "signature": "protected Object convertToInternal(Object payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint)",
    "source_code": "\tprotected Object convertToInternal(\n\t\t\tObject payload, @Nullable MessageHeaders headers, @Nullable Object conversionHint) {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromJson(payload,resolvedType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Object",
    "signature": "protected Object fromJson(String payload, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(String payload, Type resolvedType);"
  },
  "org.springframework.messaging.converter.<unknown>#fromJson(reader,resolvedType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "reader",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "Object",
    "signature": "protected Object fromJson(Reader reader, Type resolvedType)",
    "source_code": "\tprotected abstract Object fromJson(Reader reader, Type resolvedType);"
  },
  "org.springframework.messaging.converter.<unknown>#fromMessage(message,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass)",
    "source_code": "\tpublic final Object fromMessage(Message<?> message, Class<?> targetClass) {\n\t\treturn fromMessage(message, targetClass, null);\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#fromMessage(message,targetClass,conversionHint)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "targetClass",
      "conversionHint"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "Object",
    "signature": "public Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint)",
    "source_code": "\tpublic final Object fromMessage(Message<?> message, Class<?> targetClass, @Nullable Object conversionHint) {\n\t\tif (!canConvertFrom(message, targetClass)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn convertFromInternal(message, targetClass, conversionHint);\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#logWarningIfNecessary(type,cause)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether to log the given exception coming from a\n\t * {@link ObjectMapper#canDeserialize} / {@link ObjectMapper#canSerialize} check.\n\t * @param type the class that Jackson tested for (de-)serializability\n\t * @param cause the Jackson-thrown exception to evaluate\n\t * (typically a {@link JsonMappingException})\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "type",
      "cause"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void logWarningIfNecessary(Type type, @Nullable Throwable cause)",
    "source_code": "\tprotected void logWarningIfNecessary(Type type, @Nullable Throwable cause) {\n\t\tif (cause == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not log warning for serializer not found (note: different message wording on Jackson 2.9)\n\t\tboolean debugLevel = (cause instanceof JsonMappingException && cause.getMessage() != null\n\t\t\t\t&& cause.getMessage().startsWith(\"Cannot find\"));\n\n\t\tif (debugLevel ? logger.isDebugEnabled() : logger.isWarnEnabled()) {\n\t\t\tString msg = \"Failed to evaluate Jackson \" + (type instanceof JavaType ? \"de\" : \"\") +\n\t\t\t\t\t\"serialization for type [\" + type + \"]\";\n\t\t\tif (debugLevel) {\n\t\t\t\tlogger.debug(msg, cause);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.warn(msg, cause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(msg + \": \" + cause);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.converter.<unknown>#merge(message,charset,contentType,extensionRegistry,builder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "charset",
      "contentType",
      "extensionRegistry",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "void",
    "signature": "public void merge(org.springframework.messaging.Message<?> message, Charset charset,\n\t\t\t\tMimeType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder)",
    "source_code": "\t\tpublic void merge(org.springframework.messaging.Message<?> message, Charset charset,\n\t\t\t\tMimeType contentType, ExtensionRegistry extensionRegistry, Message.Builder builder)\n\t\t\t\tthrows IOException, MessageConversionException {\n\n\t\t\tif (contentType.isCompatibleWith(APPLICATION_JSON)) {\n\t\t\t\tif (message.getPayload() instanceof byte[] bytes) {\n\t\t\t\t\tthis.parser.merge(new String(bytes, charset), builder);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.parser.merge(message.getPayload().toString(), builder);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MessageConversionException(\n\t\t\t\t\t\t\"protobuf-java-util does not support parsing \" + contentType);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.converter.<unknown>#print(message,output,contentType,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "output",
      "contentType",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void print(Message message, OutputStream output, MimeType contentType, Charset charset)",
    "source_code": "\t\tpublic void print(Message message, OutputStream output, MimeType contentType, Charset charset)\n\t\t\t\tthrows IOException, MessageConversionException {\n\n\t\t\tif (contentType.isCompatibleWith(APPLICATION_JSON)) {\n\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(output, charset);\n\t\t\t\tthis.printer.appendTo(message, writer);\n\t\t\t\twriter.flush();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MessageConversionException(\n\t\t\t\t\t\t\"protobuf-java-util does not support printing \" + contentType);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.converter.<unknown>#toJson(payload,resolvedType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "String",
    "signature": "protected String toJson(Object payload, Type resolvedType)",
    "source_code": "\tprotected abstract String toJson(Object payload, Type resolvedType);"
  },
  "org.springframework.messaging.converter.<unknown>#toJson(payload,resolvedType,writer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "payload",
      "resolvedType",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "protected void toJson(Object payload, Type resolvedType, Writer writer)",
    "source_code": "\tprotected abstract void toJson(Object payload, Type resolvedType, Writer writer);"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload) throws MessagingException {\n\t\tconvertAndSend(destination, payload, (Map<String, Object>) null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,Map<String,headers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,Map<String,headers,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable Map<String, Object> headers,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tMessage<?> message = doConvert(payload, headers, postProcessor);\n\t\tsend(destination, message);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(destination,payload,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "public void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(D destination, Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(destination, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#convertAndSend(payload,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSend(Object payload, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tconvertAndSend(getRequiredDefaultDestination(), payload, postProcessor);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doSend(channel,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "channel",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message)",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message) {\n\t\tdoSend(channel, message, sendTimeout(message));\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doSend(channel,message,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "channel",
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "void",
    "signature": "protected void doSend(MessageChannel channel, Message<?> message, long timeout)",
    "source_code": "\tprotected final void doSend(MessageChannel channel, Message<?> message, long timeout) {\n\t\tAssert.notNull(channel, \"MessageChannel is required\");\n\n\t\tMessage<?> messageToSend = message;\n\t\tMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\tif (accessor != null && accessor.isMutable()) {\n\t\t\taccessor.removeHeader(this.sendTimeoutHeader);\n\t\t\taccessor.removeHeader(this.receiveTimeoutHeader);\n\t\t\taccessor.setImmutable();\n\t\t}\n\t\telse if (message.getHeaders().containsKey(this.sendTimeoutHeader)\n\t\t\t\t|| message.getHeaders().containsKey(this.receiveTimeoutHeader)) {\n\t\t\tmessageToSend = MessageBuilder.fromMessage(message)\n\t\t\t\t\t.setHeader(this.sendTimeoutHeader, null)\n\t\t\t\t\t.setHeader(this.receiveTimeoutHeader, null)\n\t\t\t\t\t.build();\n\t\t}\n\n\t\tboolean sent = (timeout >= 0 ? channel.send(messageToSend, timeout) : channel.send(messageToSend));\n\n\t\tif (!sent) {\n\t\t\tthrow new MessageDeliveryException(message,\n\t\t\t\t\t\"Failed to send message to channel '\" + channel + \"' within timeout: \" + timeout);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#doSend(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void doSend(D destination, Message<?> message)",
    "source_code": "\tprotected abstract void doSend(D destination, Message<?> message);"
  },
  "org.springframework.messaging.core.<unknown>#processHeadersToSend(Map<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provides access to the map of input headers before a send operation.\n\t * Subclasses can modify the headers and then return the same or a different map.\n\t * <p>This default implementation in this class returns the input map.\n\t * @param headers the headers to send (or {@code null} if none)\n\t * @return the actual headers to send (or {@code null} if none)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\treturn headers;\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#send(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void send(D destination, Message<?> message)",
    "source_code": "\tpublic void send(D destination, Message<?> message) {\n\t\tdoSend(destination, message);\n\t}"
  },
  "org.springframework.messaging.core.<unknown>#send(message,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\t\tpublic boolean send(Message<?> message, long timeout) {\n\t\t\tthis.replyMessage = message;\n\t\t\tboolean alreadyReceivedReply = this.hasReceived;\n\t\t\tthis.replyLatch.countDown();\n\n\t\t\tString errorDescription = null;\n\t\t\tif (this.hasTimedOut) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has exited due to a timeout\";\n\t\t\t}\n\t\t\telse if (alreadyReceivedReply) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has already received a reply\";\n\t\t\t}\n\t\t\telse if (this.hasSendFailed) {\n\t\t\t\terrorDescription = \"Reply message received but the receiving thread has exited due to \" +\n\t\t\t\t\t\t\"an exception while sending the request message\";\n\t\t\t}\n\n\t\t\tif (errorDescription != null) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(errorDescription + \": \" + message);\n\t\t\t\t}\n\t\t\t\tif (this.throwExceptionOnLateReply) {\n\t\t\t\t\tthrow new MessageDeliveryException(message, errorDescription);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.handler.<unknown>#assertTargetBean(method,targetBean,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual endpoint instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). Endpoint classes that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetBean",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "void",
    "signature": "protected void assertTargetBean(Method method, Object targetBean, Object[] args)",
    "source_code": "\tprotected void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString text = \"The mapped handler method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual endpoint bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the endpoint requires proxying \" +\n\t\t\t\t\t\"(for example, due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args));\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#compareTo(other,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int compareTo(CompositeMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(CompositeMessageCondition other, Message<?> message) {\n\t\tcheckCompatible(other);\n\t\tList<MessageCondition<?>> otherConditions = other.getMessageConditions();\n\t\tfor (int i = 0; i < this.messageConditions.size(); i++) {\n\t\t\tint result = compare (this.messageConditions.get(i), otherConditions.get(i), message);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.messaging.handler.<unknown>#formatInvokeError(text,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Endpoint [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerMessageExceptionHandlerHints(hints,annotation)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "annotation"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "protected void registerMessageExceptionHandlerHints(ReflectionHints hints, MessageExceptionHandler annotation)",
    "source_code": "\tprotected void registerMessageExceptionHandlerHints(ReflectionHints hints, MessageExceptionHandler annotation) {\n\t\tfor (Class<?> exceptionClass : annotation.value()) {\n\t\t\thints.registerType(exceptionClass);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tregisterParameterHints(hints, method);\n\t\tregisterReturnValueHints(hints, method);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerParameterHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "void",
    "signature": "protected void registerParameterHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerParameterHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tMethodParameter methodParameter = MethodParameter.forParameter(parameter);\n\t\t\tif (Message.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\t\tType messageType = getMessageType(methodParameter);\n\t\t\t\tif (messageType != null) {\n\t\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, messageType);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (couldBePayload(methodParameter)) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t\tif (element.isAnnotationPresent(MessageExceptionHandler.class)) {\n\t\t\t\tregisterMessageExceptionHandlerHints(hints, element.getAnnotation(MessageExceptionHandler.class));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerReturnValueHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "protected void registerReturnValueHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerReturnValueHints(ReflectionHints hints, Method method) {\n\t\tMethodParameter returnType = MethodParameter.forExecutable(method, -1);\n\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnType.getGenericParameterType());\n\t}"
  },
  "org.springframework.messaging.handler.annotation.<unknown>#registerTypeHints(hints,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected CompositeMessageCondition getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tCompositeMessageCondition methodCondition = getCondition(method);\n\t\tif (methodCondition != null) {\n\t\t\tCompositeMessageCondition typeCondition = getCondition(handlerType);\n\t\t\tif (typeCondition != null) {\n\t\t\t\treturn typeCondition.combine(methodCondition);\n\t\t\t}\n\t\t}\n\t\treturn methodCondition;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#getMatchingMapping(mapping,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition getMatchingMapping(CompositeMessageCondition mapping, Message<?> message)",
    "source_code": "\tprotected CompositeMessageCondition getMatchingMapping(CompositeMessageCondition mapping, Message<?> message) {\n\t\treturn mapping.getMatchingCondition(message);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#handleMatch(mapping,handlerMethod,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleMatch(CompositeMessageCondition mapping, HandlerMethod handlerMethod, Message<?> message)",
    "source_code": "\tprotected Mono<Void> handleMatch(\n\t\t\tCompositeMessageCondition mapping, HandlerMethod handlerMethod, Message<?> message) {\n\n\t\tSet<String> patterns = mapping.getCondition(DestinationPatternsMessageCondition.class).getPatterns();\n\t\tif (!CollectionUtils.isEmpty(patterns)) {\n\t\t\tString pattern = patterns.iterator().next();\n\t\t\tRouteMatcher.Route destination = getDestination(message);\n\t\t\tAssert.state(destination != null, \"Missing destination header\");\n\t\t\tMap<String, String> vars = obtainRouteMatcher().matchAndExtract(pattern, destination);\n\t\t\tif (!CollectionUtils.isEmpty(vars)) {\n\t\t\t\tMessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\t\t\tAssert.state(mha != null && mha.isMutable(), \"Mutable MessageHeaderAccessor required\");\n\t\t\t\tmha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);\n\t\t\t}\n\t\t}\n\t\treturn super.handleMatch(mapping, handlerMethod, message);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#handleMissingValue(name,parameter,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, Message<?> message)",
    "source_code": "\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#resolveArgument(parameter,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the content of the given message payload through a compatible\n\t * {@link Decoder}.\n\t *\n\t * <p>Validation is applied if the method argument is annotated with\n\t * {@code @jakarta.validation.Valid} or\n\t * {@link org.springframework.validation.annotation.Validated}. Validation\n\t * failure results in an {@link MethodArgumentNotValidException}.\n\t * @param parameter the target method argument that we are decoding to\n\t * @param message the message from which the content was extracted\n\t * @return a Mono with the result of argument resolution\n\t * @see #extractContent(MethodParameter, Message)\n\t * @see #getMimeType(Message)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic final Mono<Object> resolveArgument(MethodParameter parameter, Message<?> message) {\n\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tMimeType mimeType = getMimeType(message);\n\t\tmimeType = mimeType != null ? mimeType : MimeTypeUtils.APPLICATION_OCTET_STREAM;\n\n\t\tFlux<DataBuffer> content = extractContent(parameter, message);\n\t\treturn decodeContent(parameter, message, ann == null || ann.required(), content, mimeType);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#resolveArgumentInternal(parameter,message,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the given parameter type and value name into an argument value.\n\t * @param parameter the method parameter to resolve to an argument value\n\t * @param message the current request\n\t * @param name the name of the value being resolved\n\t * @return the resolved argument. May be {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "message",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Object",
    "signature": "protected Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)",
    "source_code": "\tprotected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name);"
  },
  "org.springframework.messaging.handler.annotation.reactive.<unknown>#resolveArgumentValue(parameter,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic Object resolveArgumentValue(MethodParameter parameter, Message<?> message) {\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n\t\t}\n\n\t\tObject arg = resolveArgumentInternal(nestedParameter, message, resolvedName.toString());\n\t\tif (arg == null) {\n\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t}\n\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\thandleMissingValue(resolvedName.toString(), nestedParameter, message);\n\t\t\t}\n\t\t\targ = handleNullValue(resolvedName.toString(), arg, nestedParameter.getNestedParameterType());\n\t\t}\n\t\telse if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t}\n\n\t\tif (parameter != nestedParameter || !ClassUtils.isAssignableValue(parameter.getParameterType(), arg)) {\n\t\t\targ = this.conversionService.convert(arg, new TypeDescriptor(parameter));\n\t\t\t// Check for null value after conversion of incoming argument value\n\t\t\tif (arg == null) {\n\t\t\t\tif (namedValueInfo.defaultValue != null) {\n\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t}\n\t\t\t\telse if (namedValueInfo.required && !nestedParameter.isOptional()) {\n\t\t\t\t\thandleMissingValue(resolvedName.toString(), nestedParameter, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn arg;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#createInvocableHandlerMethod(bean,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "InvocableHandlerMethod",
    "signature": "public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method)",
    "source_code": "\tpublic InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {\n\t\tInvocableHandlerMethod handlerMethod = new InvocableHandlerMethod(bean, method);\n\t\thandlerMethod.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#handleMissingValue(name,parameter,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}\n\t * returned {@code null} and there is no default value. Subclasses can\n\t * throw an appropriate exception for this case.\n\t * @param name the name for the value\n\t * @param parameter the target method parameter\n\t * @param message the message being processed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, Message<?> message)",
    "source_code": "\tprotected abstract void handleMissingValue(String name, MethodParameter parameter, Message<?> message);"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#handleResolvedValue(arg,name,parameter,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param message the message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Message<?> message)",
    "source_code": "\tprotected void handleResolvedValue(\n\t\t\t@Nullable Object arg, String name, MethodParameter parameter, Message<?> message) {\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#resolveArgument(parameter,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, Message<?> message)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\tPayload ann = parameter.getParameterAnnotation(Payload.class);\n\t\tif (ann != null && StringUtils.hasText(ann.expression())) {\n\t\t\tthrow new IllegalStateException(\"@Payload SpEL expressions not supported by this resolver\");\n\t\t}\n\n\t\tboolean isOptionalTargetClass = (parameter.getParameterType() == Optional.class);\n\t\tObject payload = message.getPayload();\n\t\tif (isEmptyPayload(payload)) {\n\t\t\tif ((ann == null || ann.required()) && !isOptionalTargetClass) {\n\t\t\t\tString paramName = getParameterName(parameter);\n\t\t\t\tBindingResult bindingResult = new BeanPropertyBindingResult(payload, paramName);\n\t\t\t\tbindingResult.addError(new ObjectError(paramName, \"Payload value must not be empty\"));\n\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (isOptionalTargetClass ? Optional.empty() : null);\n\t\t\t}\n\t\t}\n\n\t\tif (payload instanceof Optional<?> optional) {\n\t\t\tpayload = optional.get();\n\t\t\tmessage = MessageBuilder.createMessage(payload, message.getHeaders());\n\t\t}\n\n\t\tClass<?> targetClass = resolveTargetClass(parameter, message);\n\t\tClass<?> payloadClass = payload.getClass();\n\t\tif (!ClassUtils.isAssignable(targetClass, payloadClass)) {\n\t\t\tif (this.converter instanceof SmartMessageConverter smartConverter) {\n\t\t\t\tpayload = smartConverter.fromMessage(message, targetClass, parameter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpayload = this.converter.fromMessage(message, targetClass);\n\t\t\t}\n\t\t\tif (payload == null) {\n\t\t\t\tthrow new MessageConversionException(message, \"Cannot convert from [\" +\n\t\t\t\t\t\tpayloadClass.getName() + \"] to [\" + targetClass.getName() + \"] for \" + message);\n\t\t\t}\n\t\t}\n\t\tvalidate(message, parameter, payload);\n\t\treturn (isOptionalTargetClass ? Optional.of(payload) : payload);\n\t}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#resolveArgumentInternal(parameter,message,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolves the given parameter type and value name into an argument value.\n\t * @param parameter the method parameter to resolve to an argument value\n\t * @param message the current request\n\t * @param name the name of the value being resolved\n\t * @return the resolved argument. May be {@code null}\n\t * @throws Exception in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "message",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "Object",
    "signature": "protected Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)",
    "source_code": "\tprotected abstract Object resolveArgumentInternal(MethodParameter parameter, Message<?> message, String name)\n\t\t\tthrows Exception;\n\n\t/**\n\t * Invoked when a value is required, but {@link #resolveArgumentInternal}"
  },
  "org.springframework.messaging.handler.annotation.support.<unknown>#validate(message,parameter,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the payload if applicable.\n\t * @param message the currently processed message\n\t * @param parameter the method parameter\n\t * @param target the target payload object\n\t * @throws MethodArgumentNotValidException in case of binding errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "parameter",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "protected void validate(Message<?> message, MethodParameter parameter, Object target)",
    "source_code": "\tprotected void validate(Message<?> message, MethodParameter parameter, Object target) {\n\t\tif (this.validator == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (Annotation ann : parameter.getParameterAnnotations()) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tBeanPropertyBindingResult bindingResult =\n\t\t\t\t\t\tnew BeanPropertyBindingResult(target, getParameterName(parameter));\n\t\t\t\tif (!ObjectUtils.isEmpty(validationHints) && this.validator instanceof SmartValidator sv) {\n\t\t\t\t\tsv.validate(target, bindingResult, validationHints);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.validator.validate(target, bindingResult);\n\t\t\t\t}\n\t\t\t\tif (bindingResult.hasErrors()) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(message, parameter, bindingResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#accept(result,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 719
    },
    "return": "void",
    "signature": "public void accept(@Nullable Object result, @Nullable Throwable ex)",
    "source_code": "\t\tpublic void accept(@Nullable Object result, @Nullable Throwable ex) {\n\t\t\tif (result != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMethodParameter returnType = this.handlerMethod.getAsyncReturnValueType(result);\n\t\t\t\t\treturnValueHandlers.handleReturnValue(result, returnType, this.message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\thandleFailure(throwable);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ex != null) {\n\t\t\t\thandleFailure(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#createHandlerMethod(handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a HandlerMethod instance from an Object handler that is either a handler\n\t * instance or a String-based bean name.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerMethod = new HandlerMethod(beanName, context.getAutowireCapableBeanFactory(), method);\n\t\t}\n\t\telse {\n\t\t\thandlerMethod = new HandlerMethod(handler, method);\n\t\t}\n\t\treturn handlerMethod;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "InvocableHandlerMethod",
    "signature": "protected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMatchingMapping(mapping,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#getMethodArgumentValues(message,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current message, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 128
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(Message<?> message, @Nullable Object... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(Message<?> message, @Nullable Object... providedArgs) throws Exception {\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new MethodArgumentResolutionException(\n\t\t\t\t\t\tmessage, parameter, formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, message);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 557
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueListenableFutureCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleMessageInternal(message,lookupDestination)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "lookupDestination"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "void",
    "signature": "protected void handleMessageInternal(Message<?> message, String lookupDestination)",
    "source_code": "\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleNoMatch(ts,lookupDestination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "void",
    "signature": "protected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalStateException(\"No handler for return value type: \" + returnType.getParameterType());\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing return value with \" + handler);\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#invoke(message,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given message.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param message the current message being processed\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Object",
    "signature": "public Object invoke(Message<?> message, @Nullable Object... providedArgs)",
    "source_code": "\tpublic Object invoke(Message<?> message, @Nullable Object... providedArgs) throws Exception {\n\t\tObject[] args = getMethodArgumentValues(message, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\t\treturn doInvoke(args);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#isAsyncReturnValue(returnValue,returnType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "boolean",
    "signature": "public boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType)",
    "source_code": "\tpublic boolean isAsyncReturnValue(Object returnValue, MethodParameter returnType) {\n\t\tHandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);\n\t\treturn (handler instanceof AsyncHandlerMethodReturnValueHandler asyncHandler &&\n\t\t\t\tasyncHandler.isAsyncReturnValue(returnValue, returnType));\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#processHandlerMethodException(handlerMethod,exception,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "protected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message)",
    "source_code": "\tprotected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message) {\n\t\tInvocableHandlerMethod invocable = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (invocable == null) {\n\t\t\tlogger.error(\"Unhandled exception from message handler method\", exception);\n\t\t\treturn;\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + invocable.getShortLogMessage());\n\t\t}\n\t\ttry {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tObject returnValue = (cause != null ?\n\t\t\t\t\tinvocable.invoke(message, exception, cause, handlerMethod) :\n\t\t\t\t\tinvocable.invoke(message, exception, handlerMethod));\n\t\t\tMethodParameter returnType = invocable.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t}\n\t\tcatch (Throwable ex2) {\n\t\t\tlogger.error(\"Error while processing handler method exception\", ex2);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#registerExceptionHandlerAdvice(bean,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (for example, to support \"global\" {@code @MessageExceptionHandler}).\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.exceptionHandlerAdviceCache.put(bean, resolver);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupDestinations(mapping)) {\n\t\t\tthis.destinationLookup.add(pattern, mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "int",
    "signature": "public int compare(Match<T> match1, Match<T> match2)",
    "source_code": "\t\tpublic int compare(Match<T> match1, Match<T> match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#extendMapping(mapping,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This method is invoked just before mappings are added. It allows\n\t * subclasses to update the mapping with the {@link HandlerMethod} in mind.\n\t * This can be useful when the method signature is used to refine the\n\t * mapping, for example, based on the cardinality of input and output.\n\t * <p>By default this method returns the mapping that is passed in.\n\t * @param mapping the mapping to be added\n\t * @param handlerMethod the target handler for the mapping\n\t * @return a new mapping or the same\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "T",
    "signature": "protected T extendMapping(T mapping, HandlerMethod handlerMethod)",
    "source_code": "\tprotected T extendMapping(T mapping, HandlerMethod handlerMethod) {\n\t\treturn mapping;\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain the mapping for the given method, if any.\n\t * @param method the method to check\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 369
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#getMatchingMapping(mapping,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, Message<?> message)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleMatch(mapping,handlerMethod,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> handleMatch(T mapping, HandlerMethod handlerMethod, Message<?> message)",
    "source_code": "\tprotected Mono<Void> handleMatch(T mapping, HandlerMethod handlerMethod, Message<?> message) {\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\treturn this.invocableHelper.handleMessage(handlerMethod, message);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#handleNoMatch(destination,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching handler is found.\n\t * @param destination the destination\n\t * @param message the message\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "void",
    "signature": "protected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tlogger.debug(\"No handlers for destination '\" +\n\t\t\t\t(destination != null ? destination.value() : \"\") + \"'\");\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#invoke(message,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method for the given exchange.\n\t * @param message the current message\n\t * @param providedArgs optional list of argument values to match by type\n\t * @return a Mono with the result from the invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> invoke(Message<?> message, Object... providedArgs)",
    "source_code": "\tpublic Mono<Object> invoke(Message<?> message, Object... providedArgs) {\n\t\treturn getMethodArgumentValues(message, providedArgs).flatMap(args -> {\n\t\t\tObject value;\n\t\t\tboolean isSuspendingFunction = false;\n\t\t\ttry {\n\t\t\t\tMethod method = getBridgedMethod();\n\t\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\t\tisSuspendingFunction = true;\n\t\t\t\t\tvalue = CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = method.invoke(getBean(), args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(text, args), ex));\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\treturn Mono.error(ex.getTargetException());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Unlikely to ever get here, but it must be handled...\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(\"Invocation failure\", args), ex));\n\t\t\t}\n\n\t\t\tMethodParameter returnType = getReturnType();\n\t\t\tClass<?> reactiveType = (isSuspendingFunction ? value.getClass() : returnType.getParameterType());\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType);\n\t\t\treturn (adapter != null && isAsyncVoidReturnType(returnType, adapter) ?\n\t\t\t\t\tMono.from(adapter.toPublisher(value)) : Mono.justOrEmpty(value));\n\t\t});\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#registerExceptionHandlerAdvice(bean,resolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (for example, to support \"global\" {@code @MessageExceptionHandler}).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bean",
      "resolver"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "void",
    "signature": "protected void registerExceptionHandlerAdvice(MessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver)",
    "source_code": "\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.invocableHelper.registerExceptionHandlerAdvice(bean, resolver);\n\t}"
  },
  "org.springframework.messaging.handler.invocation.reactive.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping.\n\t * <p><strong>Note:</strong> As of 5.3 this method is public (rather than\n\t * protected) and can be used both at startup and at runtime.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tpublic final void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tmapping = extendMapping(mapping, newHandlerMethod);\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupMappings(mapping)) {\n\t\t\tList<T> values = this.destinationLookup.computeIfAbsent(pattern, p -> new CopyOnWriteArrayList<>());\n\t\t\tvalues.add(mapping);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#createPayload(data,metadata)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a Payload from the given metadata and data.\n\t * <p>If at least one is {@link NettyDataBuffer} then {@link ByteBufPayload}\n\t * is created with either obtaining the underlying native {@link ByteBuf}\n\t * or using {@link Unpooled#wrappedBuffer(ByteBuffer...)} if necessary.\n\t * Otherwise, if both are {@link DefaultDataBuffer}, then\n\t * {@link DefaultPayload} is created.\n\t * @param data the data part for the payload\n\t * @param metadata the metadata part for the payload\n\t * @return the created payload\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "Payload",
    "signature": "public Payload createPayload(DataBuffer data, DataBuffer metadata)",
    "source_code": "\tpublic static Payload createPayload(DataBuffer data, DataBuffer metadata) {\n\t\treturn data instanceof NettyDataBuffer || metadata instanceof NettyDataBuffer ?\n\t\t\t\tByteBufPayload.create(asByteBuf(data), asByteBuf(metadata)) :\n\t\t\t\tDefaultPayload.create(asByteBuffer(data), asByteBuffer(metadata));\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, Class<?> elementClass)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, Class<?> elementClass) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forClass(elementClass));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#data(producer,elementTypeRef)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\t\tpublic RequestSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\t\tReactiveAdapter adapter = getAdapter(producer.getClass());\n\t\t\tAssert.notNull(adapter, () -> \"'producer' type is unknown to ReactiveAdapterRegistry: \" +\n\t\t\t\t\tproducer.getClass().getName());\n\t\t\tcreatePayload(adapter.toPublisher(producer), ResolvableType.forType(elementTypeRef));\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadata(metadata,mimeType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "metadata",
      "mimeType"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec metadata(Object metadata, MimeType mimeType)",
    "source_code": "\t\tpublic RequestSpec metadata(Object metadata, MimeType mimeType) {\n\t\t\tthis.metadataEncoder.metadata(metadata, mimeType);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#metadataAndOrRoute(Map<Object,metadata,route,vars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add route and/or metadata, both optional.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Object",
      "metadata",
      "route",
      "vars"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "MetadataEncoder",
    "signature": "public MetadataEncoder metadataAndOrRoute(@Nullable Map<Object, MimeType> metadata,\n\t\t\t@Nullable String route, @Nullable Object[] vars)",
    "source_code": "\tpublic MetadataEncoder metadataAndOrRoute(@Nullable Map<Object, MimeType> metadata,\n\t\t\t@Nullable String route, @Nullable Object[] vars) {\n\n\t\tif (route != null) {\n\t\t\tthis.route = expand(route, vars != null ? vars : new Object[0]);\n\t\t}\n\t\tif (!CollectionUtils.isEmpty(metadata)) {\n\t\t\tfor (Map.Entry<Object, MimeType> entry : metadata.entrySet()) {\n\t\t\t\tmetadata(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\t\tassertMetadataEntryCount();\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#retainDataAndReleasePayload(payload,bufferFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Use this method to slice, retain and wrap the data portion of the\n\t * {@code Payload}, and also to release the {@code Payload}. This assumes\n\t * the Payload metadata has been read by now and ensures downstream code\n\t * need only be aware of {@code DataBuffer}s.\n\t * @param payload the payload to process\n\t * @param bufferFactory the DataBufferFactory to wrap with\n\t * @return the created {@code DataBuffer} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "bufferFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory)",
    "source_code": "\tpublic static DataBuffer retainDataAndReleasePayload(Payload payload, DataBufferFactory bufferFactory) {\n\t\ttry {\n\t\t\tif (bufferFactory instanceof NettyDataBufferFactory nettyBufferFactory) {\n\t\t\t\tByteBuf byteBuf = payload.sliceData().retain();\n\t\t\t\treturn nettyBufferFactory.wrap(byteBuf);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn bufferFactory.wrap(payload.getData());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (payload.refCnt() > 0) {\n\t\t\t\tpayload.release();\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,routeVars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the route to a remote handler as described in\n\t * {@link RSocketRequester#route(String, Object...)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "routeVars"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "MetadataEncoder",
    "signature": "public MetadataEncoder route(String route, Object... routeVars)",
    "source_code": "\tpublic MetadataEncoder route(String route, Object... routeVars) {\n\t\tthis.route = expand(route, routeVars);\n\t\tassertMetadataEntryCount();\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.rsocket.<unknown>#route(route,vars)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "route",
      "vars"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "RequestSpec",
    "signature": "public RequestSpec route(String route, Object... vars)",
    "source_code": "\tpublic RequestSpec route(String route, Object... vars) {\n\t\treturn new DefaultRequestSpec(route, vars);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#compareTo(other,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "int",
    "signature": "public int compareTo(RSocketFrameTypeMessageCondition other, Message<?> message)",
    "source_code": "\tpublic int compareTo(RSocketFrameTypeMessageCondition other, Message<?> message) {\n\t\treturn other.frameTypes.size() - this.frameTypes.size();\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#extendMapping(composite,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "composite",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "CompositeMessageCondition",
    "signature": "protected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler)",
    "source_code": "\tprotected CompositeMessageCondition extendMapping(CompositeMessageCondition composite, HandlerMethod handler) {\n\n\t\tList<MessageCondition<?>> conditions = composite.getMessageConditions();\n\t\tAssert.isTrue(conditions.size() == 2 &&\n\t\t\t\t\t\tconditions.get(0) instanceof RSocketFrameTypeMessageCondition &&\n\t\t\t\t\t\tconditions.get(1) instanceof DestinationPatternsMessageCondition,\n\t\t\t\t\"Unexpected message condition types\");\n\n\t\tif (conditions.get(0) != RSocketFrameTypeMessageCondition.EMPTY_CONDITION) {\n\t\t\treturn composite;\n\t\t}\n\n\t\tint responseCardinality = getCardinality(handler.getReturnType());\n\t\tint requestCardinality = 0;\n\t\tfor (MethodParameter parameter : handler.getMethodParameters()) {\n\t\t\tif (getArgumentResolvers().getArgumentResolver(parameter) instanceof PayloadMethodArgumentResolver) {\n\t\t\t\trequestCardinality = getCardinality(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn new CompositeMessageCondition(\n\t\t\t\tRSocketFrameTypeMessageCondition.getCondition(requestCardinality, responseCardinality),\n\t\t\t\tconditions.get(1));\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#getCondition(cardinalityIn,cardinalityOut)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a condition for matching the RSocket request interaction type with\n\t * that is selected based on the declared request and response cardinality\n\t * of some handler method.\n\t * <p>The table below shows the selections made:\n\t * <table>\n\t * <tr>\n\t * <th>Request Cardinality</th>\n\t * <th>Response Cardinality</th>\n\t * <th>Interaction Types</th>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>0</td>\n\t * <td>Fire-And-Forget, Request-Response</td>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>1</td>\n\t * <td>Request-Response</td>\n\t * </tr>\n\t * <tr>\n\t * <td>0,1</td>\n\t * <td>2</td>\n\t * <td>Request-Stream</td>\n\t * </tr>\n\t * <tr>\n\t * <td>2</td>\n\t * <td>Any</td>\n\t * <td>Request-Channel</td>\n\t * </tr>\n\t * </table>\n\t * @param cardinalityIn -- the request cardinality: 1 for a single payload,\n\t * 2 for many payloads, and 0 if input is not handled.\n\t * @param cardinalityOut -- the response cardinality: 0 for no output\n\t * payloads, 1 for a single payload, and 2 for many payloads.\n\t * @return a condition to use for matching the interaction type\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cardinalityIn",
      "cardinalityOut"
    ],
    "position": {
      "column": 1,
      "line": 195
    },
    "return": "RSocketFrameTypeMessageCondition",
    "signature": "public RSocketFrameTypeMessageCondition getCondition(int cardinalityIn, int cardinalityOut)",
    "source_code": "\tpublic static RSocketFrameTypeMessageCondition getCondition(int cardinalityIn, int cardinalityOut) {\n\t\treturn switch (cardinalityIn) {\n\t\t\tcase 0, 1 -> switch (cardinalityOut) {\n\t\t\t\tcase 0 -> REQUEST_FNF_OR_RESPONSE_CONDITION;\n\t\t\t\tcase 1 -> REQUEST_RESPONSE_CONDITION;\n\t\t\t\tcase 2 -> REQUEST_STREAM_CONDITION;\n\t\t\t\tdefault -> throw new IllegalStateException(\"Invalid response cardinality: \" + cardinalityOut);\n\t\t\t};\n\t\t\tcase 2 -> REQUEST_CHANNEL_CONDITION;\n\t\t\tdefault -> throw new IllegalStateException(\"Invalid request cardinality: \" + cardinalityIn);\n\t\t};\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#handleNoMatch(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "void",
    "signature": "protected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message)",
    "source_code": "\tprotected void handleNoMatch(@Nullable RouteMatcher.Route destination, Message<?> message) {\n\t\tFrameType frameType = RSocketFrameTypeMessageCondition.getFrameType(message);\n\t\tif (frameType == FrameType.SETUP || frameType == FrameType.METADATA_PUSH) {\n\t\t\tif (frameType == FrameType.SETUP && message.getPayload() instanceof PooledDataBuffer pooledDataBuffer) {\n\t\t\t\tpooledDataBuffer.release();\n\t\t\t}\n\t\t\treturn;  // optional handling\n\t\t}\n\t\tif (frameType == FrameType.REQUEST_FNF) {\n\t\t\t// Can't propagate error to client, so just log\n\t\t\tlogger.warn(\"No handler for fireAndForget to '\" + destination + \"'\");\n\t\t\treturn;\n\t\t}\n\n\t\tSet<FrameType> frameTypes = getHandlerMethods().keySet().stream()\n\t\t\t\t.map(CompositeMessageCondition::getMessageConditions)\n\t\t\t\t.filter(conditions -> conditions.get(1).getMatchingCondition(message) != null)\n\t\t\t\t.map(conditions -> (RSocketFrameTypeMessageCondition) conditions.get(0))\n\t\t\t\t.flatMap(condition -> condition.getFrameTypes().stream())\n\t\t\t\t.collect(Collectors.toSet());\n\n\t\tthrow new MessageDeliveryException(frameTypes.isEmpty() ?\n\t\t\t\t\"No handler for destination '\" + destination + \"'\" :\n\t\t\t\t\"Destination '\" + destination + \"' does not support \" + frameType + \". \" +\n\t\t\t\t\t\t\"Supported interaction(s): \" + frameTypes);\n\t}"
  },
  "org.springframework.messaging.rsocket.annotation.support.<unknown>#responder(strategies,candidateHandlers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create an RSocket {@link SocketAcceptor}\n\t * backed by handlers with annotated methods. Effectively a shortcut for:\n\t * <pre class=\"code\">\n\t * RSocketMessageHandler handler = new RSocketMessageHandler();\n\t * handler.setHandlers(handlers);\n\t * handler.setRSocketStrategies(strategies);\n\t * handler.afterPropertiesSet();\n\t *\n\t * SocketAcceptor acceptor = handler.responder();\n\t * </pre>\n\t * <p>This is intended for programmatic creation and registration of a\n\t * client-side responder. For example:\n\t * <pre class=\"code\">\n\t * SocketAcceptor responder =\n\t *         RSocketMessageHandler.responder(strategies, new ClientHandler());\n\t *\n\t * RSocketRequester.builder()\n\t *         .rsocketConnector(connector -&gt; connector.acceptor(responder))\n\t *         .connectTcp(\"localhost\", server.address().getPort());\n\t * </pre>\n\t *\n\t * <p>Note that the given handlers do not need to have any stereotype\n\t * annotations such as {@code @Controller} which helps to avoid overlap with\n\t * server side handlers that may be used in the same application. However,\n\t * for more advanced scenarios, for example, discovering handlers through a custom\n\t * stereotype annotation, consider declaring {@code RSocketMessageHandler}\n\t * as a bean, and then obtain the responder from it.\n\t * @param strategies the strategies to set on the created\n\t * {@code RSocketMessageHandler}\n\t * @param candidateHandlers a list of Objects and/or Classes with annotated\n\t * handler methods; used to call {@link #setHandlers(List)} with\n\t * on the created {@code RSocketMessageHandler}\n\t * @return a configurer that may be passed into\n\t * {@link org.springframework.messaging.rsocket.RSocketRequester.Builder#rsocketConnector}\n\t * @since 5.2.6\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategies",
      "candidateHandlers"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "SocketAcceptor",
    "signature": "public SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers)",
    "source_code": "\tpublic static SocketAcceptor responder(RSocketStrategies strategies, Object... candidateHandlers) {\n\t\tAssert.notEmpty(candidateHandlers, \"No handlers\");\n\t\tList<Object> handlers = new ArrayList<>(candidateHandlers.length);\n\t\tfor (Object obj : candidateHandlers) {\n\t\t\thandlers.add(obj instanceof Class<?> clazz ? BeanUtils.instantiateClass(clazz) : obj);\n\t\t}\n\t\tRSocketMessageHandler handler = new RSocketMessageHandler();\n\t\thandler.setHandlers(handlers);\n\t\thandler.setRSocketStrategies(strategies);\n\t\thandler.afterPropertiesSet();\n\t\treturn handler.responder();\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\t// Also register non-annotated parameters to handle metadata\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints,\n\t\t\t\t\tMethodParameter.forParameter(parameter).getGenericParameterType());\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tthis.registerMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.messaging.rsocket.service.<unknown>#resolve(argument,parameter,requestValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, RSocketRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, RSocketRequestValues.Builder requestValues) {\n\n\t\tDestinationVariable annot = parameter.getParameterAnnotation(DestinationVariable.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument != null) {\n\t\t\tif (argument instanceof Collection<?> collection) {\n\t\t\t\tcollection.forEach(requestValues::addRouteVariable);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (argument.getClass().isArray()) {\n\t\t\t\tfor (Object variable : (Object[]) argument) {\n\t\t\t\t\trequestValues.addRouteVariable(variable);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trequestValues.addRouteVariable(argument);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#compareTo(other,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "int",
    "signature": "public int compareTo(SimpMessageMappingInfo other, Message<?> message)",
    "source_code": "\tpublic int compareTo(SimpMessageMappingInfo other, Message<?> message) {\n\t\treturn this.delegate.compareTo(other.delegate, message);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload) throws MessagingException {\n\t\tconvertAndSendToUser(user, destination, payload, (MessagePostProcessor) null);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,Map<String,headers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers) throws MessagingException {\n\n\t\tconvertAndSendToUser(user, destination, payload, headers, null);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,Map<String,headers,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "Map<String",
      "headers",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable Map<String, Object> headers, @Nullable MessagePostProcessor postProcessor)\n\t\t\tthrows MessagingException {\n\n\t\tAssert.notNull(user, \"User must not be null\");\n\t\tString username = user;\n\t\tAssert.isTrue(!user.contains(\"%2F\"), () -> \"Invalid sequence \\\"%2F\\\" in user name: \" + username);\n\t\tuser = StringUtils.replace(user, \"/\", \"%2F\");\n\t\tdestination = destination.startsWith(\"/\") ? destination : \"/\" + destination;\n\t\tsuper.convertAndSend(this.destinationPrefix + user + destination, payload, headers, postProcessor);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#convertAndSendToUser(user,destination,payload,postProcessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "user",
      "destination",
      "payload",
      "postProcessor"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable MessagePostProcessor postProcessor)",
    "source_code": "\tpublic void convertAndSendToUser(String user, String destination, Object payload,\n\t\t\t@Nullable MessagePostProcessor postProcessor) throws MessagingException {\n\n\t\tconvertAndSendToUser(user, destination, payload, null, postProcessor);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#doSend(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "void",
    "signature": "protected void doSend(String destination, Message<?> message)",
    "source_code": "\tprotected void doSend(String destination, Message<?> message) {\n\t\tAssert.notNull(destination, \"Destination must not be null\");\n\n\t\tSimpMessageHeaderAccessor simpAccessor =\n\t\t\t\tMessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class);\n\n\t\tif (simpAccessor != null) {\n\t\t\tif (simpAccessor.isMutable()) {\n\t\t\t\tsimpAccessor.setDestination(destination);\n\t\t\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\t\t\t// ImmutableMessageChannelInterceptor will make it immutable\n\t\t\t\tsendInternal(message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try and keep the original accessor type\n\t\t\t\tsimpAccessor = (SimpMessageHeaderAccessor) MessageHeaderAccessor.getMutableAccessor(message);\n\t\t\t\tinitHeaders(simpAccessor);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsimpAccessor = SimpMessageHeaderAccessor.wrap(message);\n\t\t\tinitHeaders(simpAccessor);\n\t\t}\n\n\t\tsimpAccessor.setDestination(destination);\n\t\tsimpAccessor.setMessageTypeIfNotSet(SimpMessageType.MESSAGE);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), simpAccessor.getMessageHeaders());\n\t\tsendInternal(message);\n\t}"
  },
  "org.springframework.messaging.simp.<unknown>#processHeadersToSend(Map<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Creates a new map and puts the given headers under the key\n\t * {@link NativeMessageHeaderAccessor#NATIVE_HEADERS NATIVE_HEADERS}.\n\t * <p>Effectively treats the input header map as headers to be sent out to the\n\t * destination.\n\t * <p>However if the given headers already contain the key {@code NATIVE_HEADERS}\n\t * then the same headers instance is returned without changes.\n\t * <p>Also if the given headers were prepared and obtained with\n\t * {@link SimpMessageHeaderAccessor#getMessageHeaders()} then the same headers\n\t * instance is also returned without changes.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "Object>",
    "signature": "protected Object> processHeadersToSend(@Nullable Map<String, Object> headers)",
    "source_code": "\tprotected Map<String, Object> processHeadersToSend(@Nullable Map<String, Object> headers) {\n\t\tif (headers == null) {\n\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\tinitHeaders(headerAccessor);\n\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\treturn headerAccessor.getMessageHeaders();\n\t\t}\n\t\tif (headers.containsKey(NativeMessageHeaderAccessor.NATIVE_HEADERS)) {\n\t\t\treturn headers;\n\t\t}\n\t\tif (headers instanceof MessageHeaders messageHeaders) {\n\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(messageHeaders, SimpMessageHeaderAccessor.class);\n\t\t\tif (accessor != null) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t}\n\n\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\tinitHeaders(headerAccessor);\n\t\theaders.forEach((key, value) -> headerAccessor.setNativeHeader(key, (value != null ? value.toString() : null)));\n\t\treturn headerAccessor.getMessageHeaders();\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "SimpMessageMappingInfo",
    "signature": "protected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected SimpMessageMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tMessageMapping messageAnn = AnnotatedElementUtils.findMergedAnnotation(method, MessageMapping.class);\n\t\tif (messageAnn != null) {\n\t\t\tMessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class);\n\t\t\t// Only actually register it if there are destinations specified;\n\t\t\t// otherwise @MessageMapping is just being used as a (meta-annotation) marker.\n\t\t\tif (messageAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {\n\t\t\t\tSimpMessageMappingInfo result = createMessageMappingCondition(messageAnn.value());\n\t\t\t\tif (typeAnn != null) {\n\t\t\t\t\tresult = createMessageMappingCondition(typeAnn.value()).combine(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tSubscribeMapping subscribeAnn = AnnotatedElementUtils.findMergedAnnotation(method, SubscribeMapping.class);\n\t\tif (subscribeAnn != null) {\n\t\t\tMessageMapping typeAnn = AnnotatedElementUtils.findMergedAnnotation(handlerType, MessageMapping.class);\n\t\t\t// Only actually register it if there are destinations specified;\n\t\t\t// otherwise @SubscribeMapping is just being used as a (meta-annotation) marker.\n\t\t\tif (subscribeAnn.value().length > 0 || (typeAnn != null && typeAnn.value().length > 0)) {\n\t\t\t\tSimpMessageMappingInfo result = createSubscribeMappingCondition(subscribeAnn.value());\n\t\t\t\tif (typeAnn != null) {\n\t\t\t\t\tresult = createMessageMappingCondition(typeAnn.value()).combine(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getMatchingMapping(mapping,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "SimpMessageMappingInfo",
    "signature": "protected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message)",
    "source_code": "\tprotected SimpMessageMappingInfo getMatchingMapping(SimpMessageMappingInfo mapping, Message<?> message) {\n\t\treturn mapping.getMatchingCondition(message);\n\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getTargetDestinations(annotation,message,defaultPrefix)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotation",
      "message",
      "defaultPrefix"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "String[]",
    "signature": "protected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix)",
    "source_code": "\tprotected String[] getTargetDestinations(@Nullable Annotation annotation, Message<?> message, String defaultPrefix) {\n\t\tif (annotation != null) {\n\t\t\tString[] value = (String[]) AnnotationUtils.getValue(annotation);\n\t\t\tif (!ObjectUtils.isEmpty(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tString name = DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER;\n\t\tString destination = (String) message.getHeaders().get(name);\n\t\tif (!StringUtils.hasText(destination)) {\n\t\t\tthrow new IllegalStateException(\"No lookup destination header in \" + message);\n\t\t}\n\n\t\treturn (destination.startsWith(\"/\") ?\n\t\t\t\tnew String[] {defaultPrefix + destination} : new String[] {defaultPrefix + '/' + destination});\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#getUserName(message,headers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "message",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "String",
    "signature": "protected String getUserName(Message<?> message, MessageHeaders headers)",
    "source_code": "\tprotected String getUserName(Message<?> message, MessageHeaders headers) {\n\t\tPrincipal principal = SimpMessageHeaderAccessor.getUser(headers);\n\t\tif (principal != null) {\n\t\t\treturn (principal instanceof DestinationUserNameProvider provider ?\n\t\t\t\t\tprovider.getDestinationUserName() : principal.getName());\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#handleMatch(mapping,handlerMethod,lookupDestination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "lookupDestination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "void",
    "signature": "protected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod,\n\t\t\tString lookupDestination, Message<?> message)",
    "source_code": "\tprotected void handleMatch(SimpMessageMappingInfo mapping, HandlerMethod handlerMethod,\n\t\t\tString lookupDestination, Message<?> message) {\n\n\t\tSet<String> patterns = mapping.getDestinationConditions().getPatterns();\n\t\tif (!CollectionUtils.isEmpty(patterns)) {\n\t\t\tString pattern = patterns.iterator().next();\n\t\t\tMap<String, String> vars = getPathMatcher().extractUriTemplateVariables(pattern, lookupDestination);\n\t\t\tif (!CollectionUtils.isEmpty(vars)) {\n\t\t\t\tMessageHeaderAccessor mha = MessageHeaderAccessor.getAccessor(message, MessageHeaderAccessor.class);\n\t\t\t\tAssert.state(mha != null && mha.isMutable(), \"Mutable MessageHeaderAccessor required\");\n\t\t\t\tmha.setHeader(DestinationVariableMethodArgumentResolver.DESTINATION_TEMPLATE_VARIABLES_HEADER, vars);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\tsuper.handleMatch(mapping, handlerMethod, lookupDestination, message);\n\t\t}\n\t\tfinally {\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.annotation.support.<unknown>#handleReturnValue(returnValue,returnType,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, Message<?> message)\n\t\t\tthrows Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString sessionId = SimpMessageHeaderAccessor.getSessionId(headers);\n\t\tDestinationHelper destinationHelper = getDestinationHelper(headers, returnType);\n\n\t\tSendToUser sendToUser = destinationHelper.getSendToUser();\n\t\tif (sendToUser != null) {\n\t\t\tboolean broadcast = sendToUser.broadcast();\n\t\t\tString user = getUserName(message, headers);\n\t\t\tif (user == null) {\n\t\t\t\tif (sessionId == null) {\n\t\t\t\t\tthrow new MissingSessionUserException(message);\n\t\t\t\t}\n\t\t\t\tuser = sessionId;\n\t\t\t\tbroadcast = false;\n\t\t\t}\n\t\t\tString[] destinations = getTargetDestinations(sendToUser, message, this.defaultUserDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tif (broadcast) {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(null, returnType));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.messagingTemplate.convertAndSendToUser(\n\t\t\t\t\t\t\tuser, destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSendTo sendTo = destinationHelper.getSendTo();\n\t\tif (sendTo != null || sendToUser == null) {\n\t\t\tString[] destinations = getTargetDestinations(sendTo, message, this.defaultDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tdestination = destinationHelper.expandTemplateVars(destination);\n\t\t\t\tthis.messagingTemplate.convertAndSend(destination, returnValue, createHeaders(sessionId, returnType));\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscription(sessionId,subscription)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void addSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void addSubscription(String sessionId, Subscription subscription) {\n\t\t\tSessionInfo info = this.sessions.computeIfAbsent(sessionId, _sessionId -> new SessionInfo());\n\t\t\tinfo.addSubscription(subscription);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#addSubscriptionInternal(sessionId,subscriptionId,destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId",
      "subscriptionId",
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 157
    },
    "return": "void",
    "signature": "protected void addSubscriptionInternal(String sessionId, String subscriptionId, String destination, Message<?> message)",
    "source_code": "\tprotected void addSubscriptionInternal(\n\t\t\tString sessionId, String subscriptionId, String destination, Message<?> message) {\n\n\t\tboolean isPattern = this.pathMatcher.isPattern(destination);\n\t\tExpression expression = getSelectorExpression(message.getHeaders());\n\t\tSubscription subscription = new Subscription(subscriptionId, destination, isPattern, expression);\n\n\t\tthis.sessionRegistry.addSubscription(sessionId, subscription);\n\t\tthis.destinationCache.updateAfterNewSubscription(sessionId, subscription);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#afterMessageHandled(message,ch,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "ch",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void afterMessageHandled(Message<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterMessageHandled(\n\t\t\t\tMessage<?> message, MessageChannel ch, MessageHandler handler, @Nullable Exception ex) {\n\n\t\t\tRunnable task = getNextMessageTask(message);\n\t\t\tif (task != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#afterSendCompletion(message,channel,sent,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 374
    },
    "return": "void",
    "signature": "public void afterSendCompletion(Message<?> message, MessageChannel channel, boolean sent, @Nullable Exception ex)",
    "source_code": "\t\tpublic void afterSendCompletion(\n\t\t\t\tMessage<?> message, MessageChannel channel, boolean sent, @Nullable Exception ex) {\n\n\t\t\tif (!sent) {\n\t\t\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());\n\t\t\t\tif (SimpMessageType.DISCONNECT.equals(messageType)) {\n\t\t\t\t\tlogger.debug(\"Detected unsent DISCONNECT message. Processing anyway.\");\n\t\t\t\t\thandleMessage(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#canRead(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 511
    },
    "return": "boolean",
    "signature": "public boolean canRead(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn true;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#canWrite(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "boolean",
    "signature": "public boolean canWrite(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#configureInterceptor(channel,preserveOrder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Install or remove an {@link ExecutorChannelInterceptor} that invokes a\n\t * completion task, if found in the headers of the message.\n\t * @param channel the channel to configure\n\t * @param preserveOrder whether preserve the order or publication; when\n\t * \"true\" an interceptor is inserted, when \"false\" it removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "preserveOrder"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "void",
    "signature": "public void configureInterceptor(MessageChannel channel, boolean preserveOrder)",
    "source_code": "\tpublic static void configureInterceptor(MessageChannel channel, boolean preserveOrder) {\n\t\tif (preserveOrder) {\n\t\t\tAssert.isInstanceOf(ExecutorSubscribableChannel.class, channel,\n\t\t\t\t\t\"An ExecutorSubscribableChannel is required for 'preservePublishOrder'\");\n\t\t\tExecutorSubscribableChannel execChannel = (ExecutorSubscribableChannel) channel;\n\t\t\tif (execChannel.getInterceptors().stream().noneMatch(CallbackTaskInterceptor.class::isInstance)) {\n\t\t\t\texecChannel.addInterceptor(0, new CallbackTaskInterceptor());\n\t\t\t}\n\t\t}\n\t\telse if (channel instanceof ExecutorSubscribableChannel execChannel) {\n\t\t\texecChannel.getInterceptors().stream().filter(CallbackTaskInterceptor.class::isInstance)\n\t\t\t\t\t.findFirst().map(execChannel::removeInterceptor);\n\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#find(serverState,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serverState",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 169
    },
    "return": "String>",
    "signature": "public String> find(ServerState serverState, FindRequest request)",
    "source_code": "\tpublic MultiValueMap<String, String> find(ServerState serverState, FindRequest request) {\n\t\treturn serverState.registry.findSubscriptionsInternal(request.destination, serverState.findMessage);\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#findSubscriptionsInternal(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "String>",
    "signature": "protected String> findSubscriptionsInternal(String destination, Message<?> message)",
    "source_code": "\tprotected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n\t\tMultiValueMap<String, String> allMatches = this.destinationCache.getSubscriptions(destination);\n\t\tif (!this.selectorHeaderInUse) {\n\t\t\treturn allMatches;\n\t\t}\n\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n\t\tallMatches.forEach((sessionId, subscriptionIds) -> {\n\t\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\t\tif (info != null) {\n\t\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\t\tSubscription subscription = info.getSubscription(subscriptionId);\n\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelector(), message)) {\n\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#forEachSubscription(BiConsumer<String,consumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiConsumer<String",
      "consumer"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "void",
    "signature": "public void forEachSubscription(BiConsumer<String, Subscription> consumer)",
    "source_code": "\t\tpublic void forEachSubscription(BiConsumer<String, Subscription> consumer) {\n\t\t\tthis.sessions.forEach((sessionId, info) ->\n\t\t\t\tinfo.getSubscriptions().forEach(subscription -> consumer.accept(sessionId, subscription)));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#read(context,target,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "TypedValue",
    "signature": "public TypedValue read(EvaluationContext context, @Nullable Object target, String name)",
    "source_code": "\t\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) {\n\t\t\tObject value;\n\t\t\tif (target instanceof Message message) {\n\t\t\t\tvalue = name.equals(\"headers\") ? message.getHeaders() : null;\n\t\t\t}\n\t\t\telse if (target instanceof MessageHeaders headers) {\n\t\t\t\tSimpMessageHeaderAccessor accessor =\n\t\t\t\t\t\tMessageHeaderAccessor.getAccessor(headers, SimpMessageHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No SimpMessageHeaderAccessor\");\n\t\t\t\tif (\"destination\".equalsIgnoreCase(name)) {\n\t\t\t\t\tvalue = accessor.getDestination();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = accessor.getFirstNativeHeader(name);\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tvalue = headers.get(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Should never happen...\n\t\t\t\tthrow new IllegalStateException(\"Expected Message or MessageHeaders.\");\n\t\t\t}\n\t\t\treturn new TypedValue(value);\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#registerSubscriptions(sessionId,destination)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "destination"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void registerSubscriptions(String sessionId, String destination)",
    "source_code": "\t\tpublic void registerSubscriptions(String sessionId, String destination) {\n\t\t\tif (\"patternSubscriptions\".equals(this.specialization)) {\n\t\t\t\tdestination = \"/**/\" + destination;\n\t\t\t}\n\t\t\tString subscriptionId = \"subscription_\" + this.uniqueIdGenerator.incrementAndGet();\n\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, subscriptionId, destination));\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#registerUnregister(serverState,request,blackhole)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "serverState",
      "request",
      "blackhole"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole)",
    "source_code": "\tpublic void registerUnregister(ServerState serverState, Requests request, Blackhole blackhole) {\n\t\tserverState.registry.registerSubscription(request.subscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n\t\tblackhole.consume(serverState.registry.findSubscriptionsInternal(request.findDestination, serverState.findMessage));\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#removeSubscriptionInternal(sessionId,subscriptionId,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sessionId",
      "subscriptionId",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "protected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message)",
    "source_code": "\tprotected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message) {\n\t\tSessionInfo info = this.sessionRegistry.getSession(sessionId);\n\t\tif (info != null) {\n\t\t\tSubscription subscription = info.removeSubscription(subscriptionId);\n\t\t\tif (subscription != null) {\n\t\t\t\tthis.destinationCache.updateAfterRemovedSubscription(sessionId, subscription);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#send(message,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean send(Message<?> message, long timeout) {\n\t\tthis.messages.add(message);\n\t\ttrySend();\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#sendMessageToSubscribers(destination,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "void",
    "signature": "protected void sendMessageToSubscribers(@Nullable String destination, Message<?> message)",
    "source_code": "\tprotected void sendMessageToSubscribers(@Nullable String destination, Message<?> message) {\n\t\tMultiValueMap<String,String> subscriptions = this.subscriptionRegistry.findSubscriptions(message);\n\t\tif (!subscriptions.isEmpty() && logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Broadcasting to \" + subscriptions.size() + \" sessions.\");\n\t\t}\n\t\tlong now = System.currentTimeMillis();\n\t\tsubscriptions.forEach((sessionId, subscriptionIds) -> {\n\t\t\tfor (String subscriptionId : subscriptionIds) {\n\t\t\t\tSimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);\n\t\t\t\tinitHeaders(headerAccessor);\n\t\t\t\theaderAccessor.setSessionId(sessionId);\n\t\t\t\theaderAccessor.setSubscriptionId(subscriptionId);\n\t\t\t\theaderAccessor.copyHeadersIfAbsent(message.getHeaders());\n\t\t\t\theaderAccessor.setLeaveMutable(true);\n\t\t\t\tObject payload = message.getPayload();\n\t\t\t\tMessage<?> reply = MessageBuilder.createMessage(payload, headerAccessor.getMessageHeaders());\n\t\t\t\tSessionInfo info = this.sessions.get(sessionId);\n\t\t\t\tif (info != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinfo.getClientOutboundChannel().send(reply);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\t\tlogger.error(\"Failed to send \" + message, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tinfo.setLastWriteTime(now);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterNewSubscription(sessionId,subscription)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "public void updateAfterNewSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterNewSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tfor (String cachedDestination : this.destinationCache.keySet()) {\n\t\t\t\t\tif (pathMatcher.match(subscription.getDestination(), cachedDestination)) {\n\t\t\t\t\t\taddToDestination(cachedDestination, sessionId, subscription.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddToDestination(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSession(sessionId,info)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "info"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSession(String sessionId, SessionInfo info)",
    "source_code": "\t\tpublic void updateAfterRemovedSession(String sessionId, SessionInfo info) {\n\t\t\tfor (Subscription subscription : info.getSubscriptions()) {\n\t\t\t\tupdateAfterRemovedSubscription(sessionId, subscription);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#updateAfterRemovedSubscription(sessionId,subscription)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "subscription"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "void",
    "signature": "public void updateAfterRemovedSubscription(String sessionId, Subscription subscription)",
    "source_code": "\t\tpublic void updateAfterRemovedSubscription(String sessionId, Subscription subscription) {\n\t\t\tif (subscription.isPattern()) {\n\t\t\t\tString subscriptionId = subscription.getId();\n\t\t\t\tthis.destinationCache.forEach((destination, sessionIdToSubscriptionIds) -> {\n\t\t\t\t\tList<String> subscriptionIds = sessionIdToSubscriptionIds.get(sessionId);\n\t\t\t\t\tif (subscriptionIds != null && subscriptionIds.contains(subscriptionId)) {\n\t\t\t\t\t\tremoveInternal(destination, sessionId, subscriptionId);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremoveInternal(subscription.getDestination(), sessionId, subscription.getId());\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.broker.<unknown>#write(context,target,name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "target",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 549
    },
    "return": "void",
    "signature": "public void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value)",
    "source_code": "\t\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object value) {\n\t\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#brokerChannel(clientInboundChannel,clientOutboundChannel,@Qualifier(\"brokerChannelExecutor\")": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "@Qualifier(\"brokerChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "AbstractSubscribableChannel",
    "signature": "public AbstractSubscribableChannel brokerChannel(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\t@Qualifier(\"brokerChannelExecutor\")",
    "source_code": "\tpublic AbstractSubscribableChannel brokerChannel(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\t@Qualifier(\"brokerChannelExecutor\") Executor executor) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tChannelRegistration registration = registry.getBrokerChannelRegistration();\n\t\tExecutorSubscribableChannel channel = (registration.hasExecutor() ?\n\t\t\t\tnew ExecutorSubscribableChannel(executor) : new ExecutorSubscribableChannel());\n\t\tregistration.interceptors(new ImmutableMessageChannelInterceptor());\n\t\tchannel.setLogger(SimpLogging.forLog(channel.getLogger()));\n\t\tchannel.setInterceptors(registration.getInterceptors());\n\t\treturn channel;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#brokerChannelExecutor(clientInboundChannel,clientOutboundChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 265
    },
    "return": "Executor",
    "signature": "public Executor brokerChannelExecutor(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic Executor brokerChannelExecutor(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tChannelRegistration registration = registry.getBrokerChannelRegistration();\n\t\tExecutor executor = getExecutor(registration, \"brokerChannel-\", () -> {\n\t\t\t// Should never be used\n\t\t\tThreadPoolTaskExecutor fallbackExecutor = new ThreadPoolTaskExecutor();\n\t\t\tfallbackExecutor.setCorePoolSize(0);\n\t\t\tfallbackExecutor.setMaxPoolSize(1);\n\t\t\tfallbackExecutor.setQueueCapacity(0);\n\t\t\treturn fallbackExecutor;\n\t\t});\n\t\tif (executor instanceof ExecutorConfigurationSupport executorSupport) {\n\t\t\texecutorSupport.setPhase(getPhase());\n\t\t}\n\t\treturn executor;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#brokerMessagingTemplate(brokerChannel,clientInboundChannel,clientOutboundChannel,brokerMessageConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "brokerChannel",
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessageConverter"
    ],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "SimpMessagingTemplate",
    "signature": "public SimpMessagingTemplate brokerMessagingTemplate(AbstractSubscribableChannel brokerChannel, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel, CompositeMessageConverter brokerMessageConverter)",
    "source_code": "\tpublic SimpMessagingTemplate brokerMessagingTemplate(\n\t\t\tAbstractSubscribableChannel brokerChannel, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel, CompositeMessageConverter brokerMessageConverter) {\n\n\t\tSimpMessagingTemplate template = new SimpMessagingTemplate(brokerChannel);\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tString prefix = registry.getUserDestinationPrefix();\n\t\tif (prefix != null) {\n\t\t\ttemplate.setUserDestinationPrefix(prefix);\n\t\t}\n\t\ttemplate.setMessageConverter(brokerMessageConverter);\n\t\treturn template;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#createAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Protected method for plugging in a custom subclass of\n\t * {@link org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler\n\t * SimpAnnotationMethodMessageHandler}.\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "protected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate)",
    "source_code": "\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate) {\n\n\t\tSimpAnnotationMethodMessageHandler handler = new SimpAnnotationMethodMessageHandler(\n\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#getBrokerRegistry(clientInboundChannel,clientOutboundChannel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An accessor for the {@link MessageBrokerRegistry} that ensures its one-time creation\n\t * and initialization through {@link #configureMessageBroker(MessageBrokerRegistry)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "MessageBrokerRegistry",
    "signature": "protected MessageBrokerRegistry getBrokerRegistry(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tprotected final MessageBrokerRegistry getBrokerRegistry(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tif (this.brokerRegistry == null) {\n\t\t\tMessageBrokerRegistry registry = new MessageBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\t\tconfigureMessageBroker(registry);\n\t\t\tthis.brokerRegistry = registry;\n\t\t}\n\t\treturn this.brokerRegistry;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#getPathMatcher(clientInboundChannel,clientOutboundChannel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide access to the configured PatchMatcher for access from other\n\t * configuration classes.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "PathMatcher",
    "signature": "public PathMatcher getPathMatcher(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic final PathMatcher getPathMatcher(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\treturn getBrokerRegistry(clientInboundChannel, clientOutboundChannel).getPathMatcher();\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#simpAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate,brokerMessageConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate",
      "brokerMessageConverter"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "public SimpAnnotationMethodMessageHandler simpAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate, CompositeMessageConverter brokerMessageConverter)",
    "source_code": "\tpublic SimpAnnotationMethodMessageHandler simpAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate, CompositeMessageConverter brokerMessageConverter) {\n\n\t\tSimpAnnotationMethodMessageHandler handler = createAnnotationMethodMessageHandler(\n\t\t\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\n\t\tMessageBrokerRegistry brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\thandler.setDestinationPrefixes(brokerRegistry.getApplicationDestinationPrefixes());\n\t\thandler.setMessageConverter(brokerMessageConverter);\n\t\thandler.setValidator(simpValidator());\n\t\thandler.setPhase(getPhase());\n\n\t\tList<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<>();\n\t\taddArgumentResolvers(argumentResolvers);\n\t\thandler.setCustomArgumentResolvers(argumentResolvers);\n\n\t\tList<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>();\n\t\taddReturnValueHandlers(returnValueHandlers);\n\t\thandler.setCustomReturnValueHandlers(returnValueHandlers);\n\n\t\tPathMatcher pathMatcher = brokerRegistry.getPathMatcher();\n\t\tif (pathMatcher != null) {\n\t\t\thandler.setPathMatcher(pathMatcher);\n\t\t}\n\n\t\treturn handler;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#simpleBrokerMessageHandler(clientInboundChannel,clientOutboundChannel,brokerChannel,userDestinationResolver)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerChannel",
      "userDestinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "AbstractBrokerMessageHandler",
    "signature": "public AbstractBrokerMessageHandler simpleBrokerMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver)",
    "source_code": "\tpublic AbstractBrokerMessageHandler simpleBrokerMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tSimpleBrokerMessageHandler handler = registry.getSimpleBroker(brokerChannel);\n\t\tif (handler == null) {\n\t\t\treturn null;\n\t\t}\n\t\tupdateUserDestinationResolver(handler, userDestinationResolver, registry.getUserDestinationPrefix());\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#stompBrokerRelayMessageHandler(clientInboundChannel,clientOutboundChannel,brokerChannel,userDestinationMessageHandler,userRegistryMessageHandler,userDestinationResolver)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerChannel",
      "userDestinationMessageHandler",
      "userRegistryMessageHandler",
      "userDestinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 418
    },
    "return": "AbstractBrokerMessageHandler",
    "signature": "public AbstractBrokerMessageHandler stompBrokerRelayMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationMessageHandler userDestinationMessageHandler,\n\t\t\t@Nullable MessageHandler userRegistryMessageHandler, UserDestinationResolver userDestinationResolver)",
    "source_code": "\tpublic AbstractBrokerMessageHandler stompBrokerRelayMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationMessageHandler userDestinationMessageHandler,\n\t\t\t@Nullable MessageHandler userRegistryMessageHandler, UserDestinationResolver userDestinationResolver) {\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tStompBrokerRelayMessageHandler handler = registry.getStompBrokerRelay(brokerChannel);\n\t\tif (handler == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, MessageHandler> subscriptions = new HashMap<>(4);\n\t\tString destination = registry.getUserDestinationBroadcast();\n\t\tif (destination != null) {\n\t\t\tsubscriptions.put(destination, userDestinationMessageHandler);\n\t\t}\n\t\tdestination = registry.getUserRegistryBroadcast();\n\t\tif (destination != null) {\n\t\t\tsubscriptions.put(destination, userRegistryMessageHandler);\n\t\t}\n\t\thandler.setSystemSubscriptions(subscriptions);\n\t\tupdateUserDestinationResolver(handler, userDestinationResolver, registry.getUserDestinationPrefix());\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#userDestinationMessageHandler(clientInboundChannel,clientOutboundChannel,brokerChannel,userDestinationResolver)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerChannel",
      "userDestinationResolver"
    ],
    "position": {
      "column": 1,
      "line": 444
    },
    "return": "UserDestinationMessageHandler",
    "signature": "public UserDestinationMessageHandler userDestinationMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver)",
    "source_code": "\tpublic UserDestinationMessageHandler userDestinationMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tAbstractSubscribableChannel brokerChannel, UserDestinationResolver userDestinationResolver) {\n\n\t\tUserDestinationMessageHandler handler =\n\t\t\t\tnew UserDestinationMessageHandler(clientInboundChannel, brokerChannel, userDestinationResolver);\n\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tString destination = registry.getUserDestinationBroadcast();\n\t\tif (destination != null) {\n\t\t\thandler.setBroadcastDestination(destination);\n\t\t}\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#userDestinationResolver(userRegistry,clientInboundChannel,clientOutboundChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "userRegistry",
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 545
    },
    "return": "UserDestinationResolver",
    "signature": "public UserDestinationResolver userDestinationResolver(SimpUserRegistry userRegistry, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic UserDestinationResolver userDestinationResolver(\n\t\t\tSimpUserRegistry userRegistry, AbstractSubscribableChannel clientInboundChannel,\n\t\t\tAbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tDefaultUserDestinationResolver resolver = new DefaultUserDestinationResolver(userRegistry);\n\t\tMessageBrokerRegistry registry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tString prefix = registry.getUserDestinationPrefix();\n\t\tif (prefix != null) {\n\t\t\tresolver.setUserDestinationPrefix(prefix);\n\t\t}\n\t\treturn resolver;\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#userRegistry(clientInboundChannel,clientOutboundChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 559
    },
    "return": "SimpUserRegistry",
    "signature": "public SimpUserRegistry userRegistry(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic SimpUserRegistry userRegistry(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tMessageBrokerRegistry brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tSimpUserRegistry userRegistry = createLocalUserRegistry(brokerRegistry.getUserRegistryOrder());\n\t\tboolean broadcast = brokerRegistry.getUserRegistryBroadcast() != null;\n\t\treturn (broadcast ? new MultiServerUserRegistry(userRegistry) : userRegistry);\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#userRegistryMessageHandler(clientInboundChannel,clientOutboundChannel,userRegistry,brokerMessagingTemplate,@Qualifier(\"messageBrokerTaskScheduler\")": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "userRegistry",
      "brokerMessagingTemplate",
      "@Qualifier(\"messageBrokerTaskScheduler\""
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "MessageHandler",
    "signature": "public MessageHandler userRegistryMessageHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpUserRegistry userRegistry, SimpMessagingTemplate brokerMessagingTemplate,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\")",
    "source_code": "\tpublic MessageHandler userRegistryMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpUserRegistry userRegistry, SimpMessagingTemplate brokerMessagingTemplate,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\") TaskScheduler scheduler) {\n\n\t\tMessageBrokerRegistry brokerRegistry = getBrokerRegistry(clientInboundChannel, clientOutboundChannel);\n\t\tif (brokerRegistry.getUserRegistryBroadcast() == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.isInstanceOf(MultiServerUserRegistry.class, userRegistry, \"MultiServerUserRegistry required\");\n\t\treturn new UserRegistryMessageHandler((MultiServerUserRegistry) userRegistry,\n\t\t\t\tbrokerMessagingTemplate, brokerRegistry.getUserRegistryBroadcast(),\n\t\t\t\tscheduler);\n\t}"
  },
  "org.springframework.messaging.simp.config.<unknown>#validate(target,errors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 609
    },
    "return": "void",
    "signature": "public void validate(@Nullable Object target, Errors errors)",
    "source_code": "\t\t\t\t\tpublic void validate(@Nullable Object target, Errors errors) {\n\t\t\t\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#add(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 451
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\theaderValues.add(headerValue);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#addAll(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<String, String> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<String, String> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#addAll(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "void",
    "signature": "public void addAll(String headerName, List<? extends String> headerValues)",
    "source_code": "\tpublic void addAll(String headerName, List<? extends String> headerValues) {\n\t\tList<String> currentValues = this.headers.computeIfAbsent(headerName, k -> new ArrayList<>(1));\n\t\tcurrentValues.addAll(headerValues);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#encode(Map<String,headers,payload)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Encodes the given payload and headers into a {@code byte[]}.\n\t * @param headers the STOMP message headers\n\t * @param payload the STOMP message payload\n\t * @return the encoded message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers",
      "payload"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "byte[]",
    "signature": "public byte[] encode(Map<String, Object> headers, byte[] payload)",
    "source_code": "\tpublic byte[] encode(Map<String, Object> headers, byte[] payload) {\n\t\tAssert.notNull(headers, \"'headers' is required\");\n\t\tAssert.notNull(payload, \"'payload' is required\");\n\n\t\tif (SimpMessageType.HEARTBEAT.equals(SimpMessageHeaderAccessor.getMessageType(headers))) {\n\t\t\tlogger.trace(\"Encoding heartbeat\");\n\t\t\treturn StompDecoder.HEARTBEAT_PAYLOAD;\n\t\t}\n\n\t\tStompCommand command = StompHeaderAccessor.getCommand(headers);\n\t\tif (command == null) {\n\t\t\tthrow new IllegalStateException(\"Missing STOMP command: \" + headers);\n\t\t}\n\n\t\tResult result = new DefaultResult();\n\t\tresult.add(command.toString().getBytes(StandardCharsets.UTF_8));\n\t\tresult.add(LINE_FEED_BYTE);\n\t\twriteHeaders(command, headers, payload, result);\n\t\tresult.add(LINE_FEED_BYTE);\n\t\tresult.add(payload);\n\t\tresult.add((byte) 0);\n\t\treturn result.toByteArray();\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#forward(message,accessor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "accessor"
    ],
    "position": {
      "column": 1,
      "line": 1101
    },
    "return": "CompletableFuture<Void>",
    "signature": "public CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor)",
    "source_code": "\t\tpublic CompletableFuture<Void> forward(Message<?> message, StompHeaderAccessor accessor) {\n\t\t\ttry {\n\t\t\t\tCompletableFuture<Void> future = super.forward(message, accessor);\n\t\t\t\tif (message.getHeaders().get(SimpMessageHeaderAccessor.IGNORE_ERROR) == null) {\n\t\t\t\t\tfuture.get();\n\t\t\t\t}\n\t\t\t\treturn future;\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new MessageDeliveryException(message, ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#handleTcpConnectionFailure(error,ex)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked when any TCP connectivity issue is detected, i.e. failure to establish\n\t\t * the TCP connection, failure to send a message, missed heartbeat, etc.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "error",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String error, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String error, @Nullable Throwable ex) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"TCP connection failure in session \" + this.sessionId + \": \" + error, ex);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsendStompErrorFrameToClient(error);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tclearConnection();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failure while clearing TCP connection state in session \" + this.sessionId, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#handleTcpConnectionFailure(errorMessage,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "errorMessage",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1089
    },
    "return": "void",
    "signature": "protected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex)",
    "source_code": "\t\tprotected void handleTcpConnectionFailure(String errorMessage, @Nullable Throwable ex) {\n\t\t\tsuper.handleTcpConnectionFailure(errorMessage, ex);\n\t\t\tpublishBrokerUnavailableEvent();\n\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> map) {\n\t\tthis.headers.putAll(map);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#readOnlyStompHeaders(Map<String,headers)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code StompHeaders} object that can only be read, not written to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "StompHeaders",
    "signature": "public StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers)",
    "source_code": "\tpublic static StompHeaders readOnlyStompHeaders(@Nullable Map<String, List<String>> headers) {\n\t\treturn new StompHeaders((headers != null ? headers : Collections.emptyMap()), true);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#removeEldestEntry(Map.Entry<String,eldest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<String",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest)",
    "source_code": "\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, byte[]> eldest) {\n\t\t\t\t\tif (size() > HEADER_KEY_CACHE_LIMIT) {\n\t\t\t\t\t\theaderKeyAccessCache.remove(eldest.getKey());\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#set(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 476
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tList<String> headerValues = new ArrayList<>(1);\n\t\theaderValues.add(headerValue);\n\t\tthis.headers.put(headerName, headerValues);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 483
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tvalues.forEach(this::set);\n\t}"
  },
  "org.springframework.messaging.simp.stomp.<unknown>#setSystemSubscriptions(Map<String,subscriptions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure one more destinations to subscribe to on the shared \"system\"\n\t * connection along with MessageHandler's to handle received messages.\n\t * <p>This is for internal use in a multi-application server scenario where\n\t * servers forward messages to each other (for example, unresolved user destinations).\n\t * @param subscriptions the destinations to subscribe to.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "subscriptions"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "void",
    "signature": "public void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions)",
    "source_code": "\tpublic void setSystemSubscriptions(@Nullable Map<String, MessageHandler> subscriptions) {\n\t\tthis.systemSubscriptions.clear();\n\t\tif (subscriptions != null) {\n\t\t\tthis.systemSubscriptions.putAll(subscriptions);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#checkDestination(destination,requiredPrefix)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "destination",
      "requiredPrefix"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "boolean",
    "signature": "protected boolean checkDestination(String destination, String requiredPrefix)",
    "source_code": "\tprotected boolean checkDestination(String destination, String requiredPrefix) {\n\t\treturn destination.startsWith(requiredPrefix);\n\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#getTargetDestination(sourceDestination,actualDestination,sessionId,user)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This method determines how to translate the source \"user\" destination to an\n\t * actual target destination for the given active user session.\n\t * @param sourceDestination the source destination from the input message.\n\t * @param actualDestination a subset of the destination without any user prefix.\n\t * @param sessionId the id of an active user session, never {@code null}.\n\t * @param user the target user, possibly {@code null},, for example, if not authenticated.\n\t * @return a target destination, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sourceDestination",
      "actualDestination",
      "sessionId",
      "user"
    ],
    "position": {
      "column": 1,
      "line": 247
    },
    "return": "String",
    "signature": "protected String getTargetDestination(String sourceDestination, String actualDestination,\n\t\t\tString sessionId, @Nullable String user)",
    "source_code": "\tprotected String getTargetDestination(String sourceDestination, String actualDestination,\n\t\t\tString sessionId, @Nullable String user) {\n\n\t\treturn actualDestination + \"-user\" + sessionId;\n\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#init(expirationPeriod,sessionLookup)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expirationPeriod",
      "sessionLookup"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "public void init(long expirationPeriod, SessionLookup sessionLookup)",
    "source_code": "\t\tpublic void init(long expirationPeriod, SessionLookup sessionLookup) {\n\t\t\tthis.expirationTime = System.currentTimeMillis() + expirationPeriod;\n\t\t\tfor (TransferSimpUser user : this.users.values()) {\n\t\t\t\tuser.afterDeserialization(sessionLookup);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.simp.user.<unknown>#setUserMap(Map<String,users)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "users"
    ],
    "position": {
      "column": 1,
      "line": 231
    },
    "return": "void",
    "signature": "public void setUserMap(Map<String, TransferSimpUser> users)",
    "source_code": "\t\tpublic void setUserMap(Map<String, TransferSimpUser> users) {\n\t\t\tthis.users = users;\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#addInterceptor(index,interceptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, ChannelInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, ChannelInterceptor interceptor) {\n\t\tsuper.addInterceptor(index, interceptor);\n\t\tupdateExecutorInterceptorsFor(interceptor);\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#applyPostSend(message,channel,sent)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void applyPostSend(Message<?> message, MessageChannel channel, boolean sent)",
    "source_code": "\t\tpublic void applyPostSend(Message<?> message, MessageChannel channel, boolean sent) {\n\t\t\tfor (ChannelInterceptor interceptor : interceptors) {\n\t\t\t\tinterceptor.postSend(message, channel, sent);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeaders(Map<String,headersToCopy)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will overwrite any\n\t * existing values. Use {@link #copyHeadersIfAbsent(Map)} to avoid overwriting\n\t * values. Note that the 'id' and 'timestamp' header values will never be overwritten.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeaders(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeaders(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#copyHeadersIfAbsent(Map<String,headersToCopy)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the name-value pairs from the provided Map. This operation will <em>not</em>\n\t * overwrite any existing values.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "headersToCopy"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy)",
    "source_code": "\tpublic MessageBuilder<T> copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {\n\t\tthis.headerAccessor.copyHeadersIfAbsent(headersToCopy);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#createMessage(payload,messageHeaders)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A shortcut factory method for creating a message with the given payload\n\t * and {@code MessageHeaders}.\n\t * <p><strong>Note:</strong> the given {@code MessageHeaders} instance is used\n\t * directly in the new message, i.e. it is not copied.\n\t * @param payload the payload to use (never {@code null})\n\t * @param messageHeaders the headers to use (never {@code null})\n\t * @return the created message\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "payload",
      "messageHeaders"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Message<T>",
    "signature": "public Message<T> createMessage(T payload, MessageHeaders messageHeaders)",
    "source_code": "\tpublic static <T> Message<T> createMessage(T payload, MessageHeaders messageHeaders) {\n\t\tAssert.notNull(payload, \"Payload must not be null\");\n\t\tAssert.notNull(messageHeaders, \"MessageHeaders must not be null\");\n\t\tif (payload instanceof Throwable throwable) {\n\t\t\treturn (Message<T>) new ErrorMessage(throwable, messageHeaders);\n\t\t}\n\t\telse {\n\t\t\treturn new GenericMessage<>(payload, messageHeaders);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#fromMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance from a plain {@link Map}.\n\t * @param map the raw headers\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "MessageHeaderAccessor",
    "signature": "public MessageHeaderAccessor fromMap(@Nullable Map<String, Object> map)",
    "source_code": "\tpublic static MessageHeaderAccessor fromMap(@Nullable Map<String, Object> map) {\n\t\treturn fromMessageHeaders(new MessageHeaders(map));\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getAccessor(message,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the original {@code MessageHeaderAccessor} used to create the headers\n\t * of the given {@code Message}, or {@code null} if that's not available or if\n\t * its type does not match the required type.\n\t * <p>This is for cases where the existence of an accessor is strongly expected\n\t * (followed up with an assertion) or where an accessor will be created otherwise.\n\t * @param message the message to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "T",
    "signature": "public T getAccessor(Message<?> message, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(Message<?> message, @Nullable Class<T> requiredType) {\n\t\treturn getAccessor(message.getHeaders(), requiredType);\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#getAccessor(messageHeaders,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A variation of {@link #getAccessor(org.springframework.messaging.Message, Class)}\n\t * with a {@code MessageHeaders} instance instead of a {@code Message}.\n\t * <p>This is for cases when a full message may not have been created yet.\n\t * @param messageHeaders the message headers to get an accessor for\n\t * @param requiredType the required accessor type (or {@code null} for any)\n\t * @return an accessor instance of the specified type, or {@code null} if none\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "messageHeaders",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "T",
    "signature": "public T getAccessor(MessageHeaders messageHeaders, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T extends MessageHeaderAccessor> T getAccessor(\n\t\t\tMessageHeaders messageHeaders, @Nullable Class<T> requiredType) {\n\n\t\tif (messageHeaders instanceof MutableMessageHeaders mutableHeaders) {\n\t\t\tMessageHeaderAccessor headerAccessor = mutableHeaders.getAccessor();\n\t\t\tif (requiredType == null || requiredType.isInstance(headerAccessor)) {\n\t\t\t\treturn (T) headerAccessor;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#send(message,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "boolean",
    "signature": "public boolean send(Message<?> message, long timeout)",
    "source_code": "\tpublic final boolean send(Message<?> message, long timeout) {\n\t\tAssert.notNull(message, \"Message must not be null\");\n\t\tMessage<?> messageToUse = message;\n\t\tChannelInterceptorChain chain = new ChannelInterceptorChain();\n\t\tboolean sent = false;\n\t\ttry {\n\t\t\tmessageToUse = chain.applyPreSend(messageToUse, this);\n\t\t\tif (messageToUse == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsent = sendInternal(messageToUse, timeout);\n\t\t\tchain.applyPostSend(messageToUse, this, sent);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, null);\n\t\t\treturn sent;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex);\n\t\t\tif (ex instanceof MessagingException messagingException) {\n\t\t\t\tthrow messagingException;\n\t\t\t}\n\t\t\tthrow new MessageDeliveryException(messageToUse,\"Failed to send message to \" + this, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\tMessageDeliveryException ex2 =\n\t\t\t\t\tnew MessageDeliveryException(messageToUse, \"Failed to send message to \" + this, err);\n\t\t\tchain.triggerAfterSendCompletion(messageToUse, this, sent, ex2);\n\t\t\tthrow ex2;\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#sendInternal(message,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "boolean",
    "signature": "public boolean sendInternal(Message<?> message, long timeout)",
    "source_code": "\tpublic boolean sendInternal(Message<?> message, long timeout) {\n\t\tfor (MessageHandler handler : getSubscribers()) {\n\t\t\tSendTask sendTask = new SendTask(message, handler);\n\t\t\tif (this.executor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.executor.execute(sendTask);\n\t\t\t\t}\n\t\t\t\tcatch (RejectedExecutionException ex) {\n\t\t\t\t\t// Probably on shutdown -> run send task locally instead\n\t\t\t\t\tsendTask.run();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No executor configured -> always run send tasks locally\n\t\t\t\tsendTask.run();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name. If the provided value is {@code null},\n\t * the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeader(String headerName, @Nullable Object headerValue) {\n\t\tthis.headerAccessor.setHeader(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name.\n\t * <p>If the provided value is {@code null}, the header will be removed.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "void",
    "signature": "public void setHeader(String name, @Nullable Object value)",
    "source_code": "\tpublic void setHeader(String name, @Nullable Object value) {\n\t\tif (isReadOnly(name)) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + name + \"' header is read-only\");\n\t\t}\n\t\tverifyType(name, value);\n\t\tif (value != null) {\n\t\t\t// Modify header if necessary\n\t\t\tif (!ObjectUtils.nullSafeEquals(value, getHeader(name))) {\n\t\t\t\tthis.modified = true;\n\t\t\t\tthis.headers.getRawHeaders().put(name, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Remove header if available\n\t\t\tif (this.headers.containsKey(name)) {\n\t\t\t\tthis.modified = true;\n\t\t\t\tthis.headers.getRawHeaders().remove(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not already\n\t * associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "MessageBuilder<T>",
    "signature": "public MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue)",
    "source_code": "\tpublic MessageBuilder<T> setHeaderIfAbsent(String headerName, Object headerValue) {\n\t\tthis.headerAccessor.setHeaderIfAbsent(headerName, headerValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#setHeaderIfAbsent(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the value for the given header name only if the header name is not\n\t * already associated with a value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 348
    },
    "return": "void",
    "signature": "public void setHeaderIfAbsent(String name, Object value)",
    "source_code": "\tpublic void setHeaderIfAbsent(String name, Object value) {\n\t\tif (getHeader(name) == null) {\n\t\t\tsetHeader(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.messaging.support.<unknown>#triggerAfterReceiveCompletion(message,channel,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "void",
    "signature": "public void triggerAfterReceiveCompletion(@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex)",
    "source_code": "\t\tpublic void triggerAfterReceiveCompletion(\n\t\t\t\t@Nullable Message<?> message, MessageChannel channel, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.receiveInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterReceiveCompletion(message, channel, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\t\tlogger.error(\"Exception from afterReceiveCompletion in \" + interceptor, ex2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#triggerAfterSendCompletion(message,channel,sent,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "channel",
      "sent",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex)",
    "source_code": "\t\tpublic void triggerAfterSendCompletion(Message<?> message, MessageChannel channel,\n\t\t\t\tboolean sent, @Nullable Exception ex) {\n\n\t\t\tfor (int i = this.sendInterceptorIndex; i >= 0; i--) {\n\t\t\t\tChannelInterceptor interceptor = interceptors.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tinterceptor.afterSendCompletion(message, channel, sent, ex);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.error(\"Exception from afterSendCompletion in \" + interceptor, ex2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.messaging.support.<unknown>#verifyType(headerName,headerValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "protected void verifyType(@Nullable String headerName, @Nullable Object headerValue)",
    "source_code": "\tprotected void verifyType(@Nullable String headerName, @Nullable Object headerValue) {\n\t\tif (headerName != null && headerValue != null) {\n\t\t\tif (MessageHeaders.ERROR_CHANNEL.equals(headerName) ||\n\t\t\t\t\tMessageHeaders.REPLY_CHANNEL.endsWith(headerName)) {\n\t\t\t\tif (!(headerValue instanceof MessageChannel || headerValue instanceof String)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"'\" + headerName + \"' header value must be a MessageChannel or String\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.mock.http.client.reactive.<unknown>#setBody(body,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "void",
    "signature": "public void setBody(String body, Charset charset)",
    "source_code": "\tpublic void setBody(String body, Charset charset) {\n\t\tDataBuffer buffer = toDataBuffer(body, charset);\n\t\tthis.body = Flux.just(buffer);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addDateHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "void",
    "signature": "public void addDateHeader(String name, long value)",
    "source_code": "\tpublic void addDateHeader(String name, long value) {\n\t\taddHeaderValue(name, formatDate(value));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addHeader(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an HTTP header entry for the given name.\n\t * <p>While this method can take any {@code Object} as a parameter,\n\t * it is recommended to use the following types:\n\t * <ul>\n\t * <li>String or any Object to be converted using {@code toString()}; see {@link #getHeader}.</li>\n\t * <li>String, Number, or Date for date headers; see {@link #getDateHeader}.</li>\n\t * <li>String or Number for integer headers; see {@link #getIntHeader}.</li>\n\t * <li>{@code String[]} or {@code Collection<String>} for multiple values; see {@link #getHeaders}.</li>\n\t * </ul>\n\t * @see #getHeaderNames\n\t * @see #getHeaders\n\t * @see #getHeader\n\t * @see #getDateHeader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1066
    },
    "return": "void",
    "signature": "public void addHeader(String name, Object value)",
    "source_code": "\tpublic void addHeader(String name, Object value) {\n\t\tif (HttpHeaders.CONTENT_TYPE.equalsIgnoreCase(name) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.CONTENT_TYPE)) {\n\t\t\tsetContentType(value.toString());\n\t\t}\n\t\telse if (HttpHeaders.ACCEPT_LANGUAGE.equalsIgnoreCase(name) &&\n\t\t\t\t!this.headers.containsKey(HttpHeaders.ACCEPT_LANGUAGE)) {\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\theaders.add(HttpHeaders.ACCEPT_LANGUAGE, value.toString());\n\t\t\t\tList<Locale> locales = headers.getAcceptLanguageAsLocales();\n\t\t\t\tthis.locales.clear();\n\t\t\t\tthis.locales.addAll(locales);\n\t\t\t\tif (this.locales.isEmpty()) {\n\t\t\t\t\tthis.locales.add(Locale.ENGLISH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// Invalid Accept-Language format -> just store plain header\n\t\t\t}\n\t\t\tdoAddHeaderValue(name, value, true);\n\t\t}\n\t\telse {\n\t\t\tdoAddHeaderValue(name, value, false);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 703
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\tpublic void addIntHeader(String name, int value) {\n\t\taddHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a single value for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given value will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 571
    },
    "return": "void",
    "signature": "public void addParameter(String name, @Nullable String value)",
    "source_code": "\tpublic void addParameter(String name, @Nullable String value) {\n\t\taddParameter(name, new String[] {value});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameter(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, the given values will be added to the end of the list.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 580
    },
    "return": "void",
    "signature": "public void addParameter(String name, String... values)",
    "source_code": "\tpublic void addParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tString[] oldArr = this.parameters.get(name);\n\t\tif (oldArr != null) {\n\t\t\tString[] newArr = new String[oldArr.length + values.length];\n\t\t\tSystem.arraycopy(oldArr, 0, newArr, 0, oldArr.length);\n\t\t\tSystem.arraycopy(values, 0, newArr, oldArr.length, values.length);\n\t\t\tthis.parameters.put(name, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.parameters.put(name, values);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#addParameters(Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add all provided parameters <strong>without</strong> replacing any\n\t * existing values. To replace existing values, use\n\t * {@link #setParameters(java.util.Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "void",
    "signature": "public void addParameters(Map<String, ?> params)",
    "source_code": "\tpublic void addParameters(Map<String, ?> params) {\n\t\tAssert.notNull(params, \"Parameter map must not be null\");\n\t\tparams.forEach((key, value) -> {\n\t\t\tif (value instanceof String str) {\n\t\t\t\taddParameter(key, str);\n\t\t\t}\n\t\t\telse if (value instanceof String[] strings) {\n\t\t\t\taddParameter(key, strings);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Parameter map value must be single value \" +\n\t\t\t\t\t\t\" or array of type [\" + String.class.getName() + \"]\");\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#forward(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void forward(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void forward(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tAssert.state(!response.isCommitted(), \"Cannot perform forward - response is already committed\");\n\t\tgetMockHttpServletResponse(response).setForwardedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: forwarding to [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#getAttribute(name,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\tpublic Object getAttribute(String name, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\treturn switch (scope) {\n\t\t\tcase PAGE_SCOPE -> getAttribute(name);\n\t\t\tcase REQUEST_SCOPE -> this.request.getAttribute(name);\n\t\t\tcase SESSION_SCOPE -> {\n\t\t\t\tHttpSession session = this.request.getSession(false);\n\t\t\t\tyield (session != null ? session.getAttribute(name) : null);\n\t\t\t}\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.getAttribute(name);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t};\n\t}"
  },
  "org.springframework.mock.web.<unknown>#include(path,flush)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "flush"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void include(String path, boolean flush)",
    "source_code": "\tpublic void include(String path, boolean flush) throws ServletException, IOException {\n\t\tthis.request.getRequestDispatcher(path).include(this.request, this.response);\n\t\tif (flush) {\n\t\t\tthis.response.flushBuffer();\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#include(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void include(ServletRequest request, ServletResponse response)",
    "source_code": "\tpublic void include(ServletRequest request, ServletResponse response) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(response, \"Response must not be null\");\n\t\tgetMockHttpServletResponse(response).addIncludedUrl(this.resource);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"MockRequestDispatcher: including [\" + this.resource + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#initialize(servlet,request,response,errorPageURL,needsSession,bufferSize,autoFlush)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servlet",
      "request",
      "response",
      "errorPageURL",
      "needsSession",
      "bufferSize",
      "autoFlush"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void initialize(Servlet servlet, ServletRequest request, ServletResponse response,\n\t\t\tString errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush)",
    "source_code": "\tpublic void initialize(\n\t\t\tServlet servlet, ServletRequest request, ServletResponse response,\n\t\t\tString errorPageURL, boolean needsSession, int bufferSize, boolean autoFlush) {\n\n\t\tthrow new UnsupportedOperationException(\"Use appropriate constructor\");\n\t}"
  },
  "org.springframework.mock.web.<unknown>#login(username,password)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 1422
    },
    "return": "void",
    "signature": "public void login(String username, String password)",
    "source_code": "\tpublic void login(String username, String password) throws ServletException {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.mock.web.<unknown>#removeAttribute(name,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\tpublic void removeAttribute(String name, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tswitch (scope) {\n\t\t\tcase PAGE_SCOPE -> this.attributes.remove(name);\n\t\t\tcase REQUEST_SCOPE -> this.request.removeAttribute(name);\n\t\t\tcase SESSION_SCOPE -> this.request.getSession().removeAttribute(name);\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.removeAttribute(name);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendError(status,errorMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "status",
      "errorMessage"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "void",
    "signature": "public void sendError(int status, String errorMessage)",
    "source_code": "\tpublic void sendError(int status, String errorMessage) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot set error status - response is already committed\");\n\t\tthis.status = status;\n\t\tthis.errorMessage = errorMessage;\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#sendRedirect(url,sc,clearBuffer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void sendRedirect(String url, int sc, boolean clearBuffer)",
    "source_code": "\tpublic void sendRedirect(String url, int sc, boolean clearBuffer) throws IOException {\n\t\tAssert.state(!isCommitted(), \"Cannot send redirect - response is already committed\");\n\t\tAssert.notNull(url, \"Redirect URL must not be null\");\n\t\tsetHeader(HttpHeaders.LOCATION, url);\n\t\tsetStatus(sc);\n\t\tsetCommitted(true);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tassertIsValid();\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tif (value != null) {\n\t\t\tObject oldValue = this.attributes.put(name, value);\n\t\t\tif (value != oldValue) {\n\t\t\t\tif (oldValue instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueUnbound(new HttpSessionBindingEvent(this, name, oldValue));\n\t\t\t\t}\n\t\t\t\tif (value instanceof HttpSessionBindingListener listener) {\n\t\t\t\t\tlistener.valueBound(new HttpSessionBindingEvent(this, name, value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tremoveAttribute(name);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setAttribute(name,value,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value, int scope)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value, int scope) {\n\t\tAssert.notNull(name, \"Attribute name must not be null\");\n\t\tswitch (scope) {\n\t\t\tcase PAGE_SCOPE -> setAttribute(name, value);\n\t\t\tcase REQUEST_SCOPE -> this.request.setAttribute(name, value);\n\t\t\tcase SESSION_SCOPE -> this.request.getSession().setAttribute(name, value);\n\t\t\tcase APPLICATION_SCOPE -> this.servletContext.setAttribute(name, value);\n\t\t\tdefault -> throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n\t\t}\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setDateHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 654
    },
    "return": "void",
    "signature": "public void setDateHeader(String name, long value)",
    "source_code": "\tpublic void setDateHeader(String name, long value) {\n\t\tsetHeaderValue(name, formatDate(value));\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "void",
    "signature": "public void setHeader(String name, @Nullable String value)",
    "source_code": "\tpublic void setHeader(String name, @Nullable String value) {\n\t\tsetHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 698
    },
    "return": "void",
    "signature": "public void setIntHeader(String name, int value)",
    "source_code": "\tpublic void setIntHeader(String name, int value) {\n\t\tsetHeaderValue(name, value);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameter(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a single value for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, they will be replaced.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "void",
    "signature": "public void setParameter(String name, String value)",
    "source_code": "\tpublic void setParameter(String name, String value) {\n\t\tsetParameter(name, new String[] {value});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameter(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set an array of values for the specified HTTP parameter.\n\t * <p>If there are already one or more values registered for the given\n\t * parameter name, they will be replaced.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void setParameter(String name, String... values)",
    "source_code": "\tpublic void setParameter(String name, String... values) {\n\t\tAssert.notNull(name, \"Parameter name must not be null\");\n\t\tthis.parameters.put(name, values);\n\t}"
  },
  "org.springframework.mock.web.<unknown>#setParameters(Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set all provided parameters <strong>replacing</strong> any existing\n\t * values for the provided parameter names. To add without replacing\n\t * existing values, use {@link #addParameters(java.util.Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "void",
    "signature": "public void setParameters(Map<String, ?> params)",
    "source_code": "\tpublic void setParameters(Map<String, ?> params) {\n\t\tAssert.notNull(params, \"Parameter map must not be null\");\n\t\tparams.forEach((key, value) -> {\n\t\t\tif (value instanceof String str) {\n\t\t\t\tsetParameter(key, str);\n\t\t\t}\n\t\t\telse if (value instanceof String[] strings) {\n\t\t\t\tsetParameter(key, strings);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Parameter map value must be single value \" + \" or array of type [\" + String.class.getName() + \"]\");\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.mock.web.<unknown>#startAsync(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 926
    },
    "return": "AsyncContext",
    "signature": "public AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response)",
    "source_code": "\tpublic AsyncContext startAsync(ServletRequest request, @Nullable ServletResponse response) {\n\t\tAssert.state(this.asyncSupported, \"Async not supported\");\n\t\tthis.asyncStarted = true;\n\t\tMockAsyncContext newAsyncContext = new MockAsyncContext(request, response);\n\t\tif (this.asyncContext != null) {\n\t\t\ttry {\n\t\t\t\tAsyncEvent startEvent = new AsyncEvent(newAsyncContext);\n\t\t\t\tfor (AsyncListener asyncListener : this.asyncContext.getListeners()) {\n\t\t\t\t\tasyncListener.onStartAsync(startEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\t// ignore failures\n\t\t\t}\n\t\t}\n\t\tthis.asyncContext = newAsyncContext;\n\t\treturn this.asyncContext;\n\t}"
  },
  "org.springframework.mock.web.<unknown>#write(buf,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "buf",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 886
    },
    "return": "void",
    "signature": "public void write(char[] buf, int off, int len)",
    "source_code": "\t\tpublic void write(char[] buf, int off, int len) {\n\t\t\tsuper.write(buf, off, len);\n\t\t\tsuper.flush();\n\t\t\tsetCommittedIfBufferSizeExceeded();\n\t\t}"
  },
  "org.springframework.mock.web.<unknown>#write(s,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "void",
    "signature": "public void write(String s, int off, int len)",
    "source_code": "\t\tpublic void write(String s, int off, int len) {\n\t\t\tsuper.write(s, off, len);\n\t\t\tsuper.flush();\n\t\t\tsetCommittedIfBufferSizeExceeded();\n\t\t}"
  },
  "org.springframework.mock.web.<unknown>#write(value,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void write(char[] value, int offset, int length)",
    "source_code": "\tpublic void write(char[] value, int offset, int length) throws IOException {\n\t\tgetTargetWriter().write(value, offset, length);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#applyNamedParameterToQuery(queryObject,paramName,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given name parameter to the given Query object.\n\t * @param queryObject the Query object\n\t * @param paramName the name of the parameter\n\t * @param value the value of the parameter\n\t * @throws HibernateException if thrown by the Query object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "queryObject",
      "paramName",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 1116
    },
    "return": "void",
    "signature": "protected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)",
    "source_code": "\tprotected void applyNamedParameterToQuery(Query<?> queryObject, String paramName, Object value)\n\t\t\tthrows HibernateException {\n\n\t\tif (value instanceof Collection<?> collection) {\n\t\t\tqueryObject.setParameterList(paramName, collection);\n\t\t}\n\t\telse if (value instanceof Object[] array) {\n\t\t\tqueryObject.setParameterList(paramName, array);\n\t\t}\n\t\telse {\n\t\t\tqueryObject.setParameter(paramName, value);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#bulkUpdate(queryString,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "queryString",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 1015
    },
    "return": "int",
    "signature": "public int bulkUpdate(String queryString, @Nullable Object... values)",
    "source_code": "\tpublic int bulkUpdate(String queryString, @Nullable Object... values) throws DataAccessException {\n\t\tInteger result = executeWithNativeSession(session -> {\n\t\t\tQuery<?> queryObject = session.createQuery(queryString);\n\t\t\tprepareQuery(queryObject);\n\t\t\tif (values != null) {\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\tqueryObject.setParameter(i, values[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queryObject.executeUpdate();\n\t\t});\n\t\tAssert.state(result != null, \"No update count\");\n\t\treturn result;\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 742
    },
    "return": "void",
    "signature": "public void delete(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\tsession.delete(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 754
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity)",
    "source_code": "\tpublic void delete(String entityName, Object entity) throws DataAccessException {\n\t\tdelete(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#delete(entityName,entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 759
    },
    "return": "void",
    "signature": "public void delete(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void delete(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\tsession.delete(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tHibernateTransactionObject txObject = (HibernateTransactionObject) transaction;\n\n\t\tif (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Pre-bound JDBC Connection found! HibernateTransactionManager does not support \" +\n\t\t\t\t\t\"running within DataSourceTransactionManager if told to manage the DataSource itself. \" +\n\t\t\t\t\t\"It is recommended to use a single HibernateTransactionManager for all transactions \" +\n\t\t\t\t\t\"on a single DataSource, no matter whether Hibernate or JDBC access.\");\n\t\t}\n\n\t\tSessionImplementor session = null;\n\n\t\ttry {\n\t\t\tif (!txObject.hasSessionHolder() || txObject.getSessionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tInterceptor entityInterceptor = getEntityInterceptor();\n\t\t\t\tSession newSession = (entityInterceptor != null ?\n\t\t\t\t\t\tobtainSessionFactory().withOptions().interceptor(entityInterceptor).openSession() :\n\t\t\t\t\t\tobtainSessionFactory().openSession());\n\t\t\t\tif (this.sessionInitializer != null) {\n\t\t\t\t\tthis.sessionInitializer.accept(newSession);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Opened new Session [\" + newSession + \"] for Hibernate transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setSession(newSession);\n\t\t\t}\n\n\t\t\tsession = txObject.getSessionHolder().getSession().unwrap(SessionImplementor.class);\n\n\t\t\tboolean holdabilityNeeded = (this.allowResultAccessAfterCompletion && !txObject.isNewSession());\n\t\t\tboolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);\n\t\t\tif (holdabilityNeeded || isolationLevelNeeded || definition.isReadOnly()) {\n\t\t\t\tif (this.prepareConnection && ConnectionReleaseMode.ON_CLOSE.equals(\n\t\t\t\t\t\tsession.getJdbcCoordinator().getLogicalConnection().getConnectionHandlingMode().getReleaseMode())) {\n\t\t\t\t\t// We're allowed to change the transaction settings of the JDBC Connection.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Preparing JDBC Connection of Hibernate Session [\" + session + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tConnection con = session.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection();\n\t\t\t\t\tInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n\t\t\t\t\ttxObject.setPreviousIsolationLevel(previousIsolationLevel);\n\t\t\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\t\t\t\t\tif (holdabilityNeeded) {\n\t\t\t\t\t\tint currentHoldability = con.getHoldability();\n\t\t\t\t\t\tif (currentHoldability != ResultSet.HOLD_CURSORS_OVER_COMMIT) {\n\t\t\t\t\t\t\ttxObject.setPreviousHoldability(currentHoldability);\n\t\t\t\t\t\t\tcon.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttxObject.connectionPrepared();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Not allowed to change the transaction settings of the JDBC Connection.\n\t\t\t\t\tif (isolationLevelNeeded) {\n\t\t\t\t\t\t// We should set a specific isolation level but are not allowed to...\n\t\t\t\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\t\t\t\"HibernateTransactionManager is not allowed to support custom isolation levels: \" +\n\t\t\t\t\t\t\t\t\"make sure that its 'prepareConnection' flag is on (the default) and that the \" +\n\t\t\t\t\t\t\t\t\"Hibernate connection release mode is set to ON_CLOSE.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not preparing JDBC Connection of Hibernate Session [\" + session + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (definition.isReadOnly() && txObject.isNewSession()) {\n\t\t\t\t// Just set to MANUAL in case of a new Session for this transaction.\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\t\t// As of 5.1, we're also setting Hibernate's read-only entity mode by default.\n\t\t\t\tsession.setDefaultReadOnly(true);\n\t\t\t}\n\n\t\t\tif (!definition.isReadOnly() && !txObject.isNewSession()) {\n\t\t\t\t// We need AUTO or COMMIT for a non-read-only transaction.\n\t\t\t\tFlushMode flushMode = session.getHibernateFlushMode();\n\t\t\t\tif (FlushMode.MANUAL.equals(flushMode)) {\n\t\t\t\t\tsession.setHibernateFlushMode(FlushMode.AUTO);\n\t\t\t\t\ttxObject.getSessionHolder().setPreviousFlushMode(flushMode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransaction hibTx;\n\n\t\t\t// Register transaction timeout.\n\t\t\tint timeout = determineTimeout(definition);\n\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t// Use Hibernate's own transaction timeout mechanism on Hibernate 3.1+\n\t\t\t\t// Applies to all statements, also to inserts, updates and deletes!\n\t\t\t\thibTx = session.getTransaction();\n\t\t\t\thibTx.setTimeout(timeout);\n\t\t\t\thibTx.begin();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Open a plain Hibernate transaction without specified timeout.\n\t\t\t\thibTx = session.beginTransaction();\n\t\t\t}\n\n\t\t\t// Add the Hibernate transaction to the session holder.\n\t\t\ttxObject.getSessionHolder().setTransaction(hibTx);\n\n\t\t\t// Register the Hibernate Session's JDBC Connection for the DataSource, if set.\n\t\t\tif (getDataSource() != null) {\n\t\t\t\tfinal SessionImplementor sessionToUse = session;\n\t\t\t\tConnectionHolder conHolder = new ConnectionHolder(\n\t\t\t\t\t\t() -> sessionToUse.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection());\n\t\t\t\tif (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t\tconHolder.setTimeoutInSeconds(timeout);\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Exposing Hibernate transaction as JDBC [\" + conHolder.getConnectionHandle() + \"]\");\n\t\t\t\t}\n\t\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), conHolder);\n\t\t\t\ttxObject.setConnectionHolder(conHolder);\n\t\t\t}\n\n\t\t\t// Bind the session holder to the thread.\n\t\t\tif (txObject.isNewSessionHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(obtainSessionFactory(), txObject.getSessionHolder());\n\t\t\t}\n\t\t\ttxObject.getSessionHolder().setSynchronizedWithTransaction(true);\n\t\t}\n\n\t\tcatch (Throwable ex) {\n\t\t\tif (txObject.isNewSession()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (session != null && session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {\n\t\t\t\t\t\tsession.getTransaction().rollback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\tlogger.debug(\"Could not rollback Session after failed transaction begin\", ex);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t\t\ttxObject.setSessionHolder(null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open Hibernate Session for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doExecute(action,enforceNativeSession)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the action specified by the given action object within a Session.\n\t * @param action callback object that specifies the Hibernate action\n\t * @param enforceNativeSession whether to enforce exposure of the native\n\t * Hibernate Session to callback code\n\t * @return a result object returned by the action, or {@code null}\n\t * @throws DataAccessException in case of Hibernate errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "action",
      "enforceNativeSession"
    ],
    "position": {
      "column": 1,
      "line": 345
    },
    "return": "T",
    "signature": "protected T doExecute(HibernateCallback<T> action, boolean enforceNativeSession)",
    "source_code": "\tprotected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\n\t\tSession session = null;\n\t\tboolean isNew = false;\n\t\ttry {\n\t\t\tsession = obtainSessionFactory().getCurrentSession();\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tlogger.debug(\"Could not retrieve pre-bound Hibernate session\", ex);\n\t\t}\n\t\tif (session == null) {\n\t\t\tsession = obtainSessionFactory().openSession();\n\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\tisNew = true;\n\t\t}\n\n\t\ttry {\n\t\t\tenableFilters(session);\n\t\t\tSession sessionToExpose =\n\t\t\t\t\t(enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session));\n\t\t\treturn action.doInHibernate(sessionToExpose);\n\t\t}\n\t\tcatch (HibernateException ex) {\n\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(ex);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tif (ex.getCause() instanceof HibernateException hibernateEx) {\n\t\t\t\tthrow SessionFactoryUtils.convertHibernateAccessException(hibernateEx);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Callback code threw application exception...\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (isNew) {\n\t\t\t\tSessionFactoryUtils.closeSession(session);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdisableFilters(session);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tSessionFactory sessionFactory = obtainSessionFactory();\n\n\t\tSuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;\n\t\tif (TransactionSynchronizationManager.hasResource(sessionFactory)) {\n\t\t\t// From non-transactional code running in active transaction synchronization\n\t\t\t// -> can be safely removed, will be closed on transaction completion.\n\t\t\tTransactionSynchronizationManager.unbindResource(sessionFactory);\n\t\t}\n\t\tTransactionSynchronizationManager.bindResource(sessionFactory, resourcesHolder.getSessionHolder());\n\t\tConnectionHolder connectionHolder = resourcesHolder.getConnectionHolder();\n\t\tif (connectionHolder != null && getDataSource() != null) {\n\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), connectionHolder);\n\t\t}\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity"
    ],
    "position": {
      "column": 1,
      "line": 833
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(String entityName, T exampleEntity)",
    "source_code": "\tpublic <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {\n\t\treturn findByExample(entityName, exampleEntity, -1, -1);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(entityName,exampleEntity,firstResult,maxResults)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 844
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(@Nullable String entityName, T exampleEntity, int firstResult, int maxResults)\n\t\t\tthrows DataAccessException {\n\n\t\tAssert.notNull(exampleEntity, \"Example entity must not be null\");\n\t\treturn nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {\n\t\t\tCriteria executableCriteria = (entityName != null ?\n\t\t\t\t\tsession.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass()));\n\t\t\texecutableCriteria.add(Example.create(exampleEntity));\n\t\t\tprepareCriteria(executableCriteria);\n\t\t\tif (firstResult >= 0) {\n\t\t\t\texecutableCriteria.setFirstResult(firstResult);\n\t\t\t}\n\t\t\tif (maxResults > 0) {\n\t\t\t\texecutableCriteria.setMaxResults(maxResults);\n\t\t\t}\n\t\t\treturn executableCriteria.list();\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#findByExample(exampleEntity,firstResult,maxResults)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exampleEntity",
      "firstResult",
      "maxResults"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "List<T>",
    "signature": "public List<T> findByExample(T exampleEntity, int firstResult, int maxResults)",
    "source_code": "\tpublic <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {\n\t\treturn findByExample(null, exampleEntity, firstResult, maxResults);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 443
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn get(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityClass,id,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "T",
    "signature": "public T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T get(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityClass, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id)",
    "source_code": "\tpublic Object get(String entityName, Serializable id) throws DataAccessException {\n\t\treturn get(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#get(entityName,id,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 468
    },
    "return": "Object",
    "signature": "public Object get(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object get(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.get(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.get(entityName, id);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> (proxy == args[0]);\n\t\t\t\t// Use hashCode of EntityManagerFactory proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\tcase \"getProperties\" -> getProperties();\n\t\t\t\t// Call coming in through InfrastructureProxy interface...\n\t\t\t\tcase \"getWrappedObject\" -> getSessionFactory();\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Regular delegation to the target SessionFactory,\n\t\t\t\t\t\t// enforcing its full initialization...\n\t\t\t\t\t\tyield method.invoke(getSessionFactory(), args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entity,id)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void load(Object entity, Serializable id)",
    "source_code": "\tpublic void load(Object entity, Serializable id) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.load(entity, id);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 480
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {\n\t\treturn load(entityClass, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityClass,id,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityClass",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 485
    },
    "return": "T",
    "signature": "public T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic <T> T load(Class<T> entityClass, Serializable id, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityClass, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityClass, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id)",
    "source_code": "\tpublic Object load(String entityName, Serializable id) throws DataAccessException {\n\t\treturn load(entityName, id, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#load(entityName,id,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "id",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "Object",
    "signature": "public Object load(String entityName, Serializable id, @Nullable LockMode lockMode)",
    "source_code": "\tpublic Object load(String entityName, Serializable id, @Nullable LockMode lockMode) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\treturn session.load(entityName, id, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn session.load(entityName, id);\n\t\t\t}\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void lock(Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(Object entity, LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#lock(entityName,entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 601
    },
    "return": "void",
    "signature": "public void lock(String entityName, Object entity, LockMode lockMode)",
    "source_code": "\tpublic void lock(String entityName, Object entity, LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#merge(entityName,entity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 729
    },
    "return": "T",
    "signature": "public T merge(String entityName, T entity)",
    "source_code": "\tpublic <T> T merge(String entityName, T entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn (T) session.merge(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#persist(entityName,entity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "public void persist(String entityName, Object entity)",
    "source_code": "\tpublic void persist(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.persist(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#refresh(entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 540
    },
    "return": "void",
    "signature": "public void refresh(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void refresh(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.refresh(entity, new LockOptions(lockMode));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsession.refresh(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entity,replicationMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 681
    },
    "return": "void",
    "signature": "public void replicate(Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(Object entity, ReplicationMode replicationMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#replicate(entityName,entity,replicationMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "replicationMode"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void replicate(String entityName, Object entity, ReplicationMode replicationMode)",
    "source_code": "\tpublic void replicate(String entityName, Object entity, ReplicationMode replicationMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.replicate(entityName, entity, replicationMode);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#save(entityName,entity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 619
    },
    "return": "Serializable",
    "signature": "public Serializable save(String entityName, Object entity)",
    "source_code": "\tpublic Serializable save(String entityName, Object entity) throws DataAccessException {\n\t\treturn nonNull(executeWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\treturn session.save(entityName, entity);\n\t\t}));\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#saveOrUpdate(entityName,entity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 672
    },
    "return": "void",
    "signature": "public void saveOrUpdate(String entityName, Object entity)",
    "source_code": "\tpublic void saveOrUpdate(String entityName, Object entity) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.saveOrUpdate(entityName, entity);\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 632
    },
    "return": "void",
    "signature": "public void update(Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(Object entity, @Nullable LockMode lockMode) throws DataAccessException {\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity"
    ],
    "position": {
      "column": 1,
      "line": 644
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity)",
    "source_code": "\tpublic void update(String entityName, Object entity) throws DataAccessException {\n\t\tupdate(entityName, entity, null);\n\t}"
  },
  "org.springframework.orm.hibernate5.<unknown>#update(entityName,entity,lockMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityName",
      "entity",
      "lockMode"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void update(String entityName, Object entity, @Nullable LockMode lockMode)",
    "source_code": "\tpublic void update(String entityName, Object entity, @Nullable LockMode lockMode)\n\t\t\tthrows DataAccessException {\n\n\t\texecuteWithNativeSession(session -> {\n\t\t\tcheckWriteOperationAllowed(session);\n\t\t\tsession.update(entityName, entity);\n\t\t\tif (lockMode != null) {\n\t\t\t\tsession.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#applyTransactionTimeout(query,emf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the current transaction timeout, if any, to the given JPA Query object.\n\t * <p>This method sets the JPA query hint \"jakarta.persistence.query.timeout\" accordingly.\n\t * @param query the JPA Query object\n\t * @param emf the JPA EntityManagerFactory that the Query was created for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "query",
      "emf"
    ],
    "position": {
      "column": 1,
      "line": 338
    },
    "return": "void",
    "signature": "public void applyTransactionTimeout(Query query, EntityManagerFactory emf)",
    "source_code": "\tpublic static void applyTransactionTimeout(Query query, EntityManagerFactory emf) {\n\t\tEntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null && emHolder.hasTimeout()) {\n\t\t\tint timeoutValue = (int) emHolder.getTimeToLiveInMillis();\n\t\t\ttry {\n\t\t\t\tquery.setHint(\"jakarta.persistence.query.timeout\", timeoutValue);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t// oh well, at least we tried...\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#cleanupResource(resourceHolder,resourceKey,committed)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey",
      "committed"
    ],
    "position": {
      "column": 1,
      "line": 503
    },
    "return": "void",
    "signature": "protected void cleanupResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey, boolean committed)",
    "source_code": "\t\tprotected void cleanupResource(\n\t\t\t\tEntityManagerHolder resourceHolder, EntityManagerFactory resourceKey, boolean committed) {\n\n\t\t\tif (!committed) {\n\t\t\t\t// Clear all pending inserts/updates/deletes in the EntityManager.\n\t\t\t\t// Necessary for pre-bound EntityManagers, to avoid inconsistent state.\n\t\t\t\tresourceHolder.getEntityManager().clear();\n\t\t\t}\n\t\t\tcleanupTransaction(this.transactionData, resourceKey);\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createApplicationManagedEntityManager(rawEntityManager,emfInfo)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "EntityManager",
    "signature": "public EntityManager createApplicationManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo)",
    "source_code": "\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, false);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createApplicationManagedEntityManager(rawEntityManager,emfInfo,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an application-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return an application-managed EntityManager that can join transactions\n\t * but does not participate in them automatically\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "EntityManager",
    "signature": "public EntityManager createApplicationManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createApplicationManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo, boolean synchronizedWithTransaction) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, false, synchronizedWithTransaction);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createContainerManagedEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param emf the EntityManagerFactory to create the EntityManager with.\n\t * If this implements the EntityManagerFactoryInfo interface, the corresponding\n\t * JpaDialect and PersistenceUnitInfo will be detected accordingly.\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a container-managed EntityManager that expects container-driven lifecycle\n\t * management but may opt out of automatic transaction synchronization\n\t * @since 4.0\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tAssert.notNull(emf, \"EntityManagerFactory must not be null\");\n\t\tif (emf instanceof EntityManagerFactoryInfo emfInfo) {\n\t\t\tEntityManager rawEntityManager = emfInfo.createNativeEntityManager(properties);\n\t\t\treturn createProxy(rawEntityManager, emfInfo, true, synchronizedWithTransaction);\n\t\t}\n\t\telse {\n\t\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\t\temf.createEntityManager(properties) : emf.createEntityManager());\n\t\t\treturn createProxy(rawEntityManager, null, null, null, null, true, synchronizedWithTransaction);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createContainerManagedEntityManager(rawEntityManager,emfInfo)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a container-managed extended EntityManager proxy.\n\t * @param rawEntityManager the raw EntityManager to decorate\n\t * @param emfInfo the EntityManagerFactoryInfo to obtain the JpaDialect\n\t * and PersistenceUnitInfo from\n\t * @return a container-managed EntityManager that will automatically participate\n\t * in any managed transaction\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "rawEntityManager",
      "emfInfo"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "EntityManager",
    "signature": "public EntityManager createContainerManagedEntityManager(EntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo)",
    "source_code": "\tpublic static EntityManager createContainerManagedEntityManager(\n\t\t\tEntityManager rawEntityManager, EntityManagerFactoryInfo emfInfo) {\n\n\t\treturn createProxy(rawEntityManager, emfInfo, true, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createNativeEntityManager(Map<?,properties)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 591
    },
    "return": "EntityManager",
    "signature": "public EntityManager createNativeEntityManager(@Nullable Map<?, ?> properties)",
    "source_code": "\tpublic EntityManager createNativeEntityManager(@Nullable Map<?, ?> properties) {\n\t\tEntityManager rawEntityManager = (!CollectionUtils.isEmpty(properties) ?\n\t\t\t\tgetNativeEntityManagerFactory().createEntityManager(properties) :\n\t\t\t\tgetNativeEntityManagerFactory().createEntityManager());\n\t\tpostProcessEntityManager(rawEntityManager);\n\t\treturn rawEntityManager;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to delegate to.\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @return a shareable transaction EntityManager proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {\n\t\treturn createSharedEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,entityManagerInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "entityManagerInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces) {\n\n\t\treturn createSharedEntityManager(emf, properties, true, entityManagerInterfaces);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to delegate to.\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return a shareable transaction EntityManager proxy\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\n\t\tClass<?> emIfc = (emf instanceof EntityManagerFactoryInfo emfInfo ?\n\t\t\t\temfInfo.getEntityManagerInterface() : EntityManager.class);\n\t\treturn createSharedEntityManager(emf, properties, synchronizedWithTransaction,\n\t\t\t\t(emIfc == null ? NO_ENTITY_MANAGER_INTERFACES : new Class<?>[] {emIfc}));\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#createSharedEntityManager(emf,Map<?,properties,synchronizedWithTransaction,entityManagerInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction",
      "entityManagerInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "EntityManager",
    "signature": "public EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces)",
    "source_code": "\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces) {\n\n\t\tClassLoader cl = null;\n\t\tif (emf instanceof EntityManagerFactoryInfo emfInfo) {\n\t\t\tcl = emfInfo.getBeanClassLoader();\n\t\t}\n\t\tClass<?>[] ifcs = new Class<?>[entityManagerInterfaces.length + 1];\n\t\tSystem.arraycopy(entityManagerInterfaces, 0, ifcs, 0, entityManagerInterfaces.length);\n\t\tifcs[entityManagerInterfaces.length] = EntityManagerProxy.class;\n\t\treturn (EntityManager) Proxy.newProxyInstance(\n\t\t\t\t(cl != null ? cl : SharedEntityManagerCreator.class.getClassLoader()),\n\t\t\t\tifcs, new SharedEntityManagerInvocationHandler(emf, properties, synchronizedWithTransaction));\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tJpaTransactionObject txObject = (JpaTransactionObject) transaction;\n\n\t\tif (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Pre-bound JDBC Connection found! JpaTransactionManager does not support \" +\n\t\t\t\t\t\"running within DataSourceTransactionManager if told to manage the DataSource itself. \" +\n\t\t\t\t\t\"It is recommended to use a single JpaTransactionManager for all transactions \" +\n\t\t\t\t\t\"on a single DataSource, no matter whether JPA or JDBC access.\");\n\t\t}\n\n\t\ttry {\n\t\t\tif (!txObject.hasEntityManagerHolder() ||\n\t\t\t\t\ttxObject.getEntityManagerHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tEntityManager newEm = createEntityManagerForTransaction();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Opened new EntityManager [\" + newEm + \"] for JPA transaction\");\n\t\t\t\t}\n\t\t\t\ttxObject.setEntityManagerHolder(new EntityManagerHolder(newEm), true);\n\t\t\t}\n\n\t\t\tEntityManager em = txObject.getEntityManagerHolder().getEntityManager();\n\n\t\t\t// Delegate to JpaDialect for actual transaction begin.\n\t\t\tint timeoutToUse = determineTimeout(definition);\n\t\t\tObject transactionData = getJpaDialect().beginTransaction(em,\n\t\t\t\t\tnew JpaTransactionDefinition(definition, timeoutToUse, txObject.isNewEntityManagerHolder()));\n\t\t\ttxObject.setTransactionData(transactionData);\n\t\t\ttxObject.setReadOnly(definition.isReadOnly());\n\n\t\t\t// Register transaction timeout.\n\t\t\tif (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\ttxObject.getEntityManagerHolder().setTimeoutInSeconds(timeoutToUse);\n\t\t\t}\n\n\t\t\t// Register the JPA EntityManager's JDBC Connection for the DataSource, if set.\n\t\t\tif (getDataSource() != null) {\n\t\t\t\tConnectionHandle conHandle = getJpaDialect().getJdbcConnection(em, definition.isReadOnly());\n\t\t\t\tif (conHandle != null) {\n\t\t\t\t\tConnectionHolder conHolder = new ConnectionHolder(conHandle);\n\t\t\t\t\tif (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\t\t\t\tconHolder.setTimeoutInSeconds(timeoutToUse);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Exposing JPA transaction as JDBC [\" + conHandle + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), conHolder);\n\t\t\t\t\ttxObject.setConnectionHolder(conHolder);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Not exposing JPA transaction [\" + em + \"] as JDBC transaction because \" +\n\t\t\t\t\t\t\t\t\"JpaDialect [\" + getJpaDialect() + \"] does not support JDBC Connection retrieval\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Bind the entity manager holder to the thread.\n\t\t\tif (txObject.isNewEntityManagerHolder()) {\n\t\t\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\t\t\tobtainEntityManagerFactory(), txObject.getEntityManagerHolder());\n\t\t\t}\n\t\t\ttxObject.getEntityManagerHolder().setSynchronizedWithTransaction(true);\n\t\t}\n\n\t\tcatch (TransactionException ex) {\n\t\t\tcloseEntityManagerAfterFailedBegin(txObject);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tcloseEntityManagerAfterFailedBegin(txObject);\n\t\t\tthrow new CannotCreateTransactionException(\"Could not open JPA EntityManager for transaction\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, for example, when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, Map<?, ?> properties)\n\t\t\tthrows PersistenceException {\n\n\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doGetTransactionalEntityManager(emf,Map<?,properties,synchronizedWithTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, for example, when using JpaTransactionManager.\n\t * <p>Same as {@code getEntityManager}, but throwing the original PersistenceException.\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws jakarta.persistence.PersistenceException if the EntityManager couldn't be created\n\t * @see #getTransactionalEntityManager(jakarta.persistence.EntityManagerFactory)\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties",
      "synchronizedWithTransaction"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "EntityManager",
    "signature": "public EntityManager doGetTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)",
    "source_code": "\tpublic static EntityManager doGetTransactionalEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction)\n\t\t\tthrows PersistenceException {\n\n\t\tAssert.notNull(emf, \"No EntityManagerFactory specified\");\n\n\t\tEntityManagerHolder emHolder =\n\t\t\t\t(EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n\t\tif (emHolder != null) {\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tif (!emHolder.isSynchronizedWithTransaction()) {\n\t\t\t\t\tif (TransactionSynchronizationManager.isActualTransactionActive()) {\n\t\t\t\t\t\t// Try to explicitly synchronize the EntityManager itself\n\t\t\t\t\t\t// with an ongoing JTA transaction, if any.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\temHolder.getEntityManager().joinTransaction();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (TransactionRequiredException ex) {\n\t\t\t\t\t\t\tlogger.debug(\"Could not join transaction because none was actually active\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\tObject transactionData = prepareTransaction(emHolder.getEntityManager(), emf);\n\t\t\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, false));\n\t\t\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Use holder's reference count to track synchronizedWithTransaction access.\n\t\t\t\t// isOpen() check used below to find out about it.\n\t\t\t\temHolder.requested();\n\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// unsynchronized EntityManager demanded\n\t\t\t\tif (emHolder.isTransactionActive() && !emHolder.isOpen()) {\n\t\t\t\t\tif (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// EntityManagerHolder with an active transaction coming from JpaTransactionManager,\n\t\t\t\t\t// with no synchronized EntityManager having been requested by application code before.\n\t\t\t\t\t// Unbind in order to register a new unsynchronized EntityManager instead.\n\t\t\t\t\tTransactionSynchronizationManager.unbindResource(emf);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Either a previously bound unsynchronized EntityManager, or the application\n\t\t\t\t\t// has requested a synchronized EntityManager before and therefore upgraded\n\t\t\t\t\t// this transaction's EntityManager to synchronized before.\n\t\t\t\t\treturn emHolder.getEntityManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t// Indicate that we can't obtain a transactional EntityManager.\n\t\t\treturn null;\n\t\t}\n\n\t\t// Create a new EntityManager for use within the current transaction.\n\t\tlogger.debug(\"Opening JPA EntityManager\");\n\t\tEntityManager em = null;\n\t\tif (!synchronizedWithTransaction) {\n\t\t\ttry {\n\t\t\t\tem = emf.createEntityManager(SynchronizationType.UNSYNCHRONIZED, properties);\n\t\t\t}\n\t\t\tcatch (AbstractMethodError err) {\n\t\t\t\t// JPA 2.1 API available but method not actually implemented in persistence provider:\n\t\t\t\t// falling back to regular createEntityManager method.\n\t\t\t}\n\t\t}\n\t\tif (em == null) {\n\t\t\tem = (!CollectionUtils.isEmpty(properties) ? emf.createEntityManager(properties) : emf.createEntityManager());\n\t\t}\n\n\t\ttry {\n\t\t\t// Use same EntityManager for further JPA operations within the transaction.\n\t\t\t// Thread-bound object will get removed by synchronization at transaction completion.\n\t\t\temHolder = new EntityManagerHolder(em);\n\t\t\tif (synchronizedWithTransaction) {\n\t\t\t\tObject transactionData = prepareTransaction(em, emf);\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionalEntityManagerSynchronization(emHolder, emf, transactionData, true));\n\t\t\t\temHolder.setSynchronizedWithTransaction(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Unsynchronized - just scope it for the transaction, as demanded by the JPA 2.1 spec...\n\t\t\t\tTransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\t\tnew TransactionScopedEntityManagerSynchronization(emHolder, emf));\n\t\t\t}\n\t\t\tTransactionSynchronizationManager.bindResource(emf, emHolder);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// Unexpected exception from external delegation call -> close EntityManager and rethrow.\n\t\t\tcloseEntityManager(em);\n\t\t\tthrow ex;\n\t\t}\n\n\t\treturn em;\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tSuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;\n\t\tTransactionSynchronizationManager.bindResource(\n\t\t\t\tobtainEntityManagerFactory(), resourcesHolder.getEntityManagerHolder());\n\t\tConnectionHolder connectionHolder = resourcesHolder.getConnectionHolder();\n\t\tif (connectionHolder != null && getDataSource() != null) {\n\t\t\tTransactionSynchronizationManager.bindResource(getDataSource(), connectionHolder);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#findEntityManagerFactory(beanFactory,unitName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the given\n\t * Spring application context (represented as ListableBeanFactory).\n\t * <p>The specified unit name will be matched against the configured\n\t * persistence unit, provided that a discovered EntityManagerFactory\n\t * implements the {@link EntityManagerFactoryInfo} interface. If not,\n\t * the persistence unit name will be matched against the Spring bean name,\n\t * assuming that the EntityManagerFactory bean names follow that convention.\n\t * <p>If no unit name has been given, this method will search for a default\n\t * EntityManagerFactory through {@link ListableBeanFactory#getBean(Class)}.\n\t * @param beanFactory the ListableBeanFactory to search\n\t * @param unitName the name of the persistence unit (may be {@code null} or empty,\n\t * in which case a single bean of type EntityManagerFactory will be searched for)\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t * @see EntityManagerFactoryInfo#getPersistenceUnitName()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "unitName"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory findEntityManagerFactory(ListableBeanFactory beanFactory, @Nullable String unitName)",
    "source_code": "\tpublic static EntityManagerFactory findEntityManagerFactory(\n\t\t\tListableBeanFactory beanFactory, @Nullable String unitName) throws NoSuchBeanDefinitionException {\n\n\t\tAssert.notNull(beanFactory, \"ListableBeanFactory must not be null\");\n\t\tif (StringUtils.hasLength(unitName)) {\n\t\t\t// See whether we can find an EntityManagerFactory with matching persistence unit name.\n\t\t\tString[] candidateNames =\n\t\t\t\t\tBeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, EntityManagerFactory.class);\n\t\t\tfor (String candidateName : candidateNames) {\n\t\t\t\tEntityManagerFactory emf = (EntityManagerFactory) beanFactory.getBean(candidateName);\n\t\t\t\tif (emf instanceof EntityManagerFactoryInfo emfInfo &&\n\t\t\t\t\t\tunitName.equals(emfInfo.getPersistenceUnitName())) {\n\t\t\t\t\treturn emf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// No matching persistence unit found - simply take the EntityManagerFactory\n\t\t\t// with the persistence unit name as bean name (by convention).\n\t\t\treturn beanFactory.getBean(unitName, EntityManagerFactory.class);\n\t\t}\n\t\telse {\n\t\t\t// Find unique EntityManagerFactory bean in the context, falling back to parent contexts.\n\t\t\treturn beanFactory.getBean(EntityManagerFactory.class);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#getTransactionalEntityManager(emf,Map<?,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a JPA EntityManager from the given factory. Is aware of a corresponding\n\t * EntityManager bound to the current thread, for example, when using JpaTransactionManager.\n\t * <p>Note: Will return {@code null} if no thread-bound EntityManager found!\n\t * @param emf the EntityManagerFactory to create the EntityManager with\n\t * @param properties the properties to be passed into the {@code createEntityManager}\n\t * call (may be {@code null})\n\t * @return the EntityManager, or {@code null} if none found\n\t * @throws DataAccessResourceFailureException if the EntityManager couldn't be obtained\n\t * @see JpaTransactionManager\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "emf",
      "Map<?",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "EntityManager",
    "signature": "public EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)",
    "source_code": "\tpublic static EntityManager getTransactionalEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties)\n\t\t\tthrows DataAccessResourceFailureException {\n\t\ttry {\n\t\t\treturn doGetTransactionalEntityManager(emf, properties, true);\n\t\t}\n\t\tcatch (PersistenceException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Could not obtain JPA EntityManager\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on Query interface coming in...\n\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t}\n\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\t// Use hashCode of EntityManager proxy.\n\t\t\t\t\treturn hashCode();\n\t\t\t\t}\n\t\t\t\tcase \"unwrap\" -> {\n\t\t\t\t\t// Handle JPA 2.0 unwrap method - could be a proxy match.\n\t\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\t\tif (targetClass == null) {\n\t\t\t\t\t\treturn this.target;\n\t\t\t\t\t}\n\t\t\t\t\telse if (targetClass.isInstance(proxy)) {\n\t\t\t\t\t\treturn proxy;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn this.target.unwrap(targetClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase \"getOutputParameterValue\" -> {\n\t\t\t\t\tif (this.entityManager == null) {\n\t\t\t\t\t\tObject key = args[0];\n\t\t\t\t\t\tif (this.outputParameters == null || !this.outputParameters.containsKey(key)) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"OUT/INOUT parameter not available: \" + key);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject value = this.outputParameters.get(key);\n\t\t\t\t\t\tif (value instanceof IllegalArgumentException iae) {\n\t\t\t\t\t\t\tthrow iae;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Invoke method on actual Query object.\n\t\t\ttry {\n\t\t\t\tObject retVal = method.invoke(this.target, args);\n\t\t\t\tif (method.getName().equals(\"registerStoredProcedureParameter\") && args.length == 3 &&\n\t\t\t\t\t\t(args[2] == ParameterMode.OUT || args[2] == ParameterMode.INOUT)) {\n\t\t\t\t\tif (this.outputParameters == null) {\n\t\t\t\t\t\tthis.outputParameters = new LinkedHashMap<>();\n\t\t\t\t\t}\n\t\t\t\t\tthis.outputParameters.put(args[0], null);\n\t\t\t\t}\n\t\t\t\treturn (retVal == this.target ? proxy : retVal);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (queryTerminatingMethods.contains(method.getName())) {\n\t\t\t\t\t// Actual execution of the query: close the EntityManager right\n\t\t\t\t\t// afterwards, since that was the only reason we kept it open.\n\t\t\t\t\tif (this.outputParameters != null && this.target instanceof StoredProcedureQuery storedProc) {\n\t\t\t\t\t\tfor (Map.Entry<Object, Object> entry : this.outputParameters.entrySet()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObject key = entry.getKey();\n\t\t\t\t\t\t\t\tif (key instanceof Integer number) {\n\t\t\t\t\t\t\t\t\tentry.setValue(storedProc.getOutputParameterValue(number));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tentry.setValue(storedProc.getOutputParameterValue(key.toString()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\t\t\tentry.setValue(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tEntityManagerFactoryUtils.closeEntityManager(this.entityManager);\n\t\t\t\t\tthis.entityManager = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#postProcessEntityManagerFactory(emf,pui)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook method allowing subclasses to customize the EntityManagerFactory\n\t * after its creation via the PersistenceProvider.\n\t * <p>The default implementation is empty.\n\t * @param emf the newly created EntityManagerFactory we are working with\n\t * @param pui the PersistenceUnitInfo used to configure the EntityManagerFactory\n\t * @see jakarta.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "emf",
      "pui"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "void",
    "signature": "protected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui)",
    "source_code": "\tprotected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui) {\n\t}"
  },
  "org.springframework.orm.jpa.<unknown>#releaseResource(resourceHolder,resourceKey)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceHolder",
      "resourceKey"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "protected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey)",
    "source_code": "\t\tprotected void releaseResource(EntityManagerHolder resourceHolder, EntityManagerFactory resourceKey) {\n\t\t\tcloseEntityManager(resourceHolder.getEntityManager());\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setEntityManagerHolder(entityManagerHolder,newEntityManagerHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManagerHolder",
      "newEntityManagerHolder"
    ],
    "position": {
      "column": 1,
      "line": 676
    },
    "return": "void",
    "signature": "public void setEntityManagerHolder(@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder)",
    "source_code": "\t\tpublic void setEntityManagerHolder(\n\t\t\t\t@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder) {\n\n\t\t\tthis.entityManagerHolder = entityManagerHolder;\n\t\t\tthis.newEntityManagerHolder = newEntityManagerHolder;\n\t\t}"
  },
  "org.springframework.orm.jpa.<unknown>#setJpaPropertyMap(Map<String,jpaProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify JPA properties as a Map, to be passed into\n\t * {@code EntityManagerFactory.createEntityManager(Map)} (if any).\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @see jakarta.persistence.EntityManagerFactory#createEntityManager(java.util.Map)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jpaProperties"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void setJpaPropertyMap(@Nullable Map<String, Object> jpaProperties)",
    "source_code": "\tpublic void setJpaPropertyMap(@Nullable Map<String, Object> jpaProperties) {\n\t\tif (jpaProperties != null) {\n\t\t\tthis.jpaPropertyMap.putAll(jpaProperties);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#applyTo(generationContext,beanRegistrationCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "generationContext",
      "beanRegistrationCode"
    ],
    "position": {
      "column": 1,
      "line": 783
    },
    "return": "void",
    "signature": "public void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode)",
    "source_code": "\t\tpublic void applyTo(GenerationContext generationContext, BeanRegistrationCode beanRegistrationCode) {\n\t\t\tGeneratedClass generatedClass = generationContext.getGeneratedClasses()\n\t\t\t\t\t.addForFeatureComponent(\"PersistenceInjection\", this.target, type -> {\n\t\t\t\t\t\ttype.addJavadoc(\"Persistence injection for {@link $T}.\", this.target);\n\t\t\t\t\t\ttype.addModifiers(javax.lang.model.element.Modifier.PUBLIC);\n\t\t\t\t\t});\n\t\t\tGeneratedMethod generatedMethod = generatedClass.getMethods().add(\"apply\", method -> {\n\t\t\t\tmethod.addJavadoc(\"Apply the persistence injection.\");\n\t\t\t\tmethod.addModifiers(javax.lang.model.element.Modifier.PUBLIC,\n\t\t\t\t\t\tjavax.lang.model.element.Modifier.STATIC);\n\t\t\t\tmethod.addParameter(RegisteredBean.class, REGISTERED_BEAN_PARAMETER);\n\t\t\t\tmethod.addParameter(this.target, INSTANCE_PARAMETER);\n\t\t\t\tmethod.returns(this.target);\n\t\t\t\tmethod.addCode(generateMethodCode(generationContext.getRuntimeHints(), generatedClass));\n\t\t\t});\n\t\t\tbeanRegistrationCode.addInstancePostProcessor(generatedMethod.toMethodReference());\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findEntityManagerFactory(unitName,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current Spring\n\t * application context, falling back to a single default EntityManagerFactory\n\t * (if any) in case of no unit name specified.\n\t * @param unitName the name of the persistence unit (may be {@code null} or empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString unitNameForLookup = (unitName != null ? unitName : \"\");\n\t\tif (unitNameForLookup.isEmpty()) {\n\t\t\tunitNameForLookup = this.defaultPersistenceUnitName;\n\t\t}\n\t\tif (!unitNameForLookup.isEmpty()) {\n\t\t\treturn findNamedEntityManagerFactory(unitNameForLookup, requestingBeanName);\n\t\t}\n\t\telse {\n\t\t\treturn findDefaultEntityManagerFactory(requestingBeanName);\n\t\t}\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#findNamedEntityManagerFactory(unitName,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an EntityManagerFactory with the given name in the current\n\t * Spring application context.\n\t * @param unitName the name of the persistence unit (never empty)\n\t * @param requestingBeanName the name of the requesting bean\n\t * @return the EntityManagerFactory\n\t * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 570
    },
    "return": "EntityManagerFactory",
    "signature": "protected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)",
    "source_code": "\tprotected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tAssert.state(this.beanFactory != null, \"ListableBeanFactory required for EntityManagerFactory bean lookup\");\n\n\t\tEntityManagerFactory emf = EntityManagerFactoryUtils.findEntityManagerFactory(this.beanFactory, unitName);\n\t\tif (requestingBeanName != null && this.beanFactory instanceof ConfigurableBeanFactory cbf) {\n\t\t\tcbf.registerDependentBean(unitName, requestingBeanName);\n\t\t}\n\t\treturn emf;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#getPersistenceContext(unitName,extended)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a specified persistence context for the given unit name, as defined\n\t * through the \"persistenceContexts\" (or \"extendedPersistenceContexts\") map.\n\t * @param unitName the name of the persistence unit\n\t * @param extended whether to obtain an extended persistence context\n\t * @return the corresponding EntityManager, or {@code null} if none found\n\t * @see #setPersistenceContexts\n\t * @see #setExtendedPersistenceContexts\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "unitName",
      "extended"
    ],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "EntityManager",
    "signature": "protected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended)",
    "source_code": "\tprotected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended) {\n\t\tMap<String, String> contexts = (extended ? this.extendedPersistenceContexts : this.persistenceContexts);\n\t\tif (contexts != null) {\n\t\t\tString unitNameForLookup = (unitName != null ? unitName : \"\");\n\t\t\tif (unitNameForLookup.isEmpty()) {\n\t\t\t\tunitNameForLookup = this.defaultPersistenceUnitName;\n\t\t\t}\n\t\t\tString jndiName = contexts.get(unitNameForLookup);\n\t\t\tif (jndiName == null && unitNameForLookup.isEmpty() && contexts.size() == 1) {\n\t\t\t\tjndiName = contexts.values().iterator().next();\n\t\t\t}\n\t\t\tif (jndiName != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn lookup(jndiName, EntityManager.class);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Could not obtain EntityManager [\" + jndiName + \"] from JNDI\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#getResourceToInject(target,requestingBeanName)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Resolve the object against the application context.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 693
    },
    "return": "Object",
    "signature": "protected Object getResourceToInject(Object target, @Nullable String requestingBeanName)",
    "source_code": "\t\tprotected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {\n\t\t\t// Resolves to EntityManagerFactory or EntityManager.\n\t\t\tif (this.type != null) {\n\t\t\t\treturn (this.type == PersistenceContextType.EXTENDED ?\n\t\t\t\t\t\tresolveExtendedEntityManager(target, requestingBeanName) :\n\t\t\t\t\t\tresolveEntityManager(requestingBeanName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// OK, so we need an EntityManagerFactory...\n\t\t\t\treturn resolveEntityManagerFactory(requestingBeanName);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#lookup(jndiName,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "jndiName",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "T",
    "signature": "public T lookup(String jndiName, Class<T> requiredType)",
    "source_code": "\t\tpublic <T> T lookup(String jndiName, Class<T> requiredType) throws Exception {\n\t\t\tJndiLocatorDelegate locator = new JndiLocatorDelegate();\n\t\t\tif (jndiEnvironment instanceof JndiTemplate jndiTemplate) {\n\t\t\t\tlocator.setJndiTemplate(jndiTemplate);\n\t\t\t}\n\t\t\telse if (jndiEnvironment instanceof Properties properties) {\n\t\t\t\tlocator.setJndiEnvironment(properties);\n\t\t\t}\n\t\t\telse if (jndiEnvironment != null) {\n\t\t\t\tthrow new IllegalStateException(\"Illegal 'jndiEnvironment' type: \" + jndiEnvironment.getClass());\n\t\t\t}\n\t\t\tlocator.setResourceRef(resourceRef);\n\t\t\treturn locator.lookup(jndiName, requiredType);\n\t\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 395
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tEntityManager emToClose = this.extendedEntityManagersToClose.remove(bean);\n\t\tEntityManagerFactoryUtils.closeEntityManager(emToClose);\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t\tfindInjectionMetadata(beanDefinition, beanType, beanName);\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 383
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\tInjectionMetadata metadata = findPersistenceMetadata(beanName, bean.getClass(), pvs);\n\t\ttry {\n\t\t\tmetadata.inject(bean, beanName, pvs);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(beanName, \"Injection of persistence dependencies failed\", ex);\n\t\t}\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setExtendedPersistenceContexts(Map<String,extendedPersistenceContexts)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <i>extended</i> persistence contexts for EntityManager lookups,\n\t * as a Map from persistence unit name to persistence context JNDI name\n\t * (which needs to resolve to an EntityManager instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-context-ref}\n\t * entries in the Jakarta EE deployment descriptors, matching the target persistence unit\n\t * and being set up with persistence context type {@code Extended}.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all\n\t * lookup driven by the standard JPA annotations, and all EntityManager\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario, and all EntityManager\n\t * handling is done by the Jakarta EE server itself.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extendedPersistenceContexts"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "void",
    "signature": "public void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts)",
    "source_code": "\tpublic void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts) {\n\t\tthis.extendedPersistenceContexts = extendedPersistenceContexts;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceContexts(Map<String,persistenceContexts)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the <i>transactional</i> persistence contexts for EntityManager lookups,\n\t * as a Map from persistence unit name to persistence context JNDI name\n\t * (which needs to resolve to an EntityManager instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-context-ref}\n\t * entries in the Jakarta EE deployment descriptors, matching the target persistence unit\n\t * and being set up with persistence context type {@code Transaction}.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all\n\t * lookup driven by the standard JPA annotations, and all EntityManager\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario, and all EntityManager\n\t * handling is done by the Jakarta EE server itself.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceContexts"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "void",
    "signature": "public void setPersistenceContexts(Map<String, String> persistenceContexts)",
    "source_code": "\tpublic void setPersistenceContexts(Map<String, String> persistenceContexts) {\n\t\tthis.persistenceContexts = persistenceContexts;\n\t}"
  },
  "org.springframework.orm.jpa.support.<unknown>#setPersistenceUnits(Map<String,persistenceUnits)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the persistence units for EntityManagerFactory lookups,\n\t * as a Map from persistence unit name to persistence unit JNDI name\n\t * (which needs to resolve to an EntityManagerFactory instance).\n\t * <p>JNDI names specified here should refer to {@code persistence-unit-ref}\n\t * entries in the Jakarta EE deployment descriptor, matching the target persistence unit.\n\t * <p>In case of no unit name specified in the annotation, the specified value\n\t * for the {@link #setDefaultPersistenceUnitName default persistence unit}\n\t * will be taken (by default, the value mapped to the empty String),\n\t * or simply the single persistence unit if there is only one.\n\t * <p>This is mainly intended for use in a Jakarta EE environment, with all lookup\n\t * driven by the standard JPA annotations, and all EntityManagerFactory\n\t * references obtained from JNDI. No separate EntityManagerFactory bean\n\t * definitions are necessary in such a scenario.\n\t * <p>If no corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\"\n\t * are specified, {@code @PersistenceContext} will be resolved to\n\t * EntityManagers built on top of the EntityManagerFactory defined here.\n\t * Note that those will be Spring-managed EntityManagers, which implement\n\t * transaction synchronization based on Spring's facilities.\n\t * If you prefer the Jakarta EE server's own EntityManager handling,\n\t * specify corresponding \"persistenceContexts\"/\"extendedPersistenceContexts\".\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "persistenceUnits"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "void",
    "signature": "public void setPersistenceUnits(Map<String, String> persistenceUnits)",
    "source_code": "\tpublic void setPersistenceUnits(Map<String, String> persistenceUnits) {\n\t\tthis.persistenceUnits = persistenceUnits;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#beginTransaction(entityManager,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Object",
    "signature": "public Object beginTransaction(EntityManager entityManager, TransactionDefinition definition)",
    "source_code": "\tpublic Object beginTransaction(EntityManager entityManager, TransactionDefinition definition)\n\t\t\tthrows PersistenceException, SQLException, TransactionException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\n\t\tif (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\tsession.getTransaction().setTimeout(definition.getTimeout());\n\t\t}\n\n\t\tboolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);\n\t\tInteger previousIsolationLevel = null;\n\t\tConnection preparedCon = null;\n\n\t\tif (isolationLevelNeeded || definition.isReadOnly()) {\n\t\t\tif (this.prepareConnection && ConnectionReleaseMode.ON_CLOSE.equals(\n\t\t\t\t\tsession.getJdbcCoordinator().getLogicalConnection().getConnectionHandlingMode().getReleaseMode())) {\n\t\t\t\tpreparedCon = session.getJdbcCoordinator().getLogicalConnection().getPhysicalConnection();\n\t\t\t\tpreviousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(preparedCon, definition);\n\t\t\t}\n\t\t\telse if (isolationLevelNeeded) {\n\t\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\t\"HibernateJpaDialect is not allowed to support custom isolation levels: \" +\n\t\t\t\t\t\t\"make sure that its 'prepareConnection' flag is on (the default) and that the \" +\n\t\t\t\t\t\t\"Hibernate connection release mode is set to ON_CLOSE.\");\n\t\t\t}\n\t\t}\n\n\t\t// Standard JPA transaction begin call for full JPA context setup...\n\t\tentityManager.getTransaction().begin();\n\n\t\t// Adapt flush mode and store previous isolation level, if any.\n\t\tFlushMode previousFlushMode = prepareFlushMode(session, definition.isReadOnly());\n\t\tif (definition instanceof ResourceTransactionDefinition rtd && rtd.isLocalResource()) {\n\t\t\t// As of 5.1, we explicitly optimize for a transaction-local EntityManager,\n\t\t\t// aligned with native HibernateTransactionManager behavior.\n\t\t\tpreviousFlushMode = null;\n\t\t\tif (definition.isReadOnly()) {\n\t\t\t\tsession.setDefaultReadOnly(true);\n\t\t\t}\n\t\t}\n\t\treturn new SessionTransactionData(\n\t\t\t\tsession, previousFlushMode, (preparedCon != null), previousIsolationLevel, definition.isReadOnly());\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#createContainerEntityManagerFactory(info,properties)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "info",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "EntityManagerFactory",
    "signature": "public EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties)",
    "source_code": "\tpublic EntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo info, Map properties) {\n\t\tfinal List<String> mergedClassesAndPackages = new ArrayList<>(info.getManagedClassNames());\n\t\tif (info instanceof SmartPersistenceUnitInfo smartInfo) {\n\t\t\tmergedClassesAndPackages.addAll(smartInfo.getManagedPackages());\n\t\t}\n\t\treturn new EntityManagerFactoryBuilderImpl(\n\t\t\t\tnew PersistenceUnitInfoDescriptor(info) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic List<String> getManagedClassNames() {\n\t\t\t\t\t\treturn mergedClassesAndPackages;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n\t\t\t\t\t\tif (!NativeDetector.inNativeImage()) {\n\t\t\t\t\t\t\tsuper.pushClassTransformer(enhancementContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, properties).build();\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#getJdbcConnection(entityManager,readOnly)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "ConnectionHandle",
    "signature": "public ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)",
    "source_code": "\tpublic ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly)\n\t\t\tthrows PersistenceException, SQLException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\treturn new HibernateConnectionHandle(session);\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#prepareFlushMode(session,readOnly)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "FlushMode",
    "signature": "protected FlushMode prepareFlushMode(Session session, boolean readOnly)",
    "source_code": "\tprotected FlushMode prepareFlushMode(Session session, boolean readOnly) throws PersistenceException {\n\t\tFlushMode flushMode = session.getHibernateFlushMode();\n\t\tif (readOnly) {\n\t\t\t// We should suppress flushing for a read-only transaction.\n\t\t\tif (!flushMode.equals(FlushMode.MANUAL)) {\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.MANUAL);\n\t\t\t\treturn flushMode;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We need AUTO or COMMIT for a non-read-only transaction.\n\t\t\tif (flushMode.lessThan(FlushMode.COMMIT)) {\n\t\t\t\tsession.setHibernateFlushMode(FlushMode.AUTO);\n\t\t\t\treturn flushMode;\n\t\t\t}\n\t\t}\n\t\t// No FlushMode change needed...\n\t\treturn null;\n\t}"
  },
  "org.springframework.orm.jpa.vendor.<unknown>#prepareTransaction(entityManager,readOnly,name)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entityManager",
      "readOnly",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "Object",
    "signature": "public Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name)",
    "source_code": "\tpublic Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name)\n\t\t\tthrows PersistenceException {\n\n\t\tSessionImplementor session = getSession(entityManager);\n\t\tFlushMode previousFlushMode = prepareFlushMode(session, readOnly);\n\t\treturn new SessionTransactionData(session, previousFlushMode, false, null, readOnly);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(data,offset,length,mimeType,elementNamespace,elementLocalName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "offset",
      "length",
      "mimeType",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 1004
    },
    "return": "String",
    "signature": "public String addMtomAttachment(byte[] data, int offset, int length, String mimeType,\n\t\t\t\tString elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(byte[] data, int offset, int length, String mimeType,\n\t\t\t\tString elementNamespace, String elementLocalName) {\n\t\t\tByteArrayDataSource dataSource = new ByteArrayDataSource(mimeType, data, offset, length);\n\t\t\treturn addMtomAttachment(new DataHandler(dataSource), elementNamespace, elementLocalName);\n\t\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#addMtomAttachment(dataHandler,elementNamespace,elementLocalName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "dataHandler",
      "elementNamespace",
      "elementLocalName"
    ],
    "position": {
      "column": 1,
      "line": 1011
    },
    "return": "String",
    "signature": "public String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName)",
    "source_code": "\t\tpublic String addMtomAttachment(DataHandler dataHandler, String elementNamespace, String elementLocalName) {\n\t\t\tString host = getHost(elementNamespace, dataHandler);\n\t\t\tString contentId = UUID.randomUUID() + \"@\" + host;\n\t\t\tthis.mimeContainer.addAttachment(\"<\" + contentId + \">\", dataHandler);\n\t\t\tcontentId = URLEncoder.encode(contentId, StandardCharsets.UTF_8);\n\t\t\treturn CID + contentId;\n\t\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 722
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic void marshal(Object graph, Result result) throws XmlMappingException {\n\t\tmarshal(graph, result, null);\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#marshal(graph,result,mimeContainer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 727
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic void marshal(Object graph, Result result, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\ttry {\n\t\t\tMarshaller marshaller = createMarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tmarshaller.setAttachmentMarshaller(new Jaxb2AttachmentMarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxResult(result)) {\n\t\t\t\tmarshalStaxResult(marshaller, graph, result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmarshaller.marshal(graph, result);\n\t\t\t}\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setAdapters(XmlAdapter<?,adapters)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the {@code XmlAdapter}s to be registered with the JAXB {@code Marshaller}\n\t * and {@code Unmarshaller}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "XmlAdapter<?",
      "adapters"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void setAdapters(XmlAdapter<?, ?>... adapters)",
    "source_code": "\tpublic void setAdapters(XmlAdapter<?, ?>... adapters) {\n\t\tthis.adapters = adapters;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setJaxbContextProperties(Map<String,jaxbContextProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the {@code JAXBContext} properties. These implementation-specific\n\t * properties will be set on the underlying {@code JAXBContext}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "jaxbContextProperties"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "void",
    "signature": "public void setJaxbContextProperties(Map<String, ?> jaxbContextProperties)",
    "source_code": "\tpublic void setJaxbContextProperties(Map<String, ?> jaxbContextProperties) {\n\t\tthis.jaxbContextProperties = jaxbContextProperties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setMarshallerProperties(Map<String,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Marshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Marshaller},\n\t * and allow for features such as indentation.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Marshaller#setProperty(String, Object)\n\t * @see jakarta.xml.bind.Marshaller#JAXB_ENCODING\n\t * @see jakarta.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT\n\t * @see jakarta.xml.bind.Marshaller#JAXB_NO_NAMESPACE_SCHEMA_LOCATION\n\t * @see jakarta.xml.bind.Marshaller#JAXB_SCHEMA_LOCATION\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "public void setMarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setMarshallerProperties(Map<String, ?> properties) {\n\t\tthis.marshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#setUnmarshallerProperties(Map<String,properties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the JAXB {@code Unmarshaller} properties.\n\t * <p>These properties will be set on the underlying JAXB {@code Unmarshaller}.\n\t * @param properties the properties\n\t * @see jakarta.xml.bind.Unmarshaller#setProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "properties"
    ],
    "position": {
      "column": 1,
      "line": 307
    },
    "return": "void",
    "signature": "public void setUnmarshallerProperties(Map<String, ?> properties)",
    "source_code": "\tpublic void setUnmarshallerProperties(Map<String, ?> properties) {\n\t\tthis.unmarshallerProperties = properties;\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#unmarshal(source,mimeContainer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "mimeContainer"
    ],
    "position": {
      "column": 1,
      "line": 820
    },
    "return": "Object",
    "signature": "public Object unmarshal(Source source, @Nullable MimeContainer mimeContainer)",
    "source_code": "\tpublic Object unmarshal(Source source, @Nullable MimeContainer mimeContainer) throws XmlMappingException {\n\t\tsource = processSource(source);\n\n\t\ttry {\n\t\t\tUnmarshaller unmarshaller = createUnmarshaller();\n\t\t\tif (this.mtomEnabled && mimeContainer != null) {\n\t\t\t\tunmarshaller.setAttachmentUnmarshaller(new Jaxb2AttachmentUnmarshaller(mimeContainer));\n\t\t\t}\n\t\t\tif (StaxUtils.isStaxSource(source)) {\n\t\t\t\treturn unmarshalStaxSource(unmarshaller, source);\n\t\t\t}\n\t\t\telse if (this.mappedClass != null) {\n\t\t\t\treturn unmarshaller.unmarshal(source, this.mappedClass).getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn unmarshaller.unmarshal(source);\n\t\t\t}\n\t\t}\n\t\tcatch (NullPointerException ex) {\n\t\t\tif (!isSupportDtd()) {\n\t\t\t\tthrow new UnmarshallingFailureException(\"NPE while unmarshalling: \" +\n\t\t\t\t\t\t\"This can happen due to the presence of DTD declarations which are disabled.\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (JAXBException ex) {\n\t\t\tthrow convertJaxbException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.jaxb.<unknown>#unmarshalStaxSource(jaxbUnmarshaller,staxSource)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "jaxbUnmarshaller",
      "staxSource"
    ],
    "position": {
      "column": 1,
      "line": 868
    },
    "return": "Object",
    "signature": "protected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource)",
    "source_code": "\tprotected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException {\n\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);\n\t\tif (streamReader != null) {\n\t\t\treturn (this.mappedClass != null ?\n\t\t\t\t\tjaxbUnmarshaller.unmarshal(streamReader, this.mappedClass).getValue() :\n\t\t\t\t\tjaxbUnmarshaller.unmarshal(streamReader));\n\t\t}\n\t\telse {\n\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);\n\t\t\tif (eventReader != null) {\n\t\t\t\treturn (this.mappedClass != null ?\n\t\t\t\t\t\tjaxbUnmarshaller.unmarshal(eventReader, this.mappedClass).getValue() :\n\t\t\t\t\t\tjaxbUnmarshaller.unmarshal(eventReader));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxSource contains neither XMLStreamReader nor XMLEventReader\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshal(graph,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marshals the object graph with the given root into the provided {@code javax.xml.transform.Result}.\n\t * <p>This implementation inspects the given result, and calls {@code marshalDomResult},\n\t * {@code marshalSaxResult}, or {@code marshalStreamResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param result the result to marshal to\n\t * @throws IOException if an I/O exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code result} if neither a {@code DOMResult},\n\t * a {@code SAXResult}, nor a {@code StreamResult}\n\t * @see #marshalDomResult(Object, javax.xml.transform.dom.DOMResult)\n\t * @see #marshalSaxResult(Object, javax.xml.transform.sax.SAXResult)\n\t * @see #marshalStreamResult(Object, javax.xml.transform.stream.StreamResult)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "void",
    "signature": "public void marshal(Object graph, Result result)",
    "source_code": "\tpublic final void marshal(Object graph, Result result) throws IOException, XmlMappingException {\n\t\tif (result instanceof DOMResult domResult) {\n\t\t\tmarshalDomResult(graph, domResult);\n\t\t}\n\t\telse if (StaxUtils.isStaxResult(result)) {\n\t\t\tmarshalStaxResult(graph, result);\n\t\t}\n\t\telse if (result instanceof SAXResult saxResult) {\n\t\t\tmarshalSaxResult(graph, saxResult);\n\t\t}\n\t\telse if (result instanceof StreamResult streamResult) {\n\t\t\tmarshalStreamResult(graph, streamResult);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Result type: \" + result.getClass());\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalDomNode(graph,node)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a DOM {@code Node}.\n\t * <p>In practice, {@code node} is a {@code Document} node, a {@code DocumentFragment} node,\n\t * or a {@code Element} node. In other words, a node that accepts children.\n\t * @param graph the root of the object graph to marshal\n\t * @param node the DOM node that will contain the result tree\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t * @see org.w3c.dom.Document\n\t * @see org.w3c.dom.DocumentFragment\n\t * @see org.w3c.dom.Element\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "node"
    ],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "void",
    "signature": "protected void marshalDomNode(Object graph, Node node)",
    "source_code": "\tprotected abstract void marshalDomNode(Object graph, Node node)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}."
  },
  "org.springframework.oxm.support.<unknown>#marshalDomResult(graph,domResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code DOMResult}s.\n\t * <p>This implementation delegates to {@code marshalDomNode}.\n\t * @param graph the root of the object graph to marshal\n\t * @param domResult the {@code DOMResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "domResult"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void marshalDomResult(Object graph, DOMResult domResult)",
    "source_code": "\tprotected void marshalDomResult(Object graph, DOMResult domResult) throws XmlMappingException {\n\t\tif (domResult.getNode() == null) {\n\t\t\tdomResult.setNode(buildDocument());\n\t\t}\n\t\tmarshalDomNode(graph, domResult.getNode());\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalOutputStream(graph,outputStream)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}.\n\t * @param graph the root of the object graph to marshal\n\t * @param outputStream the {@code OutputStream} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 554
    },
    "return": "void",
    "signature": "protected void marshalOutputStream(Object graph, OutputStream outputStream)",
    "source_code": "\tprotected abstract void marshalOutputStream(Object graph, OutputStream outputStream)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code Writer}."
  },
  "org.springframework.oxm.support.<unknown>#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}.\n\t * @param graph the root of the object graph to marshal\n\t * @param contentHandler the SAX {@code ContentHandler}\n\t * @param lexicalHandler the SAX2 {@code LexicalHandler}. Can be {@code null}.\n\t * @throws XmlMappingException if the given object cannot be marshalled to the handlers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 543
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected abstract void marshalSaxHandlers(\n\t\t\tObject graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code OutputStream}."
  },
  "org.springframework.oxm.support.<unknown>#marshalSaxResult(graph,saxResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code SAXResult}s.\n\t * <p>This implementation delegates to {@code marshalSaxHandlers}.\n\t * @param graph the root of the object graph to marshal\n\t * @param saxResult the {@code SAXResult}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @see #marshalSaxHandlers(Object, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "saxResult"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "void",
    "signature": "protected void marshalSaxResult(Object graph, SAXResult saxResult)",
    "source_code": "\tprotected void marshalSaxResult(Object graph, SAXResult saxResult) throws XmlMappingException {\n\t\tContentHandler contentHandler = saxResult.getHandler();\n\t\tAssert.notNull(contentHandler, \"ContentHandler not set on SAXResult\");\n\t\tLexicalHandler lexicalHandler = saxResult.getLexicalHandler();\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalStaxResult(graph,staxResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StaxResult}s.\n\t * <p>This implementation delegates to {@code marshalXMLSteamWriter} or\n\t * {@code marshalXMLEventConsumer}, depending on what is contained in the\n\t * {@code StaxResult}.\n\t * @param graph the root of the object graph to marshal\n\t * @param staxResult a JAXP 1.4 {@link StAXSource}\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if the {@code domResult} is empty\n\t * @see #marshalDomNode(Object, org.w3c.dom.Node)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "staxResult"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "protected void marshalStaxResult(Object graph, Result staxResult)",
    "source_code": "\tprotected void marshalStaxResult(Object graph, Result staxResult) throws XmlMappingException {\n\t\tXMLStreamWriter streamWriter = StaxUtils.getXMLStreamWriter(staxResult);\n\t\tif (streamWriter != null) {\n\t\t\tmarshalXmlStreamWriter(graph, streamWriter);\n\t\t}\n\t\telse {\n\t\t\tXMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);\n\t\t\tif (eventWriter != null) {\n\t\t\t\tmarshalXmlEventWriter(graph, eventWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"StaxResult contains neither XMLStreamWriter nor XMLEventConsumer\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalStreamResult(graph,streamResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method for handling {@code StreamResult}s.\n\t * <p>This implementation delegates to {@code marshalOutputStream} or {@code marshalWriter},\n\t * depending on what is contained in the {@code StreamResult}\n\t * @param graph the root of the object graph to marshal\n\t * @param streamResult the {@code StreamResult}\n\t * @throws IOException if an I/O Exception occurs\n\t * @throws XmlMappingException if the given object cannot be marshalled to the result\n\t * @throws IllegalArgumentException if {@code streamResult} does neither\n\t * contain an {@code OutputStream} nor a {@code Writer}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamResult"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "void",
    "signature": "protected void marshalStreamResult(Object graph, StreamResult streamResult)",
    "source_code": "\tprotected void marshalStreamResult(Object graph, StreamResult streamResult)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (streamResult.getOutputStream() != null) {\n\t\t\tmarshalOutputStream(graph, streamResult.getOutputStream());\n\t\t}\n\t\telse if (streamResult.getWriter() != null) {\n\t\t\tmarshalWriter(graph, streamResult.getWriter());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"StreamResult contains neither OutputStream nor Writer\");\n\t\t}\n\t}"
  },
  "org.springframework.oxm.support.<unknown>#marshalWriter(graph,writer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object graph to a {@code Writer}.\n\t * @param graph the root of the object graph to marshal\n\t * @param writer the {@code Writer} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the writer\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 564
    },
    "return": "void",
    "signature": "protected void marshalWriter(Object graph, Writer writer)",
    "source_code": "\tprotected abstract void marshalWriter(Object graph, Writer writer)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given DOM {@code Node}."
  },
  "org.springframework.oxm.support.<unknown>#marshalXmlEventWriter(graph,eventWriter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param eventWriter the {@code XMLEventWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected abstract void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}."
  },
  "org.springframework.oxm.support.<unknown>#marshalXmlStreamWriter(graph,streamWriter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}.\n\t * @param graph the root of the object graph to marshal\n\t * @param streamWriter the {@code XMLStreamWriter} to write to\n\t * @throws XmlMappingException if the given object cannot be marshalled to the DOM node\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamWriter"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "void",
    "signature": "protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)",
    "source_code": "\tprotected abstract void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)\n\t\t\tthrows XmlMappingException;\n\n\t/**\n\t * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}."
  },
  "org.springframework.oxm.support.<unknown>#unmarshalSaxReader(xmlReader,inputSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Abstract template method for unmarshalling using a given SAX {@code XMLReader}\n\t * and {@code InputSource}.\n\t * @param xmlReader the SAX {@code XMLReader} to parse with\n\t * @param inputSource the input source to parse from\n\t * @return the object graph\n\t * @throws XmlMappingException if the given reader and input source cannot be converted to an object\n\t * @throws IOException if an I/O exception occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xmlReader",
      "inputSource"
    ],
    "position": {
      "column": 1,
      "line": 602
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)",
    "source_code": "\tprotected abstract Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)\n\t\t\tthrows XmlMappingException, IOException;\n\n\t/**\n\t * Abstract template method for unmarshalling from a given {@code InputStream}."
  },
  "org.springframework.oxm.xstream.<unknown>#convertXStreamException(ex,marshalling)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given XStream exception to an appropriate exception from the\n\t * {@code org.springframework.oxm} hierarchy.\n\t * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or\n\t * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.\n\t * @param ex the XStream exception that occurred\n\t * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),\n\t * or unmarshalling ({@code false})\n\t * @return the corresponding {@code XmlMappingException}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "marshalling"
    ],
    "position": {
      "column": 1,
      "line": 873
    },
    "return": "XmlMappingException",
    "signature": "protected XmlMappingException convertXStreamException(Exception ex, boolean marshalling)",
    "source_code": "\tprotected XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {\n\t\tif (ex instanceof StreamException || ex instanceof CannotResolveClassException ||\n\t\t\t\tex instanceof ForbiddenClassException || ex instanceof ConversionException) {\n\t\t\tif (marshalling) {\n\t\t\t\treturn new MarshallingFailureException(\"XStream marshalling exception\", ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new UnmarshallingFailureException(\"XStream unmarshalling exception\", ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// fallback\n\t\t\treturn new UncategorizedMappingException(\"Unknown XStream exception\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalDomNode(graph,node)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "node"
    ],
    "position": {
      "column": 1,
      "line": 671
    },
    "return": "void",
    "signature": "protected void marshalDomNode(Object graph, Node node)",
    "source_code": "\tprotected void marshalDomNode(Object graph, Node node) throws XmlMappingException {\n\t\tHierarchicalStreamWriter streamWriter;\n\t\tif (node instanceof Document document) {\n\t\t\tstreamWriter = new DomWriter(document, this.nameCoder);\n\t\t}\n\t\telse if (node instanceof Element element) {\n\t\t\tstreamWriter = new DomWriter(element, node.getOwnerDocument(), this.nameCoder);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"DOMResult contains neither Document nor Element\");\n\t\t}\n\t\tdoMarshal(graph, streamWriter, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalOutputStream(graph,outputStream)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "outputStream"
    ],
    "position": {
      "column": 1,
      "line": 719
    },
    "return": "void",
    "signature": "public void marshalOutputStream(Object graph, OutputStream outputStream)",
    "source_code": "\tpublic void marshalOutputStream(Object graph, OutputStream outputStream) throws XmlMappingException, IOException {\n\t\tmarshalOutputStream(graph, outputStream, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalOutputStream(graph,outputStream,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "outputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "void",
    "signature": "public void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic void marshalOutputStream(Object graph, OutputStream outputStream, @Nullable DataHolder dataHolder)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (this.streamDriver != null) {\n\t\t\tdoMarshal(graph, this.streamDriver.createWriter(outputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\tmarshalWriter(graph, new OutputStreamWriter(outputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalSaxHandlers(graph,contentHandler,lexicalHandler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "contentHandler",
      "lexicalHandler"
    ],
    "position": {
      "column": 1,
      "line": 710
    },
    "return": "void",
    "signature": "protected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)",
    "source_code": "\tprotected void marshalSaxHandlers(Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)\n\t\t\tthrows XmlMappingException {\n\n\t\tSaxWriter saxWriter = new SaxWriter(this.nameCoder);\n\t\tsaxWriter.setContentHandler(contentHandler);\n\t\tdoMarshal(graph, saxWriter, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalWriter(graph,writer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "writer"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "void",
    "signature": "public void marshalWriter(Object graph, Writer writer)",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer) throws XmlMappingException, IOException {\n\t\tmarshalWriter(graph, writer, null);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalWriter(graph,writer,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "graph",
      "writer",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 739
    },
    "return": "void",
    "signature": "public void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic void marshalWriter(Object graph, Writer writer, @Nullable DataHolder dataHolder)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tif (this.streamDriver != null) {\n\t\t\tdoMarshal(graph, this.streamDriver.createWriter(writer), dataHolder);\n\t\t}\n\t\telse {\n\t\t\tdoMarshal(graph, new CompactWriter(writer), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalXmlEventWriter(graph,eventWriter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "eventWriter"
    ],
    "position": {
      "column": 1,
      "line": 686
    },
    "return": "void",
    "signature": "protected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)",
    "source_code": "\tprotected void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter) throws XmlMappingException {\n\t\tContentHandler contentHandler = StaxUtils.createContentHandler(eventWriter);\n\t\tLexicalHandler lexicalHandler = (contentHandler instanceof LexicalHandler handler ? handler : null);\n\t\tmarshalSaxHandlers(graph, contentHandler, lexicalHandler);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#marshalXmlStreamWriter(graph,streamWriter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "graph",
      "streamWriter"
    ],
    "position": {
      "column": 1,
      "line": 693
    },
    "return": "void",
    "signature": "protected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)",
    "source_code": "\tprotected void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter) throws XmlMappingException {\n\t\ttry {\n\t\t\tStaxWriter writer;\n\t\t\tif (this.streamDriver instanceof StaxDriver staxDriver) {\n\t\t\t\twriter = staxDriver.createStaxWriter(streamWriter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriter = new StaxWriter(new QNameMap(), streamWriter, this.nameCoder);\n\t\t\t}\n\t\t\tdoMarshal(graph, writer, null);\n\t\t}\n\t\tcatch (XMLStreamException ex) {\n\t\t\tthrow convertXStreamException(ex, true);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliases(Map<String,aliases)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the alias/type map, consisting of string aliases mapped to classes.\n\t * <p>Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#alias(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliases"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "void",
    "signature": "public void setAliases(Map<String, ?> aliases)",
    "source_code": "\tpublic void setAliases(Map<String, ?> aliases) {\n\t\tthis.aliases = aliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setAliasesByType(Map<String,aliasesByType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the <em>aliases by type</em> map, consisting of string aliases mapped to classes.\n\t * <p>Any class that is assignable to this type will be aliased to the same name.\n\t * Keys are aliases; values are either {@code Class} instances, or String class names.\n\t * @see XStream#aliasType(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "aliasesByType"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "public void setAliasesByType(Map<String, ?> aliasesByType)",
    "source_code": "\tpublic void setAliasesByType(Map<String, ?> aliasesByType) {\n\t\tthis.aliasesByType = aliasesByType;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setFieldAliases(Map<String,fieldAliases)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field alias/type map, consisting of field names.\n\t * @see XStream#aliasField(String, Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "fieldAliases"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void setFieldAliases(Map<String, String> fieldAliases)",
    "source_code": "\tpublic void setFieldAliases(Map<String, String> fieldAliases) {\n\t\tthis.fieldAliases = fieldAliases;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setImplicitCollections(Map<Class<?>,implicitCollections)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify implicit collection fields, as a Map consisting of {@code Class} instances\n\t * mapped to comma separated collection field names.\n\t * @see XStream#addImplicitCollection(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "implicitCollections"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setImplicitCollections(Map<Class<?>, String> implicitCollections)",
    "source_code": "\tpublic void setImplicitCollections(Map<Class<?>, String> implicitCollections) {\n\t\tthis.implicitCollections = implicitCollections;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setOmittedFields(Map<Class<?>,omittedFields)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify omitted fields, as a Map consisting of {@code Class} instances\n\t * mapped to comma separated field names.\n\t * @see XStream#omitField(Class, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Class<?>",
      "omittedFields"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "void",
    "signature": "public void setOmittedFields(Map<Class<?>, String> omittedFields)",
    "source_code": "\tpublic void setOmittedFields(Map<Class<?>, String> omittedFields) {\n\t\tthis.omittedFields = omittedFields;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#setUseAttributeFor(Map<?,useAttributeFor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the types to use XML attributes for. The given map can contain\n\t * either {@code <String, Class>} pairs, in which case\n\t * {@link XStream#useAttributeFor(String, Class)} is called.\n\t * Alternatively, the map can contain {@code <Class, String>}\n\t * or {@code <Class, List<String>>} pairs, which results\n\t * in {@link XStream#useAttributeFor(Class, String)} calls.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "useAttributeFor"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "void",
    "signature": "public void setUseAttributeFor(Map<?, ?> useAttributeFor)",
    "source_code": "\tpublic void setUseAttributeFor(Map<?, ?> useAttributeFor) {\n\t\tthis.useAttributeFor = useAttributeFor;\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalInputStream(inputStream,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 831
    },
    "return": "Object",
    "signature": "public Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalInputStream(InputStream inputStream, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\tif (this.streamDriver != null) {\n\t\t\treturn doUnmarshal(this.streamDriver.createReader(inputStream), dataHolder);\n\t\t}\n\t\telse {\n\t\t\treturn unmarshalReader(new InputStreamReader(inputStream, this.encoding), dataHolder);\n\t\t}\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalReader(reader,dataHolder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reader",
      "dataHolder"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "Object",
    "signature": "public Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder)",
    "source_code": "\tpublic Object unmarshalReader(Reader reader, @Nullable DataHolder dataHolder) throws XmlMappingException, IOException {\n\t\treturn doUnmarshal(getDefaultDriver().createReader(reader), dataHolder);\n\t}"
  },
  "org.springframework.oxm.xstream.<unknown>#unmarshalSaxReader(xmlReader,inputSource)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "xmlReader",
      "inputSource"
    ],
    "position": {
      "column": 1,
      "line": 819
    },
    "return": "Object",
    "signature": "protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)",
    "source_code": "\tprotected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)\n\t\t\tthrows XmlMappingException, IOException {\n\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"XStreamMarshaller does not support unmarshalling using SAX XMLReaders\");\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#convertR2dbcException(task,sql,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given {@link R2dbcException} into a generic {@link DataAccessException}.\n\t * <p>The returned DataAccessException is supposed to contain the original\n\t * {@link R2dbcException} as root cause. However, client code may not generally\n\t * rely on this due to DataAccessExceptions possibly being caused by other resource\n\t * APIs as well. That said, a {@code getRootCause() instanceof R2dbcException}\n\t * check (and subsequent cast) is considered reliable when expecting R2DBC-based\n\t * access to have happened.\n\t * @param task readable text describing the task being attempted\n\t * @param sql the SQL query or update that caused the problem (if known)\n\t * @param ex the offending {@link R2dbcException}\n\t * @return the corresponding DataAccessException instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "sql",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "DataAccessException",
    "signature": "public DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex)",
    "source_code": "\tpublic static DataAccessException convertR2dbcException(String task, @Nullable String sql, R2dbcException ex) {\n\t\tif (ex instanceof R2dbcTransientException) {\n\t\t\tif (ex instanceof R2dbcTransientResourceException) {\n\t\t\t\treturn new TransientDataAccessResourceException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcRollbackException) {\n\t\t\t\tif (\"40001\".equals(ex.getSqlState())) {\n\t\t\t\t\treturn new CannotAcquireLockException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new PessimisticLockingFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcTimeoutException) {\n\t\t\t\treturn new QueryTimeoutException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof R2dbcNonTransientException) {\n\t\t\tif (ex instanceof R2dbcNonTransientResourceException) {\n\t\t\t\treturn new DataAccessResourceFailureException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcDataIntegrityViolationException) {\n\t\t\t\tif (indicatesDuplicateKey(ex.getSqlState(), ex.getErrorCode())) {\n\t\t\t\t\treturn new DuplicateKeyException(buildMessage(task, sql, ex), ex);\n\t\t\t\t}\n\t\t\t\treturn new DataIntegrityViolationException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcPermissionDeniedException) {\n\t\t\t\treturn new PermissionDeniedDataAccessException(buildMessage(task, sql, ex), ex);\n\t\t\t}\n\t\t\tif (ex instanceof R2dbcBadGrammarException) {\n\t\t\t\treturn new BadSqlGrammarException(task, (sql != null ? sql : \"\"), ex);\n\t\t\t}\n\t\t}\n\t\treturn new UncategorizedR2dbcException(buildMessage(task, sql, ex), sql, ex);\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doBegin(synchronizationManager,transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,\n\t\t\tTransactionDefinition definition)",
    "source_code": "\tprotected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,\n\t\t\tTransactionDefinition definition) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED &&\n\t\t\t\ttxObject.isTransactionActive()) {\n\t\t\treturn txObject.createSavepoint();\n\t\t}\n\n\t\treturn Mono.defer(() -> {\n\t\t\tMono<Connection> connectionMono;\n\n\t\t\tif (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n\t\t\t\tMono<Connection> newCon = Mono.from(obtainConnectionFactory().create());\n\t\t\t\tconnectionMono = newCon.doOnNext(connection -> {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Acquired Connection [\" + connection + \"] for R2DBC transaction\");\n\t\t\t\t\t}\n\t\t\t\t\ttxObject.setConnectionHolder(new ConnectionHolder(connection), true);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttxObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n\t\t\t\tconnectionMono = Mono.just(txObject.getConnectionHolder().getConnection());\n\t\t\t}\n\n\t\t\treturn connectionMono.flatMap(con -> doBegin(con, txObject, definition)\n\t\t\t\t\t.then(prepareTransactionalConnection(con, definition))\n\t\t\t\t\t.doOnSuccess(v -> {\n\t\t\t\t\t\ttxObject.getConnectionHolder().setTransactionActive(true);\n\t\t\t\t\t\tDuration timeout = determineTimeout(definition);\n\t\t\t\t\t\tif (!timeout.isNegative() && !timeout.isZero()) {\n\t\t\t\t\t\t\ttxObject.getConnectionHolder().setTimeoutInMillis(timeout.toMillis());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Bind the connection holder to the thread.\n\t\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\t\tsynchronizationManager.bindResource(obtainConnectionFactory(), txObject.getConnectionHolder());\n\t\t\t\t\t\t}\n\t\t\t\t\t}).thenReturn(con).onErrorResume(ex -> {\n\t\t\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\t\t\treturn ConnectionFactoryUtils.releaseConnection(con, obtainConnectionFactory())\n\t\t\t\t\t\t\t\t\t.doOnTerminate(() -> txObject.setConnectionHolder(null, false))\n\t\t\t\t\t\t\t\t\t.then(Mono.error(ex));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Mono.error(ex);\n\t\t\t\t\t})).onErrorMap(ex -> new CannotCreateTransactionException(\n\t\t\t\t\t\t\t\"Could not open R2DBC Connection for transaction\", ex));\n\t\t}).then();\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCleanupAfterCompletion(synchronizationManager,transaction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,\n\t\t\tObject transaction)",
    "source_code": "\tprotected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,\n\t\t\tObject transaction) {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\n\t\t\tif (txObject.hasSavepoint()) {\n\t\t\t\t// Just release the savepoint, keeping the transactional connection.\n\t\t\t\treturn txObject.releaseSavepoint();\n\t\t\t}\n\n\t\t\t// Remove the connection holder from the context, if exposed.\n\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\tsynchronizationManager.unbindResource(obtainConnectionFactory());\n\t\t\t}\n\n\t\t\t// Reset connection.\n\t\t\ttry {\n\t\t\t\tif (txObject.isNewConnectionHolder()) {\n\t\t\t\t\tConnection con = txObject.getConnectionHolder().getConnection();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Releasing R2DBC Connection [\" + con + \"] after transaction\");\n\t\t\t\t\t}\n\t\t\t\t\tMono<Void> restoreMono = Mono.empty();\n\t\t\t\t\tif (txObject.isMustRestoreAutoCommit() && !con.isAutoCommit()) {\n\t\t\t\t\t\trestoreMono = Mono.from(con.setAutoCommit(true));\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\trestoreMono = restoreMono.doOnError(ex ->\n\t\t\t\t\t\t\t\t\tlogger.debug(String.format(\"Error ignored during auto-commit restore: %s\", ex)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\trestoreMono = restoreMono.onErrorComplete();\n\t\t\t\t\t}\n\t\t\t\t\tMono<Void> releaseMono = ConnectionFactoryUtils.releaseConnection(con, obtainConnectionFactory());\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\treleaseMono = releaseMono.doOnError(ex ->\n\t\t\t\t\t\t\t\tlogger.debug(String.format(\"Error ignored during connection release: %s\", ex)));\n\t\t\t\t\t}\n\t\t\t\t\treleaseMono = releaseMono.onErrorComplete();\n\t\t\t\t\treturn restoreMono.then(releaseMono);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttxObject.getConnectionHolder().clear();\n\t\t\t}\n\n\t\t\treturn Mono.empty();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doCommit(TransactionSynchronizationManager,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doCommit(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Committing R2DBC transaction on Connection [\" +\n\t\t\t\t\ttxObject.getConnectionHolder().getConnection() + \"]\");\n\t\t}\n\t\treturn txObject.commit().onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC commit\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doReleaseConnection(connection,connectionFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually close the given {@link Connection}, obtained from the given\n\t * {@link ConnectionFactory}. Same as {@link #releaseConnection},\n\t * but preserving the original exception.\n\t * @param connection the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #doGetConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "connection",
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 185
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Void> doReleaseConnection(Connection connection, ConnectionFactory connectionFactory) {\n\t\treturn TransactionSynchronizationManager.forCurrentTransaction().flatMap(synchronizationManager -> {\n\t\t\tConnectionHolder conHolder = (ConnectionHolder) synchronizationManager.getResource(connectionFactory);\n\t\t\tif (conHolder != null && connectionEquals(conHolder, connection)) {\n\t\t\t\t// It's the transactional Connection: Don't close it.\n\t\t\t\tconHolder.released();\n\t\t\t\treturn Mono.empty();\n\t\t\t}\n\t\t\treturn Mono.from(connection.close());\n\t\t}).onErrorResume(NoTransactionException.class, ex -> Mono.from(connection.close()));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doResume(synchronizationManager,transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager,\n\t\t\t@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager,\n\t\t\t@Nullable Object transaction, Object suspendedResources) {\n\n\t\treturn Mono.defer(() -> {\n\t\t\tsynchronizationManager.bindResource(obtainConnectionFactory(), suspendedResources);\n\t\t\treturn Mono.empty();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doRollback(TransactionSynchronizationManager,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "TransactionSynchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doRollback(TransactionSynchronizationManager TransactionSynchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\tif (status.isDebug()) {\n\t\t\tlogger.debug(\"Rolling back R2DBC transaction on Connection [\" +\n\t\t\t\t\ttxObject.getConnectionHolder().getConnection() + \"]\");\n\t\t}\n\t\treturn txObject.rollback().onErrorMap(R2dbcException.class, ex -> translateException(\"R2DBC rollback\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doSetRollbackOnly(synchronizationManager,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status)",
    "source_code": "\tprotected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,\n\t\t\tGenericReactiveTransaction status) {\n\n\t\treturn Mono.fromRunnable(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) status.getTransaction();\n\t\t\tif (status.isDebug()) {\n\t\t\t\tlogger.debug(\"Setting R2DBC transaction [\" + txObject.getConnectionHolder().getConnection() +\n\t\t\t\t\t\t\"] rollback-only\");\n\t\t\t}\n\t\t\ttxObject.setRollbackOnly();\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#doSuspend(synchronizationManager,transaction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "synchronizationManager",
      "transaction"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction)",
    "source_code": "\tprotected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction) {\n\t\treturn Mono.defer(() -> {\n\t\t\tConnectionFactoryTransactionObject txObject = (ConnectionFactoryTransactionObject) transaction;\n\t\t\ttxObject.setConnectionHolder(null);\n\t\t\treturn Mono.justOrEmpty(synchronizationManager.unbindResource(obtainConnectionFactory()));\n\t\t});\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> proxy == args[0];\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\tcase \"unwrap\" -> this.target;\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> Mono.empty();\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.target, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#prepareTransactionalConnection(con,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the transactional {@link Connection} right after transaction begin.\n\t * <p>The default implementation executes a \"SET TRANSACTION READ ONLY\" statement if the\n\t * {@link #setEnforceReadOnly \"enforceReadOnly\"} flag is set to {@code true} and the\n\t * transaction definition indicates a read-only transaction.\n\t * <p>The \"SET TRANSACTION READ ONLY\" is understood by Oracle, MySQL and Postgres\n\t * and may work with other databases as well. If you'd like to adapt this treatment,\n\t * override this method accordingly.\n\t * @param con the transactional R2DBC Connection\n\t * @param definition the current transaction definition\n\t * @since 5.3.22\n\t * @see #setEnforceReadOnly\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "con",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> prepareTransactionalConnection(Connection con, TransactionDefinition definition)",
    "source_code": "\tprotected Mono<Void> prepareTransactionalConnection(Connection con, TransactionDefinition definition) {\n\t\tMono<Void> prepare = Mono.empty();\n\t\tif (isEnforceReadOnly() && definition.isReadOnly()) {\n\t\t\tprepare = Mono.from(con.createStatement(\"SET TRANSACTION READ ONLY\").execute())\n\t\t\t\t\t.flatMapMany(Result::getRowsUpdated)\n\t\t\t\t\t.then();\n\t\t}\n\t\treturn prepare;\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#releaseConnection(con,connectionFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close the given {@link Connection}, obtained from the given {@link ConnectionFactory}, if\n\t * it is not managed externally (that is, not bound to the subscription).\n\t * @param con the {@link Connection} to close if necessary\n\t * @param connectionFactory the {@link ConnectionFactory} that the Connection was obtained from\n\t * @see #getConnection\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "con",
      "connectionFactory"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory)",
    "source_code": "\tpublic static Mono<Void> releaseConnection(Connection con, ConnectionFactory connectionFactory) {\n\t\treturn doReleaseConnection(con, connectionFactory)\n\t\t\t\t.onErrorMap(ex -> new DataAccessResourceFailureException(\"Failed to close R2DBC Connection\", ex));\n\t}"
  },
  "org.springframework.r2dbc.connection.<unknown>#translateException(task,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Translate the given R2DBC commit/rollback exception to a common Spring exception to propagate\n\t * from the {@link #commit}/{@link #rollback} call.\n\t * @param task the task description (commit or rollback).\n\t * @param ex the SQLException thrown from commit/rollback.\n\t * @return the translated exception to emit\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "RuntimeException",
    "signature": "protected RuntimeException translateException(String task, R2dbcException ex)",
    "source_code": "\tprotected RuntimeException translateException(String task, R2dbcException ex) {\n\t\treturn ConnectionFactoryUtils.convertR2dbcException(task, null, ex);\n\t}"
  },
  "org.springframework.r2dbc.connection.lookup.<unknown>#setTargetConnectionFactories(Map<?,targetConnectionFactories)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the map of target {@link ConnectionFactory ConnectionFactories},\n\t * with the lookup key as key. The mapped value can either be a corresponding\n\t * {@link ConnectionFactory} instance or a connection factory name String (to be\n\t * resolved via a {@link #setConnectionFactoryLookup ConnectionFactoryLookup}).\n\t * <p>The key can be of arbitrary type; this class implements the generic lookup\n\t * process only. The concrete key representation will be handled by\n\t * {@link #resolveSpecifiedLookupKey(Object)} and {@link #determineCurrentLookupKey()}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "targetConnectionFactories"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "void",
    "signature": "public void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories)",
    "source_code": "\tpublic void setTargetConnectionFactories(Map<?, ?> targetConnectionFactories) {\n\t\tthis.targetConnectionFactories = targetConnectionFactories;\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(identifier,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 593
    },
    "return": "void",
    "signature": "public void bind(String identifier, Object value)",
    "source_code": "\t\tpublic void bind(String identifier, Object value) {\n\t\t\tthis.statement.bind(identifier, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(index,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "public void bind(int index, Object value)",
    "source_code": "\t\tpublic void bind(int index, Object value) {\n\t\t\tthis.statement.bind(index, value);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bind(String name, Object value)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bind(String name, Object value) {\n\t\t\tassertNotPreparedOperation();\n\n\t\t\tAssert.hasText(name, \"Parameter name must not be null or empty\");\n\t\t\tAssert.notNull(value, () -> String.format(\n\t\t\t\t\t\"Value for parameter %s must not be null. Use bindNull(\u2026) instead.\", name));\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tbyName.put(name, resolveParameter(value));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bind(target,identifier,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "identifier",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "public void bind(BindTarget target, String identifier, Parameter parameter)",
    "source_code": "\t\tpublic void bind(BindTarget target, String identifier, Parameter parameter) {\n\t\t\tList<BindMarker> bindMarkers = getBindMarkers(identifier);\n\t\t\tif (bindMarkers == null) {\n\t\t\t\ttarget.bind(identifier, parameter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (parameter.getValue() instanceof Collection collection) {\n\t\t\t\tIterator<Object> iterator = collection.iterator();\n\t\t\t\tIterator<BindMarker> markers = bindMarkers.iterator();\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tObject valueToBind = iterator.next();\n\t\t\t\t\tif (valueToBind instanceof Object[] objects) {\n\t\t\t\t\t\tfor (Object object : objects) {\n\t\t\t\t\t\t\tbind(target, markers, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbind(target, markers, valueToBind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (BindMarker bindMarker : bindMarkers) {\n\t\t\t\t\tbindMarker.bind(target, parameter);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(identifier,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "identifier",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 603
    },
    "return": "void",
    "signature": "public void bindNull(String identifier, Class<?> type)",
    "source_code": "\t\tpublic void bindNull(String identifier, Class<?> type) {\n\t\t\tthis.statement.bindNull(identifier, type);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(index,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "void",
    "signature": "public void bindNull(int index, Class<?> type)",
    "source_code": "\t\tpublic void bindNull(int index, Class<?> type) {\n\t\t\tthis.statement.bindNull(index, type);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(name,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "DefaultGenericExecuteSpec",
    "signature": "public DefaultGenericExecuteSpec bindNull(String name, Class<?> type)",
    "source_code": "\t\tpublic DefaultGenericExecuteSpec bindNull(String name, Class<?> type) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.hasText(name, \"Parameter name must not be null or empty\");\n\n\t\t\tMap<String, Parameter> byName = new LinkedHashMap<>(this.byName);\n\t\t\tbyName.put(name, Parameters.in(type));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, byName, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindNull(target,identifier,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "identifier",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "void",
    "signature": "public void bindNull(BindTarget target, String identifier, Parameter parameter)",
    "source_code": "\t\tpublic void bindNull(BindTarget target, String identifier, Parameter parameter) {\n\t\t\tList<BindMarker> bindMarkers = getBindMarkers(identifier);\n\t\t\tif (bindMarkers == null) {\n\t\t\t\ttarget.bind(identifier, parameter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (BindMarker bindMarker : bindMarkers) {\n\t\t\t\tbindMarker.bind(target, parameter);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#bindValues(Map<String,source)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "GenericExecuteSpec",
    "signature": "public GenericExecuteSpec bindValues(Map<String, ?> source)",
    "source_code": "\t\tpublic GenericExecuteSpec bindValues(Map<String, ?> source) {\n\t\t\tassertNotPreparedOperation();\n\t\t\tAssert.notNull(source, \"Parameter source must not be null\");\n\n\t\t\tMap<String, Parameter> target = new LinkedHashMap<>(this.byName);\n\t\t\tsource.forEach((name, value) -> target.put(name, resolveParameter(value)));\n\n\t\t\treturn new DefaultGenericExecuteSpec(this.byIndex, target, this.sqlSupplier, this.filterFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#constructMappedInstance(readable,itemMetadatas,tc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Construct an instance of the mapped class for the current {@code Readable}.\n\t * <p>The default implementation simply instantiates the mapped class. Can be\n\t * overridden in subclasses.\n\t * @param readable the {@code Readable} being mapped (a {@code Row} or {@code OutParameters})\n\t * @param itemMetadatas the list of item {@code ReadableMetadata} (either\n\t * {@code ColumnMetadata} or {@code OutParameterMetadata})\n\t * @param tc a TypeConverter with this row mapper's conversion service\n\t * @return a corresponding instance of the mapped class\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemMetadatas",
      "tc"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "T",
    "signature": "protected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc)",
    "source_code": "\tprotected T constructMappedInstance(Readable readable, List<? extends ReadableMetadata> itemMetadatas, TypeConverter tc) {\n\t\treturn BeanUtils.instantiateClass(this.mappedClass);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#flatMap(Function<Result,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Result",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "Flux<R>",
    "signature": "public Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction)",
    "source_code": "\t\tpublic <R> Flux<R> flatMap(Function<Result, Publisher<R>> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn flatMap(this.sqlSupplier, mappingFunction);\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#fromOrEmpty(value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link Parameter} from {@code value} and {@code type}.\n\t * @param value the parameter value (can be {@code null})\n\t * @param type the parameter type\n\t * @return the {@link Parameter} value for {@code value}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "Parameter",
    "signature": "public Parameter fromOrEmpty(@Nullable Object value, Class<?> type)",
    "source_code": "\tpublic static Parameter fromOrEmpty(@Nullable Object value, Class<?> type) {\n\t\treturn (value == null ? empty(type) : new Parameter(value, ClassUtils.getUserClass(value)));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#getItemValue(readable,itemIndex,paramType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve an R2DBC object value for the specified item index (a column or\n\t * an out-parameter).\n\t * <p>The default implementation calls {@link Readable#get(int, Class)} then\n\t * falls back to {@link Readable#get(int)} in case of an exception.\n\t * Subclasses may override this to check specific value types upfront,\n\t * or to post-process values returned from {@code get}.\n\t * @param readable is the {@code Row} or {@code OutParameters} holding the data\n\t * @param itemIndex is the column index or out-parameter index\n\t * @param paramType the target parameter type\n\t * @return the Object value\n\t * @see Readable#get(int, Class)\n\t * @see Readable#get(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "readable",
      "itemIndex",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "Object",
    "signature": "protected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType)",
    "source_code": "\tprotected Object getItemValue(Readable readable, int itemIndex, Class<?> paramType) {\n\t\ttry {\n\t\t\treturn readable.get(itemIndex, paramType);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\treturn readable.get(itemIndex);\n\t\t}\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnection(Function<Connection,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> inConnection(Function<Connection, Mono<T>> action)",
    "source_code": "\tpublic <T> Mono<T> inConnection(Function<Connection, Mono<T>> action) {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Mono.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Mono.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnection\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"execute\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#inConnectionMany(Function<Connection,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Connection",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> inConnectionMany(Function<Connection, Flux<T>> action)",
    "source_code": "\tpublic <T> Flux<T> inConnectionMany(Function<Connection, Flux<T>> action) {\n\t\tAssert.notNull(action, \"Callback object must not be null\");\n\t\tMono<ConnectionCloseHolder> connectionMono = getConnection().map(\n\t\t\t\tconnection -> new ConnectionCloseHolder(connection, this::closeConnection));\n\n\t\treturn Flux.usingWhen(connectionMono, connectionCloseHolder -> {\n\t\t\t// Create close-suppressing Connection proxy, also preparing returned Statements.\n\t\t\tConnection connectionToUse = createConnectionProxy(connectionCloseHolder.connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn action.apply(connectionToUse);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (R2dbcException ex) {\n\t\t\t\t\t\tString sql = getSql(action);\n\t\t\t\t\t\treturn Flux.error(ConnectionFactoryUtils.convertR2dbcException(\"doInConnectionMany\", sql, ex));\n\t\t\t\t\t}\n\t\t\t\t}, ConnectionCloseHolder::close, (it, err) -> it.close(),\n\t\t\t\tConnectionCloseHolder::close)\n\t\t\t\t.onErrorMap(R2dbcException.class,\n\t\t\t\t\t\tex -> ConnectionFactoryUtils.convertR2dbcException(\"executeMany\", getSql(action), ex));\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\treturn switch (method.getName()) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\tcase \"equals\" -> proxy == args[0];\n\t\t\t\t// Use hashCode of Connection proxy.\n\t\t\t\tcase \"hashCode\" -> System.identityHashCode(proxy);\n\t\t\t\tcase \"unwrap\" -> this.target;\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\tcase \"close\" -> Mono.error(new UnsupportedOperationException(\"Close is not supported!\"));\n\t\t\t\tdefault -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Invoke method on target Connection.\n\t\t\t\t\t\tyield method.invoke(this.target, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(BiFunction<Row,RowMetadata,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<Row",
      "RowMetadata",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(BiFunction<Row, RowMetadata, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(BiFunction<Row, RowMetadata, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#map(Readable,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Readable",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "FetchSpec<R>",
    "signature": "public FetchSpec<R> map(Function<? super Readable, R> mappingFunction)",
    "source_code": "\t\tpublic <R> FetchSpec<R> map(Function<? super Readable, R> mappingFunction) {\n\t\t\tAssert.notNull(mappingFunction, \"Mapping function must not be null\");\n\t\t\treturn execute(this.sqlSupplier, result -> result.map(mappingFunction));\n\t\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#substituteNamedParameters(parsedSql,bindMarkersFactory,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters. Named\n\t * parameters are substituted for an R2DBC placeholder, and any select list is expanded\n\t * to the required number of placeholders. Select lists may contain an array of objects,\n\t * and in that case the placeholders will be grouped and enclosed with parentheses.\n\t * This allows for the use of \"expression lists\" in the SQL statement like:\n\t * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}\n\t * <p>The parameter values passed in are used to determine the number of\n\t * placeholders to be used for a select list. Select lists should not be empty\n\t * and should be limited to 100 or fewer elements. An empty list or a larger\n\t * number of elements is not guaranteed to be supported by the database and\n\t * is strictly vendor-dependent.\n\t * @param parsedSql the parsed representation of the SQL statement\n\t * @param bindMarkersFactory the bind marker factory.\n\t * @param paramSource the source for named parameters\n\t * @return the expanded query that accepts bind parameters and allows for execution\n\t * without further translation\n\t * @see #parseSqlStatement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parsedSql",
      "bindMarkersFactory",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "PreparedOperation<String>",
    "signature": "public PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource)",
    "source_code": "\tpublic static PreparedOperation<String> substituteNamedParameters(ParsedSql parsedSql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {\n\n\t\tNamedParameters markerHolder = new NamedParameters(bindMarkersFactory);\n\t\tString originalSql = parsedSql.getOriginalSql();\n\t\tList<String> paramNames = parsedSql.getParameterNames();\n\t\tif (paramNames.isEmpty()) {\n\t\t\treturn new ExpandedQuery(originalSql, markerHolder, paramSource);\n\t\t}\n\n\t\tStringBuilder actualSql = new StringBuilder(originalSql.length());\n\t\tint lastIndex = 0;\n\t\tfor (int i = 0; i < paramNames.size(); i++) {\n\t\t\tString paramName = paramNames.get(i);\n\t\t\tint[] indexes = parsedSql.getParameterIndexes(i);\n\t\t\tint startIndex = indexes[0];\n\t\t\tint endIndex = indexes[1];\n\t\t\tactualSql.append(originalSql, lastIndex, startIndex);\n\t\t\tNamedParameters.NamedParameter marker = markerHolder.getOrCreate(paramName);\n\t\t\tif (paramSource.hasValue(paramName)) {\n\t\t\t\tParameter parameter = paramSource.getValue(paramName);\n\t\t\t\tif (parameter.getValue() instanceof Collection<?> collection) {\n\t\t\t\t\tint k = 0;\n\t\t\t\t\tint counter = 0;\n\t\t\t\t\tfor (Object entryItem : collection) {\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif (entryItem instanceof Object[] expressionList) {\n\t\t\t\t\t\t\tactualSql.append('(');\n\t\t\t\t\t\t\tfor (int m = 0; m < expressionList.length; m++) {\n\t\t\t\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\t\t\t\tactualSql.append(\", \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tactualSql.append(marker.getPlaceholder(counter));\n\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tactualSql.append(')');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tactualSql.append(marker.getPlaceholder(counter));\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tactualSql.append(marker.getPlaceholder());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactualSql.append(marker.getPlaceholder());\n\t\t\t}\n\t\t\tlastIndex = endIndex;\n\t\t}\n\t\tactualSql.append(originalSql, lastIndex, originalSql.length());\n\n\t\treturn new ExpandedQuery(actualSql.toString(), markerHolder, paramSource);\n\t}"
  },
  "org.springframework.r2dbc.core.<unknown>#substituteNamedParameters(sql,bindMarkersFactory,paramSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the SQL statement and locate any placeholders or named parameters.\n\t * <p>Named parameters are substituted for a native placeholder and any\n\t * select list is expanded to the required number of placeholders.\n\t * <p>This is a shortcut version of\n\t * {@link #parseSqlStatement(String)} in combination with\n\t * {@link #substituteNamedParameters(ParsedSql, BindMarkersFactory, BindParameterSource)}.\n\t * @param sql the SQL statement\n\t * @param bindMarkersFactory the bind marker factory\n\t * @param paramSource the source for named parameters\n\t * @return the expanded query that accepts bind parameters and allows for execution\n\t * without further translation\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sql",
      "bindMarkersFactory",
      "paramSource"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "PreparedOperation<String>",
    "signature": "public PreparedOperation<String> substituteNamedParameters(String sql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource)",
    "source_code": "\tpublic static PreparedOperation<String> substituteNamedParameters(String sql,\n\t\t\tBindMarkersFactory bindMarkersFactory, BindParameterSource paramSource) {\n\n\t\tParsedSql parsedSql = parseSqlStatement(sql);\n\t\treturn substituteNamedParameters(parsedSql, bindMarkersFactory, paramSource);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#addCallback(successCallback,failureCallback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "successCallback",
      "failureCallback"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback)",
    "source_code": "\tpublic void addCallback(SuccessCallback<? super V> successCallback, FailureCallback failureCallback) {\n\t\ttry {\n\t\t\tif (this.executionException != null) {\n\t\t\t\tfailureCallback.onFailure(exposedException(this.executionException));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsuccessCallback.onSuccess(this.value);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Ignore\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#buildAdvice(executor,exceptionHandler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "executor",
      "exceptionHandler"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "Advice",
    "signature": "protected Advice buildAdvice(@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler)",
    "source_code": "\tprotected Advice buildAdvice(\n\t\t\t@Nullable Supplier<Executor> executor, @Nullable Supplier<AsyncUncaughtExceptionHandler> exceptionHandler) {\n\n\t\tAnnotationAsyncExecutionInterceptor interceptor = new AnnotationAsyncExecutionInterceptor(null);\n\t\tinterceptor.configure(executor, exceptionHandler);\n\t\treturn interceptor;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createRunnable(target,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 5.1\n\t * @deprecated in favor of {@link #createRunnable(Object, Method, String)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 558
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createRunnable(target,method,qualifier)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the given bean instance,\n\t * calling the specified scheduled method.\n\t * <p>The default implementation creates a {@link ScheduledMethodRunnable}.\n\t * @param target the target bean instance\n\t * @param method the scheduled method to call\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "method",
      "qualifier"
    ],
    "position": {
      "column": 1,
      "line": 538
    },
    "return": "Runnable",
    "signature": "protected Runnable createRunnable(Object target, Method method, @Nullable String qualifier)",
    "source_code": "\tprotected Runnable createRunnable(Object target, Method method, @Nullable String qualifier) {\n\t\tRunnable runnable = createRunnable(target, method);\n\t\tif (runnable != null) {\n\t\t\treturn runnable;\n\t\t}\n\t\tAssert.isTrue(method.getParameterCount() == 0, \"Only no-arg methods may be annotated with @Scheduled\");\n\t\tMethod invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass());\n\t\treturn new ScheduledMethodRunnable(target, invocableMethod, qualifier, this.registrar::getObservationRegistry);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#createSubscriptionRunnable(method,targetBean,scheduled,observationRegistrySupplier,subscriptionTrackerRegistry)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link Runnable} for the Scheduled infrastructure, allowing for scheduled\n\t * subscription to the publisher produced by a reactive method.\n\t * <p>Note that the reactive method is invoked once, but the resulting {@code Publisher}\n\t * is subscribed to repeatedly, once per each invocation of the {@code Runnable}.\n\t * <p>In the case of a fixed-delay configuration, the subscription inside the\n\t * {@link Runnable} is turned into a blocking call in order to maintain fixed-delay\n\t * semantics (i.e. the task blocks until completion of the Publisher, and the\n\t * delay is applied until the next iteration).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetBean",
      "scheduled",
      "observationRegistrySupplier",
      "subscriptionTrackerRegistry"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "Runnable",
    "signature": "public Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry)",
    "source_code": "\tpublic static Runnable createSubscriptionRunnable(Method method, Object targetBean, Scheduled scheduled,\n\t\t\tSupplier<ObservationRegistry> observationRegistrySupplier, List<Runnable> subscriptionTrackerRegistry) {\n\n\t\tboolean shouldBlock = (scheduled.fixedDelay() > 0 || StringUtils.hasText(scheduled.fixedDelayString()));\n\t\tPublisher<?> publisher = getPublisherFor(method, targetBean);\n\t\tSupplier<ScheduledTaskObservationContext> contextSupplier =\n\t\t\t\t() -> new ScheduledTaskObservationContext(targetBean, method);\n\t\treturn new SubscribingRunnable(publisher, shouldBlock, scheduled.scheduler(),\n\t\t\t\tsubscriptionTrackerRegistry, observationRegistrySupplier, contextSupplier);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#get(timeout,unit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic V get(long timeout, TimeUnit unit) throws ExecutionException {\n\t\treturn get();\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler ||\n\t\t\t\tbean instanceof ScheduledExecutorService) {\n\t\t\t// Ignore AOP infrastructure such as scoped proxies.\n\t\t\treturn bean;\n\t\t}\n\n\t\tClass<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);\n\t\tif (!this.nonAnnotatedClasses.contains(targetClass) &&\n\t\t\t\tAnnotationUtils.isCandidateClass(targetClass, List.of(Scheduled.class, Schedules.class))) {\n\t\t\tMap<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {\n\t\t\t\t\t\tSet<Scheduled> scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\t\t\tmethod, Scheduled.class, Schedules.class);\n\t\t\t\t\t\treturn (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null);\n\t\t\t\t\t});\n\t\t\tif (annotatedMethods.isEmpty()) {\n\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No @Scheduled annotations found on bean class: \" + targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Non-empty set of methods\n\t\t\t\tannotatedMethods.forEach((method, scheduledAnnotations) ->\n\t\t\t\t\t\tscheduledAnnotations.forEach(scheduled -> processScheduled(scheduled, method, bean)));\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(annotatedMethods.size() + \" @Scheduled methods processed on bean '\" + beanName +\n\t\t\t\t\t\t\t\"': \" + annotatedMethods);\n\t\t\t\t}\n\t\t\t\tif ((this.beanFactory != null &&\n\t\t\t\t\t\t(!this.beanFactory.containsBean(beanName) || !this.beanFactory.isSingleton(beanName)) ||\n\t\t\t\t\t\t(this.beanFactory instanceof SingletonBeanRegistry sbr && sbr.containsSingleton(beanName)))) {\n\t\t\t\t\t// Either a prototype/scoped bean or a FactoryBean with a pre-existing managed singleton\n\t\t\t\t\t// -> trigger manual cancellation when ContextClosedEvent comes in\n\t\t\t\t\tthis.manualCancellationOnContextClose.add(bean);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 598
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) {\n\t\tcancelScheduledTasks(bean);\n\t\tthis.manualCancellationOnContextClose.remove(bean);\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 278
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#postProcessMergedBeanDefinition(beanDefinition,beanType,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanDefinition",
      "beanType",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 274
    },
    "return": "void",
    "signature": "public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)",
    "source_code": "\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n\t}"
  },
  "org.springframework.scheduling.annotation.<unknown>#processScheduled(scheduled,method,bean)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given {@code @Scheduled} method declaration on the given bean,\n\t * attempting to distinguish {@linkplain #processScheduledAsync(Scheduled, Method, Object)\n\t * reactive} methods from {@linkplain #processScheduledSync(Scheduled, Method, Object)\n\t * synchronous} methods.\n\t * @param scheduled the {@code @Scheduled} annotation\n\t * @param method the method that the annotation has been declared on\n\t * @param bean the target bean instance\n\t * @see #processScheduledSync(Scheduled, Method, Object)\n\t * @see #processScheduledAsync(Scheduled, Method, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduled",
      "method",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "protected void processScheduled(Scheduled scheduled, Method method, Object bean)",
    "source_code": "\tprotected void processScheduled(Scheduled scheduled, Method method, Object bean) {\n\t\t// Is the method a Kotlin suspending function? Throws if true and the reactor bridge isn't on the classpath.\n\t\t// Does the method return a reactive type? Throws if true and it isn't a deferred Publisher type.\n\t\tif (reactiveStreamsPresent && ScheduledAnnotationReactiveSupport.isReactive(method)) {\n\t\t\tprocessScheduledAsync(scheduled, method, bean);\n\t\t\treturn;\n\t\t}\n\t\tprocessScheduledSync(scheduled, method, bean);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#afterExecute(task,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An after-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param task the task that has been executed\n\t * @param ex the exception thrown during execution, if any\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#afterExecute(Runnable, Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "task",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "void",
    "signature": "protected void afterExecute(Runnable task, @Nullable Throwable ex)",
    "source_code": "\tprotected void afterExecute(Runnable task, @Nullable Throwable ex) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.afterExecute();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#beforeExecute(thread,task)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A before-execute callback for framework subclasses to delegate to\n\t * (for start/stop handling), and possibly also for custom subclasses\n\t * to extend (making sure to call this implementation as well).\n\t * @param thread the thread to run the task\n\t * @param task the task to be executed\n\t * @since 6.1\n\t * @see ThreadPoolExecutor#beforeExecute(Thread, Runnable)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "thread",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "void",
    "signature": "protected void beforeExecute(Thread thread, Runnable task)",
    "source_code": "\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\tif (this.lifecycleDelegate != null) {\n\t\t\tthis.lifecycleDelegate.beforeExecute(thread);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#buildManagedTask(task,identityName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "identityName"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Callable<T>",
    "signature": "public Callable<T> buildManagedTask(Callable<T> task, String identityName)",
    "source_code": "\t\tpublic static <T> Callable<T> buildManagedTask(Callable<T> task, String identityName) {\n\t\t\tMap<String, String> properties = new HashMap<>(2);\n\t\t\tproperties.put(ManagedTask.IDENTITY_NAME, identityName);\n\t\t\treturn ManagedExecutors.managedTask(task, properties, null);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#createExecutor(poolSize,threadFactory,rejectedExecutionHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link ScheduledExecutorService} instance.\n\t * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.\n\t * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.\n\t * @param poolSize the specified pool size\n\t * @param threadFactory the ThreadFactory to use\n\t * @param rejectedExecutionHandler the RejectedExecutionHandler to use\n\t * @return a new ScheduledExecutorService instance\n\t * @see #afterPropertiesSet()\n\t * @see java.util.concurrent.ScheduledThreadPoolExecutor\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "poolSize",
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "ScheduledExecutorService",
    "signature": "protected ScheduledExecutorService createExecutor(int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected ScheduledExecutorService createExecutor(\n\t\t\tint poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {\n\n\t\treturn new ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler) {\n\t\t\t@Override\n\t\t\tprotected void beforeExecute(Thread thread, Runnable task) {\n\t\t\t\tThreadPoolTaskScheduler.this.beforeExecute(thread, task);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void afterExecute(Runnable task, Throwable ex) {\n\t\t\t\tThreadPoolTaskScheduler.this.afterExecute(task, ex);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#decorateTask(callable,task)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "callable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 252
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#decorateTask(runnable,task)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "runnable",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "RunnableScheduledFuture<V>",
    "signature": "protected RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task)",
    "source_code": "\t\t\tprotected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n\t\t\t\treturn decorateTaskIfNecessary(task);\n\t\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#execute(task,startTimeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "startTimeout"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "void",
    "signature": "public void execute(Runnable task, long startTimeout)",
    "source_code": "\tpublic void execute(Runnable task, long startTimeout) {\n\t\tthis.adaptedExecutor.execute(task, startTimeout);\n\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#get(timeout,unit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "V",
    "signature": "public V get(long timeout, TimeUnit unit)",
    "source_code": "\t\tpublic V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\treturn this.future.get(timeout, unit);\n\t\t}"
  },
  "org.springframework.scheduling.concurrent.<unknown>#initializeExecutor(threadFactory,rejectedExecutionHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target {@link java.util.concurrent.ExecutorService} instance.\n\t * Called by {@code afterPropertiesSet}.\n\t * @param threadFactory the ThreadFactory to use\n\t * @param rejectedExecutionHandler the RejectedExecutionHandler to use\n\t * @return a new ExecutorService instance\n\t * @see #afterPropertiesSet()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "threadFactory",
      "rejectedExecutionHandler"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "ExecutorService",
    "signature": "protected ExecutorService initializeExecutor(ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)",
    "source_code": "\tprotected abstract ExecutorService initializeExecutor(\n\t\t\tThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler);\n\n\n\t/**\n\t * Calls {@code shutdown} when the BeanFactory destroys the executor instance."
  },
  "org.springframework.scheduling.concurrent.<unknown>#registerTasks(tasks,executor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks}\n\t * on the given {@link ScheduledExecutorService}.\n\t * @param tasks the specified ScheduledExecutorTasks (never empty)\n\t * @param executor the ScheduledExecutorService to register the tasks on.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tasks",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor)",
    "source_code": "\tprotected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor) {\n\t\tfor (ScheduledExecutorTask task : tasks) {\n\t\t\tRunnable runnable = getRunnableToSchedule(task);\n\t\t\tif (task.isOneTimeTask()) {\n\t\t\t\texecutor.schedule(runnable, task.getDelay(), task.getTimeUnit());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (task.isFixedRate()) {\n\t\t\t\t\texecutor.scheduleAtFixedRate(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texecutor.scheduleWithFixedDelay(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#TaskExecutionOutcome(executionTime,status,throwable)": {
    "deprecated": false,
    "doc": "/**\n * Outcome of a {@link Task} execution.\n *\n * @author Brian Clozel\n * @since 6.2\n * @param executionTime the instant when the task execution started, or\n * {@code null} if the task has not started\n * @param status the {@link Status} of the execution outcome\n * @param throwable the exception thrown from the task execution, if any\n */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executionTime",
      "status",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 34
    },
    "return": "record",
    "signature": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable)",
    "source_code": "public record TaskExecutionOutcome(@Nullable Instant executionTime, Status status, @Nullable Throwable throwable) {\n\n\tTaskExecutionOutcome start(Instant executionTime) {\n\t\treturn new TaskExecutionOutcome(executionTime, Status.STARTED, null);\n\t}\n\n\tTaskExecutionOutcome success() {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.SUCCESS, null);\n\t}\n\n\tTaskExecutionOutcome failure(Throwable throwable) {\n\t\tAssert.state(this.executionTime != null, \"Task has not been started yet\");\n\t\treturn new TaskExecutionOutcome(this.executionTime, Status.ERROR, throwable);\n\t}\n\n\tstatic TaskExecutionOutcome create() {\n\t\treturn new TaskExecutionOutcome(null, Status.NONE, null);\n\t}\n\n\n\t/**\n\t * Status of the task execution outcome.\n\t */\n\tpublic enum Status {\n\n\t\t/**\n\t\t * The task has not been executed so far.\n\t\t */\n\t\tNONE,\n\n\t\t/**\n\t\t * The task execution has been started and is ongoing.\n\t\t */\n\t\tSTARTED,\n\n\t\t/**\n\t\t * The task execution finished successfully.\n\t\t */\n\t\tSUCCESS,\n\n\t\t/**\n\t\t * The task execution finished with an error.\n\t\t */\n\t\tERROR\n\n\t}\n\n}"
  },
  "org.springframework.scheduling.config.<unknown>#addCronTask(task,expression)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a {@link Runnable} task to be triggered per the given cron {@code expression}.\n\t * <p>This method will not register the task if the {@code expression} is\n\t * equal to {@link #CRON_DISABLED}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "expression"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void addCronTask(Runnable task, String expression)",
    "source_code": "\tpublic void addCronTask(Runnable task, String expression) {\n\t\tif (!CRON_DISABLED.equals(expression)) {\n\t\t\taddCronTask(new CronTask(task, expression));\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addFixedDelayTask(task,interval)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered with the given fixed delay.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void addFixedDelayTask(Runnable task, Duration interval)",
    "source_code": "\tpublic void addFixedDelayTask(Runnable task, Duration interval) {\n\t\taddFixedDelayTask(new IntervalTask(task, interval));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addFixedRateTask(task,interval)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a {@code Runnable} task to be triggered at the given fixed-rate interval.\n\t * @since 6.0\n\t * @see TaskScheduler#scheduleAtFixedRate(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "interval"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "void",
    "signature": "public void addFixedRateTask(Runnable task, Duration interval)",
    "source_code": "\tpublic void addFixedRateTask(Runnable task, Duration interval) {\n\t\taddFixedRateTask(new IntervalTask(task, interval));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addOneTimeTask(task,initialDelay)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered once after the given initial delay.\n\t * @since 6.1\n\t * @see TaskScheduler#schedule(Runnable, Instant)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "initialDelay"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "void",
    "signature": "public void addOneTimeTask(Runnable task, Duration initialDelay)",
    "source_code": "\tpublic void addOneTimeTask(Runnable task, Duration initialDelay) {\n\t\taddOneTimeTask(new OneTimeTask(task, initialDelay));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#addTriggerTask(task,trigger)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a Runnable task to be triggered per the given {@link Trigger}.\n\t * @see TaskScheduler#scheduleAtFixedRate(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "trigger"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "void",
    "signature": "public void addTriggerTask(Runnable task, Trigger trigger)",
    "source_code": "\tpublic void addTriggerTask(Runnable task, Trigger trigger) {\n\t\taddTriggerTask(new TriggerTask(task, trigger));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#doParse(element,parserContext,builder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "element",
      "parserContext",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 42
    },
    "return": "void",
    "signature": "protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)",
    "source_code": "\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tString keepAliveSeconds = element.getAttribute(\"keep-alive\");\n\t\tif (StringUtils.hasText(keepAliveSeconds)) {\n\t\t\tbuilder.addPropertyValue(\"keepAliveSeconds\", keepAliveSeconds);\n\t\t}\n\t\tString queueCapacity = element.getAttribute(\"queue-capacity\");\n\t\tif (StringUtils.hasText(queueCapacity)) {\n\t\t\tbuilder.addPropertyValue(\"queueCapacity\", queueCapacity);\n\t\t}\n\t\tconfigureRejectionPolicy(element, builder);\n\t\tString poolSize = element.getAttribute(\"pool-size\");\n\t\tif (StringUtils.hasText(poolSize)) {\n\t\t\tbuilder.addPropertyValue(\"poolSize\", poolSize);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setCronTasks(Map<Runnable,cronTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and cron expressions.\n\t * @see CronTrigger\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "cronTasks"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "void",
    "signature": "public void setCronTasks(Map<Runnable, String> cronTasks)",
    "source_code": "\tpublic void setCronTasks(Map<Runnable, String> cronTasks) {\n\t\tthis.cronTasks = new ArrayList<>();\n\t\tcronTasks.forEach(this::addCronTask);\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setFixedDelayTasks(Map<Runnable,fixedDelayTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values.\n\t * @see TaskScheduler#scheduleWithFixedDelay(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "fixedDelayTasks"
    ],
    "position": {
      "column": 1,
      "line": 250
    },
    "return": "void",
    "signature": "public void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks)",
    "source_code": "\tpublic void setFixedDelayTasks(Map<Runnable, Long> fixedDelayTasks) {\n\t\tthis.fixedDelayTasks = new ArrayList<>();\n\t\tfixedDelayTasks.forEach((task, delay) -> addFixedDelayTask(task, Duration.ofMillis(delay)));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setFixedRateTasks(Map<Runnable,fixedRateTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-rate values.\n\t * @see TaskScheduler#scheduleAtFixedRate(Runnable, Duration)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "fixedRateTasks"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void setFixedRateTasks(Map<Runnable, Long> fixedRateTasks)",
    "source_code": "\tpublic void setFixedRateTasks(Map<Runnable, Long> fixedRateTasks) {\n\t\tthis.fixedRateTasks = new ArrayList<>();\n\t\tfixedRateTasks.forEach((task, interval) -> addFixedRateTask(task, Duration.ofMillis(interval)));\n\t}"
  },
  "org.springframework.scheduling.config.<unknown>#setTriggerTasks(Map<Runnable,triggerTasks)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify triggered tasks as a Map of Runnables (the tasks) and Trigger objects\n\t * (typically custom implementations of the {@link Trigger} interface).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<Runnable",
      "triggerTasks"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "void",
    "signature": "public void setTriggerTasks(Map<Runnable, Trigger> triggerTasks)",
    "source_code": "\tpublic void setTriggerTasks(Map<Runnable, Trigger> triggerTasks) {\n\t\tthis.triggerTasks = new ArrayList<>();\n\t\ttriggerTasks.forEach((task, trigger) -> addTriggerTask(new TriggerTask(task, trigger)));\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#createScheduler(schedulerFactory,schedulerName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the Scheduler instance for the given factory and scheduler name.\n\t * Called by {@link #afterPropertiesSet}.\n\t * <p>The default implementation invokes SchedulerFactory's {@code getScheduler}\n\t * method. Can be overridden for custom Scheduler creation.\n\t * @param schedulerFactory the factory to create the Scheduler with\n\t * @param schedulerName the name of the scheduler to create\n\t * @return the Scheduler instance\n\t * @throws SchedulerException if thrown by Quartz methods\n\t * @see #afterPropertiesSet\n\t * @see org.quartz.SchedulerFactory#getScheduler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "schedulerFactory",
      "schedulerName"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "Scheduler",
    "signature": "protected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)",
    "source_code": "\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)\n\t\t\tthrows SchedulerException {\n\n\t\t// Override thread context ClassLoader to work around naive Quartz ClassLoadHelper loading.\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tboolean overrideClassLoader = (this.resourceLoader != null &&\n\t\t\t\tthis.resourceLoader.getClassLoader() != threadContextClassLoader);\n\t\tif (overrideClassLoader) {\n\t\t\tcurrentThread.setContextClassLoader(this.resourceLoader.getClassLoader());\n\t\t}\n\t\ttry {\n\t\t\tSchedulerRepository repository = SchedulerRepository.getInstance();\n\t\t\tsynchronized (repository) {\n\t\t\t\tScheduler existingScheduler = (schedulerName != null ? repository.lookup(schedulerName) : null);\n\t\t\t\tScheduler newScheduler = schedulerFactory.getScheduler();\n\t\t\t\tif (newScheduler == existingScheduler) {\n\t\t\t\t\tthrow new IllegalStateException(\"Active Scheduler of name '\" + schedulerName + \"' already registered \" +\n\t\t\t\t\t\t\t\"in Quartz SchedulerRepository. Cannot create a new Spring-managed Scheduler of the same name!\");\n\t\t\t\t}\n\t\t\t\tif (!this.exposeSchedulerInRepository) {\n\t\t\t\t\t// Need to remove it in this case, since Quartz shares the Scheduler instance by default!\n\t\t\t\t\tSchedulerRepository.getInstance().remove(newScheduler.getSchedulerName());\n\t\t\t\t}\n\t\t\t\treturn newScheduler;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (overrideClassLoader) {\n\t\t\t\t// Reset original thread context ClassLoader.\n\t\t\t\tcurrentThread.setContextClassLoader(threadContextClassLoader);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#newJob(bundle,scheduler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bundle",
      "scheduler"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "Job",
    "signature": "public Job newJob(TriggerFiredBundle bundle, Scheduler scheduler)",
    "source_code": "\tpublic Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException {\n\t\ttry {\n\t\t\tObject jobObject = createJobInstance(bundle);\n\t\t\treturn adaptJob(jobObject);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new SchedulerException(\"Job instantiation failed\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#setCalendars(Map<String,calendars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a list of Quartz Calendar objects with the Scheduler\n\t * that this FactoryBean creates, to be referenced by Triggers.\n\t * @param calendars a Map with calendar names as keys as Calendar\n\t * objects as values\n\t * @see org.quartz.Calendar\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "calendars"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void setCalendars(Map<String, Calendar> calendars)",
    "source_code": "\tpublic void setCalendars(Map<String, Calendar> calendars) {\n\t\tthis.calendars = calendars;\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#setSchedulerContextAsMap(Map<String,schedulerContextAsMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register objects in the Scheduler context via a given Map.\n\t * These objects will be available to any Job that runs in this Scheduler.\n\t * <p>Note: When using persistent Jobs whose JobDetail will be kept in the\n\t * database, do not put Spring-managed beans or an ApplicationContext\n\t * reference into the JobDataMap but rather into the SchedulerContext.\n\t * @param schedulerContextAsMap a Map with String keys and any objects as\n\t * values (for example Spring-managed beans)\n\t * @see JobDetailFactoryBean#setJobDataAsMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "schedulerContextAsMap"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "void",
    "signature": "public void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap)",
    "source_code": "\tpublic void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap) {\n\t\tthis.schedulerContextMap = schedulerContextAsMap;\n\t}"
  },
  "org.springframework.scheduling.quartz.<unknown>#startScheduler(scheduler,startupDelay)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Start the Quartz Scheduler, respecting the \"startupDelay\" setting.\n\t * @param scheduler the Scheduler to start\n\t * @param startupDelay the number of seconds to wait before starting\n\t * the Scheduler asynchronously\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scheduler",
      "startupDelay"
    ],
    "position": {
      "column": 1,
      "line": 728
    },
    "return": "void",
    "signature": "protected void startScheduler(final Scheduler scheduler, final int startupDelay)",
    "source_code": "\tprotected void startScheduler(final Scheduler scheduler, final int startupDelay) throws SchedulerException {\n\t\tif (startupDelay <= 0) {\n\t\t\tlogger.info(\"Starting Quartz Scheduler now\");\n\t\t\tscheduler.start();\n\t\t}\n\t\telse {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Will start Quartz Scheduler [\" + scheduler.getSchedulerName() +\n\t\t\t\t\t\t\"] in \" + startupDelay + \" seconds\");\n\t\t\t}\n\t\t\t// Not using the Quartz startDelayed method since we explicitly want a daemon\n\t\t\t// thread here, not keeping the JVM alive in case of all other threads ending.\n\t\t\tThread schedulerThread = new Thread(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tTimeUnit.SECONDS.sleep(startupDelay);\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t// simply proceed\n\t\t\t\t}\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Starting Quartz Scheduler now, after delay of \" + startupDelay + \" seconds\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tscheduler.start();\n\t\t\t\t}\n\t\t\t\tcatch (SchedulerException ex) {\n\t\t\t\t\tthrow new SchedulingException(\"Could not start Quartz Scheduler after delay\", ex);\n\t\t\t\t}\n\t\t\t});\n\t\t\tschedulerThread.setName(\"Quartz Scheduler [\" + scheduler.getSchedulerName() + \"]\");\n\t\t\tschedulerThread.setDaemon(true);\n\t\t\tschedulerThread.start();\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#compose(fields,type,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Composes the given fields into a {@link CronField}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fields",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 46
    },
    "return": "CronField",
    "signature": "public CronField compose(CronField[] fields, Type type, String value)",
    "source_code": "\tpublic static CronField compose(CronField[] fields, Type type, String value) {\n\t\tAssert.notEmpty(fields, \"Fields must not be empty\");\n\t\tAssert.hasLength(value, \"Value must not be empty\");\n\n\t\tif (fields.length == 1) {\n\t\t\treturn fields[0];\n\t\t}\n\t\telse {\n\t\t\treturn new CompositeCronField(type, fields, value);\n\t\t}\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#decorateTaskWithErrorHandler(task,errorHandler,isRepeatingTask)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decorate the task for error handling. If the provided {@link ErrorHandler}\n\t * is not {@code null}, it will be used. Otherwise, repeating tasks will have\n\t * errors suppressed by default whereas one-shot tasks will have errors\n\t * propagated by default since those errors may be expected through the\n\t * returned {@link Future}. In both cases, the errors will be logged.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "task",
      "errorHandler",
      "isRepeatingTask"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "DelegatingErrorHandlingRunnable",
    "signature": "public DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(Runnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask)",
    "source_code": "\tpublic static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(\n\t\t\tRunnable task, @Nullable ErrorHandler errorHandler, boolean isRepeatingTask) {\n\n\t\tif (task instanceof DelegatingErrorHandlingRunnable dehRunnable) {\n\t\t\treturn dehRunnable;\n\t\t}\n\t\tErrorHandler eh = (errorHandler != null ? errorHandler : getDefaultErrorHandler(isRepeatingTask));\n\t\treturn new DelegatingErrorHandlingRunnable(task, eh);\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#resumeFixedExecution(expression,resumptionTimestamp)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CronTrigger} for fixed execution, to be rescheduled\n\t * after every task based on the last scheduled time.\n\t * <p>This variant makes up for missed trigger firings if the associated task\n\t * has taken too long, scheduling a task for every original trigger firing.\n\t * Such follow-up tasks may execute late but will never be skipped.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param resumptionTimestamp the timestamp to resume from (the last-known\n\t * scheduled timestamp), with every trigger in-between immediately firing\n\t * to make up for every execution that would have happened in the meantime\n\t * @since 6.1.3\n\t * @see #forFixedExecution\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "resumptionTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "CronTrigger",
    "signature": "public CronTrigger resumeFixedExecution(String expression, Instant resumptionTimestamp)",
    "source_code": "\tpublic static CronTrigger resumeFixedExecution(String expression, Instant resumptionTimestamp) {\n\t\treturn new CronTrigger(expression) {\n\t\t\t@Override\n\t\t\tprotected Instant determineLatestTimestamp(TriggerContext triggerContext) {\n\t\t\t\tInstant scheduled = triggerContext.lastScheduledExecution();\n\t\t\t\treturn (scheduled != null ? scheduled : super.determineLatestTimestamp(triggerContext));\n\t\t\t}\n\t\t\t@Override\n\t\t\tInstant determineInitialTimestamp(TriggerContext triggerContext) {\n\t\t\t\treturn resumptionTimestamp;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.scheduling.support.<unknown>#resumeLenientExecution(expression,resumptionTimestamp)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link CronTrigger} for lenient execution, to be rescheduled\n\t * after every task based on the completion time.\n\t * <p>This variant does not make up for missed trigger firings if the\n\t * associated task has taken too long. As a consequence, original trigger\n\t * firings may be skipped if the previous task is still running.\n\t * @param expression a space-separated list of time fields, following cron\n\t * expression conventions\n\t * @param resumptionTimestamp the timestamp to resume from (the last-known\n\t * completion timestamp), with the new trigger calculated from there and\n\t * possibly immediately firing (but only once, every subsequent calculation\n\t * will start from the completion time of that first resumed trigger)\n\t * @since 6.1.3\n\t * @see #forLenientExecution\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expression",
      "resumptionTimestamp"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "CronTrigger",
    "signature": "public CronTrigger resumeLenientExecution(String expression, Instant resumptionTimestamp)",
    "source_code": "\tpublic static CronTrigger resumeLenientExecution(String expression, Instant resumptionTimestamp) {\n\t\treturn new CronTrigger(expression) {\n\t\t\t@Override\n\t\t\tInstant determineInitialTimestamp(TriggerContext triggerContext) {\n\t\t\t\treturn resumptionTimestamp;\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source,\n\t * using the default ClassLoader.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t * @see #createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>... scriptInterfaces) throws EvalError {\n\t\treturn createBshObject(scriptSource, scriptInterfaces, ClassUtils.getDefaultClassLoader());\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#createBshObject(scriptSource,scriptInterfaces,classLoader)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new BeanShell-scripted object from the given script source.\n\t * <p>The script may either be a simple script that needs a corresponding proxy\n\t * generated (implementing the specified interfaces), or declare a full class\n\t * or return an actual instance of the scripted object (in which case the\n\t * specified interfaces, if any, need to be implemented by that class/instance).\n\t * @param scriptSource the script source text\n\t * @param scriptInterfaces the interfaces that the scripted Java object is\n\t * supposed to implement (may be {@code null} or empty if the script itself\n\t * declares a full class or returns an actual instance of the scripted object)\n\t * @param classLoader the ClassLoader to use for evaluating the script\n\t * @return the scripted Java object\n\t * @throws EvalError in case of BeanShell parsing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "scriptInterfaces",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "Object",
    "signature": "public Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)",
    "source_code": "\tpublic static Object createBshObject(String scriptSource, @Nullable Class<?>[] scriptInterfaces, @Nullable ClassLoader classLoader)\n\t\t\tthrows EvalError {\n\n\t\tObject result = evaluateBshScript(scriptSource, scriptInterfaces, classLoader);\n\t\tif (result instanceof Class<?> clazz) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load and parse the BeanShell script via {@link BshScriptUtils}.\n\t * @see BshScriptUtils#createBshObject(String, Class[], ClassLoader)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tClass<?> clazz;\n\n\t\ttry {\n\t\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\t\tboolean requiresScriptEvaluation = (this.wasModifiedForTypeCheck && this.scriptClass == null);\n\t\t\t\tthis.wasModifiedForTypeCheck = false;\n\n\t\t\t\tif (scriptSource.isModified() || requiresScriptEvaluation) {\n\t\t\t\t\t// New script content: Let's check whether it evaluates to a Class.\n\t\t\t\t\tObject result = BshScriptUtils.evaluateBshScript(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader);\n\t\t\t\t\tif (result instanceof Class<?> type) {\n\t\t\t\t\t\t// A Class: We'll cache the Class here and create an instance\n\t\t\t\t\t\t// outside the synchronized block.\n\t\t\t\t\t\tthis.scriptClass = type;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Not a Class: OK, we'll simply create BeanShell objects\n\t\t\t\t\t\t// through evaluating the script for every call later on.\n\t\t\t\t\t\t// For this first-time check, let's simply return the\n\t\t\t\t\t\t// already evaluated object.\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclazz = this.scriptClass;\n\t\t\t}\n\t\t}\n\t\tcatch (EvalError ex) {\n\t\t\tthis.scriptClass = null;\n\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t}\n\n\t\tif (clazz != null) {\n\t\t\t// A Class: We need to create an instance for every call.\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(clazz).newInstance();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not instantiate script class: \" + clazz.getName(), ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Not a Class: We need to evaluate the script for every call.\n\t\t\ttry {\n\t\t\t\treturn BshScriptUtils.createBshObject(\n\t\t\t\t\t\tscriptSource.getScriptAsString(), actualInterfaces, this.beanClassLoader);\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.bsh.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 187
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tif (ReflectionUtils.isEqualsMethod(method)) {\n\t\t\t\treturn (isProxyForSameBshObject(args[0]));\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isHashCodeMethod(method)) {\n\t\t\t\treturn this.xt.hashCode();\n\t\t\t}\n\t\t\telse if (ReflectionUtils.isToStringMethod(method)) {\n\t\t\t\treturn \"BeanShell object [\" + this.xt + \"]\";\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tObject result = this.xt.invokeMethod(method.getName(), args);\n\t\t\t\tif (result == Primitive.NULL || result == Primitive.VOID) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (result instanceof Primitive primitive) {\n\t\t\t\t\treturn primitive.getValue();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (EvalError ex) {\n\t\t\t\tthrow new BshExecutionException(ex);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#evaluate(script,Map<String,arguments)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "arguments"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> arguments) {\n\t\tGroovyShell groovyShell = new GroovyShell(\n\t\t\t\tthis.classLoader, new Binding(arguments), this.compilerConfiguration);\n\t\ttry {\n\t\t\tString filename = (script instanceof ResourceScriptSource resourceScriptSource ?\n\t\t\t\t\tresourceScriptSource.getResource().getFilename() : null);\n\t\t\tif (filename != null) {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString(), filename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn groovyShell.evaluate(script.getScriptAsString());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access Groovy script\", ex);\n\t\t}\n\t\tcatch (GroovyRuntimeException ex) {\n\t\t\tthrow new ScriptCompilationException(script, ex);\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#executeScript(scriptSource,scriptClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Instantiate the given Groovy script class and run it if necessary.\n\t * @param scriptSource the source for the underlying script\n\t * @param scriptClass the Groovy script class\n\t * @return the result object (either an instance of the script class\n\t * or the result of running the script instance)\n\t * @throws ScriptCompilationException in case of instantiation failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "scriptSource",
      "scriptClass"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "Object",
    "signature": "protected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass)",
    "source_code": "\tprotected Object executeScript(ScriptSource scriptSource, Class<?> scriptClass) throws ScriptCompilationException {\n\t\ttry {\n\t\t\tGroovyObject groovyObj = (GroovyObject) ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\n\t\t\tif (this.groovyObjectCustomizer != null) {\n\t\t\t\t// Allow metaclass and other customization.\n\t\t\t\tthis.groovyObjectCustomizer.customize(groovyObj);\n\t\t\t}\n\n\t\t\tif (groovyObj instanceof Script script) {\n\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\treturn script.run();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// An instance of the scripted class: let's return it as-is.\n\t\t\t\treturn groovyObj;\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"No default constructor on Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InstantiationException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Unable to instantiate Groovy script class: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\tscriptSource, \"Could not access Groovy script constructor: \" + scriptClass.getName(), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\"Failed to invoke Groovy script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t}\n\t}"
  },
  "org.springframework.scripting.groovy.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Loads and parses the Groovy script via the GroovyClassLoader.\n\t * @see groovy.lang.GroovyClassLoader\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tsynchronized (this.scriptClassMonitor) {\n\t\t\ttry {\n\t\t\t\tClass<?> scriptClassToExecute;\n\t\t\t\tthis.wasModifiedForTypeCheck = false;\n\n\t\t\t\tif (this.cachedResult != null) {\n\t\t\t\t\tObject result = this.cachedResult.object;\n\t\t\t\t\tthis.cachedResult = null;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (this.scriptClass == null || scriptSource.isModified()) {\n\t\t\t\t\t// New script content...\n\t\t\t\t\tthis.scriptClass = getGroovyClassLoader().parseClass(\n\t\t\t\t\t\t\tscriptSource.getScriptAsString(), scriptSource.suggestedClassName());\n\n\t\t\t\t\tif (Script.class.isAssignableFrom(this.scriptClass)) {\n\t\t\t\t\t\t// A Groovy script, probably creating an instance: let's execute it.\n\t\t\t\t\t\tObject result = executeScript(scriptSource, this.scriptClass);\n\t\t\t\t\t\tthis.scriptResultClass = (result != null ? result.getClass() : null);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.scriptResultClass = this.scriptClass;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscriptClassToExecute = this.scriptClass;\n\n\t\t\t\t// Process re-execution outside the synchronized block.\n\t\t\t\treturn executeScript(scriptSource, scriptClassToExecute);\n\t\t\t}\n\t\t\tcatch (CompilationFailedException ex) {\n\t\t\t\tthis.scriptClass = null;\n\t\t\t\tthis.scriptResultClass = null;\n\t\t\t\tthrow new ScriptCompilationException(scriptSource, ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#adaptToInterfaces(script,scriptSource,actualInterfaces)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "script",
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "Object",
    "signature": "protected Object adaptToInterfaces(@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces)",
    "source_code": "\tprotected Object adaptToInterfaces(\n\t\t\t@Nullable Object script, ScriptSource scriptSource, Class<?>... actualInterfaces) {\n\n\t\tClass<?> adaptedIfc;\n\t\tif (actualInterfaces.length == 1) {\n\t\t\tadaptedIfc = actualInterfaces[0];\n\t\t}\n\t\telse {\n\t\t\tadaptedIfc = ClassUtils.createCompositeInterface(actualInterfaces, this.beanClassLoader);\n\t\t}\n\n\t\tif (adaptedIfc != null) {\n\t\t\tScriptEngine scriptEngine = this.scriptEngine;\n\t\t\tif (!(scriptEngine instanceof Invocable invocable)) {\n\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\"ScriptEngine must implement Invocable in order to adapt it to an interface: \" + scriptEngine);\n\t\t\t}\n\t\t\tif (script != null) {\n\t\t\t\tscript = invocable.getInterface(script, adaptedIfc);\n\t\t\t}\n\t\t\tif (script == null) {\n\t\t\t\tscript = invocable.getInterface(adaptedIfc);\n\t\t\t\tif (script == null) {\n\t\t\t\t\tthrow new ScriptCompilationException(scriptSource,\n\t\t\t\t\t\t\t\"Could not adapt script to interface [\" + adaptedIfc.getName() + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#convertToScriptSource(beanName,scriptSourceLocator,resourceLoader)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given script source locator to a ScriptSource instance.\n\t * <p>By default, supported locators are Spring resource locations\n\t * (such as \"file:C:/myScript.bsh\" or \"classpath:myPackage/myScript.bsh\")\n\t * and inline scripts (\"inline:myScriptText...\").\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator\n\t * @param resourceLoader the ResourceLoader to use (if necessary)\n\t * @return the ScriptSource instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator",
      "resourceLoader"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,\n\t\t\tResourceLoader resourceLoader)",
    "source_code": "\tprotected ScriptSource convertToScriptSource(String beanName, String scriptSourceLocator,\n\t\t\tResourceLoader resourceLoader) {\n\n\t\tif (scriptSourceLocator.startsWith(INLINE_SCRIPT_PREFIX)) {\n\t\t\treturn new StaticScriptSource(scriptSourceLocator.substring(INLINE_SCRIPT_PREFIX.length()), beanName);\n\t\t}\n\t\telse {\n\t\t\treturn new ResourceScriptSource(resourceLoader.getResource(scriptSourceLocator));\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#createRefreshableProxy(ts,interfaces,proxyTargetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a refreshable proxy for the given AOP TargetSource.\n\t * @param ts the refreshable TargetSource\n\t * @param interfaces the proxy interfaces (may be {@code null} to\n\t * indicate proxying of all interfaces implemented by the target class)\n\t * @return the generated proxy\n\t * @see RefreshableScriptTargetSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ts",
      "interfaces",
      "proxyTargetClass"
    ],
    "position": {
      "column": 1,
      "line": 568
    },
    "return": "Object",
    "signature": "protected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass)",
    "source_code": "\tprotected Object createRefreshableProxy(TargetSource ts, @Nullable Class<?>[] interfaces, boolean proxyTargetClass) {\n\t\tProxyFactory proxyFactory = new ProxyFactory();\n\t\tproxyFactory.setTargetSource(ts);\n\t\tClassLoader classLoader = this.beanClassLoader;\n\n\t\tif (interfaces != null) {\n\t\t\tproxyFactory.setInterfaces(interfaces);\n\t\t}\n\t\telse {\n\t\t\tClass<?> targetClass = ts.getTargetClass();\n\t\t\tif (targetClass != null) {\n\t\t\t\tproxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.beanClassLoader));\n\t\t\t}\n\t\t}\n\n\t\tif (proxyTargetClass) {\n\t\t\tclassLoader = null;  // force use of Class.getClassLoader()\n\t\t\tproxyFactory.setProxyTargetClass(true);\n\t\t}\n\n\t\tDelegatingIntroductionInterceptor introduction = new DelegatingIntroductionInterceptor(ts);\n\t\tintroduction.suppressInterface(TargetSource.class);\n\t\tproxyFactory.addAdvice(introduction);\n\n\t\treturn proxyFactory.getProxy(classLoader);\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#createScriptedObjectBeanDefinition(bd,scriptFactoryBeanName,scriptSource,interfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a bean definition for the scripted object, based on the given script\n\t * definition, extracting the definition data that is relevant for the scripted\n\t * object (that is, everything but bean class and constructor arguments).\n\t * @param bd the full script bean definition\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptSource the ScriptSource for the scripted bean\n\t * @param interfaces the interfaces that the scripted bean is supposed to implement\n\t * @return the extracted ScriptFactory bean definition\n\t * @see org.springframework.scripting.ScriptFactory#getScriptedObject\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptSource",
      "interfaces"
    ],
    "position": {
      "column": 1,
      "line": 548
    },
    "return": "BeanDefinition",
    "signature": "protected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,\n\t\t\tScriptSource scriptSource, @Nullable Class<?>[] interfaces)",
    "source_code": "\tprotected BeanDefinition createScriptedObjectBeanDefinition(BeanDefinition bd, String scriptFactoryBeanName,\n\t\t\tScriptSource scriptSource, @Nullable Class<?>[] interfaces) {\n\n\t\tGenericBeanDefinition objectBd = new GenericBeanDefinition(bd);\n\t\tobjectBd.setFactoryBeanName(scriptFactoryBeanName);\n\t\tobjectBd.setFactoryMethodName(\"getScriptedObject\");\n\t\tobjectBd.getConstructorArgumentValues().clear();\n\t\tobjectBd.getConstructorArgumentValues().addIndexedArgumentValue(0, scriptSource);\n\t\tobjectBd.getConstructorArgumentValues().addIndexedArgumentValue(1, interfaces);\n\t\treturn objectBd;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#evaluate(script,Map<String,argumentBindings)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "script",
      "Map<String",
      "argumentBindings"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "Object",
    "signature": "public Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings)",
    "source_code": "\tpublic Object evaluate(ScriptSource script, @Nullable Map<String, Object> argumentBindings) {\n\t\tScriptEngine engine = getScriptEngine(script);\n\t\ttry {\n\t\t\tif (CollectionUtils.isEmpty(argumentBindings)) {\n\t\t\t\treturn engine.eval(script.getScriptAsString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tBindings bindings = StandardScriptUtils.getBindings(argumentBindings);\n\t\t\t\treturn engine.eval(script.getScriptAsString(), bindings);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new ScriptCompilationException(script, \"Cannot access script for ScriptEngine\", ex);\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ScriptCompilationException(script, new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#getScriptSource(beanName,scriptSourceLocator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a ScriptSource for the given bean, lazily creating it\n\t * if not cached already.\n\t * @param beanName the name of the scripted bean\n\t * @param scriptSourceLocator the script source locator associated with the bean\n\t * @return the corresponding ScriptSource instance\n\t * @see #convertToScriptSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "scriptSourceLocator"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "ScriptSource",
    "signature": "protected ScriptSource getScriptSource(String beanName, String scriptSourceLocator)",
    "source_code": "\tprotected ScriptSource getScriptSource(String beanName, String scriptSourceLocator) {\n\t\treturn this.scriptSourceCache.computeIfAbsent(beanName, key ->\n\t\t\t\tconvertToScriptSource(beanName, scriptSourceLocator, this.resourceLoader));\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#getScriptedObject(scriptSource,actualInterfaces)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load and parse the script via JSR-223's ScriptEngine.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptSource",
      "actualInterfaces"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "Object",
    "signature": "public Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)",
    "source_code": "\tpublic Object getScriptedObject(ScriptSource scriptSource, @Nullable Class<?>... actualInterfaces)\n\t\t\tthrows IOException, ScriptCompilationException {\n\n\t\tObject script = evaluateScript(scriptSource);\n\n\t\tif (!ObjectUtils.isEmpty(actualInterfaces)) {\n\t\t\tboolean adaptationRequired = false;\n\t\t\tfor (Class<?> requestedIfc : actualInterfaces) {\n\t\t\t\tif (script instanceof Class<?> clazz ? !requestedIfc.isAssignableFrom(clazz) :\n\t\t\t\t\t\t!requestedIfc.isInstance(script)) {\n\t\t\t\t\tadaptationRequired = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (adaptationRequired) {\n\t\t\t\tscript = adaptToInterfaces(script, scriptSource, actualInterfaces);\n\t\t\t}\n\t\t}\n\n\t\tif (script instanceof Class<?> scriptClass) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(scriptClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"No default constructor on script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Unable to instantiate script class: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\tscriptSource, \"Could not access script constructor: \" + scriptClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ScriptCompilationException(\n\t\t\t\t\t\t\"Failed to invoke script constructor: \" + scriptClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\n\t\treturn script;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#postProcessBeforeInstantiation(beanClass,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 308
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\t// We only apply special treatment to ScriptFactory implementations here.\n\t\tif (!ScriptFactory.class.isAssignableFrom(beanClass)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAssert.state(this.beanFactory != null, \"No BeanFactory set\");\n\t\tBeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName);\n\t\tString scriptFactoryBeanName = SCRIPT_FACTORY_NAME_PREFIX + beanName;\n\t\tString scriptedObjectBeanName = SCRIPTED_OBJECT_NAME_PREFIX + beanName;\n\t\tprepareScriptBeans(bd, scriptFactoryBeanName, scriptedObjectBeanName);\n\n\t\tScriptFactory scriptFactory = this.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\tScriptSource scriptSource = getScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\tboolean isFactoryBean = false;\n\t\ttry {\n\t\t\tClass<?> scriptedObjectType = scriptFactory.getScriptedObjectType(scriptSource);\n\t\t\t// Returned type may be null if the factory is unable to determine the type.\n\t\t\tif (scriptedObjectType != null) {\n\t\t\t\tisFactoryBean = FactoryBean.class.isAssignableFrom(scriptedObjectType);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\"Could not determine scripted object type for \" + scriptFactory, ex);\n\t\t}\n\n\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\tif (refreshCheckDelay >= 0) {\n\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\t\t\tRefreshableScriptTargetSource ts = new RefreshableScriptTargetSource(this.scriptBeanFactory,\n\t\t\t\t\tscriptedObjectBeanName, scriptFactory, scriptSource, isFactoryBean);\n\t\t\tboolean proxyTargetClass = resolveProxyTargetClass(bd);\n\t\t\tString language = (String) bd.getAttribute(LANGUAGE_ATTRIBUTE);\n\t\t\tif (proxyTargetClass && (language == null || !language.equals(\"groovy\"))) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\n\t\t\t\t\t\t\"Cannot use proxyTargetClass=true with script beans where language is not 'groovy': '\" +\n\t\t\t\t\t\tlanguage + \"'\");\n\t\t\t}\n\t\t\tts.setRefreshCheckDelay(refreshCheckDelay);\n\t\t\treturn createRefreshableProxy(ts, interfaces, proxyTargetClass);\n\t\t}\n\n\t\tif (isFactoryBean) {\n\t\t\tscriptedObjectBeanName = BeanFactory.FACTORY_BEAN_PREFIX + scriptedObjectBeanName;\n\t\t}\n\t\treturn this.scriptBeanFactory.getBean(scriptedObjectBeanName);\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#postProcessProperties(pvs,bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pvs",
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "PropertyValues",
    "signature": "public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)",
    "source_code": "\tpublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {\n\t\treturn pvs;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#prepareScriptBeans(bd,scriptFactoryBeanName,scriptedObjectBeanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare the script beans in the internal BeanFactory that this\n\t * post-processor uses. Each original bean definition will be split\n\t * into a ScriptFactory definition and a scripted object definition.\n\t * @param bd the original bean definition in the main BeanFactory\n\t * @param scriptFactoryBeanName the name of the internal ScriptFactory bean\n\t * @param scriptedObjectBeanName the name of the internal scripted object bean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bd",
      "scriptFactoryBeanName",
      "scriptedObjectBeanName"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "void",
    "signature": "protected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName)",
    "source_code": "\tprotected void prepareScriptBeans(BeanDefinition bd, String scriptFactoryBeanName, String scriptedObjectBeanName) {\n\t\t// Avoid recreation of the script bean definition in case of a prototype.\n\t\tsynchronized (this.scriptBeanFactory) {\n\t\t\tif (!this.scriptBeanFactory.containsBeanDefinition(scriptedObjectBeanName)) {\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(\n\t\t\t\t\t\tscriptFactoryBeanName, createScriptFactoryBeanDefinition(bd));\n\t\t\t\tScriptFactory scriptFactory =\n\t\t\t\t\t\tthis.scriptBeanFactory.getBean(scriptFactoryBeanName, ScriptFactory.class);\n\t\t\t\tScriptSource scriptSource =\n\t\t\t\t\t\tgetScriptSource(scriptFactoryBeanName, scriptFactory.getScriptSourceLocator());\n\t\t\t\tClass<?>[] interfaces = scriptFactory.getScriptInterfaces();\n\n\t\t\t\tClass<?>[] scriptedInterfaces = interfaces;\n\t\t\t\tif (scriptFactory.requiresConfigInterface() && !bd.getPropertyValues().isEmpty()) {\n\t\t\t\t\tClass<?> configInterface = createConfigInterface(bd, interfaces);\n\t\t\t\t\tscriptedInterfaces = ObjectUtils.addObjectToArray(interfaces, configInterface);\n\t\t\t\t}\n\n\t\t\t\tBeanDefinition objectBd = createScriptedObjectBeanDefinition(\n\t\t\t\t\t\tbd, scriptFactoryBeanName, scriptSource, scriptedInterfaces);\n\t\t\t\tlong refreshCheckDelay = resolveRefreshCheckDelay(bd);\n\t\t\t\tif (refreshCheckDelay >= 0) {\n\t\t\t\t\tobjectBd.setScope(BeanDefinition.SCOPE_PROTOTYPE);\n\t\t\t\t}\n\n\t\t\t\tthis.scriptBeanFactory.registerBeanDefinition(scriptedObjectBeanName, objectBd);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#retrieveEngineByName(scriptEngineManager,engineName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve a {@link ScriptEngine} from the given {@link ScriptEngineManager}\n\t * by name, delegating to {@link ScriptEngineManager#getEngineByName} but\n\t * throwing a descriptive exception if not found or if initialization failed.\n\t * @param scriptEngineManager the ScriptEngineManager to use\n\t * @param engineName the name of the engine\n\t * @return a corresponding ScriptEngine (never {@code null})\n\t * @throws IllegalArgumentException if no matching engine has been found\n\t * @throws IllegalStateException if the desired engine failed to initialize\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "scriptEngineManager",
      "engineName"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "ScriptEngine",
    "signature": "public ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName)",
    "source_code": "\tpublic static ScriptEngine retrieveEngineByName(ScriptEngineManager scriptEngineManager, String engineName) {\n\t\tScriptEngine engine = scriptEngineManager.getEngineByName(engineName);\n\t\tif (engine == null) {\n\t\t\tSet<String> engineNames = new LinkedHashSet<>();\n\t\t\tfor (ScriptEngineFactory engineFactory : scriptEngineManager.getEngineFactories()) {\n\t\t\t\tList<String> factoryNames = engineFactory.getNames();\n\t\t\t\tif (factoryNames.contains(engineName)) {\n\t\t\t\t\t// Special case: getEngineByName returned null but engine is present...\n\t\t\t\t\t// Let's assume it failed to initialize (which ScriptEngineManager silently swallows).\n\t\t\t\t\t// If it happens to initialize fine now, alright, but we really expect an exception.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tengine = engineFactory.getScriptEngine();\n\t\t\t\t\t\tengine.setBindings(scriptEngineManager.getBindings(), ScriptContext.GLOBAL_SCOPE);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\t\t\t\"' failed to initialize\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tengineNames.addAll(factoryNames);\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException(\"Script engine with name '\" + engineName +\n\t\t\t\t\t\"' not found; registered engine names: \" + engineNames);\n\t\t}\n\t\treturn engine;\n\t}"
  },
  "org.springframework.scripting.support.<unknown>#setGlobalBindings(Map<String,globalBindings)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the globally scoped bindings on the underlying script engine manager,\n\t * shared by all scripts, as an alternative to script argument bindings.\n\t * @since 4.2.2\n\t * @see #evaluate(ScriptSource, Map)\n\t * @see javax.script.ScriptEngineManager#setBindings(Bindings)\n\t * @see javax.script.SimpleBindings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "globalBindings"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setGlobalBindings(Map<String, Object> globalBindings)",
    "source_code": "\tpublic void setGlobalBindings(Map<String, Object> globalBindings) {\n\t\tBindings bindings = StandardScriptUtils.getBindings(globalBindings);\n\t\tthis.globalBindings = bindings;\n\t\tScriptEngineManager scriptEngineManager = this.scriptEngineManager;\n\t\tif (scriptEngineManager != null) {\n\t\t\tscriptEngineManager.setBindings(bindings);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestExecution(testInstance,testMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>immediately after</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called before framework-specific\n\t * <em>after</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * order in which they were registered.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the\n\t * test method or by a TestExecutionListener, or {@code null} if none\n\t * was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "void",
    "signature": "public void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString callbackName = \"afterTestExecution\";\n\t\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\t\tThrowable afterTestExecutionException = null;\n\n\t\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t\t// \"wrapper\"-style execution of listeners.\n\t\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\t\ttry {\n\t\t\t\t\ttestExecutionListener.afterTestExecution(getTestContext());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\t\tif (afterTestExecutionException == null) {\n\t\t\t\t\t\tafterTestExecutionException = ex;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tafterTestExecutionException.addSuppressed(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (afterTestExecutionException != null) {\n\t\t\t\tReflectionUtils.rethrowException(afterTestExecutionException);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tresetMethodInvoker();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#afterTestMethod(testInstance,testMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for post-processing a test <em>after</em> execution of <em>after</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * tearing down test fixtures, ending a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately after\n\t * framework-specific <em>after</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.AfterEach @AfterEach}.\n\t * For historical reasons, this method is named {@code afterTestMethod}. Since\n\t * the introduction of {@link #afterTestExecution}, a more suitable name for\n\t * this method might be something like {@code afterTestTearDown} or\n\t * {@code afterEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance}, {@code testMethod}, and {@code exception}.\n\t * <p>Each registered {@link TestExecutionListener} will be given a chance\n\t * to perform its post-processing. If a listener throws an exception, the\n\t * remaining registered listeners will still be called. After all listeners\n\t * have executed, the first caught exception will be rethrown with any\n\t * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in\n\t * the first exception.\n\t * <p>Note that registered listeners will be executed in the opposite\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which has just been executed on the\n\t * test instance\n\t * @param exception the exception that was thrown during execution of the test\n\t * method or by a TestExecutionListener, or {@code null} if none was thrown\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #beforeTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t * @see Throwable#addSuppressed(Throwable)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 475
    },
    "return": "void",
    "signature": "public void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)",
    "source_code": "\tpublic void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception)\n\t\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tString callbackName = \"afterTestMethod\";\n\t\t\tprepareForAfterCallback(callbackName, testInstance, testMethod, exception);\n\t\t\tThrowable afterTestMethodException = null;\n\n\t\t\t// Traverse the TestExecutionListeners in reverse order to ensure proper\n\t\t\t// \"wrapper\"-style execution of listeners.\n\t\t\tfor (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {\n\t\t\t\ttry {\n\t\t\t\t\ttestExecutionListener.afterTestMethod(getTestContext());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\t\tif (afterTestMethodException == null) {\n\t\t\t\t\t\tafterTestMethodException = ex;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tafterTestMethodException.addSuppressed(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (afterTestMethodException != null) {\n\t\t\t\tReflectionUtils.rethrowException(afterTestMethodException);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tresetMethodInvoker();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestExecution(testInstance,testMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>immediately before</em> execution of\n\t * the {@linkplain java.lang.reflect.Method test method} in the supplied\n\t * {@linkplain TestContext test context} &mdash; for example, for timing\n\t * or logging purposes.\n\t * <p>This method <strong>must</strong> be called after framework-specific\n\t * <em>before</em> lifecycle callbacks &mdash; for example, methods annotated\n\t * with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @since 5.0\n\t * @see #beforeTestMethod\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 357
    },
    "return": "void",
    "signature": "public void beforeTestExecution(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {\n\t\ttry {\n\t\t\tString callbackName = \"beforeTestExecution\";\n\t\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\t\ttry {\n\t\t\t\t\ttestExecutionListener.beforeTestExecution(getTestContext());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tresetMethodInvoker();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.<unknown>#beforeTestMethod(testInstance,testMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Hook for pre-processing a test <em>before</em> execution of <em>before</em>\n\t * lifecycle callbacks of the underlying test framework &mdash; for example,\n\t * setting up test fixtures, starting a transaction, etc.\n\t * <p>This method <strong>must</strong> be called immediately prior to\n\t * framework-specific <em>before</em> lifecycle callbacks &mdash; for example, methods\n\t * annotated with JUnit Jupiter's {@link org.junit.jupiter.api.BeforeEach @BeforeEach}.\n\t * For historical reasons, this method is named {@code beforeTestMethod}. Since\n\t * the introduction of {@link #beforeTestExecution}, a more suitable name for\n\t * this method might be something like {@code beforeTestSetUp} or\n\t * {@code beforeEach}; however, it is unfortunately impossible to rename\n\t * this method due to backward compatibility concerns.\n\t * <p>The managed {@link TestContext} will be updated with the supplied\n\t * {@code testInstance} and {@code testMethod}.\n\t * <p>An attempt will be made to give each registered\n\t * {@link TestExecutionListener} a chance to perform its pre-processing.\n\t * If a listener throws an exception, however, the remaining registered\n\t * listeners will <strong>not</strong> be called.\n\t * @param testInstance the current test instance\n\t * @param testMethod the test method which is about to be executed on the\n\t * test instance\n\t * @throws Exception if a registered TestExecutionListener throws an exception\n\t * @see #afterTestMethod\n\t * @see #beforeTestExecution\n\t * @see #afterTestExecution\n\t * @see #getTestExecutionListeners()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "void",
    "signature": "public void beforeTestMethod(Object testInstance, Method testMethod)",
    "source_code": "\tpublic void beforeTestMethod(Object testInstance, Method testMethod) throws Exception {\n\t\ttry {\n\t\t\tString callbackName = \"beforeTestMethod\";\n\t\t\tprepareForBeforeCallback(callbackName, testInstance, testMethod);\n\n\t\t\tfor (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {\n\t\t\t\ttry {\n\t\t\t\t\ttestExecutionListener.beforeTestMethod(getTestContext());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\thandleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tresetMethodInvoker();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.aot.<unknown>#registerHints(runtimeHints,mergedConfig,classLoader)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "mergedConfig",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "public void registerHints(RuntimeHints runtimeHints, MergedContextConfiguration mergedConfig, ClassLoader classLoader)",
    "source_code": "\tpublic void registerHints(RuntimeHints runtimeHints, MergedContextConfiguration mergedConfig, ClassLoader classLoader) {\n\t\t// @ContextConfiguration(loader = ...)\n\t\tContextLoader contextLoader = mergedConfig.getContextLoader();\n\t\tif (contextLoader != null) {\n\t\t\tregisterDeclaredConstructors(contextLoader.getClass(), runtimeHints);\n\t\t}\n\n\t\t// @ContextConfiguration(initializers = ...)\n\t\tmergedConfig.getContextInitializerClasses()\n\t\t\t\t.forEach(clazz -> registerDeclaredConstructors(clazz, runtimeHints));\n\n\t\t// @ContextConfiguration(locations = ...)\n\t\tregisterClasspathResources(\"@ContextConfiguration\", mergedConfig.getLocations(), runtimeHints, classLoader);\n\n\t\tfor (PropertySourceDescriptor descriptor : mergedConfig.getPropertySourceDescriptors()) {\n\t\t\t// @TestPropertySource(locations = ...)\n\t\t\tregisterClasspathResources(\"@TestPropertySource\", descriptor.locations(), runtimeHints, classLoader);\n\n\t\t\t// @TestPropertySource(factory = ...)\n\t\t\tClass<?> factoryClass = descriptor.propertySourceFactory();\n\t\t\tif (factoryClass != null) {\n\t\t\t\tregisterDeclaredConstructors(factoryClass, runtimeHints);\n\t\t\t}\n\t\t}\n\n\t\t// @WebAppConfiguration(value = ...)\n\t\tif (webMergedContextConfigurationClass.isInstance(mergedConfig)) {\n\t\t\tString resourceBasePath;\n\t\t\ttry {\n\t\t\t\tresourceBasePath = (String) getResourceBasePathMethod.invoke(mergedConfig);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Failed to invoke WebMergedContextConfiguration#getResourceBasePath()\", ex);\n\t\t\t}\n\t\t\tregisterClasspathResourceDirectoryStructure(resourceBasePath, runtimeHints);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.bean.override.convention.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "TestBeanBeanOverrideHandler",
    "signature": "public TestBeanBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic TestBeanBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (!(overrideAnnotation instanceof TestBean testBean)) {\n\t\t\tthrow new IllegalStateException(\"Invalid annotation passed to %s: expected @TestBean on field %s.%s\"\n\t\t\t\t\t.formatted(getClass().getSimpleName(), field.getDeclaringClass().getName(), field.getName()));\n\t\t}\n\n\t\tString beanName = (!testBean.name().isBlank() ? testBean.name() : null);\n\t\tString methodName = testBean.methodName();\n\t\tBeanOverrideStrategy strategy = (testBean.enforceOverride() ? REPLACE : REPLACE_OR_CREATE);\n\n\t\tMethod factoryMethod;\n\t\tif (!methodName.isBlank()) {\n\t\t\t// If the user specified an explicit method name, search for that.\n\t\t\tfactoryMethod = findTestBeanFactoryMethod(testClass, field.getType(), methodName);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise, search for candidate factory methods whose names match either\n\t\t\t// the field name or the explicit bean name (if any).\n\t\t\tList<String> candidateMethodNames = new ArrayList<>();\n\t\t\tcandidateMethodNames.add(field.getName());\n\n\t\t\tif (beanName != null) {\n\t\t\t\tcandidateMethodNames.add(beanName);\n\t\t\t}\n\t\t\tfactoryMethod = findTestBeanFactoryMethod(testClass, field.getType(), candidateMethodNames);\n\t\t}\n\n\t\treturn new TestBeanBeanOverrideHandler(\n\t\t\t\tfield, ResolvableType.forField(field, testClass), beanName, strategy, factoryMethod);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#apply(reset,settings)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply {@link MockReset} to existing {@link MockSettings settings}.\n\t * @param reset the reset type\n\t * @param settings the settings\n\t * @return the configured settings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "reset",
      "settings"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "MockSettings",
    "signature": "public MockSettings apply(MockReset reset, MockSettings settings)",
    "source_code": "\tpublic static MockSettings apply(MockReset reset, MockSettings settings) {\n\t\tAssert.notNull(settings, \"Settings must not be null\");\n\t\tif (reset != null && reset != NONE) {\n\t\t\tsettings.invocationListeners(new ResetInvocationListener(reset));\n\t\t}\n\t\treturn settings;\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createHandler(overrideAnnotation,testClass,field)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "overrideAnnotation",
      "testClass",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 37
    },
    "return": "AbstractMockitoBeanOverrideHandler",
    "signature": "public AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field)",
    "source_code": "\tpublic AbstractMockitoBeanOverrideHandler createHandler(Annotation overrideAnnotation, Class<?> testClass, Field field) {\n\t\tif (overrideAnnotation instanceof MockitoBean mockBean) {\n\t\t\treturn new MockitoBeanOverrideHandler(field, ResolvableType.forField(field, testClass), mockBean);\n\t\t}\n\t\telse if (overrideAnnotation instanceof MockitoSpyBean spyBean) {\n\t\t\treturn new MockitoSpyBeanOverrideHandler(field, ResolvableType.forField(field, testClass), spyBean);\n\t\t}\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tInvalid annotation passed to MockitoBeanOverrideProcessor: \\\n\t\t\t\texpected either @MockitoBean or @MockitoSpyBean on field %s.%s\"\"\"\n\t\t\t\t\t.formatted(field.getDeclaringClass().getName(), field.getName()));\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#createOverrideInstance(beanName,existingBeanDefinition,existingBeanInstance)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanName",
      "existingBeanDefinition",
      "existingBeanInstance"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "protected Object createOverrideInstance(String beanName, @Nullable BeanDefinition existingBeanDefinition, @Nullable Object existingBeanInstance)",
    "source_code": "\tprotected Object createOverrideInstance(String beanName, @Nullable BeanDefinition existingBeanDefinition, @Nullable Object existingBeanInstance) {\n\t\treturn createMock(beanName);\n\t}"
  },
  "org.springframework.test.context.bean.override.mockito.<unknown>#trackOverrideInstance(mock,trackingBeanRegistry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mock",
      "trackingBeanRegistry"
    ],
    "position": {
      "column": 1,
      "line": 58
    },
    "return": "void",
    "signature": "protected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry)",
    "source_code": "\tprotected void trackOverrideInstance(Object mock, SingletonBeanRegistry trackingBeanRegistry) {\n\t\tgetMockitoBeans(trackingBeanRegistry).add(mock);\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#closeContext(mergedConfig,hierarchyMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "public void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void closeContext(MergedContextConfiguration mergedConfig, @Nullable HierarchyMode hierarchyMode) {\n\t\tmergedConfig = replaceIfNecessary(mergedConfig);\n\t\tsynchronized (this.contextCache) {\n\t\t\tthis.contextCache.remove(mergedConfig, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#put(key,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "public void put(MergedContextConfiguration key, ApplicationContext context)",
    "source_code": "\tpublic void put(MergedContextConfiguration key, ApplicationContext context) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\t\tAssert.notNull(context, \"ApplicationContext must not be null\");\n\n\t\tthis.contextMap.put(key, context);\n\t\tMergedContextConfiguration child = key;\n\t\tMergedContextConfiguration parent = child.getParent();\n\t\twhile (parent != null) {\n\t\t\tSet<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>());\n\t\t\tlist.add(child);\n\t\t\tchild = parent;\n\t\t\tparent = child.getParent();\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#remove(key,hierarchyMode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tpublic void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode) {\n\t\tAssert.notNull(key, \"Key must not be null\");\n\n\t\t// startKey is the level at which to begin clearing the cache,\n\t\t// depending on the configured hierarchy mode.\n\t\tMergedContextConfiguration startKey = key;\n\t\tif (hierarchyMode == HierarchyMode.EXHAUSTIVE) {\n\t\t\tMergedContextConfiguration parent = startKey.getParent();\n\t\t\twhile (parent != null) {\n\t\t\t\tstartKey = parent;\n\t\t\t\tparent = startKey.getParent();\n\t\t\t}\n\t\t}\n\n\t\tList<MergedContextConfiguration> removedContexts = new ArrayList<>();\n\t\tremove(removedContexts, startKey);\n\n\t\t// Remove all remaining references to any removed contexts from the\n\t\t// hierarchy map.\n\t\tfor (MergedContextConfiguration currentKey : removedContexts) {\n\t\t\tfor (Set<MergedContextConfiguration> children : this.hierarchyMap.values()) {\n\t\t\t\tchildren.remove(currentKey);\n\t\t\t}\n\t\t}\n\n\t\t// Remove empty entries from the hierarchy map.\n\t\tfor (Map.Entry<MergedContextConfiguration, Set<MergedContextConfiguration>> entry : this.hierarchyMap.entrySet()) {\n\t\t\tif (entry.getValue().isEmpty()) {\n\t\t\t\tthis.hierarchyMap.remove(entry.getKey());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.cache.<unknown>#removeEldestEntry(Map.Entry<MergedContextConfiguration,eldest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<MergedContextConfiguration",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest)",
    "source_code": "\t\tprotected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {\n\t\t\tif (this.size() > DefaultContextCache.this.getMaxSize()) {\n\t\t\t\t// Do NOT delete \"DefaultContextCache.this.\"; otherwise, we accidentally\n\t\t\t\t// invoke java.util.Map.remove(Object, Object).\n\t\t\t\tDefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL);\n\t\t\t}\n\n\t\t\t// Return false since we invoke a custom eviction algorithm.\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.test.context.jdbc.<unknown>#processAheadOfTime(runtimeHints,testClass,classLoader)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the supplied test class and its methods and register run-time\n\t * hints for any SQL scripts configured or detected as classpath resources\n\t * via {@link Sql @Sql}.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runtimeHints",
      "testClass",
      "classLoader"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader)",
    "source_code": "\tpublic void processAheadOfTime(RuntimeHints runtimeHints, Class<?> testClass, ClassLoader classLoader) {\n\t\tgetSqlAnnotationsFor(testClass).forEach(sql ->\n\t\t\tregisterClasspathResources(getScripts(sql, testClass, null, true), runtimeHints, classLoader));\n\t\tgetSqlMethods(testClass).forEach(testMethod ->\n\t\t\tgetSqlAnnotationsFor(testMethod).forEach(sql ->\n\t\t\t\tregisterClasspathResources(getScripts(sql, testClass, testMethod, false), runtimeHints, classLoader)));\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#evaluateAnnotation(annotationType,Function<A,expressionExtractor,Function<A,reasonExtractor,Function<A,loadContextExtractor,enabledOnTrue,context)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the expression configured via the supplied annotation type on\n\t * the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.\n\t * @param annotationType the type of annotation to process\n\t * @param expressionExtractor a function that extracts the expression from\n\t * the annotation\n\t * @param reasonExtractor a function that extracts the reason from the\n\t * annotation\n\t * @param loadContextExtractor a function that extracts the {@code loadContext}\n\t * flag from the annotation\n\t * @param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}\n\t * should be {@link ConditionEvaluationResult#enabled(String) enabled} if the expression\n\t * evaluates to {@code true}\n\t * @param context the {@code ExtensionContext}\n\t * @return {@link ConditionEvaluationResult#enabled(String) enabled} if the container\n\t * or test should be enabled; otherwise {@link ConditionEvaluationResult#disabled(String) disabled}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "annotationType",
      "Function<A",
      "expressionExtractor",
      "Function<A",
      "reasonExtractor",
      "Function<A",
      "loadContextExtractor",
      "enabledOnTrue",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "ConditionEvaluationResult",
    "signature": "protected ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context)",
    "source_code": "\tprotected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,\n\t\t\tFunction<A, String> expressionExtractor, Function<A, String> reasonExtractor,\n\t\t\tFunction<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {\n\n\t\tAnnotatedElement element = context.getElement().orElseThrow(() -> new IllegalStateException(\"No AnnotatedElement\"));\n\t\tOptional<A> annotation = findMergedAnnotation(element, annotationType);\n\n\t\tif (annotation.isEmpty()) {\n\t\t\tString reason = String.format(\"%s is enabled since @%s is not present\", element,\n\t\t\t\t\tannotationType.getSimpleName());\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(reason);\n\t\t\t}\n\t\t\treturn ConditionEvaluationResult.enabled(reason);\n\t\t}\n\n\t\tString expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)\n\t\t\t\t.orElseThrow(() -> new IllegalStateException(String.format(\n\t\t\t\t\t\t\"The expression in @%s on [%s] must not be blank\", annotationType.getSimpleName(), element)));\n\n\t\tboolean loadContext = loadContextExtractor.apply(annotation.get());\n\t\tboolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context);\n\t\tConditionEvaluationResult result;\n\n\t\tif (evaluatedToTrue) {\n\t\t\tString adjective = (enabledOnTrue ? \"enabled\" : \"disabled\");\n\t\t\tString reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(\n\t\t\t\t\t() -> String.format(\"%s is %s because @%s(\\\"%s\\\") evaluated to true\", element, adjective,\n\t\t\t\t\t\tannotationType.getSimpleName(), expression));\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(reason);\n\t\t\t}\n\t\t\tresult = (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)\n\t\t\t\t\t: ConditionEvaluationResult.disabled(reason));\n\t\t}\n\t\telse {\n\t\t\tString adjective = (enabledOnTrue ? \"disabled\" : \"enabled\");\n\t\t\tString reason = String.format(\"%s is %s because @%s(\\\"%s\\\") did not evaluate to true\",\n\t\t\t\t\telement, adjective, annotationType.getSimpleName(), expression);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(reason);\n\t\t\t}\n\t\t\tresult = (enabledOnTrue ? ConditionEvaluationResult.disabled(reason) :\n\t\t\t\t\tConditionEvaluationResult.enabled(reason));\n\t\t}\n\n\t\t// If we eagerly loaded the ApplicationContext to evaluate SpEL expressions\n\t\t// and the test class ends up being disabled, we have to check if the\n\t\t// user asked for the ApplicationContext to be closed via @DirtiesContext,\n\t\t// since the DirtiesContextTestExecutionListener will never be invoked for\n\t\t// a disabled test class.\n\t\t// See https://github.com/spring-projects/spring-framework/issues/26694\n\t\tif (loadContext && result.isDisabled() && element instanceof Class<?> testClass) {\n\t\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\t\tif (dirtiesContext != null) {\n\t\t\t\tHierarchyMode hierarchyMode = dirtiesContext.hierarchyMode();\n\t\t\t\tSpringExtension.getTestContextManager(context).getTestContext().markApplicationContextDirty(hierarchyMode);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#postProcessTestInstance(testInstance,context)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@link TestContextManager#prepareTestInstance}.\n\t * <p>As of Spring Framework 5.3.2, this method also validates that test\n\t * methods and test lifecycle methods are not annotated with\n\t * {@link Autowired @Autowired}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void postProcessTestInstance(Object testInstance, ExtensionContext context)",
    "source_code": "\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {\n\t\tvalidateAutowiredConfig(context);\n\t\tvalidateRecordApplicationEventsConfig(context);\n\t\tTestContextManager testContextManager = getTestContextManager(context);\n\t\tregisterMethodInvoker(testContextManager, context);\n\t\ttestContextManager.prepareTestInstance(testInstance);\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#resolveParameter(parameterContext,extensionContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve a value for the {@link Parameter} in the supplied {@link ParameterContext} by\n\t * retrieving the corresponding dependency from the test's {@link ApplicationContext}.\n\t * <p>Delegates to {@link ParameterResolutionDelegate#resolveDependency}.\n\t * @see #supportsParameter\n\t * @see ParameterResolutionDelegate#resolveDependency\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Object",
    "signature": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tint index = parameterContext.getIndex();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tApplicationContext applicationContext = getApplicationContext(extensionContext);\n\t\treturn ParameterResolutionDelegate.resolveDependency(parameter, index, testClass,\n\t\t\t\tapplicationContext.getAutowireCapableBeanFactory());\n\t}"
  },
  "org.springframework.test.context.junit.jupiter.<unknown>#supportsParameter(parameterContext,extensionContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the value for the {@link Parameter} in the supplied {@link ParameterContext}\n\t * should be autowired from the test's {@link ApplicationContext}.\n\t * <p>A parameter is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t * <ol>\n\t * <li>The {@linkplain ParameterContext#getDeclaringExecutable() declaring\n\t * executable} is a {@link Constructor} and\n\t * {@link TestConstructorUtils#isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * returns {@code true}. Note that {@code isAutowirableConstructor()} will be\n\t * invoked with a fallback {@link PropertyProvider} that delegates its lookup\n\t * to {@link ExtensionContext#getConfigurationParameter(String)}.</li>\n\t * <li>The parameter is of type {@link ApplicationContext} or a sub-type thereof.</li>\n\t * <li>The parameter is of type {@link ApplicationEvents} or a sub-type thereof.</li>\n\t * <li>{@link ParameterResolutionDelegate#isAutowirable} returns {@code true}.</li>\n\t * </ol>\n\t * <p><strong>WARNING</strong>: If a test class {@code Constructor} is annotated\n\t * with {@code @Autowired} or automatically autowirable (see {@link TestConstructor}),\n\t * Spring will assume the responsibility for resolving all parameters in the\n\t * constructor. Consequently, no other registered {@link ParameterResolver}\n\t * will be able to resolve parameters.\n\t * @see #resolveParameter\n\t * @see TestConstructorUtils#isAutowirableConstructor(Constructor, Class)\n\t * @see ParameterResolutionDelegate#isAutowirable\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameterContext",
      "extensionContext"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "boolean",
    "signature": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)",
    "source_code": "\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tParameter parameter = parameterContext.getParameter();\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tClass<?> testClass = extensionContext.getRequiredTestClass();\n\t\tPropertyProvider junitPropertyProvider = propertyName ->\n\t\t\t\textensionContext.getConfigurationParameter(propertyName).orElse(null);\n\t\treturn (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) ||\n\t\t\t\tApplicationContext.class.isAssignableFrom(parameter.getType()) ||\n\t\t\t\tsupportsApplicationEvents(parameterContext) ||\n\t\t\t\tParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addInlinedPropertiesToEnvironment(context,inlinedProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> to the {@link Environment} of the\n\t * supplied {@code context}.\n\t * <p>This method simply delegates to\n\t * {@link #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see TestPropertySource#properties\n\t * @see #addInlinedPropertiesToEnvironment(ConfigurableEnvironment, String[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableApplicationContext context, String... inlinedProperties) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\taddInlinedPropertiesToEnvironment(context.getEnvironment(), inlinedProperties);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addInlinedPropertiesToEnvironment(environment,inlinedProperties)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given <em>inlined properties</em> (in the form of <em>key-value</em>\n\t * pairs) to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>All key-value pairs will be added to the {@code Environment} as a\n\t * single {@link MapPropertySource} with the highest precedence.\n\t * <p>For details on the parsing of <em>inlined properties</em>, consult the\n\t * Javadoc for {@link #convertInlinedPropertiesToMap}.\n\t * @param environment the environment to update; never {@code null}\n\t * @param inlinedProperties the inlined properties to add to the environment;\n\t * potentially empty but never {@code null}\n\t * @since 4.1.5\n\t * @see MapPropertySource\n\t * @see #INLINED_PROPERTIES_PROPERTY_SOURCE_NAME\n\t * @see TestPropertySource#properties\n\t * @see #convertInlinedPropertiesToMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "inlinedProperties"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "void",
    "signature": "public void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties)",
    "source_code": "\tpublic static void addInlinedPropertiesToEnvironment(ConfigurableEnvironment environment, String... inlinedProperties) {\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(inlinedProperties, \"'inlinedProperties' must not be null\");\n\t\tif (!ObjectUtils.isEmpty(inlinedProperties)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Adding inlined properties to environment: \" +\n\t\t\t\t\t\tObjectUtils.nullSafeToString(inlinedProperties));\n\t\t\t}\n\t\t\tMapPropertySource ps = (MapPropertySource)\n\t\t\t\t\tenvironment.getPropertySources().get(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);\n\t\t\tif (ps == null) {\n\t\t\t\tps = new MapPropertySource(INLINED_PROPERTIES_PROPERTY_SOURCE_NAME, new LinkedHashMap<>());\n\t\t\t\tenvironment.getPropertySources().addFirst(ps);\n\t\t\t}\n\t\t\tps.getSource().putAll(convertInlinedPropertiesToMap(inlinedProperties));\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertiesFilesToEnvironment(context,locations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.1.5\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableEnvironment, ResourceLoader, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableApplicationContext context, String... locations) {\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertiesFilesToEnvironment(context.getEnvironment(), context, locations);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertiesFilesToEnvironment(environment,resourceLoader,locations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the {@link Properties} files from the given resource {@code locations}\n\t * to the supplied {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each properties file will be converted to a\n\t * {@link org.springframework.core.io.support.ResourcePropertySource ResourcePropertySource}\n\t * that will be added to the {@link PropertySources} of the environment with\n\t * the highest precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load each resource;\n\t * never {@code null}\n\t * @param locations the resource locations of {@code Properties} files to add\n\t * to the environment; potentially empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing a properties file\n\t * @since 4.3\n\t * @see org.springframework.core.io.support.ResourcePropertySource\n\t * @see TestPropertySource#locations\n\t * @see #addPropertiesFilesToEnvironment(ConfigurableApplicationContext, String...)\n\t * @see #addPropertySourcesToEnvironment(ConfigurableApplicationContext, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "void",
    "signature": "public void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations)",
    "source_code": "\tpublic static void addPropertiesFilesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, String... locations) {\n\n\t\tAssert.notNull(locations, \"'locations' must not be null\");\n\t\taddPropertySourcesToEnvironment(environment, resourceLoader,\n\t\t\t\tList.of(new PropertySourceDescriptor(locations)));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertySourcesToEnvironment(context,descriptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the\n\t * {@link Environment} of the supplied {@code context}.\n\t * <p>This method delegates to\n\t * {@link #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)}.\n\t * @param context the application context whose environment should be updated;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t * @see #addPropertySourcesToEnvironment(ConfigurableEnvironment, ResourceLoader, List)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableApplicationContext context,\n\t\t\tList<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(context, \"'context' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\taddPropertySourcesToEnvironment(context.getEnvironment(), context, descriptors);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#addPropertySourcesToEnvironment(environment,resourceLoader,descriptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add property sources for the given {@code descriptors} to the supplied\n\t * {@link ConfigurableEnvironment environment}.\n\t * <p>Property placeholders in resource locations (i.e., <code>${...}</code>)\n\t * will be {@linkplain Environment#resolveRequiredPlaceholders(String) resolved}\n\t * against the {@code Environment}.\n\t * <p>A {@link ResourcePatternResolver} will be used to resolve resource\n\t * location patterns into multiple resource locations.\n\t * <p>Each {@link PropertySource} will be created via the configured\n\t * {@link PropertySourceDescriptor#propertySourceFactory() PropertySourceFactory}\n\t * (or the {@link DefaultPropertySourceFactory} if no factory is configured)\n\t * and added to the {@link PropertySources} of the environment with the highest\n\t * precedence.\n\t * @param environment the environment to update; never {@code null}\n\t * @param resourceLoader the {@code ResourceLoader} to use to load resources;\n\t * never {@code null}\n\t * @param descriptors the property source descriptors to process; potentially\n\t * empty but never {@code null}\n\t * @throws IllegalStateException if an error occurs while processing the\n\t * descriptors and registering property sources\n\t * @since 6.1\n\t * @see TestPropertySource#locations\n\t * @see TestPropertySource#encoding\n\t * @see TestPropertySource#factory\n\t * @see PropertySourceFactory\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "environment",
      "resourceLoader",
      "descriptors"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "void",
    "signature": "public void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors)",
    "source_code": "\tpublic static void addPropertySourcesToEnvironment(ConfigurableEnvironment environment,\n\t\t\tResourceLoader resourceLoader, List<PropertySourceDescriptor> descriptors) {\n\n\t\tAssert.notNull(environment, \"'environment' must not be null\");\n\t\tAssert.notNull(resourceLoader, \"'resourceLoader' must not be null\");\n\t\tAssert.notNull(descriptors, \"'descriptors' must not be null\");\n\t\tResourcePatternResolver resourcePatternResolver =\n\t\t\t\tResourcePatternUtils.getResourcePatternResolver(resourceLoader);\n\t\tMutablePropertySources propertySources = environment.getPropertySources();\n\t\ttry {\n\t\t\tfor (PropertySourceDescriptor descriptor : descriptors) {\n\t\t\t\tif (!descriptor.locations().isEmpty()) {\n\t\t\t\t\tClass<? extends PropertySourceFactory> factoryClass = descriptor.propertySourceFactory();\n\t\t\t\t\tPropertySourceFactory factory = (factoryClass != null ?\n\t\t\t\t\t\t\tBeanUtils.instantiateClass(factoryClass) : defaultPropertySourceFactory);\n\n\t\t\t\t\tfor (String location : descriptor.locations()) {\n\t\t\t\t\t\tString resolvedLocation = environment.resolveRequiredPlaceholders(location);\n\t\t\t\t\t\tfor (Resource resource : resourcePatternResolver.getResources(resolvedLocation)) {\n\t\t\t\t\t\t\tPropertySource<?> propertySource = factory.createPropertySource(descriptor.name(),\n\t\t\t\t\t\t\t\t\tnew EncodedResource(resource, descriptor.encoding()));\n\t\t\t\t\t\t\tpropertySources.addFirst(propertySource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalStateException(\"Failed to add PropertySource to Environment\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#beforeOrAfterTestClass(testContext,requiredClassMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestClass} and {@link #afterTestClass}\n\t * by dirtying the context if appropriate (i.e., according to the required mode).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 140
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestClass(TestContext testContext, ClassMode requiredClassMode) throws Exception {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext dirtiesContext = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean classAnnotated = (dirtiesContext != null);\n\t\tClassMode classMode = (classAnnotated ? dirtiesContext.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"%s test class: context %s, class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testContext, classAnnotated, classMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"%s test class: class [%s], class annotated with @DirtiesContext [%s] with mode [%s]\"\n\t\t\t\t\t.formatted(getPhase(requiredClassMode), testClass.getSimpleName(), classAnnotated, classMode));\n\t\t}\n\n\t\tif (classMode == requiredClassMode) {\n\t\t\tdirtyContext(testContext, dirtiesContext.hierarchyMode());\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#beforeOrAfterTestMethod(testContext,requiredMethodMode,requiredClassMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the actual work for {@link #beforeTestMethod} and {@link #afterTestMethod}\n\t * by dirtying the context if appropriate (i.e., according to the required modes).\n\t * @param testContext the test context whose application context should\n\t * potentially be marked as dirty; never {@code null}\n\t * @param requiredMethodMode the method mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @param requiredClassMode the class mode required for a context to\n\t * be marked dirty in the current phase; never {@code null}\n\t * @throws Exception allows any exception to propagate\n\t * @since 4.2\n\t * @see #dirtyContext\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "requiredMethodMode",
      "requiredClassMode"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "void",
    "signature": "protected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode)",
    "source_code": "\tprotected void beforeOrAfterTestMethod(TestContext testContext, MethodMode requiredMethodMode,\n\t\t\tClassMode requiredClassMode) throws Exception {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(requiredMethodMode, \"requiredMethodMode must not be null\");\n\t\tAssert.notNull(requiredClassMode, \"requiredClassMode must not be null\");\n\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testClass, \"The test class of the supplied TestContext must not be null\");\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tDirtiesContext methodAnn = AnnotatedElementUtils.findMergedAnnotation(testMethod, DirtiesContext.class);\n\t\tDirtiesContext classAnn = TestContextAnnotationUtils.findMergedAnnotation(testClass, DirtiesContext.class);\n\t\tboolean methodAnnotated = (methodAnn != null);\n\t\tboolean classAnnotated = (classAnn != null);\n\t\tMethodMode methodMode = (methodAnnotated ? methodAnn.methodMode() : null);\n\t\tClassMode classMode = (classAnnotated ? classAnn.classMode() : null);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"\"\"\n\t\t\t\t\t%s test method: context %s, class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testContext, classAnnotated, classMode,\n\t\t\t\t\t\t\tmethodAnnotated, methodMode));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t%s test method: class [%s], method [%s], class annotated with @DirtiesContext [%s] \\\n\t\t\t\t\twith mode [%s], method annotated with @DirtiesContext [%s] with mode [%s]\"\"\"\n\t\t\t\t\t\t.formatted(getPhase(requiredMethodMode), testClass.getSimpleName(),\n\t\t\t\t\t\t\ttestMethod.getName(), classAnnotated, classMode, methodAnnotated, methodMode));\n\t\t}\n\n\t\tif ((methodMode == requiredMethodMode) || (classMode == requiredClassMode)) {\n\t\t\tHierarchyMode hierarchyMode = (methodAnnotated ? methodAnn.hierarchyMode() : classAnn.hierarchyMode());\n\t\t\tdirtyContext(testContext, hierarchyMode);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#computeAttribute(name,Function<String,computeFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Function<String",
      "computeFunction"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "T",
    "signature": "public T computeAttribute(String name, Function<String, T> computeFunction)",
    "source_code": "\tpublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(computeFunction, \"Compute function must not be null\");\n\t\tObject value = this.attributes.computeIfAbsent(name, computeFunction);\n\t\tAssert.state(value != null,\n\t\t\t\t() -> \"Compute function must not return null for attribute named '%s'\".formatted(name));\n\t\treturn (T) value;\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#customizeContext(context,mergedConfig)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\tif (!(beanFactory instanceof BeanDefinitionRegistry beanDefinitionRegistry)) {\n\t\t\tthrow new IllegalStateException(\"BeanFactory must be a BeanDefinitionRegistry\");\n\t\t}\n\n\t\tif (!beanDefinitionRegistry.containsBeanDefinition(DynamicPropertyRegistrarBeanInitializer.BEAN_NAME)) {\n\t\t\tBeanDefinition beanDefinition = new RootBeanDefinition(DynamicPropertyRegistrarBeanInitializer.class);\n\t\t\tbeanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tbeanDefinitionRegistry.registerBeanDefinition(DynamicPropertyRegistrarBeanInitializer.BEAN_NAME, beanDefinition);\n\t\t}\n\n\t\tif (!this.methods.isEmpty()) {\n\t\t\tConfigurableEnvironment environment = context.getEnvironment();\n\t\t\tDynamicValuesPropertySource propertySource = DynamicValuesPropertySource.getOrCreate(environment);\n\t\t\tDynamicPropertyRegistry registry = propertySource.dynamicPropertyRegistry;\n\t\t\tthis.methods.forEach(method -> {\n\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\tReflectionUtils.invokeMethod(method, null, registry);\n\t\t\t});\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#dirtyContext(testContext,hierarchyMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Mark the {@linkplain ApplicationContext application context} of the supplied\n\t * {@linkplain TestContext test context} as\n\t * {@linkplain TestContext#markApplicationContextDirty(DirtiesContext.HierarchyMode) dirty}\n\t * and set {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE\n\t * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.\n\t * @param testContext the test context whose application context should\n\t * be marked as dirty\n\t * @param hierarchyMode the context cache clearing mode to be applied if the\n\t * context is part of a hierarchy; may be {@code null}\n\t * @since 3.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testContext",
      "hierarchyMode"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode)",
    "source_code": "\tprotected void dirtyContext(TestContext testContext, @Nullable HierarchyMode hierarchyMode) {\n\t\ttestContext.markApplicationContextDirty(hierarchyMode);\n\t\ttestContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(constructor,testClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the constructor is autowirable\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(constructor, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(constructor,testClass,fallbackPropertyProvider)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied constructor for the given test class is\n\t * autowirable.\n\t *\n\t * <p>A constructor is considered to be autowirable if one of the following\n\t * conditions is {@code true}.\n\t *\n\t * <ol>\n\t * <li>The constructor is annotated with {@link Autowired @Autowired},\n\t * {@link jakarta.inject.Inject @jakarta.inject.Inject}, or\n\t * {@link javax.inject.Inject @javax.inject.Inject}.</li>\n\t * <li>{@link TestConstructor @TestConstructor} is <em>present</em> or\n\t * <em>meta-present</em> on the test class with\n\t * {@link TestConstructor#autowireMode() autowireMode} set to\n\t * {@link AutowireMode#ALL ALL}.</li>\n\t * <li>The default <em>test constructor autowire mode</em> has been set to\n\t * {@code ALL} in {@link SpringProperties} or in the supplied fallback\n\t * {@link PropertyProvider} (see\n\t * {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}).</li>\n\t * </ol>\n\t * @param constructor a constructor for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for the default <em>test constructor autowire mode</em> if no\n\t * such value is found in {@link SpringProperties}\n\t * @return {@code true} if the constructor is autowirable\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "constructor",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Constructor<?> constructor, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\t// Is the constructor annotated with @Autowired/@Inject?\n\t\tif (isAnnotatedWithAutowiredOrInject(constructor)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tAutowireMode autowireMode;\n\n\t\t// Is the test class annotated with @TestConstructor?\n\t\tTestConstructor testConstructor = TestContextAnnotationUtils.findMergedAnnotation(testClass, TestConstructor.class);\n\t\tif (testConstructor != null) {\n\t\t\tautowireMode = testConstructor.autowireMode();\n\t\t}\n\t\telse {\n\t\t\t// Custom global default from SpringProperties?\n\t\t\tString value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\tautowireMode = AutowireMode.from(value);\n\n\t\t\t// Use fallback provider?\n\t\t\tif (autowireMode == null && fallbackPropertyProvider != null) {\n\t\t\t\tvalue = fallbackPropertyProvider.get(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME);\n\t\t\t\tautowireMode = AutowireMode.from(value);\n\t\t\t}\n\t\t}\n\n\t\treturn (autowireMode == AutowireMode.ALL);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(executable,testClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Executable, Class, PropertyProvider)}\n\t * will a value of {@code null} for the fallback {@link PropertyProvider}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @see #isAutowirableConstructor(Executable, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass) {\n\t\treturn isAutowirableConstructor(executable, testClass, null);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#isAutowirableConstructor(executable,testClass,fallbackPropertyProvider)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the supplied executable for the given test class is an\n\t * autowirable constructor.\n\t * <p>This method delegates to {@link #isAutowirableConstructor(Constructor, Class, PropertyProvider)}\n\t * if the supplied executable is a constructor and otherwise returns {@code false}.\n\t * @param executable an executable for the test class\n\t * @param testClass the test class\n\t * @param fallbackPropertyProvider fallback property provider used to look up\n\t * the value for {@link TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME}\n\t * if no such value is found in {@link SpringProperties}\n\t * @return {@code true} if the executable is an autowirable constructor\n\t * @since 5.3\n\t * @see #isAutowirableConstructor(Constructor, Class, PropertyProvider)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "executable",
      "testClass",
      "fallbackPropertyProvider"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "boolean",
    "signature": "public boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider)",
    "source_code": "\tpublic static boolean isAutowirableConstructor(Executable executable, Class<?> testClass,\n\t\t\t@Nullable PropertyProvider fallbackPropertyProvider) {\n\n\t\treturn (executable instanceof Constructor<?> constructor &&\n\t\t\t\tisAutowirableConstructor(constructor, testClass, fallbackPropertyProvider));\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#loadBeanDefinitions(context,mergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register classes in the supplied {@link GenericApplicationContext context}\n\t * from the classes in the supplied {@link MergedContextConfiguration}.\n\t * <p>Each class must represent a <em>component class</em>. An\n\t * {@link AnnotatedBeanDefinitionReader} is used to register the appropriate\n\t * bean definitions.\n\t * <p>Note that this method does not call {@link #createBeanDefinitionReader}\n\t * since {@code AnnotatedBeanDefinitionReader} is not an instance of\n\t * {@link BeanDefinitionReader}.\n\t * @param context the context in which the component classes should be registered\n\t * @param mergedConfig the merged configuration from which the classes should be retrieved\n\t * @see AbstractGenericContextLoader#loadBeanDefinitions\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "protected void loadBeanDefinitions(GenericApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tprotected void loadBeanDefinitions(GenericApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tClass<?>[] componentClasses = mergedConfig.getClasses();\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Registering component classes: \" + classNames(componentClasses));\n\t\t}\n\t\tnew AnnotatedBeanDefinitionReader(context).register(componentClasses);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#loadContextForAotRuntime(mergedConfig,initializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to an appropriate candidate {@code SmartContextLoader} to load\n\t * an {@link ApplicationContext} for AOT run-time execution.\n\t * <p>Delegation is based on explicit knowledge of the implementations of the\n\t * default loaders. See {@link #loadContext(MergedContextConfiguration)} for\n\t * details.\n\t * @param mergedConfig the merged context configuration to use to load the application context\n\t * @param initializer the {@code ApplicationContextInitializer} that should\n\t * be applied to the context in order to recreate bean definitions\n\t * @return a new application context\n\t * @throws IllegalStateException if neither candidate loader is capable of loading an\n\t * {@code ApplicationContext} from the supplied merged context configuration\n\t * @since 6.0\n\t * @see AotContextLoader#loadContextForAotRuntime(MergedContextConfiguration, ApplicationContextInitializer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "initializer"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "ApplicationContext",
    "signature": "public ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer)",
    "source_code": "\tpublic final ApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {\n\n\t\tAotContextLoader loader = getAotContextLoader(mergedConfig);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Delegating to %s to load context for AOT execution for %s\"\n\t\t\t\t\t.formatted(name(loader), mergedConfig));\n\t\t}\n\t\treturn loader.loadContextForAotRuntime(mergedConfig, initializer);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#modifyLocations(clazz,locations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@code AnnotationConfigContextLoader} should be used as a\n\t * {@link org.springframework.test.context.SmartContextLoader SmartContextLoader},\n\t * not as a legacy {@link org.springframework.test.context.ContextLoader ContextLoader}.\n\t * Consequently, this method is not supported.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @see AbstractContextLoader#modifyLocations\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "String[]",
    "signature": "protected String[] modifyLocations(Class<?> clazz, String... locations)",
    "source_code": "\tprotected String[] modifyLocations(Class<?> clazz, String... locations) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"AnnotationConfigContextLoader does not support the modifyLocations(Class, String...) method\");\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 464
    },
    "return": "Object",
    "signature": "public Object put(Object key, Object value)",
    "source_code": "\t\tpublic Object put(Object key, Object value) {\n\t\t\tif (key instanceof String str) {\n\t\t\t\treturn this.map.put(str, value);\n\t\t\t}\n\t\t\t// No need to invoke super.put(key, value);\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.test.context.support.<unknown>#resolveContextLoader(testClass,configAttributesList)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the\n\t * supplied list of {@link ContextConfigurationAttributes} and then instantiate\n\t * and return that {@code ContextLoader}.\n\t * <p>If the user has not explicitly declared which loader to use, the value\n\t * returned from {@link #getDefaultContextLoaderClass} will be used as the\n\t * default context loader class. For details on the class resolution process,\n\t * see {@link #resolveExplicitContextLoaderClass} and\n\t * {@link #getDefaultContextLoaderClass}.\n\t * @param testClass the test class for which the {@code ContextLoader} should be\n\t * resolved; must not be {@code null}\n\t * @param configAttributesList the list of configuration attributes to process; must\n\t * not be {@code null}; must be ordered <em>bottom-up</em>\n\t * (i.e., as if we were traversing up the class hierarchy and enclosing class hierarchy)\n\t * @return the resolved {@code ContextLoader} for the supplied {@code testClass}\n\t * (never {@code null})\n\t * @throws IllegalStateException if {@link #getDefaultContextLoaderClass(Class)}\n\t * returns {@code null}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "testClass",
      "configAttributesList"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "ContextLoader",
    "signature": "protected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList)",
    "source_code": "\tprotected ContextLoader resolveContextLoader(Class<?> testClass,\n\t\t\tList<ContextConfigurationAttributes> configAttributesList) {\n\n\t\tAssert.notNull(testClass, \"Class must not be null\");\n\t\tAssert.notNull(configAttributesList, \"ContextConfigurationAttributes list must not be null\");\n\n\t\tClass<? extends ContextLoader> contextLoaderClass = resolveExplicitContextLoaderClass(configAttributesList);\n\t\tif (contextLoaderClass == null) {\n\t\t\tcontextLoaderClass = getDefaultContextLoaderClass(testClass);\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Using ContextLoader class [%s] for test class [%s]\",\n\t\t\t\t\tcontextLoaderClass.getName(), testClass.getName()));\n\t\t}\n\t\treturn BeanUtils.instantiateClass(contextLoaderClass, ContextLoader.class);\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "void",
    "signature": "public void setAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic void setAttribute(String name, @Nullable Object value) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tsynchronized (this.attributes) {\n\t\t\tif (value != null) {\n\t\t\t\tthis.attributes.put(name, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.attributes.remove(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.context.support.<unknown>#updateState(testInstance,testMethod,testException)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testInstance",
      "testMethod",
      "testException"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void updateState(@Nullable Object testInstance, @Nullable Method testMethod, @Nullable Throwable testException)",
    "source_code": "\tpublic void updateState(@Nullable Object testInstance, @Nullable Method testMethod, @Nullable Throwable testException) {\n\t\tthis.testInstance = testInstance;\n\t\tthis.testMethod = testMethod;\n\t\tthis.testException = testException;\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#createDelegatingTransactionAttribute(testContext,targetAttribute)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a delegating {@link TransactionAttribute} for the supplied target\n\t * {@link TransactionAttribute} and {@link TestContext}, using the names of\n\t * the test class and test method to build the name of the transaction.\n\t * @param testContext the {@code TestContext} upon which to base the name\n\t * @param targetAttribute the {@code TransactionAttribute} to delegate to\n\t * @return the delegating {@code TransactionAttribute}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "targetAttribute"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute createDelegatingTransactionAttribute(TestContext testContext, TransactionAttribute targetAttribute)",
    "source_code": "\tpublic static TransactionAttribute createDelegatingTransactionAttribute(\n\t\t\tTestContext testContext, TransactionAttribute targetAttribute) {\n\n\t\treturn createDelegatingTransactionAttribute(testContext, targetAttribute, true);\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#createDelegatingTransactionAttribute(testContext,targetAttribute,includeMethodName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a delegating {@link TransactionAttribute} for the supplied target\n\t * {@link TransactionAttribute} and {@link TestContext}, using the names of\n\t * the test class and test method (if requested) to build the name of the\n\t * transaction.\n\t * @param testContext the {@code TestContext} upon which to base the name\n\t * @param targetAttribute the {@code TransactionAttribute} to delegate to\n\t * @param includeMethodName {@code true} if the test method's name should be\n\t * included in the name of the transaction\n\t * @return the delegating {@code TransactionAttribute}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "targetAttribute",
      "includeMethodName"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute createDelegatingTransactionAttribute(TestContext testContext, TransactionAttribute targetAttribute, boolean includeMethodName)",
    "source_code": "\tpublic static TransactionAttribute createDelegatingTransactionAttribute(\n\t\t\tTestContext testContext, TransactionAttribute targetAttribute, boolean includeMethodName) {\n\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tAssert.notNull(targetAttribute, \"Target TransactionAttribute must not be null\");\n\t\treturn new TestContextTransactionAttribute(targetAttribute, testContext, includeMethodName);\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#retrieveDataSource(testContext,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@link DataSource} to use for the supplied {@linkplain TestContext\n\t * test context}.\n\t * <p>The following algorithm is used to retrieve the {@code DataSource} from\n\t * the {@link org.springframework.context.ApplicationContext ApplicationContext}\n\t * of the supplied test context:\n\t * <ol>\n\t * <li>Look up the {@code DataSource} by type and name, if the supplied\n\t * {@code name} is non-empty, throwing a {@link BeansException} if the named\n\t * {@code DataSource} does not exist.\n\t * <li>Attempt to look up the single {@code DataSource} by type.\n\t * <li>Attempt to look up the <em>primary</em> {@code DataSource} by type.\n\t * <li>Attempt to look up the {@code DataSource} by type and the\n\t * {@linkplain #DEFAULT_DATA_SOURCE_NAME default data source name}.\n\t * </ol>\n\t * @param testContext the test context for which the {@code DataSource}\n\t * should be retrieved; never {@code null}\n\t * @param name the name of the {@code DataSource} to retrieve\n\t * (may be {@code null} or <em>empty</em>)\n\t * @return the {@code DataSource} to use, or {@code null} if not found\n\t * @throws BeansException if an error occurs while retrieving an explicitly\n\t * named {@code DataSource}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "DataSource",
    "signature": "public DataSource retrieveDataSource(TestContext testContext, @Nullable String name)",
    "source_code": "\tpublic static DataSource retrieveDataSource(TestContext testContext, @Nullable String name) {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\n\t\ttry {\n\t\t\t// Look up by type and explicit name\n\t\t\tif (StringUtils.hasText(name)) {\n\t\t\t\treturn bf.getBean(name, DataSource.class);\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.error(String.format(\"Failed to retrieve DataSource named '%s' for test context %s\",\n\t\t\t\t\tname, testContext), ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\ttry {\n\t\t\tif (bf instanceof ListableBeanFactory lbf) {\n\t\t\t\t// Look up single bean by type\n\t\t\t\tMap<String, DataSource> dataSources =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, DataSource.class);\n\t\t\t\tif (dataSources.size() == 1) {\n\t\t\t\t\treturn dataSources.values().iterator().next();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// look up single bean by type, with support for 'primary' beans\n\t\t\t\t\treturn bf.getBean(DataSource.class);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name\n\t\t\treturn bf.getBean(DEFAULT_DATA_SOURCE_NAME, DataSource.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogBeansException(testContext, ex, DataSource.class);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.transaction.<unknown>#retrieveTransactionManager(testContext,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the {@linkplain PlatformTransactionManager transaction manager}\n\t * to use for the supplied {@linkplain TestContext test context}.\n\t * <p>The following algorithm is used to retrieve the transaction manager\n\t * from the {@link org.springframework.context.ApplicationContext ApplicationContext}\n\t * of the supplied test context:\n\t * <ol>\n\t * <li>Look up the transaction manager by type and explicit name, if the supplied\n\t * {@code name} is non-empty, throwing a {@link BeansException} if the named\n\t * transaction manager does not exist.\n\t * <li>Attempt to look up the transaction manager via a\n\t * {@link TransactionManagementConfigurer}, if present.\n\t * <li>Attempt to look up the single transaction manager by type.\n\t * <li>Attempt to look up the <em>primary</em> transaction manager by type.\n\t * <li>Attempt to look up the transaction manager by type and the\n\t * {@linkplain #DEFAULT_TRANSACTION_MANAGER_NAME default transaction manager\n\t * name}.\n\t * </ol>\n\t * @param testContext the test context for which the transaction manager\n\t * should be retrieved; never {@code null}\n\t * @param name the name of the transaction manager to retrieve\n\t * (may be {@code null} or <em>empty</em>)\n\t * @return the transaction manager to use, or {@code null} if not found\n\t * @throws BeansException if an error occurs while retrieving an explicitly\n\t * named transaction manager\n\t * @throws IllegalStateException if more than one TransactionManagementConfigurer\n\t * exists in the ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "testContext",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "PlatformTransactionManager",
    "signature": "public PlatformTransactionManager retrieveTransactionManager(TestContext testContext, @Nullable String name)",
    "source_code": "\tpublic static PlatformTransactionManager retrieveTransactionManager(TestContext testContext, @Nullable String name) {\n\t\tAssert.notNull(testContext, \"TestContext must not be null\");\n\t\tBeanFactory bf = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\n\t\ttry {\n\t\t\t// Look up by type and explicit name\n\t\t\tif (StringUtils.hasText(name)) {\n\t\t\t\treturn bf.getBean(name, PlatformTransactionManager.class);\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogger.error(String.format(\"Failed to retrieve transaction manager named '%s' for test context %s\",\n\t\t\t\t\tname, testContext), ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\ttry {\n\t\t\tif (bf instanceof ListableBeanFactory lbf) {\n\t\t\t\t// Look up single TransactionManagementConfigurer\n\t\t\t\tMap<String, TransactionManagementConfigurer> configurers =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, TransactionManagementConfigurer.class);\n\t\t\t\tAssert.state(configurers.size() <= 1,\n\t\t\t\t\t\t\"Only one TransactionManagementConfigurer may exist in the ApplicationContext\");\n\t\t\t\tif (configurers.size() == 1) {\n\t\t\t\t\tTransactionManager tm = configurers.values().iterator().next().annotationDrivenTransactionManager();\n\t\t\t\t\tAssert.state(tm instanceof PlatformTransactionManager, () ->\n\t\t\t\t\t\t\"Transaction manager specified via TransactionManagementConfigurer \" +\n\t\t\t\t\t\t\"is not a PlatformTransactionManager: \" + tm);\n\t\t\t\t\treturn (PlatformTransactionManager) tm;\n\t\t\t\t}\n\n\t\t\t\t// Look up single bean by type\n\t\t\t\tMap<String, PlatformTransactionManager> txMgrs =\n\t\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(lbf, PlatformTransactionManager.class);\n\t\t\t\tif (txMgrs.size() == 1) {\n\t\t\t\t\treturn txMgrs.values().iterator().next();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// Look up single bean by type, with support for 'primary' beans\n\t\t\t\t\treturn bf.getBean(PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look up by type and default name\n\t\t\treturn bf.getBean(DEFAULT_TRANSACTION_MANAGER_NAME, PlatformTransactionManager.class);\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tlogBeansException(testContext, ex, PlatformTransactionManager.class);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToClasspathResourcePaths(clazz,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to classpath resource paths.\n\t * <p>Delegates to {@link #convertToClasspathResourcePaths(Class, boolean, String...)}\n\t * with {@code false} supplied for the {@code preservePlaceholders} flag.\n\t * @param clazz the class with which the paths are associated\n\t * @param paths the paths to be converted\n\t * @return a new array of converted resource paths\n\t * @see #convertToResources\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "String[]",
    "signature": "public String[] convertToClasspathResourcePaths(Class<?> clazz, String... paths)",
    "source_code": "\tpublic static String[] convertToClasspathResourcePaths(Class<?> clazz, String... paths) {\n\t\treturn convertToClasspathResourcePaths(clazz, false, paths);\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToClasspathResourcePaths(clazz,preservePlaceholders,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to classpath resource paths.\n\t *\n\t * <p>For each of the supplied paths:\n\t * <ul>\n\t * <li>A plain path &mdash; for example, {@code \"context.xml\"} &mdash; will\n\t * be treated as a classpath resource that is relative to the package in\n\t * which the specified class is defined. Such a path will be prepended with\n\t * the {@code classpath:} prefix and the path to the package for the class.\n\t * <li>A path starting with a slash will be treated as an absolute path\n\t * within the classpath, for example: {@code \"/org/example/schema.sql\"}.\n\t * Such a path will be prepended with the {@code classpath:} prefix.\n\t * <li>A path which is already prefixed with a URL protocol (for example,\n\t * {@code classpath:}, {@code file:}, {@code http:}, etc.) will not have its\n\t * protocol modified.\n\t * </ul>\n\t * <p>Each path will then be {@linkplain StringUtils#cleanPath cleaned},\n\t * unless the {@code preservePlaceholders} flag is {@code true} and the path\n\t * contains one or more placeholders in the form <code>${placeholder.name}</code>.\n\t * @param clazz the class with which the paths are associated\n\t * @param preservePlaceholders {@code true} if placeholders should be preserved\n\t * @param paths the paths to be converted\n\t * @return a new array of converted resource paths\n\t * @since 5.2\n\t * @see #convertToResources\n\t * @see ResourceUtils#CLASSPATH_URL_PREFIX\n\t * @see ResourceUtils#FILE_URL_PREFIX\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "preservePlaceholders",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "String[]",
    "signature": "public String[] convertToClasspathResourcePaths(Class<?> clazz, boolean preservePlaceholders, String... paths)",
    "source_code": "\tpublic static String[] convertToClasspathResourcePaths(Class<?> clazz, boolean preservePlaceholders, String... paths) {\n\t\tString[] convertedPaths = new String[paths.length];\n\t\tfor (int i = 0; i < paths.length; i++) {\n\t\t\tString path = paths[i];\n\n\t\t\t// Absolute path\n\t\t\tif (path.startsWith(SLASH)) {\n\t\t\t\tconvertedPaths[i] = ResourceUtils.CLASSPATH_URL_PREFIX + path;\n\t\t\t}\n\t\t\t// Relative path\n\t\t\telse if (!ResourcePatternUtils.isUrl(path)) {\n\t\t\t\tconvertedPaths[i] = ResourceUtils.CLASSPATH_URL_PREFIX + SLASH +\n\t\t\t\t\t\tClassUtils.classPackageAsResourcePath(clazz) + SLASH + path;\n\t\t\t}\n\t\t\t// URL\n\t\t\telse {\n\t\t\t\tconvertedPaths[i] = path;\n\t\t\t}\n\n\t\t\tif (!(preservePlaceholders && PLACEHOLDER_PATTERN.matcher(convertedPaths[i]).matches())) {\n\t\t\t\tconvertedPaths[i] = StringUtils.cleanPath(convertedPaths[i]);\n\t\t\t}\n\t\t}\n\t\treturn convertedPaths;\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToResourceList(resourceLoader,environment,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to a list of {@link Resource} handles using the given\n\t * {@link ResourceLoader} and {@link Environment}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param environment the {@code Environment} to use to resolve property placeholders\n\t * in the paths\n\t * @param paths the paths to be converted\n\t * @return a new, mutable list of resources\n\t * @since 6.2\n\t * @see #convertToResources(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t * @see Environment#resolveRequiredPlaceholders(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "environment",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "List<Resource>",
    "signature": "public List<Resource> convertToResourceList(ResourceLoader resourceLoader, Environment environment, String... paths)",
    "source_code": "\tpublic static List<Resource> convertToResourceList(\n\t\t\tResourceLoader resourceLoader, Environment environment, String... paths) {\n\n\t\treturn Arrays.stream(paths)\n\t\t\t\t.map(environment::resolveRequiredPlaceholders)\n\t\t\t\t.map(resourceLoader::getResource)\n\t\t\t\t.collect(Collectors.toCollection(ArrayList::new));\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToResourceList(resourceLoader,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to a list of {@link Resource} handles using\n\t * the given {@link ResourceLoader}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param paths the paths to be converted\n\t * @return a new, mutable list of resources\n\t * @since 4.2\n\t * @see #convertToResources(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "List<Resource>",
    "signature": "public List<Resource> convertToResourceList(ResourceLoader resourceLoader, String... paths)",
    "source_code": "\tpublic static List<Resource> convertToResourceList(ResourceLoader resourceLoader, String... paths) {\n\t\treturn stream(resourceLoader, paths).collect(Collectors.toCollection(ArrayList::new));\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#convertToResources(resourceLoader,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the supplied paths to an array of {@link Resource} handles using\n\t * the given {@link ResourceLoader}.\n\t * @param resourceLoader the {@code ResourceLoader} to use to convert the paths\n\t * @param paths the paths to be converted\n\t * @return a new array of resources\n\t * @see #convertToResourceList(ResourceLoader, String...)\n\t * @see #convertToClasspathResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resourceLoader",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "Resource[]",
    "signature": "public Resource[] convertToResources(ResourceLoader resourceLoader, String... paths)",
    "source_code": "\tpublic static Resource[] convertToResources(ResourceLoader resourceLoader, String... paths) {\n\t\treturn stream(resourceLoader, paths).toArray(Resource[]::new);\n\t}"
  },
  "org.springframework.test.context.util.<unknown>#handleFailure(factoryType,factoryImplementationName,failure)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "factoryType",
      "factoryImplementationName",
      "failure"
    ],
    "position": {
      "column": 1,
      "line": 39
    },
    "return": "void",
    "signature": "public void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure)",
    "source_code": "\tpublic void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure) {\n\t\tThrowable ex = (failure instanceof InvocationTargetException ite ? ite.getTargetException() : failure);\n\t\tif (ex instanceof ClassNotFoundException || ex instanceof NoClassDefFoundError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tSkipping candidate %1$s [%2$s] due to a missing dependency. \\\n\t\t\t\t\t\tSpecify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tand their required dependencies available. Offending class: %3$s\"\"\"\n\t\t\t\t\t\t\t.formatted(factoryType.getSimpleName(), factoryImplementationName, ex.getMessage()));\n\t\t\t}\n\t\t}\n\t\telse if (ex instanceof LinkageError) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"\"\"\n\t\t\t\t\t\tCould not load %1$s [%2$s]. Specify custom %1$s classes or make the default %1$s classes \\\n\t\t\t\t\t\tavailable.\"\"\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t\t}\n\t\t}\n\t\t// Workaround for https://github.com/oracle/graal/issues/6691\n\t\telse if (NativeDetector.inNativeImage() && ex instanceof IllegalStateException) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Skipping candidate %1$s [%2$s] due to an error when loading it in a native image.\"\n\t\t\t\t\t\t.formatted(factoryType.getSimpleName(), factoryImplementationName));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\tthrow runtimeException;\n\t\t\t}\n\t\t\tif (ex instanceof Error error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\"Failed to load %s [%s]\".formatted(factoryType.getSimpleName(), factoryImplementationName), ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#configureWebResources(context,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configures web resources for the supplied web application context (WAC).\n\t * <h4>Implementation Details</h4>\n\t * <p>If the supplied WAC has no parent or its parent is not a WAC, the\n\t * supplied WAC will be configured as the Root WAC (see \"<em>Root WAC\n\t * Configuration</em>\" below).\n\t * <p>Otherwise the context hierarchy of the supplied WAC will be traversed\n\t * to find the top-most WAC (i.e., the root); and the {@link ServletContext}\n\t * of the Root WAC will be set as the {@code ServletContext} for the supplied\n\t * WAC.\n\t * <h4>Root WAC Configuration</h4>\n\t * <ul>\n\t * <li>The resource base path is retrieved from the supplied\n\t * {@code WebMergedContextConfiguration}.</li>\n\t * <li>A {@link ResourceLoader} is instantiated for the {@link MockServletContext}:\n\t * if the resource base path is prefixed with \"{@code classpath:}\", a\n\t * {@link DefaultResourceLoader} will be used; otherwise, a\n\t * {@link FileSystemResourceLoader} will be used.</li>\n\t * <li>A {@code MockServletContext} will be created using the resource base\n\t * path and resource loader.</li>\n\t * <li>The supplied {@link GenericWebApplicationContext} is then stored in\n\t * the {@code MockServletContext} under the\n\t * {@link WebApplicationContext#ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE} key.</li>\n\t * <li>Finally, the {@code MockServletContext} is set in the\n\t * {@code WebApplicationContext}.</li>\n\t * </ul>\n\t * @param context the web application context for which to configure the web resources\n\t * @param webMergedConfig the merged context configuration to use to load the web application context\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void configureWebResources(GenericWebApplicationContext context,\n\t\t\tWebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void configureWebResources(GenericWebApplicationContext context,\n\t\t\tWebMergedContextConfiguration webMergedConfig) {\n\n\t\tApplicationContext parent = context.getParent();\n\n\t\t// If the WebApplicationContext has no parent or the parent is not a WebApplicationContext,\n\t\t// set the current context as the root WebApplicationContext:\n\t\tif (!(parent instanceof WebApplicationContext)) {\n\t\t\tString resourceBasePath = webMergedConfig.getResourceBasePath();\n\t\t\tResourceLoader resourceLoader = (resourceBasePath.startsWith(ResourceLoader.CLASSPATH_URL_PREFIX) ?\n\t\t\t\t\tnew DefaultResourceLoader() : new FileSystemResourceLoader());\n\t\t\tServletContext servletContext = new MockServletContext(resourceBasePath, resourceLoader);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);\n\t\t\tcontext.setServletContext(servletContext);\n\t\t}\n\t\telse {\n\t\t\tServletContext servletContext = null;\n\t\t\t// Find the root WebApplicationContext\n\t\t\twhile (parent != null) {\n\t\t\t\tif (parent instanceof WebApplicationContext parentWac &&\n\t\t\t\t\t\t!(parent.getParent() instanceof WebApplicationContext)) {\n\t\t\t\t\tservletContext = parentWac.getServletContext();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparent = parent.getParent();\n\t\t\t}\n\t\t\tAssert.state(servletContext != null, \"Failed to find root WebApplicationContext in the context hierarchy\");\n\t\t\tcontext.setServletContext(servletContext);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#customizeBeanFactory(beanFactory,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the internal bean factory of the {@code WebApplicationContext}\n\t * created by this context loader.\n\t * <p>The default implementation is empty but can be overridden in subclasses\n\t * to customize {@code DefaultListableBeanFactory}'s standard settings.\n\t * @param beanFactory the bean factory created by this context loader\n\t * @param webMergedConfig the merged context configuration to use to load the\n\t * web application context\n\t * @see #loadContext(MergedContextConfiguration)\n\t * @see DefaultListableBeanFactory#setAllowBeanDefinitionOverriding\n\t * @see DefaultListableBeanFactory#setAllowEagerClassLoading\n\t * @see DefaultListableBeanFactory#setAllowCircularReferences\n\t * @see DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "beanFactory",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory, WebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void customizeBeanFactory(\n\t\t\tDefaultListableBeanFactory beanFactory, WebMergedContextConfiguration webMergedConfig) {\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#customizeContext(context,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the {@link GenericWebApplicationContext} created by this context\n\t * loader <i>after</i> bean definitions have been loaded into the context but\n\t * <i>before</i> the context is refreshed.\n\t * <p>The default implementation simply delegates to\n\t * {@link AbstractContextLoader#customizeContext(ConfigurableApplicationContext, MergedContextConfiguration)}.\n\t * @param context the newly created web application context\n\t * @param webMergedConfig the merged context configuration to use to load the\n\t * web application context\n\t * @see #loadContext(MergedContextConfiguration)\n\t * @see #customizeContext(ConfigurableApplicationContext, MergedContextConfiguration)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "void",
    "signature": "protected void customizeContext(GenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected void customizeContext(\n\t\t\tGenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig) {\n\n\t\tsuper.customizeContext(context, webMergedConfig);\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#loadBeanDefinitions(context,webMergedConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load bean definitions into the supplied {@link GenericWebApplicationContext context}\n\t * from the locations or classes in the supplied {@code WebMergedContextConfiguration}.\n\t * <p>Concrete subclasses must provide an appropriate implementation.\n\t * @param context the context into which the bean definitions should be loaded\n\t * @param webMergedConfig the merged context configuration to use to load the\n\t * web application context\n\t * @see #loadContext(MergedContextConfiguration)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "webMergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "protected void loadBeanDefinitions(GenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig)",
    "source_code": "\tprotected abstract void loadBeanDefinitions(\n\t\t\tGenericWebApplicationContext context, WebMergedContextConfiguration webMergedConfig);\n\n\t/**\n\t * Customize the {@link GenericWebApplicationContext} created by this context"
  },
  "org.springframework.test.context.web.<unknown>#loadContextForAotRuntime(mergedConfig,initializer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Load a {@link GenericWebApplicationContext} for AOT run-time execution based on\n\t * the supplied {@link MergedContextConfiguration} and\n\t * {@link ApplicationContextInitializer}.\n\t * @param mergedConfig the merged context configuration to use to load the\n\t * application context\n\t * @param initializer the {@code ApplicationContextInitializer} that should\n\t * be applied to the context in order to recreate bean definitions\n\t * @return a new web application context\n\t * @throws Exception if context loading failed\n\t * @since 6.0\n\t * @see AotContextLoader#loadContextForAotRuntime(MergedContextConfiguration, ApplicationContextInitializer)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mergedConfig",
      "initializer"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "GenericWebApplicationContext",
    "signature": "public GenericWebApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer)",
    "source_code": "\tpublic final GenericWebApplicationContext loadContextForAotRuntime(MergedContextConfiguration mergedConfig,\n\t\t\tApplicationContextInitializer<ConfigurableApplicationContext> initializer) throws Exception {\n\n\t\tAssert.notNull(mergedConfig, \"MergedContextConfiguration must not be null\");\n\t\tAssert.notNull(initializer, \"ApplicationContextInitializer must not be null\");\n\t\tif (!(mergedConfig instanceof WebMergedContextConfiguration webMergedConfig)) {\n\t\t\tthrow new IllegalArgumentException(\"\"\"\n\t\t\t\t\tCannot load WebApplicationContext from non-web merged context configuration %s. \\\n\t\t\t\t\tConsider annotating your test class with @WebAppConfiguration.\"\"\"\n\t\t\t\t\t\t.formatted(mergedConfig));\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Loading WebApplicationContext for AOT runtime for \" + mergedConfig);\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Loading WebApplicationContext for AOT runtime for test class \" +\n\t\t\t\t\tmergedConfig.getTestClass().getName());\n\t\t}\n\n\t\tvalidateMergedContextConfiguration(webMergedConfig);\n\n\t\tGenericWebApplicationContext context = createContext();\n\t\ttry {\n\t\t\tconfigureWebResources(context, webMergedConfig);\n\t\t\tprepareContext(context, webMergedConfig);\n\t\t\tinitializer.initialize(context);\n\t\t\tcustomizeContext(context, webMergedConfig);\n\t\t\tcontext.refresh();\n\t\t\treturn context;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ContextLoadException(context, ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.context.web.<unknown>#modifyLocations(clazz,locations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@code AnnotationConfigWebContextLoader} should be used as a\n\t * {@link org.springframework.test.context.SmartContextLoader SmartContextLoader},\n\t * not as a legacy {@link org.springframework.test.context.ContextLoader ContextLoader}.\n\t * Consequently, this method is not supported.\n\t * @throws UnsupportedOperationException in this implementation\n\t * @see org.springframework.test.context.support.AbstractContextLoader#modifyLocations\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clazz",
      "locations"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "String[]",
    "signature": "protected String[] modifyLocations(Class<?> clazz, String... locations)",
    "source_code": "\tprotected String[] modifyLocations(Class<?> clazz, String... locations) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"AnnotationConfigWebContextLoader does not support the modifyLocations(Class, String...) method\");\n\t}"
  },
  "org.springframework.test.context.web.socket.<unknown>#customizeContext(context,mergedConfig)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "mergedConfig"
    ],
    "position": {
      "column": 1,
      "line": 38
    },
    "return": "void",
    "signature": "public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig)",
    "source_code": "\tpublic void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {\n\t\tif (context instanceof WebApplicationContext wac) {\n\t\t\tServletContext sc = wac.getServletContext();\n\t\t\tif (sc != null) {\n\t\t\t\tsc.setAttribute(\"jakarta.websocket.server.ServerContainer\", new MockServerContainer());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.http.<unknown>#convert(message,mediaType,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given {@link HttpInputMessage} whose content must match the\n\t * given {@link MediaType} to the requested {@code targetType}.\n\t * @param message an input message\n\t * @param mediaType the media type of the input\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "mediaType",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "T",
    "signature": "public T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)",
    "source_code": "\tpublic <T> T convert(HttpInputMessage message, MediaType mediaType, ResolvableType targetType)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\t\tClass<?> contextClass = targetType.getRawClass();\n\t\tSingletonSupplier<Type> javaType = SingletonSupplier.of(targetType::getType);\n\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n\t\t\tif (messageConverter instanceof GenericHttpMessageConverter<?> genericMessageConverter) {\n\t\t\t\tType type = javaType.obtain();\n\t\t\t\tif (genericMessageConverter.canRead(type, contextClass, mediaType)) {\n\t\t\t\t\treturn (T) genericMessageConverter.read(type, contextClass, message);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (messageConverter instanceof SmartHttpMessageConverter<?> smartMessageConverter) {\n\t\t\t\tif (smartMessageConverter.canRead(targetType, mediaType)) {\n\t\t\t\t\treturn (T) smartMessageConverter.read(targetType, message, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> targetClass = (contextClass != null ? contextClass : Object.class);\n\t\t\t\tif (messageConverter.canRead(targetClass, mediaType)) {\n\t\t\t\t\tHttpMessageConverter<T> simpleMessageConverter = (HttpMessageConverter<T>) messageConverter;\n\t\t\t\t\tClass<? extends T> clazz = (Class<? extends T>) targetClass;\n\t\t\t\t\treturn simpleMessageConverter.read(clazz, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"No converter found to read [%s] to [%s]\".formatted(mediaType, targetType));\n\t}"
  },
  "org.springframework.test.http.<unknown>#convertViaJson(value,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given raw value to the given {@code targetType} by writing\n\t * it first to JSON and reading it back.\n\t * @param value the value to convert\n\t * @param targetType the target type\n\t * @param <T> the converted object type\n\t * @return a value of the given {@code targetType}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "T",
    "signature": "public T convertViaJson(Object value, ResolvableType targetType)",
    "source_code": "\tpublic <T> T convertViaJson(Object value, ResolvableType targetType) throws IOException {\n\t\tMockHttpOutputMessage outputMessage = convertToJson(value, ResolvableType.forInstance(value));\n\t\treturn convert(fromHttpOutputMessage(outputMessage), JSON, targetType);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,expectedValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the JSON path expression against the supplied {@code content}\n\t * and assert that the result is equal to the expected value.\n\t * @param content the JSON content\n\t * @param expectedValue the expected value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "expectedValue"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "public void assertValue(String content, @Nullable Object expectedValue)",
    "source_code": "\tpublic void assertValue(String content, @Nullable Object expectedValue) {\n\t\tObject actualValue = evaluateJsonPath(content);\n\t\tif ((actualValue instanceof List<?> actualValueList) && !(expectedValue instanceof List)) {\n\t\t\tif (actualValueList.isEmpty()) {\n\t\t\t\tAssertionErrors.fail(\"No matching value at JSON path \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t\tif (actualValueList.size() != 1) {\n\t\t\t\tAssertionErrors.fail(\"Got a list of values \" + actualValue +\n\t\t\t\t\t\t\" instead of the expected single value \" + expectedValue);\n\t\t\t}\n\t\t\tactualValue = actualValueList.get(0);\n\t\t}\n\t\telse if (actualValue != null && expectedValue != null &&\n\t\t\t\t!actualValue.getClass().equals(expectedValue.getClass())) {\n\t\t\ttry {\n\t\t\t\tactualValue = evaluateJsonPath(content, expectedValue.getClass());\n\t\t\t}\n\t\t\tcatch (AssertionError error) {\n\t\t\t\tString message = String.format(\n\t\t\t\t\t\"At JSON path \\\"%s\\\", value <%s> of type <%s> cannot be converted to type <%s>\",\n\t\t\t\t\tthis.expression, actualValue, ClassUtils.getDescriptiveType(actualValue),\n\t\t\t\t\tClassUtils.getDescriptiveType(expectedValue));\n\t\t\t\tthrow new AssertionError(message, error.getCause());\n\t\t\t}\n\t\t}\n\t\tAssertionErrors.assertEquals(\"JSON path \\\"\" + this.expression + \"\\\"\", expectedValue, actualValue);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,matcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Evaluate the JSON path expression against the supplied {@code content}\n\t * and assert the resulting value with the given {@code Matcher}.\n\t * @param content the JSON content\n\t * @param matcher the matcher with which to assert the result\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void assertValue(String content, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> void assertValue(String content, Matcher<? super T> matcher) {\n\t\tT value = (T) evaluateJsonPath(content);\n\t\tMatcherAssert.assertThat(\"JSON path \\\"\" + this.expression + \"\\\"\", value, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#assertValue(content,matcher,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded variant of {@link #assertValue(String, Matcher)} that also\n\t * accepts a target type for the resulting value that allows generic types\n\t * to be defined.\n\t * <p>This must be used with a {@link Configuration} that defines a more\n\t * elaborate {@link MappingProvider} as the default one cannot handle\n\t * generic types.\n\t * @param content the JSON content\n\t * @param matcher the matcher with which to assert the result\n\t * @param targetType the expected type of the resulting value\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "matcher",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void assertValue(String content, Matcher<? super T> matcher, ParameterizedTypeReference<T> targetType)",
    "source_code": "\tpublic <T> void assertValue(String content, Matcher<? super T> matcher, ParameterizedTypeReference<T> targetType) {\n\t\tT value = evaluateJsonPath(content, targetType);\n\t\tMatcherAssert.assertThat(\"JSON path \\\"\" + this.expression + \"\\\"\", value, matcher);\n\t}"
  },
  "org.springframework.test.util.<unknown>#evaluateJsonPath(content,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #evaluateJsonPath(String)} with a target type that has\n\t * generics.\n\t * <p>This must be used with a {@link Configuration} that defines a more\n\t * elaborate {@link MappingProvider} as the default one cannot handle\n\t * generic types.\n\t * @param content the content to evaluate against\n\t * @param targetType the requested target type\n\t * @return the result of the evaluation\n\t * @throws AssertionError if the evaluation fails\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "T",
    "signature": "public T evaluateJsonPath(String content, ParameterizedTypeReference<T> targetType)",
    "source_code": "\tpublic <T> T evaluateJsonPath(String content, ParameterizedTypeReference<T> targetType) {\n\t\treturn evaluateExpression(content, context ->\n\t\t\t\tcontext.read(this.expression, new TypeRefAdapter<>(targetType)));\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formData(MultiValueMap<String,expected)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as form data and compare to the given {@code MultiValueMap}.\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formData(MultiValueMap<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formData(MultiValueMap<String, String> expected) {\n\t\treturn formData(expected, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#formDataContains(Map<String,expected)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formData(MultiValueMap)} that matches the given subset\n\t * of expected form parameters.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expected"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher formDataContains(Map<String, String> expected)",
    "source_code": "\tpublic RequestMatcher formDataContains(Map<String, String> expected) {\n\t\tMultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>(expected.size());\n\t\texpected.forEach(multiValueMap::add);\n\t\treturn formData(multiValueMap, false);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,comparator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@link JsonComparator}. If the comparison failed, throws an\n\t * {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use this matcher if you require a custom JSONAssert configuration or\n\t * if you desire to use another assertion library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param comparator the comparator to use\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "comparator"
    ],
    "position": {
      "column": 1,
      "line": 382
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonComparator comparator)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonComparator comparator) {\n\t\treturn request -> {\n\t\t\ttry {\n\t\t\t\tMockClientHttpRequest mockRequest = (MockClientHttpRequest) request;\n\t\t\t\tcomparator.assertIsMatch(expectedJsonContent, mockRequest.getBodyAsString());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new AssertionError(\"Failed to parse expected or actual JSON request content\", ex);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,compareMode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * using the given {@linkplain JsonCompareMode mode}. If the comparison failed,\n\t * throws an {@link AssertionError} with the message of the {@link JsonComparison}.\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param compareMode the compare mode\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "compareMode"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, JsonCompareMode compareMode) {\n\t\treturn json(expectedJsonContent, JsonAssert.comparator(compareMode));\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#json(expectedJsonContent,strict)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the request body and the given string as JSON and assert the two\n\t * are \"similar\" - i.e. they contain the same attribute-value pairs\n\t * regardless of formatting.\n\t * <p>Can compare in two modes, depending on {@code strict} parameter value:\n\t * <ul>\n\t * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>\n\t * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>\n\t * </ul>\n\t * <p>Use of this matcher requires the <a\n\t * href=\"https://jsonassert.skyscreamer.org/\">JSONassert</a> library.\n\t * @param expectedJsonContent the expected JSON content\n\t * @param strict enables strict checking\n\t * @since 5.0.5\n\t * @deprecated in favor of {@link #json(String, JsonCompareMode)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "expectedJsonContent",
      "strict"
    ],
    "position": {
      "column": 1,
      "line": 353
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher json(String expectedJsonContent, boolean strict)",
    "source_code": "\tpublic RequestMatcher json(String expectedJsonContent, boolean strict) {\n\t\tJsonCompareMode compareMode = (strict ? JsonCompareMode.STRICT : JsonCompareMode.LENIENT);\n\t\treturn json(expectedJsonContent, compareMode);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartData(MultiValueMap<String,expectedMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the body as multipart data and assert it contains exactly the\n\t * values from the given {@code MultiValueMap}. Values may be of type:\n\t * <ul>\n\t * <li>{@code String} - form field\n\t * <li>{@link Resource} - content from a file\n\t * <li>{@code byte[]} - other raw content\n\t * </ul>\n\t * <p><strong>Note:</strong> This method uses the fork of Commons FileUpload library\n\t * packaged with Apache Tomcat in the {@code org.apache.tomcat.util.http.fileupload}\n\t * package to parse the multipart data and it must be on the test classpath.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 215
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap) {\n\t\treturn multipartData(expectedMap, DEFAULT_MULTIPART_ENCODING, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartData(MultiValueMap<String,expectedMap,defaultCharset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} with a defaultCharset.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "expectedMap",
      "defaultCharset"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset)",
    "source_code": "\tpublic RequestMatcher multipartData(MultiValueMap<String, ?> expectedMap, Charset defaultCharset) {\n\t\treturn multipartData(expectedMap, defaultCharset, true);\n\t}"
  },
  "org.springframework.test.web.client.match.<unknown>#multipartDataContains(Map<String,expectedMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #multipartData(MultiValueMap)} that does the same but\n\t * only for a subset of the actual values.\n\t * <p><strong>Note:</strong> This method uses the fork of Commons FileUpload library\n\t * packaged with Apache Tomcat in the {@code org.apache.tomcat.util.http.fileupload}\n\t * package to parse the multipart data and it must be on the test classpath.\n\t * @param expectedMap the expected multipart values\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "expectedMap"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "RequestMatcher",
    "signature": "public RequestMatcher multipartDataContains(Map<String, ?> expectedMap)",
    "source_code": "\tpublic RequestMatcher multipartDataContains(Map<String, ?> expectedMap) {\n\t\tMultiValueMap<String, Object> map = new LinkedMultiValueMap<>(expectedMap.size());\n\t\texpectedMap.forEach(map::add);\n\t\treturn multipartData(map, DEFAULT_MULTIPART_ENCODING, false);\n\t}"
  },
  "org.springframework.test.web.reactive.server.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tAtomicReference<WiretapClientHttpRequest> requestRef = new AtomicReference<>();\n\n\t\treturn this.delegate\n\t\t\t\t.connect(method, uri, request -> {\n\t\t\t\t\tWiretapClientHttpRequest wrapped = new WiretapClientHttpRequest(request);\n\t\t\t\t\trequestRef.set(wrapped);\n\t\t\t\t\treturn requestCallback.apply(wrapped);\n\t\t\t\t})\n\t\t\t\t.map(response -> {\n\t\t\t\t\tWiretapClientHttpRequest wrappedRequest = requestRef.get();\n\t\t\t\t\tString header = WebTestClient.WEBTESTCLIENT_REQUEST_ID;\n\t\t\t\t\tString requestId = wrappedRequest.getHeaders().getFirst(header);\n\t\t\t\t\tAssert.state(requestId != null, () -> \"No \\\"\" + header + \"\\\" header\");\n\t\t\t\t\tWiretapClientHttpResponse wrappedResponse = new WiretapClientHttpResponse(response);\n\t\t\t\t\tthis.exchanges.put(requestId, new ClientExchangeInfo(wrappedRequest, wrappedResponse));\n\t\t\t\t\treturn wrappedResponse;\n\t\t\t\t});\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,result,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "result",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, DeferredResult<T> result, @Nullable Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, DeferredResult<T> result, @Nullable Object value) {\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#postProcess(r,task,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "r",
      "task",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest r, Callable<T> task, @Nullable Object value)",
    "source_code": "\t\t\t\t\tpublic <T> void postProcess(NativeWebRequest r, Callable<T> task, @Nullable Object value) {\n\t\t\t\t\t\t// We got the result, must also wait for the dispatch\n\t\t\t\t\t\tgetMvcResult(request).setAsyncResult(value);\n\t\t\t\t\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\tModelAndView mav = super.processHandlerException(request, response, handler, ex);\n\n\t\t// We got this far, exception was processed..\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setResolvedException(ex);\n\t\tmvcResult.setModelAndView(mav);\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#render(mv,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tDefaultMvcResult mvcResult = getMvcResult(request);\n\t\tmvcResult.setModelAndView(mv);\n\t\tsuper.render(mv, request, response);\n\t}"
  },
  "org.springframework.test.web.servlet.<unknown>#service(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tregisterAsyncResultInterceptors(request);\n\n\t\tsuper.service(request, response);\n\n\t\tif (request.getAsyncContext() != null) {\n\t\t\tMockAsyncContext asyncContext;\n\t\t\tif (request.getAsyncContext() instanceof MockAsyncContext mockAsyncContext) {\n\t\t\t\tasyncContext = mockAsyncContext;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMockHttpServletRequest mockRequest = WebUtils.getNativeRequest(request, MockHttpServletRequest.class);\n\t\t\t\tAssert.notNull(mockRequest, \"Expected MockHttpServletRequest\");\n\t\t\t\tasyncContext = (MockAsyncContext) mockRequest.getAsyncContext();\n\t\t\t\tString requestClassName = request.getClass().getName();\n\t\t\t\tAssert.notNull(asyncContext, () ->\n\t\t\t\t\t\t\"Outer request wrapper \" + requestClassName + \" has an AsyncContext,\" +\n\t\t\t\t\t\t\t\t\"but it is not a MockAsyncContext, while the nested \" +\n\t\t\t\t\t\t\t\tmockRequest.getClass().getName() + \" does not have an AsyncContext at all.\");\n\t\t\t}\n\n\t\t\tCountDownLatch dispatchLatch = new CountDownLatch(1);\n\t\t\tasyncContext.addDispatchHandler(dispatchLatch::countDown);\n\t\t\tgetMvcResult(request).setAsyncDispatchLatch(dispatchLatch);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#from(applicationContext,Function<DefaultMockMvcBuilder,customizations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance using the given, fully initialized (i.e.,\n\t * <em>refreshed</em>) {@link WebApplicationContext}. The given\n\t * {@code customizations} are applied to the {@link DefaultMockMvcBuilder}\n\t * that ultimately creates the underlying {@link MockMvc} instance.\n\t * <p>If no further customization of the underlying {@link MockMvc} instance\n\t * is required, use {@link #from(WebApplicationContext)}.\n\t * @param applicationContext the application context to detect the Spring\n\t * MVC infrastructure and application controllers from\n\t * @param customizations a function that creates a {@link MockMvc}\n\t * instance based on a {@link DefaultMockMvcBuilder}\n\t * @see MockMvcBuilders#webAppContextSetup(WebApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "applicationContext",
      "Function<DefaultMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester from(WebApplicationContext applicationContext,\n\t\t\tFunction<DefaultMockMvcBuilder, MockMvc> customizations) {\n\n\t\tDefaultMockMvcBuilder builder = MockMvcBuilders.webAppContextSetup(applicationContext);\n\t\tMockMvc mockMvc = customizations.apply(builder);\n\t\treturn create(mockMvc);\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#isInvokedOn(controllerType,Function<T,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Verify that the handler is managed by the given {@code handlerMethod}.\n\t * <p>This creates a \"mock\" for the given {@code controllerType} and records\n\t * the method invocation in the {@code handlerMethod}. The arguments used by\n\t * the target method invocation can be {@code null} as the purpose of the mock\n\t * is to identify the method that was invoked.\n\t * <p>Example: <pre><code class=\"java\">\n\t * // If the method has a return type, you can return the result of the invocation\n\t * assertThat(mvc.perform(get(\"/greet\")).handler().isInvokedOn(\n\t *         GreetController.class, controller -> controller.sayGreet());\n\t *\n\t * // If the method has a void return type, the controller should be returned\n\t * assertThat(mvc.perform(post(\"/persons/\")).handler().isInvokedOn(\n\t *         PersonController.class, controller -> controller.createPerson(null, null));\n\t * </code></pre>\n\t * @param controllerType the controller to mock\n\t * @param handlerMethod the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "Function<T",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HandlerResultAssert",
    "signature": "public HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod)",
    "source_code": "\tpublic <T> HandlerResultAssert isInvokedOn(Class<T> controllerType, Function<T, Object> handlerMethod) {\n\t\tMethodAssert actual = method();\n\t\tObject methodInvocationInfo = handlerMethod.apply(MvcUriComponentsBuilder.on(controllerType));\n\t\tAssertions.assertThat(methodInvocationInfo)\n\t\t\t\t.as(\"Method invocation on controller '%s'\", controllerType.getSimpleName())\n\t\t\t\t.isInstanceOfSatisfying(MethodInvocationInfo.class, mii ->\n\t\t\t\t\t\tactual.isEqualTo(mii.getControllerMethod()));\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.assertj.<unknown>#of(controllers,Function<StandaloneMockMvcBuilder,customizations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an instance by registering one or more {@code @Controller} instances\n\t * and configuring Spring MVC infrastructure programmatically.\n\t * <p>This allows full control over the instantiation and initialization of\n\t * controllers and their dependencies, similar to plain unit tests while\n\t * also making it possible to test one controller at a time.\n\t * @param controllers one or more {@code @Controller} instances or\n\t * {@code @Controller} types to test; a type ({@code Class}) will be turned\n\t * into an instance\n\t * @param customizations a function that creates a {@link MockMvc} instance\n\t * based on a {@link StandaloneMockMvcBuilder}, typically to configure the\n\t * Spring MVC infrastructure\n\t * @see MockMvcBuilders#standaloneSetup(Object...)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllers",
      "Function<StandaloneMockMvcBuilder",
      "customizations"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "MockMvcTester",
    "signature": "public MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations)",
    "source_code": "\tpublic static MockMvcTester of(Collection<?> controllers,\n\t\t\tFunction<StandaloneMockMvcBuilder, MockMvc> customizations) {\n\n\t\tStandaloneMockMvcBuilder builder = MockMvcBuilders.standaloneSetup(controllers.toArray());\n\t\treturn create(customizations.apply(builder));\n\t}"
  },
  "org.springframework.test.web.servlet.client.<unknown>#connect(method,uri,ClientHttpRequest,requestCallback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "uri",
      "ClientHttpRequest",
      "requestCallback"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Mono<ClientHttpResponse>",
    "signature": "public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback)",
    "source_code": "\tpublic Mono<ClientHttpResponse> connect(\n\t\t\tHttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n\n\t\tRequestBuilder requestBuilder = adaptRequest(method, uri, requestCallback);\n\t\ttry {\n\t\t\tMvcResult mvcResult = this.mockMvc.perform(requestBuilder).andReturn();\n\t\t\tif (mvcResult.getRequest().isAsyncStarted()) {\n\t\t\t\tmvcResult.getAsyncResult();\n\t\t\t\tmvcResult = this.mockMvc.perform(asyncDispatch(mvcResult)).andReturn();\n\t\t\t}\n\t\t\treturn Mono.just(adaptResponse(mvcResult));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#file(name,content)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a new {@link MockMultipartFile} with the given content.\n\t * @param name the name of the file\n\t * @param content the content of the file\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "content"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "B",
    "signature": "public B file(String name, byte[] content)",
    "source_code": "\tpublic B file(String name, byte[] content) {\n\t\tthis.files.add(new MockMultipartFile(name, content));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttr(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set an \"input\" flash attribute.\n\t * @param name the flash attribute name\n\t * @param value the flash attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "B",
    "signature": "public B flashAttr(String name, Object value)",
    "source_code": "\tpublic B flashAttr(String name, Object value) {\n\t\taddToMap(this.flashAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#flashAttrs(Map<String,flashAttributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set flash attributes.\n\t * @param flashAttributes the flash attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "flashAttributes"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "B",
    "signature": "public B flashAttrs(Map<String, Object> flashAttributes)",
    "source_code": "\tpublic B flashAttrs(Map<String, Object> flashAttributes) {\n\t\tAssert.notEmpty(flashAttributes, \"'flashAttributes' must not be empty\");\n\t\tflashAttributes.forEach(this::flashAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#formField(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given value(s) to the given form field and also add them to the\n\t * {@linkplain #param(String, String...) request parameters} map.\n\t * @param name the field name\n\t * @param values one or more values\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 430
    },
    "return": "B",
    "signature": "public B formField(String name, String... values)",
    "source_code": "\tpublic B formField(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.formFields.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#formFields(MultiValueMap<String,formFields)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #formField(String, String...)} with a {@link MultiValueMap}.\n\t * @param formFields the form fields to add\n\t * @since 6.1.7\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formFields"
    ],
    "position": {
      "column": 1,
      "line": 441
    },
    "return": "B",
    "signature": "public B formFields(MultiValueMap<String, String> formFields)",
    "source_code": "\tpublic B formFields(MultiValueMap<String, String> formFields) {\n\t\tparams(formFields);\n\t\tthis.formFields.addAll(formFields);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#header(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a header to the request. Values are always added.\n\t * @param name the header name\n\t * @param values one or more header values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "B",
    "signature": "public B header(String name, Object... values)",
    "source_code": "\tpublic B header(String name, Object... values) {\n\t\taddToMultiValueMap(this.headers, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#param(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.\n\t * <p>In the Servlet API, a request parameter may be parsed from the query\n\t * string and/or from the body of an {@code application/x-www-form-urlencoded}\n\t * request. This method simply adds to the request parameter map. You may\n\t * also use add Servlet request parameters by specifying the query or form\n\t * data through one of the following:\n\t * <ul>\n\t * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.\n\t * <li>Add query params via {@link #queryParam} or {@link #queryParams}.\n\t * <li>Provide {@link #content} with {@link #contentType}\n\t * {@code application/x-www-form-urlencoded}.\n\t * </ul>\n\t * @param name the parameter name\n\t * @param values one or more values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "B",
    "signature": "public B param(String name, String... values)",
    "source_code": "\tpublic B param(String name, String... values) {\n\t\taddToMultiValueMap(this.parameters, name, values);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#params(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.\n\t * @param params the parameters to add\n\t * @since 4.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "B",
    "signature": "public B params(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B params(MultiValueMap<String, String> params) {\n\t\tparams.forEach((name, values) -> {\n\t\t\tfor (String value : values) {\n\t\t\t\tthis.parameters.add(name, value);\n\t\t\t}\n\t\t});\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParam(name,values)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #param(String, String...) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param name the parameter name\n\t * @param values one or more values\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 404
    },
    "return": "B",
    "signature": "public B queryParam(String name, String... values)",
    "source_code": "\tpublic B queryParam(String name, String... values) {\n\t\tparam(name, values);\n\t\tthis.queryParams.addAll(name, Arrays.asList(values));\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#queryParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append to the query string and also add to the\n\t * {@link #params(MultiValueMap) request parameters} map. The parameter\n\t * name and value are encoded when they are added to the query string.\n\t * @param params the parameters to add\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "B",
    "signature": "public B queryParams(MultiValueMap<String, String> params)",
    "source_code": "\tpublic B queryParams(MultiValueMap<String, String> params) {\n\t\tparams(params);\n\t\tthis.queryParams.addAll(params);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#requestAttr(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a request attribute.\n\t * @param name the attribute name\n\t * @param value the attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "B",
    "signature": "public B requestAttr(String name, Object value)",
    "source_code": "\tpublic B requestAttr(String name, Object value) {\n\t\taddToMap(this.requestAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttr(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a session attribute.\n\t * @param name the session attribute name\n\t * @param value the session attribute value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "B",
    "signature": "public B sessionAttr(String name, Object value)",
    "source_code": "\tpublic B sessionAttr(String name, Object value) {\n\t\taddToMap(this.sessionAttributes, name, value);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#sessionAttrs(Map<String,sessionAttributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set session attributes.\n\t * @param sessionAttributes the session attributes\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "sessionAttributes"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "B",
    "signature": "public B sessionAttrs(Map<String, Object> sessionAttributes)",
    "source_code": "\tpublic B sessionAttrs(Map<String, Object> sessionAttributes) {\n\t\tAssert.notEmpty(sessionAttributes, \"'sessionAttributes' must not be empty\");\n\t\tsessionAttributes.forEach(this::sessionAttr);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.request.<unknown>#uri(uriTemplate,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Specify the URI for the request using a URI template and URI variables.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "B",
    "signature": "public B uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\tpublic B uri(String uriTemplate, Object... uriVariables) {\n\t\treturn updateUri(initUri(uriTemplate, uriVariables), uriTemplate);\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,matcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value with the given Hamcrest {@link Matcher}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, Matcher<? super T> matcher)",
    "source_code": "\tpublic <T> ResultMatcher attribute(String name, Matcher<? super T> matcher) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertThat(\"Model attribute '\" + name + \"'\", (T) mav.getModel().get(name), matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attribute(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a model attribute value.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ResultMatcher attribute(String name, @Nullable Object value) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tassertEquals(\"Model attribute '\" + name + \"'\", value, mav.getModel().get(name));\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeErrorCount(name,expectedCount)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "expectedCount"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeErrorCount(String name, int expectedCount)",
    "source_code": "\tpublic ResultMatcher attributeErrorCount(String name, int expectedCount) {\n\t\treturn result -> {\n\t\t\tModelAndView mav = getModelAndView(result);\n\t\t\tErrors errors = getBindingResult(mav, name);\n\t\t\tassertEquals(\"Binding/validation error count for attribute '\" + name + \"',\",\n\t\t\t\t\texpectedCount, errors.getErrorCount());\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrorCode(name,fieldName,error)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using exact String match.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "error"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName, String error) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertEquals(\"Field error code\", error, code);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrorCode(name,fieldName,matcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert a field error code for a model attribute using a {@link org.hamcrest.Matcher}.\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldName",
      "matcher"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrorCode(String name, String fieldName,\n\t\t\tMatcher<? super String> matcher) {\n\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tFieldError fieldError = result.getFieldError(fieldName);\n\t\t\tassertNotNull(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", fieldError);\n\t\t\tString code = fieldError.getCode();\n\t\t\tassertThat(\"Field name '\" + fieldName + \"' of attribute '\" + name + \"'\", code, matcher);\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#attributeHasFieldErrors(name,fieldNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert the given model attribute field(s) have errors.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "fieldNames"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "ResultMatcher",
    "signature": "public ResultMatcher attributeHasFieldErrors(String name, String... fieldNames)",
    "source_code": "\tpublic ResultMatcher attributeHasFieldErrors(String name, String... fieldNames) {\n\t\treturn mvcResult -> {\n\t\t\tModelAndView mav = getModelAndView(mvcResult);\n\t\t\tBindingResult result = getBindingResult(mav, name);\n\t\t\tassertTrue(\"No errors for attribute '\" + name + \"'\", result.hasErrors());\n\t\t\tfor (String fieldName : fieldNames) {\n\t\t\t\tboolean hasFieldErrors = result.hasFieldErrors(fieldName);\n\t\t\t\tassertTrue(\"No errors for field '\" + fieldName + \"' of attribute '\" + name + \"'\", hasFieldErrors);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.test.web.servlet.result.<unknown>#printHandler(handler,interceptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Print the handler.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "void",
    "signature": "protected void printHandler(@Nullable Object handler, @Nullable HandlerInterceptor[] interceptors)",
    "source_code": "\tprotected void printHandler(@Nullable Object handler, @Nullable HandlerInterceptor[] interceptors)\n\t\t\tthrows Exception {\n\n\t\tif (handler == null) {\n\t\t\tthis.printer.printValue(\"Type\", null);\n\t\t}\n\t\telse {\n\t\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\t\tthis.printer.printValue(\"Type\", handlerMethod.getBeanType().getName());\n\t\t\t\tthis.printer.printValue(\"Method\", handlerMethod);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.printer.printValue(\"Type\", handler.getClass().getName());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addBean(name,bean)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "bean"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "public void addBean(String name, Object bean)",
    "source_code": "\tpublic void addBean(String name, Object bean) {\n\t\tthis.beanFactory.addBean(name, bean);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addFilter(filter,filterName,Map<String,initParams,dispatcherTypes,urlPatterns)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "filterName",
      "Map<String",
      "initParams",
      "dispatcherTypes",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, @Nullable String filterName, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns)",
    "source_code": "\tpublic <T extends B> T addFilter(\n\t\t\tFilter filter, @Nullable String filterName, Map<String, String> initParams,\n\t\t\tEnumSet<DispatcherType> dispatcherTypes, String... urlPatterns) {\n\n\t\tfilter = new MockMvcFilterDecorator(filter, filterName, initParams, dispatcherTypes, urlPatterns);\n\t\tthis.filters.add(filter);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addFilter(filter,urlPatterns)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "filter",
      "urlPatterns"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T addFilter(Filter filter, String... urlPatterns)",
    "source_code": "\tpublic final <T extends B> T addFilter(Filter filter, String... urlPatterns) {\n\t\tAssert.notNull(filter, \"filter cannot be null\");\n\t\tAssert.notNull(urlPatterns, \"urlPatterns cannot be null\");\n\t\tif (urlPatterns.length > 0) {\n\t\t\tfilter = new MockMvcFilterDecorator(filter, urlPatterns);\n\t\t}\n\t\tthis.filters.add(filter);\n\t\treturn self();\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addMappedInterceptors(pathPatterns,interceptors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add interceptors mapped to a set of path patterns.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathPatterns",
      "interceptors"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "RouterFunctionMockMvcBuilder",
    "signature": "public RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors)",
    "source_code": "\tpublic RouterFunctionMockMvcBuilder addMappedInterceptors(@Nullable String[] pathPatterns,\n\t\t\tHandlerInterceptor... interceptors) {\n\n\t\tfor (HandlerInterceptor interceptor : interceptors) {\n\t\t\tthis.mappedInterceptors.add(new MappedInterceptor(pathPatterns, null, interceptor));\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#addPlaceholderValue(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * In a standalone setup there is no support for placeholder values embedded in\n\t * request mappings. This method allows manually provided placeholder values so they\n\t * can be resolved. Alternatively consider creating a test that initializes a\n\t * {@link WebApplicationContext}.\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "StandaloneMockMvcBuilder",
    "signature": "public StandaloneMockMvcBuilder addPlaceholderValue(String name, String value)",
    "source_code": "\tpublic StandaloneMockMvcBuilder addPlaceholderValue(String name, String value) {\n\t\tthis.placeholderValues.put(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsAfterInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 488
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPostProcessorsBeforeInitialization(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 482
    },
    "return": "Object",
    "signature": "public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#applyBeanPropertyValues(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "void",
    "signature": "public void applyBeanPropertyValues(Object existingBean, String beanName)",
    "source_code": "\t\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowire(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "Object",
    "signature": "public Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#autowireBeanProperties(existingBean,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "void",
    "signature": "public void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck) {\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#configureBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 449
    },
    "return": "Object",
    "signature": "public Object configureBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object configureBean(Object existingBean, String beanName) {\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#createBean(beanClass,autowireMode,dependencyCheck)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanClass",
      "autowireMode",
      "dependencyCheck"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "Object",
    "signature": "public Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck)",
    "source_code": "\t\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) {\n\t\t\treturn BeanUtils.instantiateClass(beanClass);\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#doFilter(request,response,filterChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 155
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tString requestPath = UrlPathHelper.defaultInstance.getPathWithinApplication(httpRequest);\n\n\t\tif (matchDispatcherType(httpRequest.getDispatcherType()) && matchRequestPath(requestPath)) {\n\t\t\tthis.delegate.doFilter(request, response, filterChain);\n\t\t}\n\t\telse {\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAllAnnotationsOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "Set<A>",
    "signature": "public Set<A> findAllAnnotationsOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAllAnnotationsOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException{\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#findAnnotationOnBean(beanName,annotationType,allowFactoryBeanInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanName",
      "annotationType",
      "allowFactoryBeanInit"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "A",
    "signature": "public A findAnnotationOnBean(String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)",
    "source_code": "\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn this.beanFactory.findAnnotationOnBean(beanName, annotationType, allowFactoryBeanInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Object",
    "signature": "public Object getBean(String name, Object... args)",
    "source_code": "\tpublic Object getBean(String name, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(name,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "T",
    "signature": "public T getBean(String name, Class<T> requiredType)",
    "source_code": "\tpublic <T> T getBean(String name, Class<T> requiredType) throws BeansException {\n\t\treturn this.beanFactory.getBean(name, requiredType);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBean(requiredType,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "T",
    "signature": "public T getBean(Class<T> requiredType, Object... args)",
    "source_code": "\tpublic <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {\n\t\treturn this.beanFactory.getBean(requiredType, args);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanNamesForType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "String[]",
    "signature": "public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeanProvider(requiredType,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "ObjectProvider<T>",
    "signature": "public ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit)",
    "source_code": "\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn this.beanFactory.getBeanProvider(requiredType, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getBeansOfType(type,includeNonSingletons,allowEagerInit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "type",
      "includeNonSingletons",
      "allowEagerInit"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "T>",
    "signature": "public T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)",
    "source_code": "\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException {\n\n\t\treturn this.beanFactory.getBeansOfType(type, includeNonSingletons, allowEagerInit);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getHandlerMapping(mvcConversionService,mvcResourceUrlProvider)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mvcConversionService",
      "mvcResourceUrlProvider"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "RouterFunctionMapping",
    "signature": "public RouterFunctionMapping getHandlerMapping(FormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider)",
    "source_code": "\t\tpublic RouterFunctionMapping getHandlerMapping(\n\t\t\t\tFormattingConversionService mvcConversionService,\n\t\t\t\tResourceUrlProvider mvcResourceUrlProvider) {\n\n\t\t\tRouterFunctionMapping handlerMapping = handlerMappingFactory.get();\n\t\t\thandlerMapping.setOrder(0);\n\t\t\thandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\t\t\thandlerMapping.setMessageConverters(getMessageConverters());\n\t\t\tif (patternParser != null) {\n\t\t\t\thandlerMapping.setPatternParser(patternParser);\n\t\t\t}\n\t\t\treturn handlerMapping;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,defaultMessage,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 360
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {\n\t\treturn this.messageSource.getMessage(code, args, defaultMessage, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(code,args,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, Locale locale)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(code, args, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#getMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 370
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {\n\t\treturn this.messageSource.getMessage(resolvable, locale);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#initializeBean(existingBean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "existingBean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 417
    },
    "return": "Object",
    "signature": "public Object initializeBean(Object existingBean, String beanName)",
    "source_code": "\t\tpublic Object initializeBean(Object existingBean, String beanName) throws BeansException {\n\t\t\tif (existingBean instanceof ApplicationContextAware applicationContextAware) {\n\t\t\t\tapplicationContextAware.setApplicationContext(StubWebApplicationContext.this);\n\t\t\t}\n\t\t\treturn existingBean;\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#isTypeMatch(name,typeToMatch)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "typeToMatch"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "boolean",
    "signature": "public boolean isTypeMatch(String name, Class<?> typeToMatch)",
    "source_code": "\tpublic boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException {\n\t\treturn this.beanFactory.isTypeMatch(name, typeToMatch);\n\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveBeanByName(name,descriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "Object",
    "signature": "public Object resolveBeanByName(String name, DependencyDescriptor descriptor)",
    "source_code": "\t\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) throws BeansException {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName"
    ],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.test.web.servlet.setup.<unknown>#resolveDependency(descriptor,requestingBeanName,autowiredBeanNames,typeConverter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "descriptor",
      "requestingBeanName",
      "autowiredBeanNames",
      "typeConverter"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "Object",
    "signature": "public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter)",
    "source_code": "\t\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\t\t\tthrow new UnsupportedOperationException(\"Dependency resolution not supported\");\n\t\t}"
  },
  "org.springframework.transaction.event.<unknown>#register(event,listener,callbacks)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "event",
      "listener",
      "callbacks"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "boolean",
    "signature": "public boolean register(E event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks)",
    "source_code": "\tpublic static <E extends ApplicationEvent> boolean register(\n\t\t\tE event, TransactionalApplicationListener<E> listener,\n\t\t\tList<TransactionalApplicationListener.SynchronizationCallback> callbacks) {\n\n\t\tif (org.springframework.transaction.support.TransactionSynchronizationManager.isSynchronizationActive() &&\n\t\t\t\torg.springframework.transaction.support.TransactionSynchronizationManager.isActualTransactionActive()) {\n\t\t\torg.springframework.transaction.support.TransactionSynchronizationManager.registerSynchronization(\n\t\t\t\t\tnew PlatformSynchronization<>(event, listener, callbacks));\n\t\t\treturn true;\n\t\t}\n\t\telse if (event.getSource() instanceof TransactionContext txContext) {\n\t\t\torg.springframework.transaction.reactive.TransactionSynchronizationManager rtsm =\n\t\t\t\t\tnew org.springframework.transaction.reactive.TransactionSynchronizationManager(txContext);\n\t\t\tif (rtsm.isSynchronizationActive() && rtsm.isActualTransactionActive()) {\n\t\t\t\trtsm.registerSynchronization(new ReactiveSynchronization<>(event, listener, callbacks));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(clazz,mappedName,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * Method names can end or start with \"*\" for matching multiple methods.\n\t * @param clazz target interface or class\n\t * @param mappedName mapped method name\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mappedName",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(mappedName, \"Mapped name must not be null\");\n\t\tString name = clazz.getName() + '.' + mappedName;\n\n\t\tMethod[] methods = clazz.getDeclaredMethods();\n\t\tList<Method> matchingMethods = new ArrayList<>();\n\t\tfor (Method method : methods) {\n\t\t\tif (isMatch(method.getName(), mappedName)) {\n\t\t\t\tmatchingMethods.add(method);\n\t\t\t}\n\t\t}\n\t\tif (matchingMethods.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not find method '\" + mappedName + \"' on class [\" + clazz.getName() + \"]\");\n\t\t}\n\n\t\t// Register all matching methods\n\t\tfor (Method method : matchingMethods) {\n\t\t\tString regMethodName = this.methodNameMap.get(method);\n\t\t\tif (regMethodName == null || (!regMethodName.equals(name) && regMethodName.length() <= name.length())) {\n\t\t\t\t// No already registered method name, or more specific\n\t\t\t\t// method name specification now -> (re-)register method.\n\t\t\t\tif (logger.isDebugEnabled() && regMethodName != null) {\n\t\t\t\t\tlogger.debug(\"Replacing attribute for transactional method [\" + method + \"]: current name '\" +\n\t\t\t\t\t\t\tname + \"' is more specific than '\" + regMethodName + \"'\");\n\t\t\t\t}\n\t\t\t\tthis.methodNameMap.put(method, name);\n\t\t\t\taddTransactionalMethod(method, attr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Keeping attribute for transactional method [\" + method + \"]: current name '\" +\n\t\t\t\t\t\t\tname + \"' is not more specific than '\" + regMethodName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(method,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * @param method the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(Method method, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(Method method, TransactionAttribute attr) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tAssert.notNull(attr, \"TransactionAttribute must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + method + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.transactionAttributeMap.put(method, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(methodName,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can be exact matches, or of the pattern \"xxx*\",\n\t * \"*xxx\", or \"*xxx*\" for matching multiple methods.\n\t * @param methodName the name of the method\n\t * @param attr attribute associated with the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodName",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String methodName, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String methodName, TransactionAttribute attr) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding transactional method [\" + methodName + \"] with attribute [\" + attr + \"]\");\n\t\t}\n\t\tif (this.embeddedValueResolver != null && attr instanceof DefaultTransactionAttribute dta) {\n\t\t\tdta.resolveAttributeStrings(this.embeddedValueResolver);\n\t\t}\n\t\tthis.nameMap.put(methodName, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#addTransactionalMethod(name,attr)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute for a transactional method.\n\t * <p>Method names can end or start with \"*\" for matching multiple methods.\n\t * @param name class and method name, separated by a dot\n\t * @param attr attribute associated with the method\n\t * @throws IllegalArgumentException in case of an invalid name\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "attr"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "public void addTransactionalMethod(String name, TransactionAttribute attr)",
    "source_code": "\tpublic void addTransactionalMethod(String name, TransactionAttribute attr) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tint lastDotIndex = name.lastIndexOf('.');\n\t\tif (lastDotIndex == -1) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"'\" + name + \"' is not a valid method name: format is <fully-qualified class name>.<method-name>\");\n\t\t}\n\t\tString className = name.substring(0, lastDotIndex);\n\t\tString methodName = name.substring(lastDotIndex + 1);\n\t\tClass<?> clazz = ClassUtils.resolveClassName(className, this.beanClassLoader);\n\t\taddTransactionalMethod(clazz, methodName, attr);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#completeTransactionAfterThrowing(txInfo,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a throwable, completing the transaction.\n\t * We may commit or roll back, depending on the configuration.\n\t * @param txInfo information about the current transaction\n\t * @param ex throwable encountered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txInfo",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 708
    },
    "return": "void",
    "signature": "protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex)",
    "source_code": "\tprotected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {\n\t\tif (txInfo != null && txInfo.getTransactionStatus() != null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() +\n\t\t\t\t\t\t\"] after exception: \" + ex);\n\t\t\t}\n\t\t\tif (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {\n\t\t\t\ttry {\n\t\t\t\t\ttxInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());\n\t\t\t\t}\n\t\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\tex2.initApplicationException(ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException | Error ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by rollback exception\", ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don't roll back on this exception.\n\t\t\t\t// Will still roll back if TransactionStatus.isRollbackOnly() is true.\n\t\t\t\ttry {\n\t\t\t\t\ttxInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n\t\t\t\t}\n\t\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\tex2.initApplicationException(ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException | Error ex2) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", ex);\n\t\t\t\t\tthrow ex2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#computeTransactionAttribute(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Same signature as {@link #getTransactionAttribute}, but doesn't cache the result.\n\t * {@link #getTransactionAttribute} is effectively a caching decorator for this method.\n\t * <p>As of 4.1.8, this method can be overridden.\n\t * @since 4.1.8\n\t * @see #getTransactionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "TransactionAttribute",
    "signature": "protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\t// Don't allow non-public methods, as configured.\n\t\tif (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// The method may be on an interface, but we need attributes from the target class.\n\t\t// If the target class is null, the method will be unchanged.\n\t\tMethod specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);\n\n\t\t// First try is the method in the target class.\n\t\tTransactionAttribute txAttr = findTransactionAttribute(specificMethod);\n\t\tif (txAttr != null) {\n\t\t\treturn txAttr;\n\t\t}\n\n\t\t// Second try is the transaction attribute on the target class.\n\t\ttxAttr = findTransactionAttribute(specificMethod.getDeclaringClass());\n\t\tif (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n\t\t\treturn txAttr;\n\t\t}\n\n\t\tif (specificMethod != method) {\n\t\t\t// Fallback is to look at the original method.\n\t\t\ttxAttr = findTransactionAttribute(method);\n\t\t\tif (txAttr != null) {\n\t\t\t\treturn txAttr;\n\t\t\t}\n\t\t\t// Last fallback is the class of the original method.\n\t\t\ttxAttr = findTransactionAttribute(method.getDeclaringClass());\n\t\t\tif (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n\t\t\t\treturn txAttr;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#createTransactionIfNecessary(tm,txAttr,joinpointIdentification)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a transaction if necessary based on the given TransactionAttribute.\n\t * <p>Allows callers to perform custom TransactionAttribute lookups through\n\t * the TransactionAttributeSource.\n\t * @param txAttr the TransactionAttribute (may be {@code null})\n\t * @param joinpointIdentification the fully qualified method name\n\t * (used for monitoring and logging purposes)\n\t * @return a TransactionInfo object, whether a transaction was created.\n\t * The {@code hasTransaction()} method on TransactionInfo can be used to\n\t * tell if there was a transaction created.\n\t * @see #getTransactionAttributeSource()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tm",
      "txAttr",
      "joinpointIdentification"
    ],
    "position": {
      "column": 1,
      "line": 623
    },
    "return": "TransactionInfo",
    "signature": "protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, final String joinpointIdentification)",
    "source_code": "\tprotected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {\n\n\t\t// If no name specified, apply method identification as transaction name.\n\t\tif (txAttr != null && txAttr.getName() == null) {\n\t\t\ttxAttr = new DelegatingTransactionAttribute(txAttr) {\n\t\t\t\t@Override\n\t\t\t\tpublic String getName() {\n\t\t\t\t\treturn joinpointIdentification;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tTransactionStatus status = null;\n\t\tif (txAttr != null) {\n\t\t\tif (tm != null) {\n\t\t\t\tstatus = tm.getTransaction(txAttr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Skipping transactional joinpoint [\" + joinpointIdentification +\n\t\t\t\t\t\t\t\"] because no transaction manager has been configured\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#determineTransactionManager(txAttr,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the specific transaction manager to use for the given transaction.\n\t * @param txAttr the current transaction attribute\n\t * @param targetClass the target class that the attribute has been declared on\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txAttr",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 497
    },
    "return": "TransactionManager",
    "signature": "protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected TransactionManager determineTransactionManager(\n\t\t\t@Nullable TransactionAttribute txAttr, @Nullable Class<?> targetClass) {\n\n\t\tTransactionManager tm = determineTransactionManager(txAttr);\n\t\tif (tm != null) {\n\t\t\treturn tm;\n\t\t}\n\n\t\t// Do not attempt to lookup tx manager if no tx attributes are set\n\t\tif (txAttr == null || this.beanFactory == null) {\n\t\t\treturn getTransactionManager();\n\t\t}\n\n\t\tString qualifier = txAttr.getQualifier();\n\t\tif (StringUtils.hasText(qualifier)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, qualifier);\n\t\t}\n\t\telse if (targetClass != null) {\n\t\t\t// Consider type-level qualifier annotations for transaction manager selection\n\t\t\tString typeQualifier = BeanFactoryAnnotationUtils.getQualifierValue(targetClass);\n\t\t\tif (StringUtils.hasText(typeQualifier)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, typeQualifier);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t// Consider type qualifier as optional, proceed with regular resolution below.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StringUtils.hasText(this.transactionManagerBeanName)) {\n\t\t\treturn determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);\n\t\t}\n\t\telse {\n\t\t\tTransactionManager defaultTransactionManager = getTransactionManager();\n\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\tdefaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);\n\t\t\t\tif (defaultTransactionManager == null) {\n\t\t\t\t\tdefaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);\n\t\t\t\t\tthis.transactionManagerCache.putIfAbsent(\n\t\t\t\t\t\t\tDEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn defaultTransactionManager;\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#evaluateTryFailure(retVal,txAttr,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "retVal",
      "txAttr",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 893
    },
    "return": "Object",
    "signature": "public Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status)",
    "source_code": "\t\tpublic static Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status) {\n\t\t\treturn ((Try<?>) retVal).onFailure(ex -> {\n\t\t\t\tif (txAttr.rollbackOn(ex)) {\n\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getCacheKey(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine a cache key for the given method and target class.\n\t * <p>Must not produce same key for overloaded methods.\n\t * Must produce same key for different instances of the same method.\n\t * @param method the method (never {@code null})\n\t * @param targetClass the target class (may be {@code null})\n\t * @return the cache key (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {\n\t\treturn new MethodClassKey(method, targetClass);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#getTransactionAttribute(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "TransactionAttribute",
    "signature": "public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (ClassUtils.isUserLevelMethod(method) ? this.transactionAttribute : null);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#hasTransactionAttribute(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "boolean",
    "signature": "public boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tpublic boolean hasTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\treturn (getTransactionAttribute(method, targetClass, false) != null);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#initMethodMap(Map<String,methodMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the specified {@link #setMethodMap(java.util.Map) \"methodMap\"}, if any.\n\t * @param methodMap a Map from method names to {@code TransactionAttribute} instances\n\t * @see #setMethodMap\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "methodMap"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "protected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap)",
    "source_code": "\tprotected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap) {\n\t\tif (methodMap != null) {\n\t\t\tmethodMap.forEach(this::addTransactionalMethod);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#invokeWithinTransaction(method,targetClass,invocation)": {
    "deprecated": false,
    "doc": "\t/**\n\t * General delegate for around-advice-based subclasses, delegating to several other template\n\t * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}\n\t * as well as regular {@link PlatformTransactionManager} implementations and\n\t * {@link ReactiveTransactionManager} implementations for reactive return types.\n\t * @param method the Method being invoked\n\t * @param targetClass the target class that we're invoking the method on\n\t * @param invocation the callback to use for proceeding with the target invocation\n\t * @return the return value of the method, if any\n\t * @throws Throwable propagated from the target invocation\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass",
      "invocation"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "Object",
    "signature": "protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\tfinal InvocationCallback invocation)",
    "source_code": "\tprotected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\tfinal InvocationCallback invocation) throws Throwable {\n\n\t\t// If the transaction attribute is null, the method is non-transactional.\n\t\tTransactionAttributeSource tas = getTransactionAttributeSource();\n\t\tfinal TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);\n\t\tfinal TransactionManager tm = determineTransactionManager(txAttr, targetClass);\n\n\t\tif (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager rtm) {\n\t\t\tboolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method);\n\t\t\tboolean hasSuspendingFlowReturnType = isSuspendingFunction &&\n\t\t\t\t\tCOROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName());\n\n\t\t\tReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> {\n\t\t\t\tClass<?> reactiveType =\n\t\t\t\t\t\t(isSuspendingFunction ? (hasSuspendingFlowReturnType ? Flux.class : Mono.class) : method.getReturnType());\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType);\n\t\t\t\tif (adapter == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Cannot apply reactive transaction to non-reactive return type [\" +\n\t\t\t\t\t\t\tmethod.getReturnType() + \"] with specified transaction manager: \" + tm);\n\t\t\t\t}\n\t\t\t\treturn new ReactiveTransactionSupport(adapter);\n\t\t\t});\n\n\t\t\treturn txSupport.invokeWithinTransaction(method, targetClass, invocation, txAttr, rtm);\n\t\t}\n\n\t\tPlatformTransactionManager ptm = asPlatformTransactionManager(tm);\n\t\tfinal String joinpointIdentification = methodIdentification(method, targetClass, txAttr);\n\n\t\tif (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager cpptm)) {\n\t\t\t// Standard transaction demarcation with getTransaction and commit/rollback calls.\n\t\t\tTransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);\n\n\t\t\tObject retVal;\n\t\t\ttry {\n\t\t\t\t// This is an around advice: Invoke the next interceptor in the chain.\n\t\t\t\t// This will normally result in a target object being invoked.\n\t\t\t\tretVal = invocation.proceedWithInvocation();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// target invocation exception\n\t\t\t\tcompleteTransactionAfterThrowing(txInfo, ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tcleanupTransactionInfo(txInfo);\n\t\t\t}\n\n\t\t\tif (retVal != null && txAttr != null) {\n\t\t\t\tTransactionStatus status = txInfo.getTransactionStatus();\n\t\t\t\tif (status != null) {\n\t\t\t\t\tif (retVal instanceof Future<?> future && future.isDone()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfuture.get();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (ExecutionException ex) {\n\t\t\t\t\t\t\tThrowable cause = ex.getCause();\n\t\t\t\t\t\t\tAssert.state(cause != null, \"Cause must not be null\");\n\t\t\t\t\t\t\tif (txAttr.rollbackOn(cause)) {\n\t\t\t\t\t\t\t\tstatus.setRollbackOnly();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {\n\t\t\t\t\t\t// Set rollback-only in case of Vavr failure matching our rollback rules...\n\t\t\t\t\t\tretVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcommitTransactionAfterReturning(txInfo);\n\t\t\treturn retVal;\n\t\t}\n\n\t\telse {\n\t\t\tObject result;\n\t\t\tfinal ThrowableHolder throwableHolder = new ThrowableHolder();\n\n\t\t\t// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.\n\t\t\ttry {\n\t\t\t\tresult = cpptm.execute(txAttr, status -> {\n\t\t\t\t\tTransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject retVal = invocation.proceedWithInvocation();\n\t\t\t\t\t\tif (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {\n\t\t\t\t\t\t\t// Set rollback-only in case of Vavr failure matching our rollback rules...\n\t\t\t\t\t\t\tretVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn retVal;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (txAttr.rollbackOn(ex)) {\n\t\t\t\t\t\t\t// A RuntimeException: will lead to a rollback.\n\t\t\t\t\t\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\t\t\t\t\t\tthrow runtimeException;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new ThrowableHolderException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// A normal return value: will lead to a commit.\n\t\t\t\t\t\t\tthrowableHolder.throwable = ex;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tcleanupTransactionInfo(txInfo);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (ThrowableHolderException ex) {\n\t\t\t\tthrow ex.getCause();\n\t\t\t}\n\t\t\tcatch (TransactionSystemException ex2) {\n\t\t\t\tif (throwableHolder.throwable != null) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable);\n\t\t\t\t\tex2.initApplicationException(throwableHolder.throwable);\n\t\t\t\t}\n\t\t\t\tthrow ex2;\n\t\t\t}\n\t\t\tcatch (Throwable ex2) {\n\t\t\t\tif (throwableHolder.throwable != null) {\n\t\t\t\t\tlogger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable);\n\t\t\t\t}\n\t\t\t\tthrow ex2;\n\t\t\t}\n\n\t\t\t// Check result state: It might indicate a Throwable to rethrow.\n\t\t\tif (throwableHolder.throwable != null) {\n\t\t\t\tthrow throwableHolder.throwable;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#invokeWithinTransaction(method,targetClass,invocation,txAttr,rtm)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass",
      "invocation",
      "txAttr",
      "rtm"
    ],
    "position": {
      "column": 1,
      "line": 915
    },
    "return": "Object",
    "signature": "public Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\t\tInvocationCallback invocation, @Nullable TransactionAttribute txAttr, ReactiveTransactionManager rtm)",
    "source_code": "\t\tpublic Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,\n\t\t\t\tInvocationCallback invocation, @Nullable TransactionAttribute txAttr, ReactiveTransactionManager rtm) {\n\n\t\t\tString joinpointIdentification = methodIdentification(method, targetClass, txAttr);\n\n\t\t\t// For Mono and suspending functions not returning kotlinx.coroutines.flow.Flow\n\t\t\tif (Mono.class.isAssignableFrom(method.getReturnType()) || (KotlinDetector.isSuspendingFunction(method) &&\n\t\t\t\t\t!COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()))) {\n\n\t\t\t\treturn TransactionContextManager.currentContext().flatMap(context ->\n\t\t\t\t\t\t\tMono.<Object, ReactiveTransactionInfo>usingWhen(\n\t\t\t\t\t\t\t\tcreateTransactionIfNecessary(rtm, txAttr, joinpointIdentification),\n\t\t\t\t\t\t\t\ttx -> {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\treturn (Mono<?>) invocation.proceedWithInvocation();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\t\t\treturn Mono.error(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tthis::commitTransactionAfterReturning,\n\t\t\t\t\t\t\t\tthis::completeTransactionAfterThrowing,\n\t\t\t\t\t\t\t\tthis::rollbackTransactionOnCancel)\n\t\t\t\t\t\t\t.onErrorMap(this::unwrapIfResourceCleanupFailure))\n\t\t\t\t\t\t.contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t\t\t\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder());\n\t\t\t}\n\n\t\t\t// Any other reactive type, typically a Flux\n\t\t\treturn this.adapter.fromPublisher(TransactionContextManager.currentContext().flatMapMany(context ->\n\t\t\t\t\t\tFlux.usingWhen(\n\t\t\t\t\t\t\tcreateTransactionIfNecessary(rtm, txAttr, joinpointIdentification),\n\t\t\t\t\t\t\ttx -> {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn this.adapter.toPublisher(invocation.proceedWithInvocation());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\t\t\treturn Mono.error(ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tthis::commitTransactionAfterReturning,\n\t\t\t\t\t\t\tthis::completeTransactionAfterThrowing,\n\t\t\t\t\t\t\tthis::rollbackTransactionOnCancel)\n\t\t\t\t\t\t.onErrorMap(this::unwrapIfResourceCleanupFailure))\n\t\t\t\t\t.contextWrite(TransactionContextManager.getOrCreateContext())\n\t\t\t\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder()));\n\t\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#isMatch(methodName,mappedName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return if the given method name matches the mapped name.\n\t * <p>The default implementation checks for \"xxx*\", \"*xxx\" and \"*xxx*\"\n\t * matches, as well as direct equality.\n\t * @param methodName the method name of the class\n\t * @param mappedName the name in the descriptor\n\t * @return if the names match\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "methodName",
      "mappedName"
    ],
    "position": {
      "column": 1,
      "line": 218
    },
    "return": "boolean",
    "signature": "protected boolean isMatch(String methodName, String mappedName)",
    "source_code": "\tprotected boolean isMatch(String methodName, String mappedName) {\n\t\treturn PatternMatchUtils.simpleMatch(mappedName, methodName);\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#matches(method,targetClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean matches(Method method, Class<?> targetClass)",
    "source_code": "\tpublic boolean matches(Method method, Class<?> targetClass) {\n\t\treturn (this.transactionAttributeSource == null ||\n\t\t\t\tthis.transactionAttributeSource.hasTransactionAttribute(method, targetClass));\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#methodIdentification(method,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to return a String representation of this Method\n\t * for use in logging. Can be overridden in subclasses to provide a\n\t * different identifier for the given method.\n\t * <p>The default implementation returns {@code null}, indicating the\n\t * use of {@link DefaultTransactionAttribute#getDescriptor()} instead,\n\t * ending up as {@link ClassUtils#getQualifiedMethodName(Method, Class)}.\n\t * @param method the method we're interested in\n\t * @param targetClass the class that the method is being invoked on\n\t * @return a String representation identifying this method\n\t * @see org.springframework.util.ClassUtils#getQualifiedMethodName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 606
    },
    "return": "String",
    "signature": "protected String methodIdentification(Method method, @Nullable Class<?> targetClass)",
    "source_code": "\tprotected String methodIdentification(Method method, @Nullable Class<?> targetClass) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#prepareTransactionInfo(tm,txAttr,joinpointIdentification,status)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Prepare a TransactionInfo for the given attribute and status object.\n\t * @param txAttr the TransactionAttribute (may be {@code null})\n\t * @param joinpointIdentification the fully qualified method name\n\t * (used for monitoring and logging purposes)\n\t * @param status the TransactionStatus for the current transaction\n\t * @return the prepared TransactionInfo object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "tm",
      "txAttr",
      "joinpointIdentification",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 659
    },
    "return": "TransactionInfo",
    "signature": "protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, String joinpointIdentification,\n\t\t\t@Nullable TransactionStatus status)",
    "source_code": "\tprotected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,\n\t\t\t@Nullable TransactionAttribute txAttr, String joinpointIdentification,\n\t\t\t@Nullable TransactionStatus status) {\n\n\t\tTransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);\n\t\tif (txAttr != null) {\n\t\t\t// We need a transaction for this method...\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Getting transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n\t\t\t}\n\t\t\t// The transaction manager will flag an error if an incompatible tx already exists.\n\t\t\ttxInfo.newTransactionStatus(status);\n\t\t}\n\t\telse {\n\t\t\t// The TransactionInfo.hasTransaction() method will return false. We created it only\n\t\t\t// to preserve the integrity of the ThreadLocal stack maintained in this class.\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No need to create transaction for [\" + joinpointIdentification +\n\t\t\t\t\t\t\"]: This method is not transactional.\");\n\t\t\t}\n\t\t}\n\n\t\t// We always bind the TransactionInfo to the thread, even if we didn't create\n\t\t// a new transaction here. This guarantees that the TransactionInfo stack\n\t\t// will be managed correctly even if no transaction was created by this aspect.\n\t\ttxInfo.bindToThread();\n\t\treturn txInfo;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#setMethodMap(Map<String,methodMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of \"{@code <fully-qualified class name>.<method-name>}\"\n\t * method names (for example, \"com.mycompany.mycode.MyClass.myMethod\") and\n\t * {@link TransactionAttribute} instances (or Strings to be converted\n\t * to {@code TransactionAttribute} instances).\n\t * <p>Intended for configuration via setter injection, typically within\n\t * a Spring bean factory. Relies on {@link #afterPropertiesSet()}\n\t * being called afterwards.\n\t * @param methodMap said {@link Map} from method name to attribute value\n\t * @see TransactionAttribute\n\t * @see TransactionAttributeEditor\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "methodMap"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void setMethodMap(Map<String, TransactionAttribute> methodMap)",
    "source_code": "\tpublic void setMethodMap(Map<String, TransactionAttribute> methodMap) {\n\t\tthis.methodMap = methodMap;\n\t}"
  },
  "org.springframework.transaction.interceptor.<unknown>#setNameMap(Map<String,nameMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a name/attribute map, consisting of method names\n\t * (for example, \"myMethod\") and {@link TransactionAttribute} instances.\n\t * @see #setProperties\n\t * @see TransactionAttribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "nameMap"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void setNameMap(Map<String, TransactionAttribute> nameMap)",
    "source_code": "\tpublic void setNameMap(Map<String, TransactionAttribute> nameMap) {\n\t\tnameMap.forEach(this::addTransactionalMethod);\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#applyIsolationLevel(txObject,isolationLevel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given transaction isolation level. The default implementation\n\t * will throw an exception for any level other than ISOLATION_DEFAULT.\n\t * <p>To be overridden in subclasses for specific JTA implementations,\n\t * as alternative to overriding the full {@link #doJtaBegin} method.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param isolationLevel isolation level taken from transaction definition\n\t * @throws InvalidIsolationLevelException if the given isolation level\n\t * cannot be applied\n\t * @throws SystemException if thrown by the JTA implementation\n\t * @see #doJtaBegin\n\t * @see JtaTransactionObject#getUserTransaction()\n\t * @see #getTransactionManager()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "isolationLevel"
    ],
    "position": {
      "column": 1,
      "line": 894
    },
    "return": "void",
    "signature": "protected void applyIsolationLevel(JtaTransactionObject txObject, int isolationLevel)",
    "source_code": "\tprotected void applyIsolationLevel(JtaTransactionObject txObject, int isolationLevel)\n\t\t\tthrows InvalidIsolationLevelException, SystemException {\n\n\t\tif (!this.allowCustomIsolationLevels && isolationLevel != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\tthrow new InvalidIsolationLevelException(\n\t\t\t\t\t\"JtaTransactionManager does not support custom isolation levels by default - \" +\n\t\t\t\t\t\"switch 'allowCustomIsolationLevels' to 'true'\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#applyTimeout(txObject,timeout)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given transaction timeout. The default implementation will call\n\t * {@code UserTransaction.setTransactionTimeout} for a non-default timeout value.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param timeout the timeout value taken from transaction definition\n\t * @throws SystemException if thrown by the JTA implementation\n\t * @see #doJtaBegin\n\t * @see JtaTransactionObject#getUserTransaction()\n\t * @see jakarta.transaction.UserTransaction#setTransactionTimeout(int)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 914
    },
    "return": "void",
    "signature": "protected void applyTimeout(JtaTransactionObject txObject, int timeout)",
    "source_code": "\tprotected void applyTimeout(JtaTransactionObject txObject, int timeout) throws SystemException {\n\t\tif (timeout > TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\ttxObject.getUserTransaction().setTransactionTimeout(timeout);\n\t\t\tif (timeout > 0) {\n\t\t\t\ttxObject.resetTransactionTimeout = true;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#createTransaction(name,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 1196
    },
    "return": "Transaction",
    "signature": "public Transaction createTransaction(@Nullable String name, int timeout)",
    "source_code": "\tpublic Transaction createTransaction(@Nullable String name, int timeout) throws NotSupportedException, SystemException {\n\t\tTransactionManager tm = getTransactionManager();\n\t\tAssert.state(tm != null, \"No JTA TransactionManager available\");\n\t\tif (timeout >= 0) {\n\t\t\ttm.setTransactionTimeout(timeout);\n\t\t}\n\t\ttm.begin();\n\t\treturn new ManagedTransactionAdapter(tm);\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#doBegin(transaction,definition)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 837
    },
    "return": "void",
    "signature": "protected void doBegin(Object transaction, TransactionDefinition definition)",
    "source_code": "\tprotected void doBegin(Object transaction, TransactionDefinition definition) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\ttry {\n\t\t\tdoJtaBegin(txObject, definition);\n\t\t}\n\t\tcatch (NotSupportedException | UnsupportedOperationException ex) {\n\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\"JTA implementation does not support nested transactions\", ex);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new CannotCreateTransactionException(\"JTA failure on begin\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#doJtaBegin(txObject,definition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a JTA begin on the JTA UserTransaction or TransactionManager.\n\t * <p>This implementation only supports standard JTA functionality:\n\t * that is, no per-transaction isolation levels and no transaction names.\n\t * Can be overridden in subclasses, for specific JTA implementations.\n\t * <p>Calls {@code applyIsolationLevel} and {@code applyTimeout}\n\t * before invoking the UserTransaction's {@code begin} method.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param definition the TransactionDefinition instance, describing propagation\n\t * behavior, isolation level, read-only flag, timeout, and transaction name\n\t * @throws NotSupportedException if thrown by JTA methods\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getUserTransaction\n\t * @see #getTransactionManager\n\t * @see #applyIsolationLevel\n\t * @see #applyTimeout\n\t * @see JtaTransactionObject#getUserTransaction()\n\t * @see jakarta.transaction.UserTransaction#setTransactionTimeout\n\t * @see jakarta.transaction.UserTransaction#begin\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "definition"
    ],
    "position": {
      "column": 1,
      "line": 871
    },
    "return": "void",
    "signature": "protected void doJtaBegin(JtaTransactionObject txObject, TransactionDefinition definition)",
    "source_code": "\tprotected void doJtaBegin(JtaTransactionObject txObject, TransactionDefinition definition)\n\t\t\tthrows NotSupportedException, SystemException {\n\n\t\tapplyIsolationLevel(txObject, definition.getIsolationLevel());\n\t\tint timeout = determineTimeout(definition);\n\t\tapplyTimeout(txObject, timeout);\n\t\ttxObject.getUserTransaction().begin();\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#doJtaResume(txObject,suspendedTransaction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform a JTA resume on the JTA TransactionManager.\n\t * <p>Can be overridden in subclasses, for specific JTA implementations.\n\t * @param txObject the JtaTransactionObject containing the UserTransaction\n\t * @param suspendedTransaction the suspended JTA Transaction object\n\t * @throws InvalidTransactionException if thrown by JTA methods\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getTransactionManager()\n\t * @see jakarta.transaction.TransactionManager#resume(jakarta.transaction.Transaction)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "suspendedTransaction"
    ],
    "position": {
      "column": 1,
      "line": 980
    },
    "return": "void",
    "signature": "protected void doJtaResume(@Nullable JtaTransactionObject txObject, Object suspendedTransaction)",
    "source_code": "\tprotected void doJtaResume(@Nullable JtaTransactionObject txObject, Object suspendedTransaction)\n\t\tthrows InvalidTransactionException, SystemException {\n\n\t\tif (getTransactionManager() == null) {\n\t\t\tthrow new TransactionSuspensionNotSupportedException(\n\t\t\t\t\t\"JtaTransactionManager needs a JTA TransactionManager for suspending a transaction: \" +\n\t\t\t\t\t\"specify the 'transactionManager' or 'transactionManagerName' property\");\n\t\t}\n\t\tgetTransactionManager().resume((Transaction) suspendedTransaction);\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#doRegisterAfterCompletionWithJtaTransaction(txObject,synchronizations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a JTA synchronization on the JTA TransactionManager, for calling\n\t * {@code afterCompletion} on the given Spring TransactionSynchronizations.\n\t * <p>The default implementation registers the synchronizations on the\n\t * JTA 1.1 TransactionSynchronizationRegistry, if available, or on the\n\t * JTA TransactionManager's current Transaction - again, if available.\n\t * If none of the two is available, a warning will be logged.\n\t * <p>Can be overridden in subclasses, for specific JTA implementations.\n\t * @param txObject the current transaction object\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @throws RollbackException if thrown by JTA methods\n\t * @throws SystemException if thrown by JTA methods\n\t * @see #getTransactionManager()\n\t * @see jakarta.transaction.Transaction#registerSynchronization\n\t * @see jakarta.transaction.TransactionSynchronizationRegistry#registerInterposedSynchronization\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "txObject",
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 1141
    },
    "return": "void",
    "signature": "protected void doRegisterAfterCompletionWithJtaTransaction(JtaTransactionObject txObject, List<TransactionSynchronization> synchronizations)",
    "source_code": "\tprotected void doRegisterAfterCompletionWithJtaTransaction(\n\t\t\tJtaTransactionObject txObject, List<TransactionSynchronization> synchronizations)\n\t\t\tthrows RollbackException, SystemException {\n\n\t\tint jtaStatus = txObject.getUserTransaction().getStatus();\n\t\tif (jtaStatus == Status.STATUS_NO_TRANSACTION) {\n\t\t\tthrow new RollbackException(\"JTA transaction already completed - probably rolled back\");\n\t\t}\n\t\tif (jtaStatus == Status.STATUS_ROLLEDBACK) {\n\t\t\tthrow new RollbackException(\"JTA transaction already rolled back (probably due to a timeout)\");\n\t\t}\n\n\t\tif (this.transactionSynchronizationRegistry != null) {\n\t\t\t// JTA 1.1 TransactionSynchronizationRegistry available - use it.\n\t\t\tthis.transactionSynchronizationRegistry.registerInterposedSynchronization(\n\t\t\t\t\tnew JtaAfterCompletionSynchronization(synchronizations));\n\t\t}\n\n\t\telse if (getTransactionManager() != null) {\n\t\t\t// At least the JTA TransactionManager available - use that one.\n\t\t\tTransaction transaction = getTransactionManager().getTransaction();\n\t\t\tif (transaction == null) {\n\t\t\t\tthrow new IllegalStateException(\"No JTA Transaction available\");\n\t\t\t}\n\t\t\ttransaction.registerSynchronization(new JtaAfterCompletionSynchronization(synchronizations));\n\t\t}\n\n\t\telse {\n\t\t\t// No JTA TransactionManager available - log a warning.\n\t\t\tlogger.warn(\"Participating in existing JTA transaction, but no JTA TransactionManager available: \" +\n\t\t\t\t\t\"cannot register Spring after-completion callbacks with outer JTA transaction - \" +\n\t\t\t\t\t\"processing Spring after-completion callbacks with outcome status 'unknown'\");\n\t\t\tinvokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#doResume(transaction,suspendedResources)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "suspendedResources"
    ],
    "position": {
      "column": 1,
      "line": 954
    },
    "return": "void",
    "signature": "protected void doResume(@Nullable Object transaction, Object suspendedResources)",
    "source_code": "\tprotected void doResume(@Nullable Object transaction, Object suspendedResources) {\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\ttry {\n\t\t\tdoJtaResume(txObject, suspendedResources);\n\t\t}\n\t\tcatch (InvalidTransactionException ex) {\n\t\t\tthrow new IllegalTransactionStateException(\"Tried to resume invalid JTA transaction\", ex);\n\t\t}\n\t\tcatch (IllegalStateException ex) {\n\t\t\tthrow new TransactionSystemException(\"Unexpected internal transaction state\", ex);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on resume\", ex);\n\t\t}\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#findTransactionSynchronizationRegistry(ut,tm)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find the JTA 1.1 TransactionSynchronizationRegistry through autodetection:\n\t * checking whether the UserTransaction object or TransactionManager object\n\t * implements it, and checking Jakarta EE's standard JNDI location.\n\t * <p>The default implementation simply returns {@code null}.\n\t * @param ut the JTA UserTransaction object\n\t * @param tm the JTA TransactionManager object\n\t * @return the JTA TransactionSynchronizationRegistry handle to use,\n\t * or {@code null} if none found\n\t * @throws TransactionSystemException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ut",
      "tm"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "TransactionSynchronizationRegistry",
    "signature": "protected TransactionSynchronizationRegistry findTransactionSynchronizationRegistry(@Nullable UserTransaction ut, @Nullable TransactionManager tm)",
    "source_code": "\tprotected TransactionSynchronizationRegistry findTransactionSynchronizationRegistry(\n\t\t\t@Nullable UserTransaction ut, @Nullable TransactionManager tm) throws TransactionSystemException {\n\n\t\tif (this.userTransactionObtainedFromJndi) {\n\t\t\t// UserTransaction has already been obtained from JNDI, so the\n\t\t\t// TransactionSynchronizationRegistry probably sits there as well.\n\t\t\tString jndiName = DEFAULT_TRANSACTION_SYNCHRONIZATION_REGISTRY_NAME;\n\t\t\ttry {\n\t\t\t\tTransactionSynchronizationRegistry tsr = getJndiTemplate().lookup(jndiName, TransactionSynchronizationRegistry.class);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"JTA TransactionSynchronizationRegistry found at default JNDI location [\" + jndiName + \"]\");\n\t\t\t\t}\n\t\t\t\treturn tsr;\n\t\t\t}\n\t\t\tcatch (NamingException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No JTA TransactionSynchronizationRegistry found at default JNDI location [\" + jndiName + \"]\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check whether the UserTransaction or TransactionManager implements it...\n\t\tif (ut instanceof TransactionSynchronizationRegistry tsr) {\n\t\t\treturn tsr;\n\t\t}\n\t\tif (tm instanceof TransactionSynchronizationRegistry tsr) {\n\t\t\treturn tsr;\n\t\t}\n\t\t// OK, so no JTA 1.1 TransactionSynchronizationRegistry is available...\n\t\treturn null;\n\t}"
  },
  "org.springframework.transaction.jta.<unknown>#registerAfterCompletionWithExistingTransaction(transaction,synchronizations)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transaction",
      "synchronizations"
    ],
    "position": {
      "column": 1,
      "line": 1095
    },
    "return": "void",
    "signature": "protected void registerAfterCompletionWithExistingTransaction(Object transaction, List<TransactionSynchronization> synchronizations)",
    "source_code": "\tprotected void registerAfterCompletionWithExistingTransaction(\n\t\t\tObject transaction, List<TransactionSynchronization> synchronizations) {\n\n\t\tJtaTransactionObject txObject = (JtaTransactionObject) transaction;\n\t\tlogger.debug(\"Registering after-completion synchronization with existing JTA transaction\");\n\t\ttry {\n\t\t\tdoRegisterAfterCompletionWithJtaTransaction(txObject, synchronizations);\n\t\t}\n\t\tcatch (SystemException ex) {\n\t\t\tthrow new TransactionSystemException(\"JTA failure on registerSynchronization\", ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Note: JBoss throws plain RuntimeException with RollbackException as cause.\n\t\t\tif (ex instanceof RollbackException || ex.getCause() instanceof RollbackException) {\n\t\t\t\tlogger.debug(\"Participating in existing JTA transaction that has been marked for rollback: \" +\n\t\t\t\t\t\t\"cannot register Spring after-completion callbacks with outer JTA transaction - \" +\n\t\t\t\t\t\t\"immediately performing Spring after-completion callbacks with outcome status 'rollback'. \" +\n\t\t\t\t\t\t\"Original exception: \" + ex);\n\t\t\t\tinvokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_ROLLED_BACK);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Participating in existing JTA transaction, but unexpected internal transaction \" +\n\t\t\t\t\t\t\"state encountered: cannot register Spring after-completion callbacks with outer JTA \" +\n\t\t\t\t\t\t\"transaction - processing Spring after-completion callbacks with outcome status 'unknown'\" +\n\t\t\t\t\t\t\"Original exception: \" + ex);\n\t\t\t\tinvokeAfterCompletion(synchronizations, TransactionSynchronization.STATUS_UNKNOWN);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#invokeAfterCompletion(synchronizations,completionStatus)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code afterCompletion} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations",
      "completionStatus"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> invokeAfterCompletion(Collection<TransactionSynchronization> synchronizations, int completionStatus)",
    "source_code": "\tpublic static Mono<Void> invokeAfterCompletion(\n\t\t\tCollection<TransactionSynchronization> synchronizations, int completionStatus) {\n\n\t\treturn Flux.fromIterable(synchronizations).concatMap(it -> it.afterCompletion(completionStatus))\n\t\t\t\t.onErrorContinue((t, o) -> logger.error(\"TransactionSynchronization.afterCompletion threw exception\", t)).then();\n\t}"
  },
  "org.springframework.transaction.reactive.<unknown>#triggerBeforeCommit(synchronizations,readOnly)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code triggerBeforeCommit} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @see TransactionSynchronization#beforeCommit(boolean)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations",
      "readOnly"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> triggerBeforeCommit(Collection<TransactionSynchronization> synchronizations, boolean readOnly)",
    "source_code": "\tpublic static Mono<Void> triggerBeforeCommit(Collection<TransactionSynchronization> synchronizations, boolean readOnly) {\n\t\treturn Flux.fromIterable(synchronizations).concatMap(it -> it.beforeCommit(readOnly)).then();\n\t}"
  },
  "org.springframework.transaction.support.<unknown>#bindResource(key,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Bind the given resource for the given key to the current thread.\n\t * @param key the key to bind the value to (usually the resource factory)\n\t * @param value the value to bind (usually the active resource object)\n\t * @throws IllegalStateException if there is already a value bound to the thread\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void bindResource(Object key, Object value)",
    "source_code": "\tpublic static void bindResource(Object key, Object value) throws IllegalStateException {\n\t\tObject actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);\n\t\tAssert.notNull(value, \"Value must not be null\");\n\t\tMap<Object, Object> map = resources.get();\n\t\t// set ThreadLocal Map if none found\n\t\tif (map == null) {\n\t\t\tmap = new HashMap<>();\n\t\t\tresources.set(map);\n\t\t}\n\t\tObject oldValue = map.put(actualKey, value);\n\t\t// Transparently suppress a ResourceHolder that was marked as void...\n\t\tif (oldValue instanceof ResourceHolder resourceHolder && resourceHolder.isVoid()) {\n\t\t\toldValue = null;\n\t\t}\n\t\tif (oldValue != null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Already value [\" + oldValue + \"] for key [\" + actualKey + \"] bound to thread\");\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.<unknown>#invokeAfterCompletion(synchronizations,completionStatus)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the {@code afterCompletion} methods of the\n\t * given Spring TransactionSynchronization objects.\n\t * @param synchronizations a List of TransactionSynchronization objects\n\t * @param completionStatus the completion status according to the\n\t * constants in the TransactionSynchronization interface\n\t * @see TransactionSynchronization#afterCompletion(int)\n\t * @see TransactionSynchronization#STATUS_COMMITTED\n\t * @see TransactionSynchronization#STATUS_ROLLED_BACK\n\t * @see TransactionSynchronization#STATUS_UNKNOWN\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "synchronizations",
      "completionStatus"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "void",
    "signature": "public void invokeAfterCompletion(@Nullable List<TransactionSynchronization> synchronizations,\n\t\t\tint completionStatus)",
    "source_code": "\tpublic static void invokeAfterCompletion(@Nullable List<TransactionSynchronization> synchronizations,\n\t\t\tint completionStatus) {\n\n\t\tif (synchronizations != null) {\n\t\t\tfor (TransactionSynchronization synchronization : synchronizations) {\n\t\t\t\ttry {\n\t\t\t\t\tsynchronization.afterCompletion(completionStatus);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.error(\"TransactionSynchronization.afterCompletion threw exception\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.transaction.support.<unknown>#sameResourceFactory(tm,resourceFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given resource transaction manager refers to the given\n\t * (underlying) resource factory.\n\t * @see ResourceTransactionManager#getResourceFactory()\n\t * @see InfrastructureProxy#getWrappedObject()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tm",
      "resourceFactory"
    ],
    "position": {
      "column": 1,
      "line": 53
    },
    "return": "boolean",
    "signature": "public boolean sameResourceFactory(ResourceTransactionManager tm, Object resourceFactory)",
    "source_code": "\tpublic static boolean sameResourceFactory(ResourceTransactionManager tm, Object resourceFactory) {\n\t\treturn unwrapResourceIfNecessary(tm.getResourceFactory()).equals(unwrapResourceIfNecessary(resourceFactory));\n\t}"
  },
  "org.springframework.ui.<unknown>#addAllAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map}.\n\t * @see #addAttribute(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 137
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tputAll(attributes);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#addAttribute(attributeName,attributeValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute under the supplied name.\n\t * @param attributeName the name of the model attribute (never {@code null})\n\t * @param attributeValue the model attribute value (ignored if {@code null},\n\t * just removing an existing entry if any)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ConcurrentModel addAttribute(String attributeName, @Nullable Object attributeValue) {\n\t\tAssert.notNull(attributeName, \"Model attribute name must not be null\");\n\t\tput(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#mergeAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes in the supplied {@code Map} into this {@code Map},\n\t * with existing objects of the same name taking precedence (i.e. not getting\n\t * replaced).\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 150
    },
    "return": "ConcurrentModel",
    "signature": "public ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ConcurrentModel mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tattributes.forEach((key, value) -> {\n\t\t\t\tif (!containsKey(key)) {\n\t\t\t\t\tput(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.ui.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "Object",
    "signature": "public Object put(String key, @Nullable Object value)",
    "source_code": "\tpublic Object put(String key, @Nullable Object value) {\n\t\tif (value != null) {\n\t\t\treturn super.put(key, value);\n\t\t}\n\t\telse {\n\t\t\treturn remove(key);\n\t\t}\n\t}"
  },
  "org.springframework.ui.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ?> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tfor (Map.Entry<? extends String, ?> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.ui.freemarker.<unknown>#setFreemarkerVariables(Map<String,variables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map that contains well-known FreeMarker objects which will be passed\n\t * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.\n\t * @see freemarker.template.Configuration#setAllSharedVariables\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "variables"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "void",
    "signature": "public void setFreemarkerVariables(Map<String, Object> variables)",
    "source_code": "\tpublic void setFreemarkerVariables(Map<String, Object> variables) {\n\t\tthis.freemarkerVariables = variables;\n\t}"
  },
  "org.springframework.util.<unknown>#accessibleConstructor(clazz,parameterTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain an accessible constructor for the given class and parameters.\n\t * @param clazz the clazz to check\n\t * @param parameterTypes the parameter types of the desired constructor\n\t * @return the constructor reference\n\t * @throws NoSuchMethodException if no such constructor exists\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "parameterTypes"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Constructor<T>",
    "signature": "public Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)",
    "source_code": "\tpublic static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tConstructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);\n\t\tmakeAccessible(ctor);\n\t\treturn ctor;\n\t}"
  },
  "org.springframework.util.<unknown>#add(Entry<K,kListEntry)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "kListEntry"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "boolean",
    "signature": "public boolean add(Entry<K, List<V>> kListEntry)",
    "source_code": "\t\tpublic boolean add(Entry<K, List<V>> kListEntry) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#add(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 76
    },
    "return": "void",
    "signature": "public void add(K key, @Nullable V value)",
    "source_code": "\tpublic void add(K key, @Nullable V value) {\n\t\tif (!this.targetMap.containsKey(key)) {\n\t\t\tthis.targetMap.put(key, value);\n\t\t}\n\t\telse {\n\t\t\tthrow new UnsupportedOperationException(\"Duplicate key: \" + key);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(Entry<K,c)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 394
    },
    "return": "boolean",
    "signature": "public boolean addAll(Collection<? extends Entry<K, List<V>>> c)",
    "source_code": "\t\tpublic boolean addAll(Collection<? extends Entry<K, List<V>>> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#addAll(MultiValueMap<K,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<K",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void addAll(MultiValueMap<K, V> values)",
    "source_code": "\tpublic void addAll(MultiValueMap<K, V> values) {\n\t\tvalues.forEach(this::addAll);\n\t}"
  },
  "org.springframework.util.<unknown>#addAll(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "public void addAll(K key, List<? extends V> values)",
    "source_code": "\tpublic void addAll(K key, List<? extends V> values) {\n\t\tif (!this.targetMap.containsKey(key)) {\n\t\t\tput(key, (List<V>) values);\n\t\t}\n\t\telse {\n\t\t\tthrow new UnsupportedOperationException(\"Duplicate key: \" + key);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#addIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "void",
    "signature": "public void addIfAbsent(K key, @Nullable V value)",
    "source_code": "\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#addObjectToArray(array,obj)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given object to the given array, returning a new array\n\t * consisting of the input array contents plus the given object.\n\t * @param array the array to append to (can be {@code null})\n\t * @param obj the object to append\n\t * @return the new array (of the same component type; never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "obj"
    ],
    "position": {
      "column": 1,
      "line": 255
    },
    "return": "A[]",
    "signature": "public A[] addObjectToArray(@Nullable A[] array, @Nullable O obj)",
    "source_code": "\tpublic static <A, O extends A> A[] addObjectToArray(@Nullable A[] array, @Nullable O obj) {\n\t\treturn addObjectToArray(array, obj, (array != null ? array.length : 0));\n\t}"
  },
  "org.springframework.util.<unknown>#addObjectToArray(array,obj,position)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given object to the given array at the specified position, returning\n\t * a new array consisting of the input array contents plus the given object.\n\t * @param array the array to add to (can be {@code null})\n\t * @param obj the object to append\n\t * @param position the position at which to add the object\n\t * @return the new array (of the same component type; never {@code null})\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "obj",
      "position"
    ],
    "position": {
      "column": 1,
      "line": 268
    },
    "return": "A[]",
    "signature": "public A[] addObjectToArray(@Nullable A[] array, @Nullable O obj, int position)",
    "source_code": "\tpublic static <A, O extends A> A[] addObjectToArray(@Nullable A[] array, @Nullable O obj, int position) {\n\t\tClass<?> componentType = Object.class;\n\t\tif (array != null) {\n\t\t\tcomponentType = array.getClass().componentType();\n\t\t}\n\t\telse if (obj != null) {\n\t\t\tcomponentType = obj.getClass();\n\t\t}\n\t\tint newArrayLength = (array != null ? array.length + 1 : 1);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tA[] newArray = (A[]) Array.newInstance(componentType, newArrayLength);\n\t\tif (array != null) {\n\t\t\tSystem.arraycopy(array, 0, newArray, 0, position);\n\t\t\tSystem.arraycopy(array, position, newArray, position + 1, array.length - position);\n\t\t}\n\t\tnewArray[position] = obj;\n\t\treturn newArray;\n\t}"
  },
  "org.springframework.util.<unknown>#addStringToArray(array,str)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append the given {@code String} to the given {@code String} array,\n\t * returning a new array consisting of the input array contents plus\n\t * the given {@code String}.\n\t * @param array the array to append to (can be {@code null})\n\t * @param str the {@code String} to append\n\t * @return the new array (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "str"
    ],
    "position": {
      "column": 1,
      "line": 993
    },
    "return": "String[]",
    "signature": "public String[] addStringToArray(@Nullable String[] array, String str)",
    "source_code": "\tpublic static String[] addStringToArray(@Nullable String[] array, String str) {\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tString[] newArr = new String[array.length + 1];\n\t\tSystem.arraycopy(array, 0, newArr, 0, array.length);\n\t\tnewArr[array.length] = str;\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#appendMd5DigestAsHex(bytes,builder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append a hexadecimal string representation of the MD5 digest of the given\n\t * bytes to the given {@link StringBuilder}.\n\t * @param bytes the bytes to calculate the digest over\n\t * @param builder the string builder to append the digest to\n\t * @return the given string builder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bytes",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "StringBuilder",
    "signature": "public StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder)",
    "source_code": "\tpublic static StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder) {\n\t\treturn appendDigestAsHex(MD5_ALGORITHM_NAME, bytes, builder);\n\t}"
  },
  "org.springframework.util.<unknown>#appendMd5DigestAsHex(inputStream,builder)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append a hexadecimal string representation of the MD5 digest of the given\n\t * inputStream to the given {@link StringBuilder}.\n\t * <p>This method does <strong>not</strong> close the input stream.\n\t * @param inputStream the inputStream to calculate the digest over\n\t * @param builder the string builder to append the digest to\n\t * @return the given string builder\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inputStream",
      "builder"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "StringBuilder",
    "signature": "public StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder)",
    "source_code": "\tpublic static StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder) throws IOException {\n\t\treturn appendDigestAsHex(MD5_ALGORITHM_NAME, inputStream, builder);\n\t}"
  },
  "org.springframework.util.<unknown>#applyRelativePath(path,relativePath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the given relative path to the given Java resource path,\n\t * assuming standard Java folder separation (i.e. \"/\" separators).\n\t * @param path the path to start from (usually a full file path)\n\t * @param relativePath the relative path to apply\n\t * (relative to the full file path above)\n\t * @return the full file path that results from applying the relative path\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "relativePath"
    ],
    "position": {
      "column": 1,
      "line": 685
    },
    "return": "String",
    "signature": "public String applyRelativePath(String path, String relativePath)",
    "source_code": "\tpublic static String applyRelativePath(String path, String relativePath) {\n\t\tint separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR_CHAR);\n\t\tif (separatorIndex != -1) {\n\t\t\tString newPath = path.substring(0, separatorIndex);\n\t\t\tif (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n\t\t\t\tnewPath += FOLDER_SEPARATOR_CHAR;\n\t\t\t}\n\t\t\treturn newPath + relativePath;\n\t\t}\n\t\telse {\n\t\t\treturn relativePath;\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#arrayToDelimitedString(arr,delim)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code String} array into a delimited {@code String} (for example, CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param arr the array to display (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "arr",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1356
    },
    "return": "String",
    "signature": "public String arrayToDelimitedString(@Nullable Object[] arr, String delim)",
    "source_code": "\tpublic static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {\n\t\tif (ObjectUtils.isEmpty(arr)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (arr.length == 1) {\n\t\t\treturn ObjectUtils.nullSafeToString(arr[0]);\n\t\t}\n\n\t\tStringJoiner sj = new StringJoiner(delim);\n\t\tfor (Object elem : arr) {\n\t\t\tsj.add(String.valueOf(elem));\n\t\t}\n\t\treturn sj.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#calculateShift(minimumValue,maximumValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Calculate a shift value that can be used to create a power-of-two value between\n\t * the specified maximum and minimum values.\n\t * @param minimumValue the minimum value\n\t * @param maximumValue the maximum value\n\t * @return the calculated shift (use {@code 1 << shift} to obtain a value)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "minimumValue",
      "maximumValue"
    ],
    "position": {
      "column": 1,
      "line": 434
    },
    "return": "int",
    "signature": "protected int calculateShift(int minimumValue, int maximumValue)",
    "source_code": "\tprotected static int calculateShift(int minimumValue, int maximumValue) {\n\t\tint shift = 0;\n\t\tint value = 1;\n\t\twhile (value < minimumValue && value < maximumValue) {\n\t\t\tvalue <<= 1;\n\t\t\tshift++;\n\t\t}\n\t\treturn shift;\n\t}"
  },
  "org.springframework.util.<unknown>#checkParameters(parameter,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void checkParameters(String parameter, String value)",
    "source_code": "\tprotected void checkParameters(String parameter, String value) {\n\t\tAssert.hasLength(parameter, \"'parameter' must not be empty\");\n\t\tAssert.hasLength(value, \"'value' must not be empty\");\n\t\tcheckToken(parameter);\n\t\tif (PARAM_CHARSET.equals(parameter)) {\n\t\t\tif (this.resolvedCharset == null) {\n\t\t\t\tthis.resolvedCharset = Charset.forName(unquote(value));\n\t\t\t}\n\t\t}\n\t\telse if (!isQuotedString(value)) {\n\t\t\tcheckToken(value);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#collectionToDelimitedString(coll,delim)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@code Collection} into a delimited {@code String} (for example, CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim"
    ],
    "position": {
      "column": 1,
      "line": 1335
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim)",
    "source_code": "\tpublic static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {\n\t\treturn collectionToDelimitedString(coll, delim, \"\", \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#collectionToDelimitedString(coll,delim,prefix,suffix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert a {@link Collection} to a delimited {@code String} (for example, CSV).\n\t * <p>Useful for {@code toString()} implementations.\n\t * @param coll the {@code Collection} to convert (potentially {@code null} or empty)\n\t * @param delim the delimiter to use (typically a \",\")\n\t * @param prefix the {@code String} to start each element with\n\t * @param suffix the {@code String} to end each element with\n\t * @return the delimited {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coll",
      "delim",
      "prefix",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 1305
    },
    "return": "String",
    "signature": "public String collectionToDelimitedString(@Nullable Collection<?> coll, String delim, String prefix, String suffix)",
    "source_code": "\tpublic static String collectionToDelimitedString(\n\t\t\t@Nullable Collection<?> coll, String delim, String prefix, String suffix) {\n\n\t\tif (CollectionUtils.isEmpty(coll)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tint totalLength = coll.size() * (prefix.length() + suffix.length()) + (coll.size() - 1) * delim.length();\n\t\tfor (Object element : coll) {\n\t\t\ttotalLength += String.valueOf(element).length();\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder(totalLength);\n\t\tIterator<?> it = coll.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tsb.append(prefix).append(it.next()).append(suffix);\n\t\t\tif (it.hasNext()) {\n\t\t\t\tsb.append(delim);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#compare(mimeType1,mimeType2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 711
    },
    "return": "int",
    "signature": "public int compare(T mimeType1, T mimeType2)",
    "source_code": "\t\tpublic int compare(T mimeType1, T mimeType2) {\n\t\t\tif (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {  // mediaType1.getType().equals(mediaType2.getType())\n\t\t\t\tif (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())\n\t\t\t\t\treturn compareParameters(mimeType1, mimeType2);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#compareParameters(mimeType1,mimeType2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mimeType1",
      "mimeType2"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "int",
    "signature": "protected int compareParameters(T mimeType1, T mimeType2)",
    "source_code": "\t\tprotected int compareParameters(T mimeType1, T mimeType2) {\n\t\t\tint paramsSize1 = mimeType1.getParameters().size();\n\t\t\tint paramsSize2 = mimeType2.getParameters().size();\n\t\t\treturn Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic\n\t\t}"
  },
  "org.springframework.util.<unknown>#compositeMap(Map<K,first,Map<K,second)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t *\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second) {\n\t\treturn new CompositeMap<>(first, second);\n\t}"
  },
  "org.springframework.util.<unknown>#compositeMap(Map<K,first,Map<K,second,BiFunction<K,V,putFunction,Consumer<Map<K,putAllFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t *\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "first",
      "Map<K",
      "second",
      "BiFunction<K",
      "V",
      "putFunction",
      "Consumer<Map<K",
      "putAllFunction"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "V>",
    "signature": "public V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction)",
    "source_code": "\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction) {\n\n\t\treturn new CompositeMap<>(first, second, putFunction, putAllFunction);\n\t}"
  },
  "org.springframework.util.<unknown>#compute(key,K,List<V>,remappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "List<V>",
    "signature": "public List<V> compute(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> compute(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfAbsent(key,K,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "List<V>",
    "signature": "public List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction)",
    "source_code": "\tpublic List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfAbsent(key,String,mappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "String",
      "mappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "V",
    "signature": "public V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction)",
    "source_code": "\tpublic V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction) {\n\t\tString oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\n\t\tif (oldKey != null) {\n\t\t\tV oldKeyValue = this.targetMap.get(oldKey);\n\t\t\tif (oldKeyValue != null) {\n\t\t\t\treturn oldKeyValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey = oldKey;\n\t\t\t}\n\t\t}\n\t\treturn this.targetMap.computeIfAbsent(key, mappingFunction);\n\t}"
  },
  "org.springframework.util.<unknown>#computeIfPresent(key,K,List<V>,remappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "K",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "List<V>",
    "signature": "public List<V> computeIfPresent(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> computeIfPresent(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#concatenateStringArrays(array1,array2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Concatenate the given {@code String} arrays into one,\n\t * with overlapping array elements included twice.\n\t * <p>The order of elements in the original arrays is preserved.\n\t * @param array1 the first array (can be {@code null})\n\t * @param array2 the second array (can be {@code null})\n\t * @return the new array ({@code null} if both given arrays were {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array1",
      "array2"
    ],
    "position": {
      "column": 1,
      "line": 1013
    },
    "return": "String[]",
    "signature": "public String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2)",
    "source_code": "\tpublic static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {\n\t\tif (ObjectUtils.isEmpty(array1)) {\n\t\t\treturn array2;\n\t\t}\n\t\tif (ObjectUtils.isEmpty(array2)) {\n\t\t\treturn array1;\n\t\t}\n\n\t\tString[] newArr = new String[array1.length + array2.length];\n\t\tSystem.arraycopy(array1, 0, newArr, 0, array1.length);\n\t\tSystem.arraycopy(array2, 0, newArr, array1.length, array2.length);\n\t\treturn newArr;\n\t}"
  },
  "org.springframework.util.<unknown>#contains(enumeration,element)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Enumeration<?> enumeration, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tObject candidate = enumeration.nextElement();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#contains(iterator,element)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Iterator contains the given element.\n\t * @param iterator the Iterator to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "iterator",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "boolean",
    "signature": "public boolean contains(@Nullable Iterator<?> iterator, Object element)",
    "source_code": "\tpublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\n\t\tif (iterator != null) {\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject candidate = iterator.next();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#containsAny(source,candidates)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if any element in '{@code candidates}' is\n\t * contained in '{@code source}'; otherwise returns {@code false}.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return whether any of the candidates has been found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "boolean",
    "signature": "public boolean containsAny(Collection<?> source, Collection<?> candidates)",
    "source_code": "\tpublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\n\t\treturn findFirstMatch(source, candidates) != null;\n\t}"
  },
  "org.springframework.util.<unknown>#containsConstant(enumValues,constant)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given array of enum constants contains a constant with the given name,\n\t * ignoring case when determining a match.\n\t * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\n\t * @param constant the constant name to find (must not be null or empty string)\n\t * @return whether the constant has been found in the given array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumValues",
      "constant"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "boolean",
    "signature": "public boolean containsConstant(Enum<?>[] enumValues, String constant)",
    "source_code": "\tpublic static boolean containsConstant(Enum<?>[] enumValues, String constant) {\n\t\treturn containsConstant(enumValues, constant, false);\n\t}"
  },
  "org.springframework.util.<unknown>#containsConstant(enumValues,constant,caseSensitive)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given array of enum constants contains a constant with the given name.\n\t * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\n\t * @param constant the constant name to find (must not be null or empty string)\n\t * @param caseSensitive whether case is significant in determining a match\n\t * @return whether the constant has been found in the given array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumValues",
      "constant",
      "caseSensitive"
    ],
    "position": {
      "column": 1,
      "line": 220
    },
    "return": "boolean",
    "signature": "public boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)",
    "source_code": "\tpublic static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n\t\tfor (Enum<?> candidate : enumValues) {\n\t\t\tif (caseSensitive ? candidate.toString().equals(constant) :\n\t\t\t\t\tcandidate.toString().equalsIgnoreCase(constant)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#containsElement(array,element)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given array contains the given element.\n\t * @param array the array to check (may be {@code null},\n\t * in which case the return value will always be {@code false})\n\t * @param element the element to check for\n\t * @return whether the element has been found in the given array\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "boolean",
    "signature": "public boolean containsElement(@Nullable Object[] array, Object element)",
    "source_code": "\tpublic static boolean containsElement(@Nullable Object[] array, Object element) {\n\t\tif (array == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (Object arrayEle : array) {\n\t\t\tif (nullSafeEquals(arrayEle, element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#containsInstance(collection,element)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given Collection contains the given element instance.\n\t * <p>Enforces the given instance to be present, rather than returning\n\t * {@code true} for an equal element as well.\n\t * @param collection the Collection to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "boolean",
    "signature": "public boolean containsInstance(@Nullable Collection<?> collection, Object element)",
    "source_code": "\tpublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\n\t\tif (collection != null) {\n\t\t\tfor (Object candidate : collection) {\n\t\t\t\tif (candidate == element) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#convertNumberToTargetClass(number,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert the given number into an instance of the given target class.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the converted number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.lang.Byte\n\t * @see java.lang.Short\n\t * @see java.lang.Integer\n\t * @see java.lang.Long\n\t * @see java.math.BigInteger\n\t * @see java.lang.Float\n\t * @see java.lang.Double\n\t * @see java.math.BigDecimal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "number",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "T",
    "signature": "public T convertNumberToTargetClass(Number number, Class<T> targetClass)",
    "source_code": "\tpublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tAssert.notNull(number, \"Number must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\n\t\tif (targetClass.isInstance(number)) {\n\t\t\treturn (T) number;\n\t\t}\n\t\telse if (Byte.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Byte.valueOf(number.byteValue());\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Short.valueOf(number.shortValue());\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\tif (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\n\t\t\t\traiseOverflowException(number, targetClass);\n\t\t\t}\n\t\t\treturn (T) Integer.valueOf(number.intValue());\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\tlong value = checkedLongValue(number, targetClass);\n\t\t\treturn (T) Long.valueOf(value);\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\tif (number instanceof BigDecimal bigDecimal) {\n\t\t\t\t// do not lose precision - use BigDecimal's own conversion\n\t\t\t\treturn (T) bigDecimal.toBigInteger();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// original value is not a Big* number - use standard long conversion\n\t\t\t\treturn (T) BigInteger.valueOf(number.longValue());\n\t\t\t}\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) Float.valueOf(number.floatValue());\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) Double.valueOf(number.doubleValue());\n\t\t}\n\t\telse if (BigDecimal.class == targetClass) {\n\t\t\t// always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\n\t\t\t// (see BigDecimal javadoc for details)\n\t\t\treturn (T) new BigDecimal(number.toString());\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" +\n\t\t\t\t\tnumber.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#copy(in,out)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy the contents of the given String to the given Writer.\n\t * Closes the writer when done.\n\t * @param in the String to copy from\n\t * @param out the Writer to copy to\n\t * @throws IOException in case of I/O errors\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "in",
      "out"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "void",
    "signature": "public void copy(String in, Writer out)",
    "source_code": "\tpublic static void copy(String in, Writer out) throws IOException {\n\t\tAssert.notNull(in, \"No input String specified\");\n\t\tAssert.notNull(out, \"No Writer specified\");\n\n\t\ttry {\n\t\t\tout.write(in);\n\t\t}\n\t\tfinally {\n\t\t\tclose(out);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#countOccurrencesOf(str,sub)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Count the occurrences of the substring {@code sub} in string {@code str}.\n\t * @param str string to search in\n\t * @param sub string to search for\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "sub"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "int",
    "signature": "public int countOccurrencesOf(String str, String sub)",
    "source_code": "\tpublic static int countOccurrencesOf(String str, String sub) {\n\t\tif (!hasLength(str) || !hasLength(sub)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint count = 0;\n\t\tint pos = 0;\n\t\tint idx;\n\t\twhile ((idx = str.indexOf(sub, pos)) != -1) {\n\t\t\t++count;\n\t\t\tpos = idx + sub.length();\n\t\t}\n\t\treturn count;\n\t}"
  },
  "org.springframework.util.<unknown>#createReference(Entry<K,entry,hash,Reference<K,next)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Factory method used to create a new {@link Reference}.\n\t\t * @param entry the entry contained in the reference\n\t\t * @param hash the hash\n\t\t * @param next the next reference in the chain, or {@code null} if none\n\t\t * @return a new {@link Reference}\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "entry",
      "hash",
      "Reference<K",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 1008
    },
    "return": "V>",
    "signature": "public V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next)",
    "source_code": "\t\tpublic Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\n\t\t\tif (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\n\t\t\t\treturn new WeakEntryReference<>(entry, hash, next, this.queue);\n\t\t\t}\n\t\t\treturn new SoftEntryReference<>(entry, hash, next, this.queue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#declaresException(method,exceptionType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given method explicitly declares the given\n\t * exception or one of its superclasses, which means that an exception\n\t * of that type can be propagated as-is within a reflective invocation.\n\t * @param method the declaring method\n\t * @param exceptionType the exception to throw\n\t * @return {@code true} if the exception can be thrown as-is;\n\t * {@code false} if it needs to be wrapped\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "exceptionType"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "boolean",
    "signature": "public boolean declaresException(Method method, Class<?> exceptionType)",
    "source_code": "\tpublic static boolean declaresException(Method method, Class<?> exceptionType) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tClass<?>[] declaredExceptions = method.getExceptionTypes();\n\t\tfor (Class<?> declaredException : declaredExceptions) {\n\t\t\tif (declaredException.isAssignableFrom(exceptionType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#delete(inString,pattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delete all occurrences of the given substring.\n\t * @param inString the original {@code String}\n\t * @param pattern the pattern to delete all occurrences of\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 478
    },
    "return": "String",
    "signature": "public String delete(String inString, String pattern)",
    "source_code": "\tpublic static String delete(String inString, String pattern) {\n\t\treturn replace(inString, pattern, \"\");\n\t}"
  },
  "org.springframework.util.<unknown>#deleteAny(inString,charsToDelete)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delete any character in a given {@code String}.\n\t * @param inString the original {@code String}\n\t * @param charsToDelete a set of characters to delete.\n\t * For example, \"az\\n\" will delete 'a's, 'z's and new lines.\n\t * @return the resulting {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "String",
    "signature": "public String deleteAny(String inString, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String deleteAny(String inString, @Nullable String charsToDelete) {\n\t\tif (!hasLength(inString) || !hasLength(charsToDelete)) {\n\t\t\treturn inString;\n\t\t}\n\n\t\tint lastCharIndex = 0;\n\t\tchar[] result = new char[inString.length()];\n\t\tfor (int i = 0; i < inString.length(); i++) {\n\t\t\tchar c = inString.charAt(i);\n\t\t\tif (charsToDelete.indexOf(c) == -1) {\n\t\t\t\tresult[lastCharIndex++] = c;\n\t\t\t}\n\t\t}\n\t\tif (lastCharIndex == inString.length()) {\n\t\t\treturn inString;\n\t\t}\n\t\treturn new String(result, 0, lastCharIndex);\n\t}"
  },
  "org.springframework.util.<unknown>#delimitedListToStringArray(str,delimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into a\n\t * {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1223
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {\n\t\treturn delimitedListToStringArray(str, delimiter, null);\n\t}"
  },
  "org.springframework.util.<unknown>#delimitedListToStringArray(str,delimiter,charsToDelete)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Take a {@code String} that is a delimited list and convert it into\n\t * a {@code String} array.\n\t * <p>A single {@code delimiter} may consist of more than one character,\n\t * but it will still be considered as a single delimiter string, rather\n\t * than as a bunch of potential delimiter characters, in contrast to\n\t * {@link #tokenizeToStringArray}.\n\t * @param str the input {@code String} (potentially {@code null} or empty)\n\t * @param delimiter the delimiter between elements (this is a single delimiter,\n\t * rather than a bunch individual delimiter characters)\n\t * @param charsToDelete a set of characters to delete; useful for deleting unwanted\n\t * line breaks: for example, \"\\r\\n\\f\" will delete all new lines and line feeds in a {@code String}\n\t * @return an array of the tokens in the list\n\t * @see #tokenizeToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1242
    },
    "return": "String[]",
    "signature": "public String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static String[] delimitedListToStringArray(\n\t\t\t@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\t\tif (delimiter == null) {\n\t\t\treturn new String[] {str};\n\t\t}\n\n\t\tList<String> result = new ArrayList<>();\n\t\tif (delimiter.isEmpty()) {\n\t\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\t\tresult.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint pos = 0;\n\t\t\tint delPos;\n\t\t\twhile ((delPos = str.indexOf(delimiter, pos)) != -1) {\n\t\t\t\tresult.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n\t\t\t\tpos = delPos + delimiter.length();\n\t\t\t}\n\t\t\tif (!str.isEmpty() && pos <= str.length()) {\n\t\t\t\t// Add rest of String, but not in case of empty input.\n\t\t\t\tresult.add(deleteAny(str.substring(pos), charsToDelete));\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(result);\n\t}"
  },
  "org.springframework.util.<unknown>#doTask(hash,key,task)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Apply an update operation to this segment.\n\t\t * The segment will be locked during the update.\n\t\t * @param hash the hash of the key\n\t\t * @param key the key\n\t\t * @param task the update operation\n\t\t * @return the result of the operation\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hash",
      "key",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "T",
    "signature": "public T doTask(final int hash, @Nullable final Object key, final Task<T> task)",
    "source_code": "\t\tpublic <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {\n\t\t\tboolean resize = task.hasOption(TaskOption.RESIZE);\n\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\n\t\t\t\trestructureIfNecessary(resize);\n\t\t\t}\n\t\t\tif (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\n\t\t\t\treturn task.execute(null, null, null);\n\t\t\t}\n\t\t\tlock();\n\t\t\ttry {\n\t\t\t\tfinal int index = getIndex(hash, this.references);\n\t\t\t\tfinal Reference<K, V> head = this.references[index];\n\t\t\t\tReference<K, V> ref = findInChain(head, key, hash);\n\t\t\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\t\t\tEntries<V> entries = value -> {\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tEntry<K, V> newEntry = new Entry<>((K) key, value);\n\t\t\t\t\tReference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\n\t\t\t\t\tSegment.this.references[index] = newReference;\n\t\t\t\t\tSegment.this.count.incrementAndGet();\n\t\t\t\t};\n\t\t\t\treturn task.execute(ref, entry, entries);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tunlock();\n\t\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\n\t\t\t\t\trestructureIfNecessary(resize);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.util.<unknown>#doWithFields(clazz,fc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "void",
    "signature": "public void doWithFields(Class<?> clazz, FieldCallback fc)",
    "source_code": "\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\n\t\tdoWithFields(clazz, fc, null);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithFields(clazz,fc,ff)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @param ff the filter that determines the fields to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc",
      "ff"
    ],
    "position": {
      "column": 1,
      "line": 718
    },
    "return": "void",
    "signature": "public void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff)",
    "source_code": "\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tClass<?> targetClass = clazz;\n\t\tdo {\n\t\t\tField[] fields = getDeclaredFields(targetClass);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (ff != null && !ff.matches(field)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfc.doWith(field);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t}\n\t\twhile (targetClass != null && targetClass != Object.class);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithLocalFields(clazz,fc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given callback on all locally declared fields in the given class.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithFields\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "fc"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "void",
    "signature": "public void doWithLocalFields(Class<?> clazz, FieldCallback fc)",
    "source_code": "\tpublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\n\t\tfor (Field field : getDeclaredFields(clazz)) {\n\t\t\ttry {\n\t\t\t\tfc.doWith(field);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#doWithLocalMethods(clazz,mc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class, as locally declared or equivalent thereof (such as default methods\n\t * on Java 8 based interfaces that the given class implements).\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithMethods\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mc"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "public void doWithLocalMethods(Class<?> clazz, MethodCallback mc)",
    "source_code": "\tpublic static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#doWithMethods(clazz,mc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses.\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by a {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @see #doWithMethods(Class, MethodCallback, MethodFilter)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mc"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "void",
    "signature": "public void doWithMethods(Class<?> clazz, MethodCallback mc)",
    "source_code": "\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc) {\n\t\tdoWithMethods(clazz, mc, null);\n\t}"
  },
  "org.springframework.util.<unknown>#doWithMethods(clazz,mc,mf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses (or given interface and super-interfaces).\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by the specified {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @param mf the filter that determines the methods to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mc",
      "mf"
    ],
    "position": {
      "column": 1,
      "line": 355
    },
    "return": "void",
    "signature": "public void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf)",
    "source_code": "\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\n\t\tif (mf == USER_DECLARED_METHODS && clazz == Object.class) {\n\t\t\t// nothing to introspect\n\t\t\treturn;\n\t\t}\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\tif (mf != null && !mf.matches(method)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tif (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\n\t\t\tdoWithMethods(clazz.getSuperclass(), mc, mf);\n\t\t}\n\t\telse if (clazz.isInterface()) {\n\t\t\tfor (Class<?> superIfc : clazz.getInterfaces()) {\n\t\t\t\tdoWithMethods(superIfc, mc, mf);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#endsWithIgnoreCase(str,suffix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} ends with the specified suffix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param suffix the suffix to look for\n\t * @see java.lang.String#endsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "suffix"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "boolean",
    "signature": "public boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix)",
    "source_code": "\tpublic static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {\n\t\treturn (str != null && suffix != null && str.length() >= suffix.length() &&\n\t\t\t\tstr.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()));\n\t}"
  },
  "org.springframework.util.<unknown>#execute(Reference<K,ref,Entry<K,entry)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Convenience method that can be used for tasks that do not need access to {@link Entries}.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry, Entries)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Reference<K",
      "ref",
      "Entry<K",
      "entry"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "T",
    "signature": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry)",
    "source_code": "\t\tprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.util.<unknown>#execute(Reference<K,ref,Entry<K,entry,entries)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Execute the task.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @param entries access to the underlying entries\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry)\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Reference<K",
      "ref",
      "Entry<K",
      "entry",
      "entries"
    ],
    "position": {
      "column": 1,
      "line": 816
    },
    "return": "T",
    "signature": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries)",
    "source_code": "\t\tprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\n\t\t\treturn execute(ref, entry);\n\t\t}"
  },
  "org.springframework.util.<unknown>#findField(clazz,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 581
    },
    "return": "Field",
    "signature": "public Field findField(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findField(Class<?> clazz, String name) {\n\t\treturn findField(clazz, name, null);\n\t}"
  },
  "org.springframework.util.<unknown>#findField(clazz,name,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name} and/or {@link Class type}. Searches all superclasses\n\t * up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (may be {@code null} if type is specified)\n\t * @param type the type of the field (may be {@code null} if name is specified)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "Field",
    "signature": "public Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type)",
    "source_code": "\tpublic static Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.isTrue(name != null || type != null, \"Either name or type of the field must be specified\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif ((name == null || name.equals(field.getName())) &&\n\t\t\t\t\t\t(type == null || type.equals(field.getType()))) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#findFieldIgnoreCase(clazz,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 621
    },
    "return": "Field",
    "signature": "public Field findFieldIgnoreCase(Class<?> clazz, String name)",
    "source_code": "\tpublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#findFirstMatch(source,candidates)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "candidates"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "E",
    "signature": "public E findFirstMatch(Collection<?> source, Collection<E> candidates)",
    "source_code": "\tpublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\n\t\tif (isEmpty(source) || isEmpty(candidates)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (E candidate : candidates) {\n\t\t\tif (source.contains(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#findMethod(clazz,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and no parameters. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @return the Method object, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "Method",
    "signature": "public Method findMethod(Class<?> clazz, String name)",
    "source_code": "\tpublic static Method findMethod(Class<?> clazz, String name) {\n\t\treturn findMethod(clazz, name, EMPTY_CLASS_ARRAY);\n\t}"
  },
  "org.springframework.util.<unknown>#findMethod(clazz,name,paramTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and parameter types. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (may be {@code null} to indicate any signature)\n\t * @return the Method object, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "name",
      "paramTypes"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Method",
    "signature": "public Method findMethod(Class<?> clazz, String name, @Nullable Class<?>... paramTypes)",
    "source_code": "\tpublic static Method findMethod(Class<?> clazz, String name, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Method name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (searchType != null) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() :\n\t\t\t\t\tgetDeclaredMethods(searchType, false));\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#findValueOfType(collection,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "T",
    "signature": "public T findValueOfType(Collection<?> collection, @Nullable Class<T> type)",
    "source_code": "\tpublic static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.util.<unknown>#findValueOfType(collection,types)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a single value of one of the given types in the given Collection:\n\t * searching the Collection for a value of the first type, then\n\t * searching for a value of the second type, etc.\n\t * @param collection the collection to search\n\t * @param types the types to look for, in prioritized order\n\t * @return a value of one of the given types found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "collection",
      "types"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "Object",
    "signature": "public Object findValueOfType(Collection<?> collection, Class<?>[] types)",
    "source_code": "\tpublic static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n\t\tif (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Class<?> type : types) {\n\t\t\tObject value = findValueOfType(collection, type);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.<unknown>#forEach(Entry<K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "public void forEach(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\tpublic void forEach(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\tthis.delegate.forEach(e -> action.accept(new UnmodifiableEntry<>(e)));\n\t\t}"
  },
  "org.springframework.util.<unknown>#forEach(Entry<String,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<String",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 487
    },
    "return": "void",
    "signature": "public void forEach(Consumer<? super Entry<String, V>> action)",
    "source_code": "\t\tpublic void forEach(Consumer<? super Entry<String, V>> action) {\n\t\t\tthis.delegate.forEach(action);\n\t\t}"
  },
  "org.springframework.util.<unknown>#forEach(K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "public void forEach(BiConsumer<? super K, ? super V> action)",
    "source_code": "\tpublic void forEach(BiConsumer<? super K, ? super V> action) {\n\t\tthis.targetMap.forEach((k, vs) -> action.accept(k, vs.get(0)));\n\t}"
  },
  "org.springframework.util.<unknown>#forEach(String,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "void",
    "signature": "public void forEach(BiConsumer<? super String, ? super V> action)",
    "source_code": "\tpublic void forEach(BiConsumer<? super String, ? super V> action) {\n\t\tthis.targetMap.forEach(action);\n\t}"
  },
  "org.springframework.util.<unknown>#forEachRemaining(Entry<K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 431
    },
    "return": "void",
    "signature": "public void forEachRemaining(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\t\tpublic void forEachRemaining(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\tthis.delegate.forEachRemaining(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}"
  },
  "org.springframework.util.<unknown>#getField(field,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the field represented by the supplied {@link Field field object} on the\n\t * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\n\t * semantics, the returned value is automatically wrapped if the underlying field\n\t * has a primitive type.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to get\n\t * @param target the target object from which to get the field\n\t * (or {@code null} for a static field)\n\t * @return the field's current value\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 670
    },
    "return": "Object",
    "signature": "public Object getField(Field field, @Nullable Object target)",
    "source_code": "\tpublic static Object getField(Field field, @Nullable Object target) {\n\t\ttry {\n\t\t\treturn field.get(target);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}"
  },
  "org.springframework.util.<unknown>#getOrDefault(key,defaultValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "V",
    "signature": "public V getOrDefault(Object key, V defaultValue)",
    "source_code": "\tpublic V getOrDefault(Object key, V defaultValue) {\n\t\tif (key instanceof String string) {\n\t\t\tString caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey(string));\n\t\t\tif (caseInsensitiveKey != null) {\n\t\t\t\treturn this.targetMap.get(caseInsensitiveKey);\n\t\t\t}\n\t\t}\n\t\treturn defaultValue;\n\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,hash,restructure)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "hash",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "V>",
    "signature": "public V> getReference(@Nullable Object key, int hash, Restructure restructure)",
    "source_code": "\t\tpublic Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\n\t\t\tif (restructure == Restructure.WHEN_NECESSARY) {\n\t\t\t\trestructureIfNecessary(false);\n\t\t\t}\n\t\t\tif (this.count.get() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Use a local copy to protect against other threads writing\n\t\t\tReference<K, V>[] references = this.references;\n\t\t\tint index = getIndex(hash, references);\n\t\t\tReference<K, V> head = references[index];\n\t\t\treturn findInChain(head, key, hash);\n\t\t}"
  },
  "org.springframework.util.<unknown>#getReference(key,restructure)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\n\t * or {@code null} if not found.\n\t * @param key the key (can be {@code null})\n\t * @param restructure types of restructure allowed during this call\n\t * @return the reference, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "restructure"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "V>",
    "signature": "protected V> getReference(@Nullable Object key, Restructure restructure)",
    "source_code": "\tprotected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {\n\t\tint hash = getHash(key);\n\t\treturn getSegmentForHash(hash).getReference(key, hash, restructure);\n\t}"
  },
  "org.springframework.util.<unknown>#getUniqueDeclaredMethods(leafClass,mf)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @param mf the filter that determines the methods to take into account\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "leafClass",
      "mf"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "Method[]",
    "signature": "public Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf)",
    "source_code": "\tpublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {\n\t\tfinal List<Method> methods = new ArrayList<>(20);\n\t\tdoWithMethods(leafClass, method -> {\n\t\t\tboolean knownSignature = false;\n\t\t\tMethod methodBeingOverriddenWithCovariantReturnType = null;\n\t\t\tfor (Method existingMethod : methods) {\n\t\t\t\tif (method.getName().equals(existingMethod.getName()) &&\n\t\t\t\t\t\tmethod.getParameterCount() == existingMethod.getParameterCount() &&\n\t\t\t\t\t\tArrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\n\t\t\t\t\t// Is this a covariant return type situation?\n\t\t\t\t\tif (existingMethod.getReturnType() != method.getReturnType() &&\n\t\t\t\t\t\t\texistingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\n\t\t\t\t\t\tmethodBeingOverriddenWithCovariantReturnType = existingMethod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tknownSignature = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (methodBeingOverriddenWithCovariantReturnType != null) {\n\t\t\t\tmethods.remove(methodBeingOverriddenWithCovariantReturnType);\n\t\t\t}\n\t\t\tif (!knownSignature && !isCglibRenamedMethod(method)) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t}, mf);\n\t\treturn methods.toArray(EMPTY_METHOD_ARRAY);\n\t}"
  },
  "org.springframework.util.<unknown>#handleUnresolvablePlaceholder(key,text)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "text"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "String",
    "signature": "public String handleUnresolvablePlaceholder(String key, String text)",
    "source_code": "\t\tpublic String handleUnresolvablePlaceholder(String key, String text) {\n\t\t\tif (this.ignoreUnresolvablePlaceholders) {\n\t\t\t\treturn toPlaceholderText(key);\n\t\t\t}\n\t\t\tString originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\n\t\t\tthrow new PlaceholderResolutionException(\n\t\t\t\t\t\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\n\t\t}"
  },
  "org.springframework.util.<unknown>#invokeMethod(method,target)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with no arguments.\n\t * The target object can be {@code null} when invoking a static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Object",
    "signature": "public Object invokeMethod(Method method, @Nullable Object target)",
    "source_code": "\tpublic static Object invokeMethod(Method method, @Nullable Object target) {\n\t\treturn invokeMethod(method, target, EMPTY_OBJECT_ARRAY);\n\t}"
  },
  "org.springframework.util.<unknown>#invokeMethod(method,target,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with the\n\t * supplied arguments. The target object can be {@code null} when invoking a\n\t * static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @param args the invocation arguments (may be {@code null})\n\t * @return the invocation result, if any\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "Object",
    "signature": "public Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args)",
    "source_code": "\tpublic static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignable(lhsType,rhsType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type following the Java generics rules.\n\t * @param lhsType the target type (left-hand side (LHS) type)\n\t * @param rhsType the value type (right-hand side (RHS) type) that should\n\t * be assigned to the target type\n\t * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\n\t * @see ClassUtils#isAssignable(Class, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 52
    },
    "return": "boolean",
    "signature": "public boolean isAssignable(Type lhsType, Type rhsType)",
    "source_code": "\tpublic static boolean isAssignable(Type lhsType, Type rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\n\t\t// all types are assignable to themselves and to class Object\n\t\tif (lhsType.equals(rhsType) || Object.class == lhsType) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lhsType instanceof Class<?> lhsClass) {\n\t\t\t// just comparing two classes\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t}\n\n\t\t\tif (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\tType rhsRaw = rhsParameterizedType.getRawType();\n\n\t\t\t\t// a parameterized type is always assignable to its raw class type\n\t\t\t\tif (rhsRaw instanceof Class<?> rhRawClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhRawClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (lhsClass.isArray() && rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsClass.componentType(), rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\t// parameterized types are only assignable to other parameterized types and class types\n\t\tif (lhsType instanceof ParameterizedType lhsParameterizedType) {\n\t\t\tif (rhsType instanceof Class<?> rhsClass) {\n\t\t\t\tType lhsRaw = lhsParameterizedType.getRawType();\n\n\t\t\t\tif (lhsRaw instanceof Class<?> lhsClass) {\n\t\t\t\t\treturn ClassUtils.isAssignable(lhsClass, rhsClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rhsType instanceof ParameterizedType rhsParameterizedType) {\n\t\t\t\treturn isAssignable(lhsParameterizedType, rhsParameterizedType);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof GenericArrayType lhsGenericArrayType) {\n\t\t\tType lhsComponent = lhsGenericArrayType.getGenericComponentType();\n\n\t\t\tif (rhsType instanceof Class<?> rhsClass && rhsClass.isArray()) {\n\t\t\t\treturn isAssignable(lhsComponent, rhsClass.componentType());\n\t\t\t}\n\t\t\telse if (rhsType instanceof GenericArrayType rhsGenericArrayType) {\n\t\t\t\tType rhsComponent = rhsGenericArrayType.getGenericComponentType();\n\n\t\t\t\treturn isAssignable(lhsComponent, rhsComponent);\n\t\t\t}\n\t\t}\n\n\t\tif (lhsType instanceof WildcardType lhsWildcardType) {\n\t\t\treturn isAssignable(lhsWildcardType, rhsType);\n\t\t}\n\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#isAssignableBound(lhsType,rhsType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lhsType",
      "rhsType"
    ],
    "position": {
      "column": 1,
      "line": 213
    },
    "return": "boolean",
    "signature": "public boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType)",
    "source_code": "\tpublic static boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType) {\n\t\tif (rhsType == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lhsType == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn isAssignable(lhsType, rhsType);\n\t}"
  },
  "org.springframework.util.<unknown>#isCompatibleWithThrowsClause(ex,declaredExceptions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given exception is compatible with the specified\n\t * exception types, as declared in a {@code throws} clause.\n\t * @param ex the exception to check\n\t * @param declaredExceptions the exception types declared in the throws clause\n\t * @return whether the given exception is compatible\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "declaredExceptions"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "boolean",
    "signature": "public boolean isCompatibleWithThrowsClause(Throwable ex, @Nullable Class<?>... declaredExceptions)",
    "source_code": "\tpublic static boolean isCompatibleWithThrowsClause(Throwable ex, @Nullable Class<?>... declaredExceptions) {\n\t\tif (!isCheckedException(ex)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (declaredExceptions != null) {\n\t\t\tfor (Class<?> declaredException : declaredExceptions) {\n\t\t\t\tif (declaredException.isInstance(ex)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#isEmpty(Map<?,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean isEmpty(@Nullable Map<?, ?> map)",
    "source_code": "\tpublic static boolean isEmpty(@Nullable Map<?, ?> map) {\n\t\treturn (map == null || map.isEmpty());\n\t}"
  },
  "org.springframework.util.<unknown>#matchesCharacter(str,singleCharacter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} matches the given single character.\n\t * @param str the {@code String} to check\n\t * @param singleCharacter the character to compare to\n\t * @since 5.2.9\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "singleCharacter"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "boolean",
    "signature": "public boolean matchesCharacter(@Nullable String str, char singleCharacter)",
    "source_code": "\tpublic static boolean matchesCharacter(@Nullable String str, char singleCharacter) {\n\t\treturn (str != null && str.length() == 1 && str.charAt(0) == singleCharacter);\n\t}"
  },
  "org.springframework.util.<unknown>#merge(key,value,List<V>,List<V>,remappingFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "List<V>",
      "List<V>",
      "remappingFunction"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "List<V>",
    "signature": "public List<V> merge(K key, List<V> value, BiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction)",
    "source_code": "\tpublic List<V> merge(K key, List<V> value, BiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#mergeArrayIntoCollection(array,collection)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given array into the given Collection.\n\t * @param array the array to merge (may be {@code null})\n\t * @param collection the target Collection to merge the array into\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "collection"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "void",
    "signature": "public void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection)",
    "source_code": "\tpublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\n\t\tObject[] arr = ObjectUtils.toObjectArray(array);\n\t\tCollections.addAll(collection, (E[])arr);\n\t}"
  },
  "org.springframework.util.<unknown>#mergePropertiesIntoMap(props,Map<K,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Merge the given Properties instance into the given Map,\n\t * copying all properties (key-value pairs) over.\n\t * <p>Uses {@code Properties.propertyNames()} to even catch\n\t * default properties linked into the original Properties instance.\n\t * @param props the Properties instance to merge (may be {@code null})\n\t * @param map the target Map to merge the properties into\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "props",
      "Map<K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "void",
    "signature": "public void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map)",
    "source_code": "\tpublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\n\t\tif (props != null) {\n\t\t\tfor (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {\n\t\t\t\tString key = (String) en.nextElement();\n\t\t\t\tObject value = props.get(key);\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// Allow for defaults fallback or potentially overridden accessor...\n\t\t\t\t\tvalue = props.getProperty(key);\n\t\t\t\t}\n\t\t\t\tmap.put((K) key, (V) value);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#nullSafeEquals(o1,o2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if the given objects are equal, returning {@code true} if\n\t * both are {@code null} or {@code false} if only one is {@code null}.\n\t * <p>Compares arrays with {@code Arrays.equals}, performing an equality\n\t * check based on the array elements rather than the array reference.\n\t * @param o1 first Object to compare\n\t * @param o2 second Object to compare\n\t * @return whether the given objects are equal\n\t * @see Object#equals(Object)\n\t * @see java.util.Arrays#equals\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "boolean",
    "signature": "public boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2)",
    "source_code": "\tpublic static boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2) {\n\t\tif (o1 == o2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o1 == null || o2 == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (o1.equals(o2)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o1.getClass().isArray() && o2.getClass().isArray()) {\n\t\t\treturn arrayEquals(o1, o2);\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#parseNumber(text,targetClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code text} into a {@link Number} instance of the given\n\t * target class, using the corresponding {@code decode} / {@code valueOf} method.\n\t * <p>Trims all whitespace (leading, trailing, and in between characters) from\n\t * the input {@code String} before attempting to parse the number.\n\t * <p>Supports numbers in hex format (with leading \"0x\", \"0X\", or \"#\") as well.\n\t * @param text the text to convert\n\t * @param targetClass the target class to parse into\n\t * @return the parsed number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see Byte#decode\n\t * @see Short#decode\n\t * @see Integer#decode\n\t * @see Long#decode\n\t * @see #decodeBigInteger(String)\n\t * @see Float#valueOf\n\t * @see Double#valueOf\n\t * @see java.math.BigDecimal#BigDecimal(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "targetClass"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "T",
    "signature": "public T parseNumber(String text, Class<T> targetClass)",
    "source_code": "\tpublic static <T extends Number> T parseNumber(String text, Class<T> targetClass) {\n\t\tAssert.notNull(text, \"Text must not be null\");\n\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\tString trimmed = StringUtils.trimAllWhitespace(text);\n\n\t\tif (Byte.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));\n\t\t}\n\t\telse if (Short.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));\n\t\t}\n\t\telse if (Integer.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));\n\t\t}\n\t\telse if (Long.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));\n\t\t}\n\t\telse if (BigInteger.class == targetClass) {\n\t\t\treturn (T) (isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed));\n\t\t}\n\t\telse if (Float.class == targetClass) {\n\t\t\treturn (T) Float.valueOf(trimmed);\n\t\t}\n\t\telse if (Double.class == targetClass) {\n\t\t\treturn (T) Double.valueOf(trimmed);\n\t\t}\n\t\telse if (BigDecimal.class == targetClass || Number.class == targetClass) {\n\t\t\treturn (T) new BigDecimal(trimmed);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot convert String [\" + text + \"] to target class [\" + targetClass.getName() + \"]\");\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#parseNumber(text,targetClass,numberFormat)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given {@code text} into a {@link Number} instance of the\n\t * given target class, using the supplied {@link NumberFormat}.\n\t * <p>Trims the input {@code String} before attempting to parse the number.\n\t * @param text the text to convert\n\t * @param targetClass the target class to parse into\n\t * @param numberFormat the {@code NumberFormat} to use for parsing (if\n\t * {@code null}, this method falls back to {@link #parseNumber(String, Class)})\n\t * @return the parsed number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.text.NumberFormat#parse\n\t * @see #convertNumberToTargetClass\n\t * @see #parseNumber(String, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "text",
      "targetClass",
      "numberFormat"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "T",
    "signature": "public T parseNumber(String text, Class<T> targetClass, @Nullable NumberFormat numberFormat)",
    "source_code": "\tpublic static <T extends Number> T parseNumber(\n\t\t\tString text, Class<T> targetClass, @Nullable NumberFormat numberFormat) {\n\n\t\tif (numberFormat != null) {\n\t\t\tAssert.notNull(text, \"Text must not be null\");\n\t\t\tAssert.notNull(targetClass, \"Target class must not be null\");\n\t\t\tDecimalFormat decimalFormat = null;\n\t\t\tboolean resetBigDecimal = false;\n\t\t\tif (numberFormat instanceof DecimalFormat dc) {\n\t\t\t\tdecimalFormat = dc;\n\t\t\t\tif (BigDecimal.class == targetClass && !decimalFormat.isParseBigDecimal()) {\n\t\t\t\t\tdecimalFormat.setParseBigDecimal(true);\n\t\t\t\t\tresetBigDecimal = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tNumber number = numberFormat.parse(StringUtils.trimAllWhitespace(text));\n\t\t\t\treturn convertNumberToTargetClass(number, targetClass);\n\t\t\t}\n\t\t\tcatch (ParseException ex) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not parse number: \" + ex.getMessage());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (resetBigDecimal) {\n\t\t\t\t\tdecimalFormat.setParseBigDecimal(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn parseNumber(text, targetClass);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#pathEquals(path1,path2)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Compare two paths after normalization of them.\n\t * @param path1 first path for comparison\n\t * @param path2 second path for comparison\n\t * @return whether the two paths are equivalent after normalization\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path1",
      "path2"
    ],
    "position": {
      "column": 1,
      "line": 801
    },
    "return": "boolean",
    "signature": "public boolean pathEquals(String path1, String path2)",
    "source_code": "\tpublic static boolean pathEquals(String path1, String path2) {\n\t\treturn cleanPath(path1).equals(cleanPath(path2));\n\t}"
  },
  "org.springframework.util.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "V",
    "signature": "public V put(K key, @Nullable V value)",
    "source_code": "\tpublic V put(K key, @Nullable V value) {\n\t\treturn adaptValue(this.targetMap.put(key, adaptValue(value)));\n\t}"
  },
  "org.springframework.util.<unknown>#put(key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 165
    },
    "return": "List<V>",
    "signature": "public List<V> put(K key, List<V> values)",
    "source_code": "\tpublic List<V> put(K key, List<V> values) {\n\t\tif (values.isEmpty()) {\n\t\t\tV result = this.targetMap.put(key, null);\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse if (values.size() == 1) {\n\t\t\tV result = this.targetMap.put(key, values.get(0));\n\t\t\treturn (result != null) ? Collections.singletonList(result) : null;\n\t\t}\n\t\telse {\n\t\t\tthrow new UnsupportedOperationException(\"Duplicate key: \" + key);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,m)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "m"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends List<V>> m)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends List<V>> m) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(K,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends K, ? extends V> map)",
    "source_code": "\tpublic void putAll(Map<? extends K, ? extends V> map) {\n\t\tfor (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n\t\t\tput(entry.getKey(), entry.getValue());\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends V> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends V> map) {\n\t\tif (map.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tmap.forEach(this::put);\n\t}"
  },
  "org.springframework.util.<unknown>#putIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "V",
    "signature": "public V putIfAbsent(String key, @Nullable V value)",
    "source_code": "\tpublic V putIfAbsent(String key, @Nullable V value) {\n\t\tString oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\n\t\tif (oldKey != null) {\n\t\t\tV oldKeyValue = this.targetMap.get(oldKey);\n\t\t\tif (oldKeyValue != null) {\n\t\t\t\treturn oldKeyValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey = oldKey;\n\t\t\t}\n\t\t}\n\t\treturn this.targetMap.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.util.<unknown>#remove(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean remove(Object key, Object value)",
    "source_code": "\tpublic boolean remove(Object key, Object value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#removeEldestEntry(Map.Entry<String,eldest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether this map should remove the given eldest entry.\n\t * @param eldest the candidate entry\n\t * @return {@code true} for removing it, {@code false} for keeping it\n\t * @see LinkedHashMap#removeEldestEntry\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map.Entry<String",
      "eldest"
    ],
    "position": {
      "column": 1,
      "line": 347
    },
    "return": "boolean",
    "signature": "protected boolean removeEldestEntry(Map.Entry<String, V> eldest)",
    "source_code": "\tprotected boolean removeEldestEntry(Map.Entry<String, V> eldest) {\n\t\treturn false;\n\t}"
  },
  "org.springframework.util.<unknown>#removeIf(Entry<K,filter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "filter"
    ],
    "position": {
      "column": 1,
      "line": 389
    },
    "return": "boolean",
    "signature": "public boolean removeIf(Predicate<? super Entry<K, List<V>>> filter)",
    "source_code": "\t\tpublic boolean removeIf(Predicate<? super Entry<K, List<V>>> filter) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.util.<unknown>#replace(inString,oldPattern,newPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all occurrences of a substring within a string with another string.\n\t * @param inString {@code String} to examine\n\t * @param oldPattern {@code String} to replace\n\t * @param newPattern {@code String} to insert\n\t * @return a {@code String} with the replacements\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "inString",
      "oldPattern",
      "newPattern"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "String",
    "signature": "public String replace(String inString, String oldPattern, @Nullable String newPattern)",
    "source_code": "\tpublic static String replace(String inString, String oldPattern, @Nullable String newPattern) {\n\t\tif (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n\t\t\treturn inString;\n\t\t}\n\t\tint index = inString.indexOf(oldPattern);\n\t\tif (index == -1) {\n\t\t\t// no occurrence -> can return input as-is\n\t\t\treturn inString;\n\t\t}\n\n\t\tint capacity = inString.length();\n\t\tif (newPattern.length() > oldPattern.length()) {\n\t\t\tcapacity += 16;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(capacity);\n\n\t\tint pos = 0;  // our position in the old string\n\t\tint patLen = oldPattern.length();\n\t\twhile (index >= 0) {\n\t\t\tsb.append(inString, pos, index);\n\t\t\tsb.append(newPattern);\n\t\t\tpos = index + patLen;\n\t\t\tindex = inString.indexOf(oldPattern, pos);\n\t\t}\n\n\t\t// append any characters to the right of a match\n\t\tsb.append(inString, pos, inString.length());\n\t\treturn sb.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#replace(key,oldValue,newValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "oldValue",
      "newValue"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "boolean",
    "signature": "public boolean replace(K key, List<V> oldValue, List<V> newValue)",
    "source_code": "\tpublic boolean replace(K key, List<V> oldValue, List<V> newValue) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#replace(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "List<V>",
    "signature": "public List<V> replace(K key, List<V> value)",
    "source_code": "\tpublic List<V> replace(K key, List<V> value) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#replaceAll(K,List<V>,function)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "List<V>",
      "function"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "void",
    "signature": "public void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function)",
    "source_code": "\tpublic void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function) {\n\t\tthrow new UnsupportedOperationException();\n\t}"
  },
  "org.springframework.util.<unknown>#replacePlaceholders(value,placeholderResolver)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "placeholderResolver"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "String",
    "signature": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver)",
    "source_code": "\tpublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\tParsedValue parsedValue = parse(value);\n\t\tPartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver,\n\t\t\t\tthis.prefix, this.suffix, this.ignoreUnresolvablePlaceholders,\n\t\t\t\tcandidate -> parse(candidate, false));\n\t\treturn parsedValue.resolve(resolutionContext);\n\t}"
  },
  "org.springframework.util.<unknown>#set(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void set(K key, @Nullable V value)",
    "source_code": "\tpublic void set(K key, @Nullable V value) {\n\t\tthis.targetMap.put(key, value);\n\t}"
  },
  "org.springframework.util.<unknown>#setAll(Map<K,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void setAll(Map<K, V> values)",
    "source_code": "\tpublic void setAll(Map<K, V> values) {\n\t\tthis.targetMap.putAll(values);\n\t}"
  },
  "org.springframework.util.<unknown>#setField(field,target,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the field represented by the supplied {@linkplain Field field object} on\n\t * the specified {@linkplain Object target object} to the specified {@code value}.\n\t * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\n\t * is automatically unwrapped if the underlying field has a primitive type.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to set\n\t * @param target the target object on which to set the field\n\t * (or {@code null} for a static field)\n\t * @param value the value to set (may be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "target",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 649
    },
    "return": "void",
    "signature": "public void setField(Field field, @Nullable Object target, @Nullable Object value)",
    "source_code": "\tpublic static void setField(Field field, @Nullable Object target, @Nullable Object value) {\n\t\ttry {\n\t\t\tfield.set(target, value);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t}"
  },
  "org.springframework.util.<unknown>#setNext(Node<K,next)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Node<K",
      "next"
    ],
    "position": {
      "column": 1,
      "line": 514
    },
    "return": "void",
    "signature": "public void setNext(@Nullable Node<K, V> next)",
    "source_code": "\t\tpublic void setNext(@Nullable Node<K, V> next) {\n\t\t\tthis.next = next;\n\t\t}"
  },
  "org.springframework.util.<unknown>#setPrevious(Node<K,prev)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Node<K",
      "prev"
    ],
    "position": {
      "column": 1,
      "line": 505
    },
    "return": "void",
    "signature": "public void setPrevious(@Nullable Node<K, V> prev)",
    "source_code": "\t\tpublic void setPrevious(@Nullable Node<K, V> prev) {\n\t\t\tthis.prev = prev;\n\t\t}"
  },
  "org.springframework.util.<unknown>#shallowCopyFieldState(src,dest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Given the source object and the destination, which must be the same class\n\t * or a subclass, copy all fields, including inherited fields. Designed to\n\t * work on objects with public no-arg constructors.\n\t * @throws IllegalStateException if introspection fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "src",
      "dest"
    ],
    "position": {
      "column": 1,
      "line": 769
    },
    "return": "void",
    "signature": "public void shallowCopyFieldState(final Object src, final Object dest)",
    "source_code": "\tpublic static void shallowCopyFieldState(final Object src, final Object dest) {\n\t\tAssert.notNull(src, \"Source for field copy cannot be null\");\n\t\tAssert.notNull(dest, \"Destination for field copy cannot be null\");\n\t\tif (!src.getClass().isAssignableFrom(dest.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Destination class [\" + dest.getClass().getName() +\n\t\t\t\t\t\"] must be same or subclass as source class [\" + src.getClass().getName() + \"]\");\n\t\t}\n\t\tdoWithFields(src.getClass(), field -> {\n\t\t\tmakeAccessible(field);\n\t\t\tObject srcValue = field.get(src);\n\t\t\tfield.set(dest, srcValue);\n\t\t}, COPYABLE_FIELDS);\n\t}"
  },
  "org.springframework.util.<unknown>#split(toSplit,delimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Split a {@code String} at the first occurrence of the delimiter.\n\t * Does not include the delimiter in the result.\n\t * @param toSplit the string to split (potentially {@code null} or empty)\n\t * @param delimiter to split the string up with (potentially {@code null} or empty)\n\t * @return a two element array with index 0 being before the delimiter, and\n\t * index 1 being after the delimiter (neither element includes the delimiter);\n\t * or {@code null} if the delimiter wasn't found in the given input {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "toSplit",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1085
    },
    "return": "String[]",
    "signature": "public String[] split(@Nullable String toSplit, @Nullable String delimiter)",
    "source_code": "\tpublic static String[] split(@Nullable String toSplit, @Nullable String delimiter) {\n\t\tif (!hasLength(toSplit) || !hasLength(delimiter)) {\n\t\t\treturn null;\n\t\t}\n\t\tint offset = toSplit.indexOf(delimiter);\n\t\tif (offset < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString beforeDelimiter = toSplit.substring(0, offset);\n\t\tString afterDelimiter = toSplit.substring(offset + delimiter.length());\n\t\treturn new String[] {beforeDelimiter, afterDelimiter};\n\t}"
  },
  "org.springframework.util.<unknown>#splitArrayElementsIntoProperties(array,delimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the delimiter\n\t * providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the {@code Properties}.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter"
    ],
    "position": {
      "column": 1,
      "line": 1110
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {\n\t\treturn splitArrayElementsIntoProperties(array, delimiter, null);\n\t}"
  },
  "org.springframework.util.<unknown>#splitArrayElementsIntoProperties(array,delimiter,charsToDelete)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Take an array of strings and split each element based on the given delimiter.\n\t * A {@code Properties} instance is then generated, with the left of the\n\t * delimiter providing the key, and the right of the delimiter providing the value.\n\t * <p>Will trim both the key and value before adding them to the\n\t * {@code Properties} instance.\n\t * @param array the array to process\n\t * @param delimiter to split each element using (typically the equals symbol)\n\t * @param charsToDelete one or more characters to remove from each element\n\t * prior to attempting the split operation (typically the quotation mark\n\t * symbol), or {@code null} if no removal should occur\n\t * @return a {@code Properties} instance representing the array contents,\n\t * or {@code null} if the array to process was {@code null} or empty\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "array",
      "delimiter",
      "charsToDelete"
    ],
    "position": {
      "column": 1,
      "line": 1129
    },
    "return": "Properties",
    "signature": "public Properties splitArrayElementsIntoProperties(String[] array, String delimiter, @Nullable String charsToDelete)",
    "source_code": "\tpublic static Properties splitArrayElementsIntoProperties(\n\t\t\tString[] array, String delimiter, @Nullable String charsToDelete) {\n\n\t\tif (ObjectUtils.isEmpty(array)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tProperties result = new Properties();\n\t\tfor (String element : array) {\n\t\t\tif (charsToDelete != null) {\n\t\t\t\telement = deleteAny(element, charsToDelete);\n\t\t\t}\n\t\t\tString[] splittedElement = split(element, delimiter);\n\t\t\tif (splittedElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.util.<unknown>#startsWithIgnoreCase(str,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Test if the given {@code String} starts with the specified prefix,\n\t * ignoring upper/lower case.\n\t * @param str the {@code String} to check\n\t * @param prefix the prefix to look for\n\t * @see java.lang.String#startsWith\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "boolean",
    "signature": "public boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix)",
    "source_code": "\tpublic static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {\n\t\treturn (str != null && prefix != null && str.length() >= prefix.length() &&\n\t\t\t\tstr.regionMatches(true, 0, prefix, 0, prefix.length()));\n\t}"
  },
  "org.springframework.util.<unknown>#substringMatch(str,index,substring)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Test whether the given string matches the given substring\n\t * at the given index.\n\t * @param str the original string (or StringBuilder)\n\t * @param index the index in the original string to start matching against\n\t * @param substring the substring to match at the given index\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "index",
      "substring"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "boolean",
    "signature": "public boolean substringMatch(CharSequence str, int index, CharSequence substring)",
    "source_code": "\tpublic static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n\t\tif (index + substring.length() > str.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < substring.length(); i++) {\n\t\t\tif (str.charAt(index + i) != substring.charAt(i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.util.<unknown>#toArray(enumeration,array)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "enumeration",
      "array"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "A[]",
    "signature": "public A[] toArray(Enumeration<E> enumeration, A[] array)",
    "source_code": "\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}"
  },
  "org.springframework.util.<unknown>#toMultiValueMap(Map<K,targetMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\n\t * @param targetMap the original map\n\t * @return the adapted multi-value map (wrapping the original map)\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "V>",
    "signature": "public V> toMultiValueMap(Map<K, List<V>> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\n\t\treturn new MultiValueMapAdapter<>(targetMap);\n\t}"
  },
  "org.springframework.util.<unknown>#tokenizeToStringArray(str,delimiters)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>Trims tokens and omits empty tokens.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters"
    ],
    "position": {
      "column": 1,
      "line": 1166
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters)",
    "source_code": "\tpublic static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {\n\t\treturn tokenizeToStringArray(str, delimiters, true, true);\n\t}"
  },
  "org.springframework.util.<unknown>#tokenizeToStringArray(str,delimiters,trimTokens,ignoreEmptyTokens)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Tokenize the given {@code String} into a {@code String} array via a\n\t * {@link StringTokenizer}.\n\t * <p>The given {@code delimiters} string can consist of any number of\n\t * delimiter characters. Each of those characters can be used to separate\n\t * tokens. A delimiter is always a single character; for multi-character\n\t * delimiters, consider using {@link #delimitedListToStringArray}.\n\t * @param str the {@code String} to tokenize (potentially {@code null} or empty)\n\t * @param delimiters the delimiter characters, assembled as a {@code String}\n\t * (each of the characters is individually considered as a delimiter)\n\t * @param trimTokens trim the tokens via {@link String#trim()}\n\t * @param ignoreEmptyTokens omit empty tokens from the result array\n\t * (only applies to tokens that are empty after trimming; StringTokenizer\n\t * will not consider subsequent delimiters as token in the first place).\n\t * @return an array of the tokens\n\t * @see java.util.StringTokenizer\n\t * @see String#trim()\n\t * @see #delimitedListToStringArray\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "delimiters",
      "trimTokens",
      "ignoreEmptyTokens"
    ],
    "position": {
      "column": 1,
      "line": 1189
    },
    "return": "String[]",
    "signature": "public String[] tokenizeToStringArray(@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)",
    "source_code": "\tpublic static String[] tokenizeToStringArray(\n\t\t\t@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n\t\tif (str == null) {\n\t\t\treturn EMPTY_STRING_ARRAY;\n\t\t}\n\n\t\tStringTokenizer st = new StringTokenizer(str, delimiters);\n\t\tList<String> tokens = new ArrayList<>();\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tString token = st.nextToken();\n\t\t\tif (trimTokens) {\n\t\t\t\ttoken = token.trim();\n\t\t\t}\n\t\t\tif (!ignoreEmptyTokens || !token.isEmpty()) {\n\t\t\t\ttokens.add(token);\n\t\t\t}\n\t\t}\n\t\treturn toStringArray(tokens);\n\t}"
  },
  "org.springframework.util.<unknown>#trimLeadingCharacter(str,leadingCharacter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Trim all occurrences of the supplied leading character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param leadingCharacter the leading character to be trimmed\n\t * @return the trimmed {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "leadingCharacter"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "String",
    "signature": "public String trimLeadingCharacter(String str, char leadingCharacter)",
    "source_code": "\tpublic static String trimLeadingCharacter(String str, char leadingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint beginIdx = 0;\n\t\twhile (beginIdx < str.length() && leadingCharacter == str.charAt(beginIdx)) {\n\t\t\tbeginIdx++;\n\t\t}\n\t\treturn str.substring(beginIdx);\n\t}"
  },
  "org.springframework.util.<unknown>#trimTrailingCharacter(str,trailingCharacter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Trim all occurrences of the supplied trailing character from the given {@code String}.\n\t * @param str the {@code String} to check\n\t * @param trailingCharacter the trailing character to be trimmed\n\t * @return the trimmed {@code String}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "str",
      "trailingCharacter"
    ],
    "position": {
      "column": 1,
      "line": 350
    },
    "return": "String",
    "signature": "public String trimTrailingCharacter(String str, char trailingCharacter)",
    "source_code": "\tpublic static String trimTrailingCharacter(String str, char trailingCharacter) {\n\t\tif (!hasLength(str)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tint endIdx = str.length() - 1;\n\t\twhile (endIdx >= 0 && trailingCharacter == str.charAt(endIdx)) {\n\t\t\tendIdx--;\n\t\t}\n\t\treturn str.substring(0, endIdx + 1);\n\t}"
  },
  "org.springframework.util.<unknown>#truncate(charSequence,threshold)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Truncate the supplied {@link CharSequence}.\n\t * <p>If the length of the {@code CharSequence} is greater than the threshold,\n\t * this method returns a {@linkplain CharSequence#subSequence(int, int)\n\t * subsequence} of the {@code CharSequence} (up to the threshold) appended\n\t * with the suffix {@code \" (truncated)...\"}. Otherwise, this method returns\n\t * {@code charSequence.toString()}.\n\t * @param charSequence the {@code CharSequence} to truncate\n\t * @param threshold the maximum length after which to truncate; must be a\n\t * positive number\n\t * @return a truncated string, or a string representation of the original\n\t * {@code CharSequence} if its length does not exceed the threshold\n\t * @since 5.3.27\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "charSequence",
      "threshold"
    ],
    "position": {
      "column": 1,
      "line": 1409
    },
    "return": "String",
    "signature": "public String truncate(CharSequence charSequence, int threshold)",
    "source_code": "\tpublic static String truncate(CharSequence charSequence, int threshold) {\n\t\tAssert.isTrue(threshold > 0,\n\t\t\t\t() -> \"Truncation threshold must be a positive number: \" + threshold);\n\t\tif (charSequence.length() > threshold) {\n\t\t\treturn charSequence.subSequence(0, threshold) + TRUNCATION_SUFFIX;\n\t\t}\n\t\treturn charSequence.toString();\n\t}"
  },
  "org.springframework.util.<unknown>#tryAdvance(Entry<K,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<K",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "boolean",
    "signature": "public boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action)",
    "source_code": "\t\t\tpublic boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\treturn this.delegate.tryAdvance(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}"
  },
  "org.springframework.util.<unknown>#unmodifiableMultiValueMap(K,targetMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "K",
      "targetMap"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "V>",
    "signature": "public V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> targetMap)",
    "source_code": "\tpublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(\n\t\t\tMultiValueMap<? extends K, ? extends V> targetMap) {\n\n\t\tAssert.notNull(targetMap, \"'targetMap' must not be null\");\n\t\tif (targetMap instanceof UnmodifiableMultiValueMap) {\n\t\t\treturn (MultiValueMap<K, V>) targetMap;\n\t\t}\n\t\treturn new UnmodifiableMultiValueMap<>(targetMap);\n\t}"
  },
  "org.springframework.util.<unknown>#unqualify(qualifiedName,separator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Unqualify a string qualified by a separator character. For example,\n\t * \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.\n\t * @param qualifiedName the qualified name\n\t * @param separator the separator\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "qualifiedName",
      "separator"
    ],
    "position": {
      "column": 1,
      "line": 550
    },
    "return": "String",
    "signature": "public String unqualify(String qualifiedName, char separator)",
    "source_code": "\tpublic static String unqualify(String qualifiedName, char separator) {\n\t\treturn qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);\n\t}"
  },
  "org.springframework.util.<unknown>#uriDecode(source,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Decode the given encoded URI component value. Based on the following rules:\n\t * <ul>\n\t * <li>Alphanumeric characters {@code \"a\"} through {@code \"z\"}, {@code \"A\"} through {@code \"Z\"},\n\t * and {@code \"0\"} through {@code \"9\"} stay the same.</li>\n\t * <li>Special characters {@code \"-\"}, {@code \"_\"}, {@code \".\"}, and {@code \"*\"} stay the same.</li>\n\t * <li>A sequence \"{@code %<i>xy</i>}\" is interpreted as a hexadecimal representation of the character.</li>\n\t * <li>For all other characters (including those already decoded), the output is undefined.</li>\n\t * </ul>\n\t * @param source the encoded String\n\t * @param charset the character set\n\t * @return the decoded value\n\t * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n\t * @since 5.0\n\t * @see java.net.URLDecoder#decode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 821
    },
    "return": "String",
    "signature": "public String uriDecode(String source, Charset charset)",
    "source_code": "\tpublic static String uriDecode(String source, Charset charset) {\n\t\tint length = source.length();\n\t\tif (length == 0) {\n\t\t\treturn source;\n\t\t}\n\t\tAssert.notNull(charset, \"Charset must not be null\");\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n\t\tboolean changed = false;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tint ch = source.charAt(i);\n\t\t\tif (ch == '%') {\n\t\t\t\tif (i + 2 < length) {\n\t\t\t\t\tchar hex1 = source.charAt(i + 1);\n\t\t\t\t\tchar hex2 = source.charAt(i + 2);\n\t\t\t\t\tint u = Character.digit(hex1, 16);\n\t\t\t\t\tint l = Character.digit(hex2, 16);\n\t\t\t\t\tif (u == -1 || l == -1) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tbaos.write((char) ((u << 4) + l));\n\t\t\t\t\ti += 2;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbaos.write(ch);\n\t\t\t}\n\t\t}\n\t\treturn (changed ? StreamUtils.copyToString(baos, charset) : source);\n\t}"
  },
  "org.springframework.util.comparator.<unknown>#compare(left,right)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "left",
      "right"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "int",
    "signature": "public int compare(@Nullable T left, @Nullable T right)",
    "source_code": "\tpublic int compare(@Nullable T left, @Nullable T right) {\n\t\tComparator<T> comparator = this.nullsLow ? Comparator.nullsFirst(this.nonNullComparator) : Comparator.nullsLast(this.nonNullComparator);\n\t\treturn comparator.compare(left, right);\n\t}"
  },
  "org.springframework.util.concurrent.<unknown>#get(timeout,unit)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "timeout",
      "unit"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "T",
    "signature": "public T get(long timeout, TimeUnit unit)",
    "source_code": "\tpublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\treturn adaptInternal(this.adaptee.get(timeout, unit));\n\t}"
  },
  "org.springframework.util.xml.<unknown>#characters(ch,start,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ch",
      "start",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "void",
    "signature": "public void characters(char[] ch, int start, int length)",
    "source_code": "\tpublic void characters(char[] ch, int start, int length) {\n\t\tString data = new String(ch, start, length);\n\t\tNode parent = getParent();\n\t\tNode lastChild = parent.getLastChild();\n\t\tif (lastChild != null && lastChild.getNodeType() == Node.TEXT_NODE) {\n\t\t\t((Text) lastChild).appendData(data);\n\t\t}\n\t\telse {\n\t\t\tText text = this.document.createTextNode(data);\n\t\t\tparent.appendChild(text);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#createEventStreamWriter(eventWriter,eventFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\n\t * @return a stream writer that writes to an event writer\n\t * @since 3.0.5\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eventWriter",
      "eventFactory"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "XMLStreamWriter",
    "signature": "public XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory)",
    "source_code": "\tpublic static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory) {\n\t\treturn new XMLEventStreamWriter(eventWriter, eventFactory);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#endElement(uri,localName,qName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "localName",
      "qName"
    ],
    "position": {
      "column": 1,
      "line": 90
    },
    "return": "void",
    "signature": "public void endElement(String uri, String localName, String qName)",
    "source_code": "\tpublic void endElement(String uri, String localName, String qName) {\n\t\tthis.elements.remove(this.elements.size() - 1);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementByTagName(ele,childEleName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Utility method that returns the first child element identified by its name.\n\t * @param ele the DOM element to analyze\n\t * @param childEleName the child element name to look for\n\t * @return the {@code org.w3c.dom.Element} instance, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleName"
    ],
    "position": {
      "column": 1,
      "line": 96
    },
    "return": "Element",
    "signature": "public Element getChildElementByTagName(Element ele, String childEleName)",
    "source_code": "\tpublic static Element getChildElementByTagName(Element ele, String childEleName) {\n\t\tAssert.notNull(ele, \"Element must not be null\");\n\t\tAssert.notNull(childEleName, \"Element name must not be null\");\n\t\tNodeList nl = ele.getChildNodes();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element element && nodeNameMatch(node, childEleName)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementValueByTagName(ele,childEleName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Utility method that returns the first child element value identified by its name.\n\t * @param ele the DOM element to analyze\n\t * @param childEleName the child element name to look for\n\t * @return the extracted text value, or {@code null} if no child element found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleName"
    ],
    "position": {
      "column": 1,
      "line": 116
    },
    "return": "String",
    "signature": "public String getChildElementValueByTagName(Element ele, String childEleName)",
    "source_code": "\tpublic static String getChildElementValueByTagName(Element ele, String childEleName) {\n\t\tElement child = getChildElementByTagName(ele, childEleName);\n\t\treturn (child != null ? getTextValue(child) : null);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementsByTagName(ele,childEleName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieves all child elements of the given DOM element that match the given element name.\n\t * Only look at the direct child level of the given element; do not go into further depth\n\t * (in contrast to the DOM API's {@code getElementsByTagName} method).\n\t * @param ele the DOM element to analyze\n\t * @param childEleName the child element name to look for\n\t * @return a List of child {@code org.w3c.dom.Element} instances\n\t * @see org.w3c.dom.Element\n\t * @see org.w3c.dom.Element#getElementsByTagName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleName"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "List<Element>",
    "signature": "public List<Element> getChildElementsByTagName(Element ele, String childEleName)",
    "source_code": "\tpublic static List<Element> getChildElementsByTagName(Element ele, String childEleName) {\n\t\treturn getChildElementsByTagName(ele, new String[] {childEleName});\n\t}"
  },
  "org.springframework.util.xml.<unknown>#getChildElementsByTagName(ele,childEleNames)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieves all child elements of the given DOM element that match any of the given element names.\n\t * Only looks at the direct child level of the given element; do not go into further depth\n\t * (in contrast to the DOM API's {@code getElementsByTagName} method).\n\t * @param ele the DOM element to analyze\n\t * @param childEleNames the child element names to look for\n\t * @return a List of child {@code org.w3c.dom.Element} instances\n\t * @see org.w3c.dom.Element\n\t * @see org.w3c.dom.Element#getElementsByTagName\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ele",
      "childEleNames"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "List<Element>",
    "signature": "public List<Element> getChildElementsByTagName(Element ele, String... childEleNames)",
    "source_code": "\tpublic static List<Element> getChildElementsByTagName(Element ele, String... childEleNames) {\n\t\tAssert.notNull(ele, \"Element must not be null\");\n\t\tAssert.notNull(childEleNames, \"Element names collection must not be null\");\n\t\tList<String> childEleNameList = Arrays.asList(childEleNames);\n\t\tNodeList nl = ele.getChildNodes();\n\t\tList<Element> childEles = new ArrayList<>();\n\t\tfor (int i = 0; i < nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element element && nodeNameMatch(node, childEleNameList)) {\n\t\t\t\tchildEles.add(element);\n\t\t\t}\n\t\t}\n\t\treturn childEles;\n\t}"
  },
  "org.springframework.util.xml.<unknown>#ignorableWhitespace(ch,start,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ch",
      "start",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 139
    },
    "return": "void",
    "signature": "public void ignorableWhitespace(char[] ch, int start, int length)",
    "source_code": "\tpublic void ignorableWhitespace(char[] ch, int start, int length) {\n\t}"
  },
  "org.springframework.util.xml.<unknown>#nodeNameEquals(node,desiredName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Namespace-aware equals comparison. Returns {@code true} if either\n\t * {@link Node#getLocalName} or {@link Node#getNodeName} equals\n\t * {@code desiredName}, otherwise returns {@code false}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "node",
      "desiredName"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "public boolean nodeNameEquals(Node node, String desiredName)",
    "source_code": "\tpublic static boolean nodeNameEquals(Node node, String desiredName) {\n\t\tAssert.notNull(node, \"Node must not be null\");\n\t\tAssert.notNull(desiredName, \"Desired name must not be null\");\n\t\treturn nodeNameMatch(node, desiredName);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#processingInstruction(target,data)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "data"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "void",
    "signature": "public void processingInstruction(String target, String data)",
    "source_code": "\tpublic void processingInstruction(String target, String data) {\n\t\tNode parent = getParent();\n\t\tProcessingInstruction pi = this.document.createProcessingInstruction(target, data);\n\t\tparent.appendChild(pi);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#setFeature(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void setFeature(String name, boolean value)",
    "source_code": "\tpublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n\t\tif (NAMESPACES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacesFeature = value;\n\t\t}\n\t\telse if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\n\t\t\tthis.namespacePrefixesFeature = value;\n\t\t}\n\t\telse {\n\t\t\tsuper.setFeature(name, value);\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startElement(uri,localName,qName,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "localName",
      "qName",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void startElement(String uri, String localName, String qName, Attributes attributes)",
    "source_code": "\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) {\n\t\tNode parent = getParent();\n\t\tElement element = this.document.createElementNS(uri, qName);\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tString attrUri = attributes.getURI(i);\n\t\t\tString attrQname = attributes.getQName(i);\n\t\t\tString value = attributes.getValue(i);\n\t\t\tif (!attrQname.startsWith(\"xmlns\")) {\n\t\t\t\telement.setAttributeNS(attrUri, attrQname, value);\n\t\t\t}\n\t\t}\n\t\telement = (Element) parent.appendChild(element);\n\t\tthis.elements.add(element);\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startPrefixMapping(prefix,namespace)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Start the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "prefix",
      "namespace"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "protected void startPrefixMapping(@Nullable String prefix, String namespace)",
    "source_code": "\tprotected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {\n\t\tif (getContentHandler() != null && StringUtils.hasLength(namespace)) {\n\t\t\tif (prefix == null) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\tif (!namespace.equals(this.namespaces.get(prefix))) {\n\t\t\t\tgetContentHandler().startPrefixMapping(prefix, namespace);\n\t\t\t\tthis.namespaces.put(prefix, namespace);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.util.xml.<unknown>#startPrefixMapping(prefix,uri)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "prefix",
      "uri"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void startPrefixMapping(String prefix, String uri)",
    "source_code": "\tpublic void startPrefixMapping(String prefix, String uri) {\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fieldTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter, applying it to the specified field types only, if any,\n\t * or otherwise to all fields matching the {@link Formatter}-declared type.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add (does not need to generically declare a\n\t * field type if field types are explicitly specified as parameters)\n\t * @param fieldTypes the field types to apply the formatter to, or none if to be\n\t * derived from the given {@link Formatter} implementation class\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fieldTypes"
    ],
    "position": {
      "column": 1,
      "line": 827
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tif (ObjectUtils.isEmpty(fieldTypes)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (Class<?> fieldType : fieldTypes) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#addCustomFormatter(formatter,fields)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add a custom formatter for the field type specified in {@link Formatter} class,\n\t * applying it to the specified fields only, if any, or otherwise to all fields.\n\t * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.\n\t * @param formatter the formatter to add, generically declared for a specific type\n\t * @param fields the fields to apply the formatter to, or none if to be applied to all\n\t * @since 4.2\n\t * @see #registerCustomEditor(Class, String, PropertyEditor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "formatter",
      "fields"
    ],
    "position": {
      "column": 1,
      "line": 803
    },
    "return": "void",
    "signature": "public void addCustomFormatter(Formatter<?> formatter, String... fields)",
    "source_code": "\tpublic void addCustomFormatter(Formatter<?> formatter, String... fields) {\n\t\tFormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);\n\t\tClass<?> fieldType = adapter.getFieldType();\n\t\tif (ObjectUtils.isEmpty(fields)) {\n\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);\n\t\t}\n\t\telse {\n\t\t\tfor (String field : fields) {\n\t\t\t\tgetPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,field)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 871
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)\n\t\t\tthrows TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, field);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,methodParam)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "methodParam"
    ],
    "position": {
      "column": 1,
      "line": 863
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable MethodParameter methodParam) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, methodParam);\n\t}"
  },
  "org.springframework.validation.<unknown>#convertIfNecessary(value,requiredType,typeDescriptor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "requiredType",
      "typeDescriptor"
    ],
    "position": {
      "column": 1,
      "line": 879
    },
    "return": "T",
    "signature": "public T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor)",
    "source_code": "\tpublic <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,\n\t\t\t@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {\n\n\t\treturn getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);\n\t}"
  },
  "org.springframework.validation.<unknown>#findCustomEditor(requiredType,propertyPath)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyPath"
    ],
    "position": {
      "column": 1,
      "line": 851
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath)",
    "source_code": "\tpublic PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {\n\t\treturn getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);\n\t}"
  },
  "org.springframework.validation.<unknown>#findEditor(field,valueType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation delegates to the\n\t * {@link #getPropertyEditorRegistry() PropertyEditorRegistry}'s\n\t * editor lookup facility, if available.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "valueType"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "PropertyEditor",
    "signature": "public PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType)",
    "source_code": "\tpublic PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType) {\n\t\tPropertyEditorRegistry editorRegistry = getPropertyEditorRegistry();\n\t\tif (editorRegistry != null) {\n\t\t\tClass<?> valueTypeToUse = valueType;\n\t\t\tif (valueTypeToUse == null) {\n\t\t\t\tvalueTypeToUse = getFieldType(field);\n\t\t\t}\n\t\t\treturn editorRegistry.findCustomEditor(valueTypeToUse, fixedField(field));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#formatFieldValue(field,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Format the given value for the specified field.\n\t * <p>The default implementation simply returns the field value as-is.\n\t * @param field the field to check\n\t * @param value the value of the field (either a rejected value\n\t * other than from a binding error, or an actual field value)\n\t * @return the formatted value\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 401
    },
    "return": "Object",
    "signature": "protected Object formatFieldValue(String field, @Nullable Object value)",
    "source_code": "\tprotected Object formatFieldValue(String field, @Nullable Object value) {\n\t\treturn value;\n\t}"
  },
  "org.springframework.validation.<unknown>#getBindingResult(Map<?,model,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find the BindingResult for the given name in the given model.\n\t * @param model the model to search\n\t * @param name the name of the target object to find a BindingResult for\n\t * @return the BindingResult, or {@code null} if none found\n\t * @throws IllegalStateException if the attribute found is not of type BindingResult\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "model",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 41
    },
    "return": "BindingResult",
    "signature": "public BindingResult getBindingResult(Map<?, ?> model, String name)",
    "source_code": "\tpublic static BindingResult getBindingResult(Map<?, ?> model, String name) {\n\t\tAssert.notNull(model, \"Model map must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tObject attr = model.get(BindingResult.MODEL_KEY_PREFIX + name);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof BindingResult bindingResult) {\n\t\t\treturn bindingResult;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"BindingResult attribute is not of type BindingResult: \" + attr);\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#getRequiredBindingResult(Map<?,model,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a required BindingResult for the given name in the given model.\n\t * @param model the model to search\n\t * @param name the name of the target object to find a BindingResult for\n\t * @return the BindingResult (never {@code null})\n\t * @throws IllegalStateException if no BindingResult found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<?",
      "model",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "BindingResult",
    "signature": "public BindingResult getRequiredBindingResult(Map<?, ?> model, String name)",
    "source_code": "\tpublic static BindingResult getRequiredBindingResult(Map<?, ?> model, String name) {\n\t\tBindingResult bindingResult = getBindingResult(model, name);\n\t\tif (bindingResult == null) {\n\t\t\tthrow new IllegalStateException(\"No BindingResult attribute found for name '\" + name +\n\t\t\t\t\t\"'- have you exposed the correct model?\");\n\t\t}\n\t\treturn bindingResult;\n\t}"
  },
  "org.springframework.validation.<unknown>#invokeValidator(validator,target,errors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@link Validator} for the supplied object and\n\t * {@link Errors} instance.\n\t * @param validator the {@code Validator} to be invoked\n\t * @param target the object to bind the parameters to\n\t * @param errors the {@link Errors} instance that should store the errors\n\t * @throws IllegalArgumentException if either of the {@code Validator} or {@code Errors}\n\t * arguments is {@code null}, or if the supplied {@code Validator} does not\n\t * {@link Validator#supports(Class) support} the validation of the supplied object's type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator",
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void invokeValidator(Validator validator, Object target, Errors errors)",
    "source_code": "\tpublic static void invokeValidator(Validator validator, Object target, Errors errors) {\n\t\tinvokeValidator(validator, target, errors, (Object[]) null);\n\t}"
  },
  "org.springframework.validation.<unknown>#invokeValidator(validator,target,errors,validationHints)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given {@link Validator}/{@link SmartValidator} for the supplied object and\n\t * {@link Errors} instance.\n\t * @param validator the {@code Validator} to be invoked\n\t * @param target the object to bind the parameters to\n\t * @param errors the {@link Errors} instance that should store the errors\n\t * @param validationHints one or more hint objects to be passed to the validation engine\n\t * @throws IllegalArgumentException if either of the {@code Validator} or {@code Errors}\n\t * arguments is {@code null}, or if the supplied {@code Validator} does not\n\t * {@link Validator#supports(Class) support} the validation of the supplied object's type\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "validator",
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void invokeValidator(Validator validator, Object target, Errors errors, @Nullable Object... validationHints)",
    "source_code": "\tpublic static void invokeValidator(\n\t\t\tValidator validator, Object target, Errors errors, @Nullable Object... validationHints) {\n\n\t\tAssert.notNull(validator, \"Validator must not be null\");\n\t\tAssert.notNull(target, \"Target object must not be null\");\n\t\tAssert.notNull(errors, \"Errors object must not be null\");\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking validator [\" + validator + \"]\");\n\t\t}\n\t\tif (!validator.supports(target.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Validator [\" + validator.getClass() + \"] does not support [\" + target.getClass() + \"]\");\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator smartValidator) {\n\t\t\tsmartValidator.validate(target, errors, validationHints);\n\t\t}\n\t\telse {\n\t\t\tvalidator.validate(target, errors);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (errors.hasErrors()) {\n\t\t\t\tlogger.debug(\"Validator found \" + errors.getErrorCount() + \" errors\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.debug(\"Validator found no errors\");\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#recordFieldValue(field,type,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "type",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 331
    },
    "return": "void",
    "signature": "public void recordFieldValue(String field, Class<?> type, @Nullable Object value)",
    "source_code": "\tpublic void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n\t\tthis.fieldTypes.put(field, type);\n\t\tthis.fieldValues.put(field, value);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,field,propertyEditor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "field",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 845
    },
    "return": "void",
    "signature": "public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);\n\t}"
  },
  "org.springframework.validation.<unknown>#registerCustomEditor(requiredType,propertyEditor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requiredType",
      "propertyEditor"
    ],
    "position": {
      "column": 1,
      "line": 840
    },
    "return": "void",
    "signature": "public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor)",
    "source_code": "\tpublic void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {\n\t\tgetPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);\n\t}"
  },
  "org.springframework.validation.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\taddError(new ObjectError(getObjectName(), resolveMessageCodes(errorCode), errorArgs, defaultMessage));\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmpty(errors,field,errorCode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode) {\n\t\trejectIfEmpty(errors, field, errorCode, null, null);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmpty(errors,field,errorCode,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode, String defaultMessage) {\n\t\trejectIfEmpty(errors, field, errorCode, null, defaultMessage);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmpty(errors,field,errorCode,errorArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and error arguments\n\t * if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode, Object[] errorArgs)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode, Object[] errorArgs) {\n\t\trejectIfEmpty(errors, field, errorCode, errorArgs, null);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmpty(errors,field,errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code, error arguments\n\t * and default message if the value is empty.\n\t * <p>An 'empty' value in this context means either {@code null} or\n\t * the empty string \"\".\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 168
    },
    "return": "void",
    "signature": "public void rejectIfEmpty(Errors errors, String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmpty(Errors errors, String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tAssert.notNull(errors, \"Errors object must not be null\");\n\t\tObject value = errors.getFieldValue(field);\n\t\tif (value == null || !StringUtils.hasLength(value.toString())) {\n\t\t\terrors.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmptyOrWhitespace(errors,field,errorCode)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code if the value is empty\n\t * or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 190
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode) {\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, null, null);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmptyOrWhitespace(errors,field,errorCode,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and default message\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace(\n\t\t\tErrors errors, String field, String errorCode, String defaultMessage) {\n\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, null, defaultMessage);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmptyOrWhitespace(errors,field,errorCode,errorArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code and error arguments\n\t * if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, @Nullable Object[] errorArgs)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace(\n\t\t\tErrors errors, String field, String errorCode, @Nullable Object[] errorArgs) {\n\n\t\trejectIfEmptyOrWhitespace(errors, field, errorCode, errorArgs, null);\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectIfEmptyOrWhitespace(errors,field,errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Reject the given field with the given error code, error arguments\n\t * and default message if the value is empty or just contains whitespace.\n\t * <p>An 'empty' value in this context means either {@code null},\n\t * the empty string \"\", or consisting wholly of whitespace.\n\t * <p>The object whose field is being validated does not need to be passed\n\t * in because the {@link Errors} instance can resolve field values by itself\n\t * (it will usually hold an internal reference to the target object).\n\t * @param errors the {@code Errors} instance to register errors on\n\t * @param field the field name to check\n\t * @param errorCode the error code, interpretable as message key\n\t * @param errorArgs the error arguments, for argument binding via MessageFormat\n\t * (can be {@code null})\n\t * @param defaultMessage fallback default message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "void",
    "signature": "public void rejectIfEmptyOrWhitespace(Errors errors, String field, String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic static void rejectIfEmptyOrWhitespace(\n\t\t\tErrors errors, String field, String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tAssert.notNull(errors, \"Errors object must not be null\");\n\t\tObject value = errors.getFieldValue(field);\n\t\tif (value == null ||!StringUtils.hasText(value.toString())) {\n\t\t\terrors.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t\t}\n\t}"
  },
  "org.springframework.validation.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tif (!StringUtils.hasLength(getNestedPath()) && !StringUtils.hasLength(field)) {\n\t\t\t// We're at the top of the nested object hierarchy,\n\t\t\t// so the present level is not a field but rather the top object.\n\t\t\t// The best we can do is register a global error here...\n\t\t\treject(errorCode, errorArgs, defaultMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tString fixedField = fixedField(field);\n\t\tObject newVal = getActualFieldValue(fixedField);\n\t\tFieldError fe = new FieldError(getObjectName(), fixedField, newVal, false,\n\t\t\t\tresolveMessageCodes(errorCode, field), errorArgs, defaultMessage);\n\t\taddError(fe);\n\t}"
  },
  "org.springframework.validation.<unknown>#resolveMessageCodes(errorCode,field)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 320
    },
    "return": "String[]",
    "signature": "public String[] resolveMessageCodes(String errorCode, @Nullable String field)",
    "source_code": "\tpublic String[] resolveMessageCodes(String errorCode, @Nullable String field) {\n\t\treturn getMessageCodesResolver().resolveMessageCodes(\n\t\t\t\terrorCode, getObjectName(), fixedField(field), getFieldType(field));\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#compare(result1,result2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "result1",
      "result2"
    ],
    "position": {
      "column": 1,
      "line": 614
    },
    "return": "int",
    "signature": "public int compare(ParameterValidationResult result1, ParameterValidationResult result2)",
    "source_code": "\t\tpublic int compare(ParameterValidationResult result1, ParameterValidationResult result2) {\n\t\t\tint index1 = result1.getMethodParameter().getParameterIndex();\n\t\t\tint index2 = result2.getMethodParameter().getParameterIndex();\n\t\t\tint i = Integer.compare(index1, index2);\n\t\t\tif (i != 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tif (result1 instanceof ParameterErrors errors1 && result2 instanceof ParameterErrors errors2) {\n\t\t\t\tInteger containerIndex1 = errors1.getContainerIndex();\n\t\t\t\tInteger containerIndex2 = errors2.getContainerIndex();\n\t\t\t\tif (containerIndex1 != null && containerIndex2 != null) {\n\t\t\t\t\ti = Integer.compare(containerIndex1, containerIndex2);\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = compareKeys(errors1, errors2);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getArgumentsForConstraint(objectName,field,descriptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return FieldError arguments for a validation error on the given field.\n\t * Invoked for each violated constraint.\n\t * <p>The default implementation returns a first argument indicating the field name\n\t * (see {@link #getResolvableField}). Afterwards, it adds all actual constraint\n\t * annotation attributes (i.e. excluding \"message\", \"groups\" and \"payload\") in\n\t * alphabetical order of their attribute names.\n\t * <p>Can be overridden to, for example, add further attributes from the constraint descriptor.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @param descriptor the JSR-303 constraint descriptor\n\t * @return the Object array that represents the FieldError arguments\n\t * @see org.springframework.validation.FieldError#getArguments\n\t * @see org.springframework.context.support.DefaultMessageSourceResolvable\n\t * @see org.springframework.validation.DefaultBindingErrorProcessor#getArgumentsForBindError\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName",
      "field",
      "descriptor"
    ],
    "position": {
      "column": 1,
      "line": 260
    },
    "return": "Object[]",
    "signature": "protected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor)",
    "source_code": "\tprotected Object[] getArgumentsForConstraint(String objectName, String field, ConstraintDescriptor<?> descriptor) {\n\t\tList<Object> arguments = new ArrayList<>();\n\t\targuments.add(getResolvableField(objectName, field));\n\t\t// Using a TreeMap for alphabetical ordering of attribute names\n\t\tMap<String, Object> attributesToExpose = new TreeMap<>();\n\t\tdescriptor.getAttributes().forEach((attributeName, attributeValue) -> {\n\t\t\tif (!internalAnnotationAttributes.contains(attributeName)) {\n\t\t\t\tif (attributeValue instanceof String str) {\n\t\t\t\t\tattributeValue = new ResolvableAttribute(str);\n\t\t\t\t}\n\t\t\t\tattributesToExpose.put(attributeName, attributeValue);\n\t\t\t}\n\t\t});\n\t\targuments.addAll(attributesToExpose.values());\n\t\treturn arguments.toArray();\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getRejectedValue(field,violation,bindingResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract the rejected value behind the given constraint violation,\n\t * for exposure through the Spring errors representation.\n\t * @param field the field that caused the binding error\n\t * @param violation the corresponding JSR-303 ConstraintViolation\n\t * @param bindingResult a Spring BindingResult for the backing object\n\t * which contains the current field's value\n\t * @return the invalid value to expose as part of the field error\n\t * @since 4.2\n\t * @see jakarta.validation.ConstraintViolation#getInvalidValue()\n\t * @see org.springframework.validation.FieldError#getRejectedValue()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "field",
      "violation",
      "bindingResult"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "Object",
    "signature": "protected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult)",
    "source_code": "\tprotected Object getRejectedValue(String field, ConstraintViolation<Object> violation, BindingResult bindingResult) {\n\t\tObject invalidValue = violation.getInvalidValue();\n\t\tif (!field.isEmpty() && !field.contains(\"[]\") &&\n\t\t\t\t(invalidValue == violation.getLeafBean() || field.contains(\"[\") || field.contains(\".\"))) {\n\t\t\t// Possibly a bean constraint with property path: retrieve the actual property value.\n\t\t\t// However, explicitly avoid this for \"address[]\" style paths that we can't handle.\n\t\t\ttry {\n\t\t\t\tinvalidValue = bindingResult.getRawFieldValue(field);\n\t\t\t}\n\t\t\tcatch (InvalidPropertyException ex) {\n\t\t\t\t// Bean validation uses ValueExtractor's to unwrap container values\n\t\t\t\t// in which cases we can't access the raw value.\n\t\t\t}\n\t\t}\n\t\treturn invalidValue;\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#getResolvableField(objectName,field)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a resolvable wrapper for the specified field, allowing to resolve the field's\n\t * name in a {@code MessageSource}.\n\t * <p>The default implementation returns a first argument indicating the field:\n\t * of type {@code DefaultMessageSourceResolvable}, with \"objectName.field\" and \"field\"\n\t * as codes, and with the plain field name as default message.\n\t * @param objectName the name of the target object\n\t * @param field the field that caused the binding error\n\t * @return a corresponding {@code MessageSourceResolvable} for the specified field\n\t * @since 4.3\n\t * @see #getArgumentsForConstraint\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "objectName",
      "field"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "MessageSourceResolvable",
    "signature": "protected MessageSourceResolvable getResolvableField(String objectName, String field)",
    "source_code": "\tprotected MessageSourceResolvable getResolvableField(String objectName, String field) {\n\t\tString[] codes = (StringUtils.hasText(field) ?\n\t\t\t\tnew String[] {objectName + Errors.NESTED_PATH_SEPARATOR + field, field} :\n\t\t\t\tnew String[] {objectName});\n\t\treturn new DefaultMessageSourceResolvable(codes, field);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#invokeValidatorForArguments(target,method,arguments,groups)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 256
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForArguments(Object target, Method method, Object[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForArguments(\n\t\t\tObject target, Method method, Object[] arguments, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\ttry {\n\t\t\treturn execVal.validateParameters(target, method, arguments, groups);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011\n\t\t\t// Let's try to find the bridged method on the implementation class...\n\t\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(method, target.getClass());\n\t\t\treturn execVal.validateParameters(target, bridgedMethod, arguments, groups);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#invokeValidatorForReturnValue(target,method,returnValue,groups)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the validator, and return the resulting violations.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 291
    },
    "return": "Set<ConstraintViolation<Object>>",
    "signature": "public Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(Object target, Method method, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic final Set<ConstraintViolation<Object>> invokeValidatorForReturnValue(\n\t\t\tObject target, Method method, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tExecutableValidator execVal = this.validator.get().forExecutables();\n\t\treturn execVal.validateReturnValue(target, method, returnValue, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#processConstraintViolations(violations,errors)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given JSR-303 ConstraintViolations, adding corresponding errors to\n\t * the provided Spring {@link Errors} object.\n\t * @param violations the JSR-303 ConstraintViolation results\n\t * @param errors the Spring errors object to register to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "violations",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "protected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors)",
    "source_code": "\tprotected void processConstraintViolations(Set<ConstraintViolation<Object>> violations, Errors errors) {\n\t\tfor (ConstraintViolation<Object> violation : violations) {\n\t\t\tString field = determineField(violation);\n\t\t\tFieldError fieldError = errors.getFieldError(field);\n\t\t\tif (fieldError == null || !fieldError.isBindingFailure()) {\n\t\t\t\ttry {\n\t\t\t\t\tConstraintDescriptor<?> cd = violation.getConstraintDescriptor();\n\t\t\t\t\tString errorCode = determineErrorCode(cd);\n\t\t\t\t\tObject[] errorArgs = getArgumentsForConstraint(errors.getObjectName(), field, cd);\n\t\t\t\t\tif (errors instanceof BindingResult bindingResult) {\n\t\t\t\t\t\t// Can do custom FieldError registration with invalid value from ConstraintViolation,\n\t\t\t\t\t\t// as necessary for Hibernate Validator compatibility (non-indexed set path in field)\n\t\t\t\t\t\tString nestedField = bindingResult.getNestedPath() + field;\n\t\t\t\t\t\tif (nestedField.isEmpty()) {\n\t\t\t\t\t\t\tString[] errorCodes = bindingResult.resolveMessageCodes(errorCode);\n\t\t\t\t\t\t\tObjectError error = new ViolationObjectError(\n\t\t\t\t\t\t\t\t\terrors.getObjectName(), errorCodes, errorArgs, violation, this);\n\t\t\t\t\t\t\tbindingResult.addError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tObject rejectedValue = getRejectedValue(field, violation, bindingResult);\n\t\t\t\t\t\t\tString[] errorCodes = bindingResult.resolveMessageCodes(errorCode, field);\n\t\t\t\t\t\t\tFieldError error = new ViolationFieldError(errors.getObjectName(), nestedField,\n\t\t\t\t\t\t\t\t\trejectedValue, errorCodes, errorArgs, violation, this);\n\t\t\t\t\t\t\tbindingResult.addError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Got no BindingResult - can only do standard rejectValue call\n\t\t\t\t\t\t// with automatic extraction of the current field value\n\t\t\t\t\t\terrors.rejectValue(field, errorCode, errorArgs, violation.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"JSR-303 validated property '\" + field +\n\t\t\t\t\t\t\t\"' does not have a corresponding accessor for Spring data binding - \" +\n\t\t\t\t\t\t\t\"check your DataBinder's configuration (bean property versus direct field access)\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#resolveName(parameter,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 579
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter parameter, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter parameter, @Nullable Object value) {\n\t\t\tString objectName = null;\n\t\t\tif (parameter.getParameterIndex() != -1) {\n\t\t\t\tobjectName = parameter.getParameterName();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tMethod method = parameter.getMethod();\n\t\t\t\t\tif (method != null) {\n\t\t\t\t\t\tClass<?> containingClass = parameter.getContainingClass();\n\t\t\t\t\t\tClass<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n\t\t\t\t\t\tobjectName = Conventions.getVariableNameForReturnType(method, resolvedType, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t// insufficient type information\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objectName == null) {\n\t\t\t\tint index = parameter.getParameterIndex();\n\t\t\t\tobjectName = (parameter.getExecutable().getName() + (index != -1 ? \".arg\" + index : \".returnValue\"));\n\t\t\t}\n\t\t\treturn objectName;\n\t\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(object,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 359
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validate(T object, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validate(object, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors)",
    "source_code": "\tpublic void validate(Object target, Errors errors) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(this.targetValidator.validate(target), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validate(target,errors,validationHints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "void",
    "signature": "public void validate(Object target, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateArguments(target,method,parameters,arguments,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForArguments(target, method, arguments, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (parameters != null ? parameters[i] : initMethodParameter(method, i)),\n\t\t\t\ti -> arguments[i]);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateProperty(object,propertyName,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "propertyName",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 365
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validateProperty(object, propertyName, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic final MethodValidationResult validateReturnValue(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tSet<ConstraintViolation<Object>> violations =\n\t\t\t\tinvokeValidatorForReturnValue(target, method, returnValue, groups);\n\n\t\tif (violations.isEmpty()) {\n\t\t\treturn emptyValidationResult;\n\t\t}\n\n\t\treturn adaptViolations(target, method, violations,\n\t\t\t\ti -> (returnType != null ? returnType : initMethodParameter(method, -1)),\n\t\t\t\ti -> returnValue);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateValue(beanType,propertyName,value,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "propertyName",
      "value",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 371
    },
    "return": "Set<ConstraintViolation<T>>",
    "signature": "public Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>... groups)",
    "source_code": "\tpublic <T> Set<ConstraintViolation<T>> validateValue(\n\t\t\tClass<T> beanType, String propertyName, Object value, Class<?>... groups) {\n\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validateValue(beanType, propertyName, value, groups);\n\t}"
  },
  "org.springframework.validation.beanvalidation.<unknown>#validateValue(targetType,fieldName,value,errors,validationHints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "targetType",
      "fieldName",
      "value",
      "errors",
      "validationHints"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void validateValue(Class<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints)",
    "source_code": "\tpublic void validateValue(\n\t\t\tClass<?> targetType, String fieldName, @Nullable Object value, Errors errors, Object... validationHints) {\n\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(this.targetValidator.validateValue(\n\t\t\t\t\t(Class) targetType, fieldName, value, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}"
  },
  "org.springframework.validation.method.<unknown>#unwrap(error,sourceType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Unwrap the source behind the given error. For Jakarta Bean validation the\n\t * source is a {@link jakarta.validation.ConstraintViolation}.\n\t * @param sourceType the expected source type\n\t * @return the source object of the given type\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error",
      "sourceType"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "T",
    "signature": "public T unwrap(MessageSourceResolvable error, Class<T> sourceType)",
    "source_code": "\tpublic <T> T unwrap(MessageSourceResolvable error, Class<T> sourceType) {\n\t\treturn (T) this.sourceLookup.apply(error, sourceType);\n\t}"
  },
  "org.springframework.validation.support.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 43
    },
    "return": "Object",
    "signature": "public Object put(String key, @Nullable Object value)",
    "source_code": "\tpublic Object put(String key, @Nullable Object value) {\n\t\tremoveBindingResultIfNecessary(key, value);\n\t\treturn super.put(key, value);\n\t}"
  },
  "org.springframework.validation.support.<unknown>#putAll(String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 49
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ?> map)",
    "source_code": "\tpublic void putAll(Map<? extends String, ?> map) {\n\t\tmap.forEach(this::removeBindingResultIfNecessary);\n\t\tsuper.putAll(map);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#reject(errorCode,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "void",
    "signature": "public void reject(String errorCode, String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, String defaultMessage) {\n\t\tthis.source.reject(errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#reject(errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void reject(String errorCode, @Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\t\tthis.source.reject(errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode) {\n\t\tthis.source.rejectValue(field, errorCode);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode, String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode, String defaultMessage) {\n\t\tthis.source.rejectValue(field, errorCode, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.<unknown>#rejectValue(field,errorCode,errorArgs,defaultMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "field",
      "errorCode",
      "errorArgs",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage)",
    "source_code": "\tpublic void rejectValue(@Nullable String field, String errorCode,\n\t\t\t@Nullable Object[] errorArgs, @Nullable String defaultMessage) {\n\n\t\tthis.source.rejectValue(field, errorCode, errorArgs, defaultMessage);\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\tif (KotlinDetector.isKotlinType(declaringClass)) {\n\t\t\tReflectionUtils.doWithMethods(declaringClass, m -> hints.registerMethod(m, ExecutableMode.INVOKE),\n\t\t\t\t\tm -> m.getName().equals(method.getName() + \"$default\"));\n\t\t}\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerParameterTypeHints(hints,methodParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "void",
    "signature": "protected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter)",
    "source_code": "\tprotected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter) {\n\t\tif (methodParameter.hasParameterAnnotation(RequestBody.class) ||\n\t\t\t\tmethodParameter.hasParameterAnnotation(ModelAttribute.class) ||\n\t\t\t\tmethodParameter.hasParameterAnnotation(RequestPart.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t}\n\t\telse if (HttpEntity.class.isAssignableFrom(methodParameter.getParameterType())) {\n\t\t\tType httpEntityType = getHttpEntityType(methodParameter);\n\t\t\tif (httpEntityType != null) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, httpEntityType);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Class<?> type) {\n\t\t\tregisterTypeHints(hints, type);\n\t\t}\n\t\telse if (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (AnnotatedElementUtils.hasAnnotation(returnTypeParameter.getContainingClass(), ResponseBody.class) ||\n\t\t\t\treturnTypeParameter.hasMethodAnnotation(ResponseBody.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t\telse if (HttpEntity.class.isAssignableFrom(returnTypeParameter.getParameterType())) {\n\t\t\tType httpEntityType = getHttpEntityType(returnTypeParameter);\n\t\t\tif (httpEntityType != null) {\n\t\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, httpEntityType);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.annotation.<unknown>#registerTypeHints(hints,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "protected void registerTypeHints(ReflectionHints hints, Class<?> type)",
    "source_code": "\tprotected void registerTypeHints(ReflectionHints hints, Class<?> type) {\n\t\thints.registerType(type);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#addBindValue(Map<String,params,key,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "params",
      "key",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "protected void addBindValue(Map<String, Object> params, String key, List<?> values)",
    "source_code": "\tprotected static void addBindValue(Map<String, Object> params, String key, List<?> values) {\n\t\tif (!CollectionUtils.isEmpty(values)) {\n\t\t\tif (values.size() == 1) {\n\t\t\t\tparams.put(key, adaptBindValue(values.get(0)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparams.put(key, values.stream().map(WebExchangeDataBinder::adaptBindValue).toList());\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#createBinder(webRequest,target,objectName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a new {@link WebDataBinder} for the given target object and\n\t * initialize it through a {@link WebBindingInitializer}.\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName)",
    "source_code": "\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, null);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#createBinder(webRequest,target,objectName,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>By default, if the parameter has {@code @Valid}, Bean Validation is\n\t * excluded, deferring to method validation.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "target",
      "objectName",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 83
    },
    "return": "WebDataBinder",
    "signature": "public WebDataBinder createBinder(NativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type)",
    "source_code": "\tpublic final WebDataBinder createBinder(\n\t\t\tNativeWebRequest webRequest, @Nullable Object target, String objectName,\n\t\t\tResolvableType type) throws Exception {\n\n\t\treturn createBinderInternal(webRequest, target, objectName, type);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#createBinderInstance(target,objectName,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to create the WebDataBinder instance.\n\t * By default, this is {@code WebRequestDataBinder}.\n\t * @param target the binding target or {@code null} for type conversion only\n\t * @param objectName the binding target object name\n\t * @param webRequest the current request\n\t * @throws Exception in case of invalid state or arguments\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "target",
      "objectName",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 124
    },
    "return": "WebDataBinder",
    "signature": "protected WebDataBinder createBinderInstance(@Nullable Object target, String objectName, NativeWebRequest webRequest)",
    "source_code": "\tprotected WebDataBinder createBinderInstance(\n\t\t\t@Nullable Object target, String objectName, NativeWebRequest webRequest) throws Exception {\n\n\t\treturn new WebRequestDataBinder(target, objectName);\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#initBinder(binder,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 149
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.bind.support.<unknown>#initBinder(dataBinder,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extension point to further initialize the created data binder instance\n\t * (for example, with {@code @InitBinder} methods) after \"global\" initialization\n\t * via {@link WebBindingInitializer}.\n\t * @param dataBinder the data binder instance to customize\n\t * @param webRequest the current request\n\t * @throws Exception if initialization fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "dataBinder",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 138
    },
    "return": "void",
    "signature": "protected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)",
    "source_code": "\tprotected void initBinder(WebDataBinder dataBinder, NativeWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t}"
  },
  "org.springframework.web.bind.support.<unknown>#resolveValue(name,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 172
    },
    "return": "Object",
    "signature": "public Object resolveValue(String name, Class<?> type)",
    "source_code": "\t\tpublic Object resolveValue(String name, Class<?> type) {\n\t\t\treturn this.map.get(name);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attribute(String name, Object value)",
    "source_code": "\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tgetAttributes().put(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#attributes(Consumer<Map<String,attributesConsumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<Map<String",
      "attributesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 432
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer)",
    "source_code": "\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(getAttributes());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#body(body,bodyType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 460
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\t\tpublic <T> RequestBodySpec body(T body, ParameterizedTypeReference<T> bodyType) {\n\t\t\tthis.body = clientHttpRequest -> writeWithMessageConverters(body, bodyType.getType(), clientHttpRequest);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#cookie(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 390
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookie(String name, String value)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#cookies(Consumer<MultiValueMap<String,cookiesConsumer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Consumer<MultiValueMap<String",
      "cookiesConsumer"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#create(message,statusCode,statusText,headers,body,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #create(HttpStatusCode, String, HttpHeaders, byte[], Charset)}\n\t * with an optional prepared message.\n\t * @since 5.2.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(@Nullable String message, HttpStatusCode statusCode,\n\t\t\tString statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\tif (statusCode instanceof HttpStatus status) {\n\t\t\treturn switch (status) {\n\t\t\t\tcase BAD_REQUEST -> message != null ?\n\t\t\t\t\t\tnew BadRequest(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew BadRequest(statusText, headers, body, charset);\n\t\t\t\tcase UNAUTHORIZED -> message != null ?\n\t\t\t\t\t\tnew Unauthorized(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Unauthorized(statusText, headers, body, charset);\n\t\t\t\tcase FORBIDDEN -> message != null ?\n\t\t\t\t\t\tnew Forbidden(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Forbidden(statusText, headers, body, charset);\n\t\t\t\tcase NOT_FOUND -> message != null ?\n\t\t\t\t\t\tnew NotFound(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotFound(statusText, headers, body, charset);\n\t\t\t\tcase METHOD_NOT_ALLOWED -> message != null ?\n\t\t\t\t\t\tnew MethodNotAllowed(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew MethodNotAllowed(statusText, headers, body, charset);\n\t\t\t\tcase NOT_ACCEPTABLE -> message != null ?\n\t\t\t\t\t\tnew NotAcceptable(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew NotAcceptable(statusText, headers, body, charset);\n\t\t\t\tcase CONFLICT -> message != null ?\n\t\t\t\t\t\tnew Conflict(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Conflict(statusText, headers, body, charset);\n\t\t\t\tcase GONE -> message != null ?\n\t\t\t\t\t\tnew Gone(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew Gone(statusText, headers, body, charset);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE -> message != null ?\n\t\t\t\t\t\tnew UnsupportedMediaType(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnsupportedMediaType(statusText, headers, body, charset);\n\t\t\t\tcase TOO_MANY_REQUESTS -> message != null ?\n\t\t\t\t\t\tnew TooManyRequests(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew TooManyRequests(statusText, headers, body, charset);\n\t\t\t\tcase UNPROCESSABLE_ENTITY -> message != null ?\n\t\t\t\t\t\tnew UnprocessableEntity(message, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew UnprocessableEntity(statusText, headers, body, charset);\n\t\t\t\tdefault -> message != null ?\n\t\t\t\t\t\tnew HttpClientErrorException(message, statusCode, statusText, headers, body, charset) :\n\t\t\t\t\t\tnew HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t\t};\n\t\t}\n\t\tif (message != null) {\n\t\t\treturn new HttpClientErrorException(message, statusCode, statusText, headers, body, charset);\n\t\t}\n\t\telse {\n\t\t\treturn new HttpClientErrorException(statusCode, statusText, headers, body, charset);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code HttpClientErrorException} or an HTTP status specific subclass.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "HttpClientErrorException",
    "signature": "public HttpClientErrorException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static HttpClientErrorException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(null, statusCode, statusText, headers, body, charset);\n\t}"
  },
  "org.springframework.web.client.<unknown>#delete(url,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void delete(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic void delete(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\texecute(url, HttpMethod.DELETE, null, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#delete(url,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "void",
    "signature": "public void delete(String url, Object... uriVariables)",
    "source_code": "\tpublic void delete(String url, Object... uriVariables) throws RestClientException {\n\t\texecute(url, HttpMethod.DELETE, null, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#doExecute(url,method,requestCallback,responseExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t * @deprecated in favor of {@link #doExecute(URI, String, HttpMethod, RequestCallback, ResponseExtractor)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\treturn doExecute(url, null, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#doExecute(url,uriTemplate,method,requestCallback,responseExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Execute the given method on the provided URI.\n\t * <p>The {@link ClientHttpRequest} is processed using the {@link RequestCallback};\n\t * the response with the {@link ResponseExtractor}.\n\t * @param url the fully-expanded URL to connect to\n\t * @param uriTemplate the URI template that was used for creating the expanded URL\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param requestCallback object that prepares the request (can be {@code null})\n\t * @param responseExtractor object that extracts the return value from the response (can be {@code null})\n\t * @return an arbitrary object, as returned by the {@link ResponseExtractor}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 877
    },
    "return": "T",
    "signature": "protected T doExecute(URI url, @Nullable String uriTemplate, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tprotected <T> T doExecute(URI url, @Nullable String uriTemplate, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\tAssert.notNull(url, \"url is required\");\n\t\tAssert.notNull(method, \"HttpMethod is required\");\n\t\tClientHttpRequest request;\n\t\ttry {\n\t\t\trequest = createRequest(url, method);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow createResourceAccessException(url, method, ex);\n\t\t}\n\n\t\tClientRequestObservationContext observationContext = new ClientRequestObservationContext(request);\n\t\tobservationContext.setUriTemplate(uriTemplate);\n\t\tObservation observation = ClientHttpObservationDocumentation.HTTP_CLIENT_EXCHANGES.observation(\n\t\t\t\tthis.observationConvention, DEFAULT_OBSERVATION_CONVENTION,\n\t\t\t\t() -> observationContext, this.observationRegistry).start();\n\t\tClientHttpResponse response = null;\n\t\ttry (Observation.Scope scope = observation.openScope()){\n\t\t\tif (requestCallback != null) {\n\t\t\t\trequestCallback.doWithRequest(request);\n\t\t\t}\n\t\t\tresponse = request.execute();\n\t\t\tobservationContext.setResponse(response);\n\t\t\thandleResponse(url, method, response);\n\t\t\treturn (responseExtractor != null ? responseExtractor.extractData(response) : null);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tResourceAccessException accessEx = createResourceAccessException(url, method, ex);\n\t\t\tobservation.error(accessEx);\n\t\t\tthrow accessEx;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tobservation.error(ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tif (response != null) {\n\t\t\t\tresponse.close();\n\t\t\t}\n\t\t\tobservation.stop();\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(entity,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "entity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 745
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(RequestEntity<?> entity, ParameterizedTypeReference<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(entity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(doExecute(resolveUrl(entity), resolveUriTemplate(entity), entity.getMethod(), requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(exchangeFunction,close)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchangeFunction",
      "close"
    ],
    "position": {
      "column": 1,
      "line": 531
    },
    "return": "T",
    "signature": "public T exchange(ExchangeFunction<T> exchangeFunction, boolean close)",
    "source_code": "\t\tpublic <T> T exchange(ExchangeFunction<T> exchangeFunction, boolean close) {\n\t\t\treturn exchangeInternal(exchangeFunction, close);\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 726
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(URI url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 716
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#exchange(url,method,requestEntity,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestEntity",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 706
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity,\n\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException {\n\n\t\tType type = responseType.getType();\n\t\tRequestCallback requestCallback = httpEntityCallback(requestEntity, type);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(type);\n\t\treturn nonNull(execute(url, method, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(uriTemplate,method,requestCallback,responseExtractor,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 817
    },
    "return": "T",
    "signature": "public T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tURI url = getUriTemplateHandler().expand(uriTemplate, uriVariables);\n\t\treturn doExecute(url, uriTemplate, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(uriTemplate,method,requestCallback,responseExtractor,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "method",
      "requestCallback",
      "responseExtractor",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 797
    },
    "return": "T",
    "signature": "public T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables)",
    "source_code": "\tpublic <T> T execute(String uriTemplate, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {\n\n\t\tURI url = getUriTemplateHandler().expand(uriTemplate, uriVariables);\n\t\treturn doExecute(url, uriTemplate, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#execute(url,method,requestCallback,responseExtractor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p>To provide a {@code RequestCallback} or {@code ResponseExtractor} only,\n\t * but not both, consider using:\n\t * <ul>\n\t * <li>{@link #acceptHeaderRequestCallback(Class)}\n\t * <li>{@link #httpEntityCallback(Object)}\n\t * <li>{@link #httpEntityCallback(Object, Type)}\n\t * <li>{@link #responseEntityExtractor(Type)}\n\t * </ul>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "method",
      "requestCallback",
      "responseExtractor"
    ],
    "position": {
      "column": 1,
      "line": 838
    },
    "return": "T",
    "signature": "public T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor)",
    "source_code": "\tpublic <T> T execute(URI url, HttpMethod method, @Nullable RequestCallback requestCallback,\n\t\t\t@Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {\n\n\t\treturn doExecute(url, null, method, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 455
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(URI url, Class<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 446
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForEntity(url,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "T",
    "signature": "public T getForObject(URI url, Class<T> responseType)",
    "source_code": "\tpublic <T> T getForObject(URI url, Class<T> responseType) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 420
    },
    "return": "T",
    "signature": "public T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#getForObject(url,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "T",
    "signature": "public T getForObject(String url, Class<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n\t\tRequestCallback requestCallback = acceptHeaderRequestCallback(responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#handleResponse(url,method,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the given response, performing appropriate logging and\n\t * invoking the {@link ResponseErrorHandler} if necessary.\n\t * <p>Can be overridden in subclasses.\n\t * @param url the fully-expanded URL to connect to\n\t * @param method the HTTP method to execute (GET, POST, etc.)\n\t * @param response the resulting {@link ClientHttpResponse}\n\t * @throws IOException if propagated from {@link ResponseErrorHandler}\n\t * @since 4.1.6\n\t * @see #setErrorHandler\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "url",
      "method",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 940
    },
    "return": "void",
    "signature": "protected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response)",
    "source_code": "\tprotected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n\t\tResponseErrorHandler errorHandler = getErrorHandler();\n\t\tboolean hasError = errorHandler.hasError(response);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\ttry {\n\t\t\t\tHttpStatusCode statusCode = response.getStatusCode();\n\t\t\t\tlogger.debug(\"Response \" + statusCode);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tlogger.debug(\"Failed to obtain response status code\", ex);\n\t\t\t}\n\t\t}\n\t\tif (hasError) {\n\t\t\terrorHandler.handleError(url, method, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#headForHeaders(url,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 470
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic HttpHeaders headForHeaders(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\treturn nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#headForHeaders(url,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 465
    },
    "return": "HttpHeaders",
    "signature": "public HttpHeaders headForHeaders(String url, Object... uriVariables)",
    "source_code": "\tpublic HttpHeaders headForHeaders(String url, Object... uriVariables) throws RestClientException {\n\t\treturn nonNull(execute(url, HttpMethod.HEAD, null, headersExtractor(), uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#header(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "DefaultRequestBodyUriSpec",
    "signature": "public DefaultRequestBodyUriSpec header(String headerName, String... headerValues)",
    "source_code": "\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#httpEntityCallback(requestBody,responseType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestCallback} implementation that:\n\t * <ol>\n\t * <li>Sets the request {@code Accept} header based on the given response\n\t * type, cross-checked against the configured message converters.\n\t * <li>Writes the given object to the request stream.\n\t * </ol>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestBody",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 982
    },
    "return": "RequestCallback",
    "signature": "public RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType)",
    "source_code": "\tpublic <T> RequestCallback httpEntityCallback(@Nullable Object requestBody, Type responseType) {\n\t\treturn new HttpEntityRequestCallback(requestBody, responseType);\n\t}"
  },
  "org.springframework.web.client.<unknown>#onStatus(statusPredicate,errorHandler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 717
    },
    "return": "ResponseSpec",
    "signature": "public ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler)",
    "source_code": "\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusPredicate, ErrorHandler errorHandler) {\n\t\t\tAssert.notNull(statusPredicate, \"StatusPredicate must not be null\");\n\t\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\n\t\t\treturn onStatusInternal(StatusHandler.of(statusPredicate, errorHandler));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Map<String, ?> uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#optionsForAllow(url,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "Set<HttpMethod>",
    "signature": "public Set<HttpMethod> optionsForAllow(String url, Object... uriVariables)",
    "source_code": "\tpublic Set<HttpMethod> optionsForAllow(String url, Object... uriVariables) throws RestClientException {\n\t\tResponseExtractor<HttpHeaders> headersExtractor = headersExtractor();\n\t\tHttpHeaders headers = execute(url, HttpMethod.OPTIONS, null, headersExtractor, uriVariables);\n\t\treturn (headers != null ? headers.getAllow() : Collections.emptySet());\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 622
    },
    "return": "T",
    "signature": "public T patchForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T patchForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "T",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#patchForObject(url,request,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 600
    },
    "return": "T",
    "signature": "public T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables)",
    "source_code": "\tpublic <T> T patchForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.PATCH, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Map<String, ?> uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForEntity(url,request,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 544
    },
    "return": "ResponseEntity<T>",
    "signature": "public ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Object... uriVariables)",
    "source_code": "\tpublic <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request,\n\t\t\tClass<T> responseType, Object... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tResponseExtractor<ResponseEntity<T>> responseExtractor = responseEntityExtractor(responseType);\n\t\treturn nonNull(execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 504
    },
    "return": "URI",
    "signature": "public URI postForLocation(URI url, @Nullable Object request)",
    "source_code": "\tpublic URI postForLocation(URI url, @Nullable Object request) throws RestClientException {\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor());\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 494
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForLocation(url,request,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 484
    },
    "return": "URI",
    "signature": "public URI postForLocation(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic URI postForLocation(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\tHttpHeaders headers = execute(url, HttpMethod.POST, requestCallback, headersExtractor(), uriVariables);\n\t\treturn (headers != null ? headers.getLocation() : null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType"
    ],
    "position": {
      "column": 1,
      "line": 534
    },
    "return": "T",
    "signature": "public T postForObject(URI url, @Nullable Object request, Class<T> responseType)",
    "source_code": "\tpublic <T> T postForObject(URI url, @Nullable Object request, Class<T> responseType)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters());\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "T",
    "signature": "public T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables)",
    "source_code": "\tpublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tMap<String, ?> uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#postForObject(url,request,responseType,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "responseType",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "T",
    "signature": "public T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables)",
    "source_code": "\tpublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n\t\t\tObject... uriVariables) throws RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request, responseType);\n\t\tHttpMessageConverterExtractor<T> responseExtractor =\n\t\t\t\tnew HttpMessageConverterExtractor<>(responseType, getMessageConverters(), logger);\n\t\treturn execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 590
    },
    "return": "void",
    "signature": "public void put(URI url, @Nullable Object request)",
    "source_code": "\tpublic void put(URI url, @Nullable Object request) throws RestClientException {\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 582
    },
    "return": "void",
    "signature": "public void put(String url, @Nullable Object request, Map<String, ?> uriVariables)",
    "source_code": "\tpublic void put(String url, @Nullable Object request, Map<String, ?> uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#put(url,request,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "request",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 574
    },
    "return": "void",
    "signature": "public void put(String url, @Nullable Object request, Object... uriVariables)",
    "source_code": "\tpublic void put(String url, @Nullable Object request, Object... uriVariables)\n\t\t\tthrows RestClientException {\n\n\t\tRequestCallback requestCallback = httpEntityCallback(request);\n\t\texecute(url, HttpMethod.PUT, requestCallback, null, uriVariables);\n\t}"
  },
  "org.springframework.web.client.<unknown>#setDefaultUriVariables(Map<String,uriVars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure default URI variable values. This is a shortcut for:\n\t * <pre class=\"code\">\n\t * DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory();\n\t * handler.setDefaultUriVariables(...);\n\t *\n\t * RestTemplate restTemplate = new RestTemplate();\n\t * restTemplate.setUriTemplateHandler(handler);\n\t * </pre>\n\t * @param uriVars the default URI variable values\n\t * @since 4.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "void",
    "signature": "public void setDefaultUriVariables(Map<String, ?> uriVars)",
    "source_code": "\tpublic void setDefaultUriVariables(Map<String, ?> uriVars) {\n\t\tif (this.uriTemplateHandler instanceof DefaultUriBuilderFactory factory) {\n\t\t\tfactory.setDefaultUriVariables(uriVars);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"This property is not supported with the configured UriTemplateHandler.\");\n\t\t}\n\t}"
  },
  "org.springframework.web.client.<unknown>#uri(Function<UriBuilder,uriFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 333
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.builder()));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Function<UriBuilder,uriFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Function<UriBuilder",
      "uriFunction"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriFunction.apply(DefaultRestClient.this.uriBuilderFactory.uriString(uriTemplate)));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.client.<unknown>#uri(uriTemplate,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriTemplate",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "RequestBodySpec",
    "signature": "public RequestBodySpec uri(String uriTemplate, Object... uriVariables)",
    "source_code": "\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(DefaultRestClient.this.uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}"
  },
  "org.springframework.web.context.<unknown>#configureAndRefreshWebApplicationContext(wac,sc)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "wac",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 364
    },
    "return": "void",
    "signature": "protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc)",
    "source_code": "\tprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n\t\t\tif (idParam != null) {\n\t\t\t\twac.setId(idParam);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Generate default id...\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\tObjectUtils.getDisplayString(sc.getContextPath()));\n\t\t\t}\n\t\t}\n\n\t\twac.setServletContext(sc);\n\t\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n\t\tif (configLocationParam != null) {\n\t\t\twac.setConfigLocation(configLocationParam);\n\t\t}\n\n\t\t// The wac environment's #initPropertySources will be called in any case when the context\n\t\t// is refreshed; do it eagerly here to ensure servlet property sources are in place for\n\t\t// use in any post-processing or initialization that occurs below prior to #refresh\n\t\tConfigurableEnvironment env = wac.getEnvironment();\n\t\tif (env instanceof ConfigurableWebEnvironment cwe) {\n\t\t\tcwe.initPropertySources(sc, null);\n\t\t}\n\n\t\tcustomizeContext(sc, wac);\n\t\twac.refresh();\n\t}"
  },
  "org.springframework.web.context.<unknown>#customizeContext(sc,wac)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the {@link ConfigurableWebApplicationContext} created by this\n\t * ContextLoader after config locations have been supplied to the context\n\t * but before the context is <em>refreshed</em>.\n\t * <p>The default implementation {@linkplain #determineContextInitializerClasses(ServletContext)\n\t * determines} what (if any) context initializer classes have been specified through\n\t * {@linkplain #CONTEXT_INITIALIZER_CLASSES_PARAM context init parameters} and\n\t * {@linkplain ApplicationContextInitializer#initialize invokes each} with the\n\t * given web application context.\n\t * <p>Any {@code ApplicationContextInitializers} implementing\n\t * {@link org.springframework.core.Ordered Ordered} or marked with @{@link\n\t * org.springframework.core.annotation.Order Order} will be sorted appropriately.\n\t * @param sc the current servlet context\n\t * @param wac the newly created application context\n\t * @see #CONTEXT_INITIALIZER_CLASSES_PARAM\n\t * @see ApplicationContextInitializer#initialize(ConfigurableApplicationContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "sc",
      "wac"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "void",
    "signature": "protected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac)",
    "source_code": "\tprotected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {\n\t\tList<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> initializerClasses =\n\t\t\t\tdetermineContextInitializerClasses(sc);\n\n\t\tfor (Class<ApplicationContextInitializer<ConfigurableApplicationContext>> initializerClass : initializerClasses) {\n\t\t\tClass<?> initializerContextClass =\n\t\t\t\t\tGenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);\n\t\t\tif (initializerContextClass != null && !initializerContextClass.isInstance(wac)) {\n\t\t\t\tthrow new ApplicationContextException(String.format(\n\t\t\t\t\t\t\"Could not apply context initializer [%s] since its generic parameter [%s] \" +\n\t\t\t\t\t\t\"is not assignable from the type of application context used by this \" +\n\t\t\t\t\t\t\"context loader: [%s]\", initializerClass.getName(), initializerContextClass.getName(),\n\t\t\t\t\t\twac.getClass().getName()));\n\t\t\t}\n\t\t\tthis.contextInitializers.add(BeanUtils.instantiateClass(initializerClass));\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(this.contextInitializers);\n\t\tfor (ApplicationContextInitializer<ConfigurableApplicationContext> initializer : this.contextInitializers) {\n\t\t\tinitializer.initialize(wac);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.<unknown>#getAttribute(name,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "Object",
    "signature": "public Object getAttribute(String name, int scope)",
    "source_code": "\tpublic Object getAttribute(String name, int scope) {\n\t\treturn getAttributeMap(scope).get(name);\n\t}"
  },
  "org.springframework.web.context.request.<unknown>#registerDestructionCallback(name,callback,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "callback",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void registerDestructionCallback(String name, Runnable callback, int scope)",
    "source_code": "\tpublic void registerDestructionCallback(String name, Runnable callback, int scope) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Could not register destruction callback [\" + callback + \"] for attribute '\" + name +\n\t\t\t\t\t\"' because FacesRequestAttributes does not support such callbacks\");\n\t\t}\n\t}"
  },
  "org.springframework.web.context.request.<unknown>#removeAttribute(name,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void removeAttribute(String name, int scope)",
    "source_code": "\tpublic void removeAttribute(String name, int scope) {\n\t\tgetAttributeMap(scope).remove(name);\n\t}"
  },
  "org.springframework.web.context.request.<unknown>#setAttribute(name,value,scope)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value",
      "scope"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value, int scope)",
    "source_code": "\tpublic void setAttribute(String name, Object value, int scope) {\n\t\tgetAttributeMap(scope).put(name, value);\n\t}"
  },
  "org.springframework.web.context.request.async.<unknown>#createAsyncWebRequest(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create an AsyncWebRequest instance. By default, an instance of\n\t * {@link StandardServletAsyncWebRequest} gets created.\n\t * @param request the current request\n\t * @param response the current response\n\t * @return an AsyncWebRequest instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "AsyncWebRequest",
    "signature": "public AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic static AsyncWebRequest createAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) {\n\t\tAsyncWebRequest prev = getAsyncManager(request).getAsyncWebRequest();\n\t\treturn (prev instanceof StandardServletAsyncWebRequest standardRequest ?\n\t\t\t\tnew StandardServletAsyncWebRequest(request, response, standardRequest) :\n\t\t\t\tnew StandardServletAsyncWebRequest(request, response));\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#doFindPathMatchingFileResources(rootDirResource,subPattern)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden version which checks for ServletContextResource\n\t * and uses {@code ServletContext.getResourcePaths} to find\n\t * matching resources below the web application root directory.\n\t * In case of other resources, delegates to the superclass version.\n\t * @see #doRetrieveMatchingServletContextResources\n\t * @see ServletContextResource\n\t * @see jakarta.servlet.ServletContext#getResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rootDirResource",
      "subPattern"
    ],
    "position": {
      "column": 1,
      "line": 80
    },
    "return": "Set<Resource>",
    "signature": "protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)",
    "source_code": "\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tif (rootDirResource instanceof ServletContextResource scResource) {\n\t\t\tServletContext sc = scResource.getServletContext();\n\t\t\tString fullPattern = scResource.getPath() + subPattern;\n\t\t\tSet<Resource> result = new LinkedHashSet<>(8);\n\t\t\tdoRetrieveMatchingServletContextResources(sc, fullPattern, scResource.getPath(), result);\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\treturn super.doFindPathMatchingFileResources(rootDirResource, subPattern);\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#doRetrieveMatchingServletContextResources(servletContext,fullPattern,dir,result)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Recursively retrieve ServletContextResources that match the given pattern,\n\t * adding them to the given result set.\n\t * @param servletContext the ServletContext to work on\n\t * @param fullPattern the pattern to match against,\n\t * with prepended root directory path\n\t * @param dir the current directory\n\t * @param result the Set of matching Resources to add to\n\t * @throws IOException if directory contents could not be retrieved\n\t * @see ServletContextResource\n\t * @see jakarta.servlet.ServletContext#getResourcePaths\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext",
      "fullPattern",
      "dir",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "void",
    "signature": "protected void doRetrieveMatchingServletContextResources(ServletContext servletContext, String fullPattern, String dir, Set<Resource> result)",
    "source_code": "\tprotected void doRetrieveMatchingServletContextResources(\n\t\t\tServletContext servletContext, String fullPattern, String dir, Set<Resource> result)\n\t\t\tthrows IOException {\n\n\t\tSet<String> candidates = servletContext.getResourcePaths(dir);\n\t\tif (candidates != null) {\n\t\t\tboolean dirDepthNotFixed = fullPattern.contains(\"**\");\n\t\t\tint jarFileSep = fullPattern.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t\tString jarFilePath = null;\n\t\t\tString pathInJarFile = null;\n\t\t\tif (jarFileSep > 0 && jarFileSep + ResourceUtils.JAR_URL_SEPARATOR.length() < fullPattern.length()) {\n\t\t\t\tjarFilePath = fullPattern.substring(0, jarFileSep);\n\t\t\t\tpathInJarFile = fullPattern.substring(jarFileSep + ResourceUtils.JAR_URL_SEPARATOR.length());\n\t\t\t}\n\t\t\tfor (String currPath : candidates) {\n\t\t\t\tif (!currPath.startsWith(dir)) {\n\t\t\t\t\t// Returned resource path does not start with relative directory:\n\t\t\t\t\t// assuming absolute path returned -> strip absolute path.\n\t\t\t\t\tint dirIndex = currPath.indexOf(dir);\n\t\t\t\t\tif (dirIndex != -1) {\n\t\t\t\t\t\tcurrPath = currPath.substring(dirIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currPath.endsWith(\"/\") && (dirDepthNotFixed || StringUtils.countOccurrencesOf(currPath, \"/\") <=\n\t\t\t\t\t\tStringUtils.countOccurrencesOf(fullPattern, \"/\"))) {\n\t\t\t\t\t// Search subdirectories recursively: ServletContext.getResourcePaths\n\t\t\t\t\t// only returns entries for one directory level.\n\t\t\t\t\tdoRetrieveMatchingServletContextResources(servletContext, fullPattern, currPath, result);\n\t\t\t\t}\n\t\t\t\tif (jarFilePath != null && getPathMatcher().match(jarFilePath, currPath)) {\n\t\t\t\t\t// Base pattern matches a jar file - search for matching entries within.\n\t\t\t\t\tString absoluteJarPath = servletContext.getRealPath(currPath);\n\t\t\t\t\tif (absoluteJarPath != null) {\n\t\t\t\t\t\tdoRetrieveMatchingJarEntries(absoluteJarPath, pathInJarFile, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (getPathMatcher().match(fullPattern, currPath)) {\n\t\t\t\t\tresult.add(new ServletContextResource(servletContext, currPath));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#getWebApplicationContext(sc,attrName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a custom {@code WebApplicationContext} for this web app.\n\t * @param sc the ServletContext to find the web application context for\n\t * @param attrName the name of the ServletContext attribute to look for\n\t * @return the desired WebApplicationContext for this web app, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "attrName"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName)",
    "source_code": "\tpublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n\t\tAssert.notNull(sc, \"ServletContext must not be null\");\n\t\tObject attr = sc.getAttribute(attrName);\n\t\tif (attr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (attr instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (attr instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (attr instanceof Exception exception) {\n\t\t\tthrow new IllegalStateException(exception);\n\t\t}\n\t\tif (!(attr instanceof WebApplicationContext wac)) {\n\t\t\tthrow new IllegalStateException(\"Context attribute is not of type WebApplicationContext: \" + attr);\n\t\t}\n\t\treturn wac;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(propertySources,servletContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenient variant of {@link #initServletPropertySources(MutablePropertySources,\n\t * ServletContext, ServletConfig)} that always provides {@code null} for the\n\t * {@link ServletConfig} parameter.\n\t * @see #initServletPropertySources(MutablePropertySources, ServletContext, ServletConfig)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "propertySources",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources propertySources, ServletContext servletContext) {\n\t\tinitServletPropertySources(propertySources, servletContext, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#initServletPropertySources(sources,servletContext,servletConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace {@code Servlet}-based {@link StubPropertySource stub property sources} with\n\t * actual instances populated with the given {@code servletContext} and\n\t * {@code servletConfig} objects.\n\t * <p>This method is idempotent with respect to the fact it may be called any number\n\t * of times but will perform replacement of stub property sources with their\n\t * corresponding actual property sources once and only once.\n\t * @param sources the {@link MutablePropertySources} to initialize (must not\n\t * be {@code null})\n\t * @param servletContext the current {@link ServletContext} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONTEXT_PROPERTY_SOURCE_NAME\n\t * servlet context property source} has already been initialized)\n\t * @param servletConfig the current {@link ServletConfig} (ignored if {@code null}\n\t * or if the {@link StandardServletEnvironment#SERVLET_CONFIG_PROPERTY_SOURCE_NAME\n\t * servlet config property source} has already been initialized)\n\t * @see org.springframework.core.env.PropertySource.StubPropertySource\n\t * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sources",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "void",
    "signature": "public void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void initServletPropertySources(MutablePropertySources sources,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tAssert.notNull(sources, \"'propertySources' must not be null\");\n\t\tString name = StandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAME;\n\t\tif (servletContext != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletContextPropertySource(name, servletContext));\n\t\t}\n\t\tname = StandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAME;\n\t\tif (servletConfig != null && sources.get(name) instanceof StubPropertySource) {\n\t\t\tsources.replace(name, new ServletConfigPropertySource(name, servletConfig));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (getServletContext() != null && bean instanceof ServletContextAware servletContextAware) {\n\t\t\tservletContextAware.setServletContext(getServletContext());\n\t\t}\n\t\tif (getServletConfig() != null && bean instanceof ServletConfigAware servletConfigAware) {\n\t\t\tservletConfigAware.setServletConfig(getServletConfig());\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,sc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf, @Nullable ServletContext sc) {\n\t\tregisterEnvironmentBeans(bf, sc, null);\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerEnvironmentBeans(bf,servletContext,servletConfig)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific environment beans (\"contextParameters\", \"contextAttributes\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param bf the BeanFactory to configure\n\t * @param servletContext the ServletContext that we're running within\n\t * @param servletConfig the ServletConfig\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bf",
      "servletContext",
      "servletConfig"
    ],
    "position": {
      "column": 1,
      "line": 221
    },
    "return": "void",
    "signature": "public void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig)",
    "source_code": "\tpublic static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,\n\t\t\t@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {\n\n\t\tif (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);\n\t\t}\n\n\t\tif (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {\n\t\t\tbf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME)) {\n\t\t\tMap<String, String> parameterMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletContext.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletContext.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (servletConfig != null) {\n\t\t\t\tEnumeration<?> paramNameEnum = servletConfig.getInitParameterNames();\n\t\t\t\twhile (paramNameEnum.hasMoreElements()) {\n\t\t\t\t\tString paramName = (String) paramNameEnum.nextElement();\n\t\t\t\t\tparameterMap.put(paramName, servletConfig.getInitParameter(paramName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(parameterMap));\n\t\t}\n\n\t\tif (!bf.containsBean(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME)) {\n\t\t\tMap<String, Object> attributeMap = new HashMap<>();\n\t\t\tif (servletContext != null) {\n\t\t\t\tEnumeration<?> attrNameEnum = servletContext.getAttributeNames();\n\t\t\t\twhile (attrNameEnum.hasMoreElements()) {\n\t\t\t\t\tString attrName = (String) attrNameEnum.nextElement();\n\t\t\t\t\tattributeMap.put(attrName, servletContext.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,\n\t\t\t\t\tCollections.unmodifiableMap(attributeMap));\n\t\t}\n\t}"
  },
  "org.springframework.web.context.support.<unknown>#registerWebApplicationScopes(beanFactory,sc)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register web-specific scopes (\"request\", \"session\", \"globalSession\", \"application\")\n\t * with the given BeanFactory, as used by the WebApplicationContext.\n\t * @param beanFactory the BeanFactory to configure\n\t * @param sc the ServletContext that we're running within\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanFactory",
      "sc"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "void",
    "signature": "public void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc)",
    "source_code": "\tpublic static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,\n\t\t\t@Nullable ServletContext sc) {\n\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());\n\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope());\n\t\tif (sc != null) {\n\t\t\tServletContextScope appScope = new ServletContextScope(sc);\n\t\t\tbeanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);\n\t\t\t// Register as ServletContext attribute, for ContextCleanupListener to detect it.\n\t\t\tsc.setAttribute(ServletContextScope.class.getName(), appScope);\n\t\t}\n\n\t\tbeanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());\n\t\tbeanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());\n\t\tif (jsfPresent) {\n\t\t\tFacesDependencyRegistrar.registerFacesDependencies(beanFactory);\n\t\t}\n\t}"
  },
  "org.springframework.web.filter.<unknown>#doFilter(request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This {@code doFilter} implementation stores a request attribute for\n\t * \"already filtered\", proceeding without filtering again if the\n\t * attribute is already there.\n\t * @see #getAlreadyFilteredAttributeName\n\t * @see #shouldNotFilter\n\t * @see #doFilterInternal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (!((request instanceof HttpServletRequest httpRequest) && (response instanceof HttpServletResponse httpResponse))) {\n\t\t\tthrow new ServletException(\"OncePerRequestFilter only supports HTTP requests\");\n\t\t}\n\n\t\tString alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();\n\t\tboolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null;\n\n\t\tif (skipDispatch(httpRequest) || shouldNotFilter(httpRequest)) {\n\t\t\t// Proceed without invoking this filter...\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t\telse if (hasAlreadyFilteredAttribute) {\n\t\t\tif (DispatcherType.ERROR.equals(request.getDispatcherType())) {\n\t\t\t\tdoFilterNestedErrorDispatch(httpRequest, httpResponse, filterChain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Proceed without invoking this filter...\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t\telse {\n\t\t\t// Do invoke this filter...\n\t\t\trequest.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);\n\t\t\ttry {\n\t\t\t\tdoFilterInternal(httpRequest, httpResponse, filterChain);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t// Remove the \"already filtered\" request attribute for this request.\n\t\t\t\trequest.removeAttribute(alreadyFilteredAttributeName);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.filter.<unknown>#doFilterInternal(request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@code doFilter}, but guaranteed to be\n\t * just invoked once per request within a single request thread.\n\t * See {@link #shouldNotFilterAsyncDispatch()} for details.\n\t * <p>Provides HttpServletRequest and HttpServletResponse arguments instead of the\n\t * default ServletRequest and ServletResponse ones.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected abstract void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException;\n\n\t/**\n\t * Typically an ERROR dispatch happens after the REQUEST dispatch completes,\n\t * and the filter chain starts anew. On some servers however the ERROR\n\t * dispatch may be nested within the REQUEST dispatch, for example, as a result of\n\t * calling {@code sendError} on the response. In that case we are still in"
  },
  "org.springframework.web.filter.<unknown>#doFilterNestedErrorDispatch(request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Typically an ERROR dispatch happens after the REQUEST dispatch completes,\n\t * and the filter chain starts anew. On some servers however the ERROR\n\t * dispatch may be nested within the REQUEST dispatch, for example, as a result of\n\t * calling {@code sendError} on the response. In that case we are still in\n\t * the filter chain, on the same thread, but the request and response have\n\t * been switched to the original, unwrapped ones.\n\t * <p>Sub-classes may use this method to filter such nested ERROR dispatches\n\t * and re-apply wrapping on the request or response. {@code ThreadLocal}\n\t * context, if any, should still be active as we are still nested within\n\t * the filter chain.\n\t * @since 5.1.9\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 245
    },
    "return": "void",
    "signature": "protected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)",
    "source_code": "\tprotected void doFilterNestedErrorDispatch(HttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain) throws ServletException, IOException {\n\n\t\tfilterChain.doFilter(request, response);\n\t}"
  },
  "org.springframework.web.filter.<unknown>#invokeDelegate(delegate,request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually invoke the delegate Filter with the given request and response.\n\t * @param delegate the delegate Filter\n\t * @param request the current HTTP request\n\t * @param response the current HTTP response\n\t * @param filterChain the current FilterChain\n\t * @throws ServletException if thrown by the Filter\n\t * @throws IOException if thrown by the Filter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "delegate",
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "void",
    "signature": "protected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void invokeDelegate(\n\t\t\tFilter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tdelegate.doFilter(request, response, filterChain);\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#callNextHandlerInChain(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 133
    },
    "return": "void",
    "signature": "protected void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tprotected final void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler) {\n\n\t\tNavigationHandler decoratedNavigationHandler = getDecoratedNavigationHandler();\n\n\t\tif (decoratedNavigationHandler instanceof DecoratingNavigationHandler decHandler) {\n\t\t\t// DecoratingNavigationHandler specified through constructor argument:\n\t\t\t// Call it with original NavigationHandler passed in.\n\t\t\tdecHandler.handleNavigation(facesContext, fromAction, outcome, originalNavigationHandler);\n\t\t}\n\t\telse if (decoratedNavigationHandler != null) {\n\t\t\t// Standard NavigationHandler specified through constructor argument:\n\t\t\t// Call it through standard API, without original NavigationHandler passed in.\n\t\t\t// The called handler will not be able to redirect to the original handler.\n\t\t\tdecoratedNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t\telse if (originalNavigationHandler != null) {\n\t\t\t// No NavigationHandler specified through constructor argument:\n\t\t\t// Call original handler, marking the end of this chain.\n\t\t\toriginalNavigationHandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#handleNavigation(facesContext,fromAction,outcome)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the navigation request implied by the specified parameters,\n\t * through delegating to the target bean in the Spring application context.\n\t * <p>The target bean needs to extend the JSF NavigationHandler class.\n\t * If it extends Spring's DecoratingNavigationHandler, the overloaded\n\t * {@code handleNavigation} method with the original NavigationHandler\n\t * as argument will be used. Else, the standard {@code handleNavigation}\n\t * method will be called.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, String fromAction, String outcome)",
    "source_code": "\tpublic void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {\n\t\tNavigationHandler handler = getDelegate(facesContext);\n\t\tif (handler instanceof DecoratingNavigationHandler decoratingNavigationHandler) {\n\t\t\tdecoratingNavigationHandler.handleNavigation(\n\t\t\t\t\tfacesContext, fromAction, outcome, this.originalNavigationHandler);\n\t\t}\n\t\telse {\n\t\t\thandler.handleNavigation(facesContext, fromAction, outcome);\n\t\t}\n\t}"
  },
  "org.springframework.web.jsf.<unknown>#handleNavigation(facesContext,fromAction,outcome,originalNavigationHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Special {@code handleNavigation} variant with explicit NavigationHandler\n\t * argument. Either called directly, by code with an explicit original handler,\n\t * or called from the standard {@code handleNavigation} method, as\n\t * plain JSF-defined NavigationHandler.\n\t * <p>Implementations should invoke {@code callNextHandlerInChain} to\n\t * delegate to the next handler in the chain. This will always call the most\n\t * appropriate next handler (see {@code callNextHandlerInChain} javadoc).\n\t * Alternatively, the decorated NavigationHandler or the passed-in original\n\t * NavigationHandler can also be called directly; however, this is not as\n\t * flexible in terms of reacting to potential positions in the chain.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means\n\t * @param outcome the logical outcome returned by a previous invoked application action\n\t * (which may be {@code null})\n\t * @param originalNavigationHandler the original NavigationHandler,\n\t * or {@code null} if none\n\t * @see #callNextHandlerInChain\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "facesContext",
      "fromAction",
      "outcome",
      "originalNavigationHandler"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void handleNavigation(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler)",
    "source_code": "\tpublic abstract void handleNavigation(FacesContext facesContext, @Nullable String fromAction,\n\t\t\t@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler);\n\n\n\t/**\n\t * Method to be called by subclasses when intending to delegate to the next\n\t * handler in the NavigationHandler chain. Will always call the most\n\t * appropriate next handler, either the decorated NavigationHandler passed\n\t * in as constructor argument or the original NavigationHandler as passed\n\t * into this method - according to the position of this instance in the chain.\n\t * <p>Will call the decorated NavigationHandler specified as constructor\n\t * argument, if any. In case of a DecoratingNavigationHandler as target, the\n\t * original NavigationHandler as passed into this method will be passed on to\n\t * the next element in the chain: This ensures propagation of the original\n\t * handler that the last element in the handler chain might delegate back to.\n\t * In case of a standard NavigationHandler as target, the original handler\n\t * will simply not get passed on; no delegating back to the original is\n\t * possible further down the chain in that scenario.\n\t * <p>If no decorated NavigationHandler specified as constructor argument,\n\t * this instance is the last element in the chain. Hence, this method will\n\t * call the original NavigationHandler as passed into this method. If no\n\t * original NavigationHandler has been passed in (for example if this\n\t * instance is the last element in a chain with standard NavigationHandlers\n\t * as earlier elements), this method corresponds to a no-op.\n\t * @param facesContext the current JSF context\n\t * @param fromAction the action binding expression that was evaluated to retrieve the\n\t * specified outcome, or {@code null} if the outcome was acquired by some other means"
  },
  "org.springframework.web.jsf.el.<unknown>#getFeatureDescriptors(elContext,base)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "Iterator<FeatureDescriptor>",
    "signature": "public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base)",
    "source_code": "\tpublic Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext elContext, Object base) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#getValue(elContext,base,property)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "Object",
    "signature": "public Object getValue(ELContext elContext, @Nullable Object base, Object property)",
    "source_code": "\tpublic Object getValue(ELContext elContext, @Nullable Object base, Object property) throws ELException {\n\t\tif (base != null) {\n\t\t\tif (base instanceof WebApplicationContext wac) {\n\t\t\t\tString beanName = property.toString();\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Attempting to resolve property '\" + beanName + \"' in root WebApplicationContext\");\n\t\t\t\t}\n\t\t\t\tif (wac.containsBean(beanName)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Successfully resolved property '\" + beanName + \"' in root WebApplicationContext\");\n\t\t\t\t\t}\n\t\t\t\t\telContext.setPropertyResolved(true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn wac.getBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\tthrow new ELException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mimic standard JSF/JSP behavior when base is a Map by returning null.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (WEB_APPLICATION_CONTEXT_VARIABLE_NAME.equals(property)) {\n\t\t\t\telContext.setPropertyResolved(true);\n\t\t\t\treturn getWebApplicationContext(elContext);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#isReadOnly(elContext,base,property)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "boolean",
    "signature": "public boolean isReadOnly(ELContext elContext, Object base, Object property)",
    "source_code": "\tpublic boolean isReadOnly(ELContext elContext, Object base, Object property) throws ELException {\n\t\tif (base instanceof WebApplicationContext) {\n\t\t\telContext.setPropertyResolved(true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.jsf.el.<unknown>#setValue(elContext,base,property,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "elContext",
      "base",
      "property",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void setValue(ELContext elContext, Object base, Object property, Object value)",
    "source_code": "\tpublic void setValue(ELContext elContext, Object base, Object property, Object value) throws ELException {\n\t}"
  },
  "org.springframework.web.method.<unknown>#assertTargetBean(method,targetBean,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual controller instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). {@code @Controller}'s that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "targetBean",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 368
    },
    "return": "void",
    "signature": "protected void assertTargetBean(Method method, Object targetBean, Object[] args)",
    "source_code": "\tprotected void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString text = \"The mapped handler method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual controller bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the controller requires proxying \" +\n\t\t\t\t\t\"(for example, due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(formatInvokeError(text, args));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.<unknown>#checkArguments(beanType,parameters)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "boolean",
    "signature": "public boolean checkArguments(Class<?> beanType, MethodParameter[] parameters)",
    "source_code": "\t\tpublic static boolean checkArguments(Class<?> beanType, MethodParameter[] parameters) {\n\t\t\tif (BEAN_VALIDATION_PRESENT && AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tfor (MethodParameter param : parameters) {\n\t\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(param.getParameterAnnotations());\n\t\t\t\t\tif (merged.stream().anyMatch(CONSTRAINT_PREDICATE)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tClass<?> type = param.getParameterType();\n\t\t\t\t\tif (merged.stream().anyMatch(VALID_PREDICATE) && isIndexOrKeyBasedContainer(type)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tmerged = MergedAnnotations.from(getContainerElementAnnotations(param));\n\t\t\t\t\tif (merged.stream().anyMatch(CONSTRAINT_PREDICATE.or(VALID_PREDICATE))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.<unknown>#checkReturnValue(beanType,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "beanType",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 428
    },
    "return": "boolean",
    "signature": "public boolean checkReturnValue(Class<?> beanType, Method method)",
    "source_code": "\t\tpublic static boolean checkReturnValue(Class<?> beanType, Method method) {\n\t\t\tif (BEAN_VALIDATION_PRESENT && AnnotationUtils.findAnnotation(beanType, Validated.class) == null) {\n\t\t\t\tMergedAnnotations merged = MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);\n\t\t\t\treturn merged.stream().anyMatch(CONSTRAINT_PREDICATE.or(VALID_PREDICATE));\n\t\t\t}\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.method.<unknown>#formatInvokeError(text,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "text",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "String",
    "signature": "protected String formatInvokeError(String text, Object[] args)",
    "source_code": "\tprotected String formatInvokeError(String text, Object[] args) {\n\t\tString formattedArgs = IntStream.range(0, args.length)\n\t\t\t\t.mapToObj(i -> (args[i] != null ?\n\t\t\t\t\t\t\"[\" + i + \"] [type=\" + args[i].getClass().getName() + \"] [value=\" + args[i] + \"]\" :\n\t\t\t\t\t\t\"[\" + i + \"] [null]\"))\n\t\t\t\t.collect(Collectors.joining(\",\\n\", \" \", \" \"));\n\t\treturn text + \"\\n\" +\n\t\t\t\t\"Controller [\" + getBeanType().getName() + \"]\\n\" +\n\t\t\t\t\"Method [\" + getBridgedMethod().toGenericString() + \"] \" +\n\t\t\t\t\"with argument values:\\n\" + formattedArgs;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#applyArgumentValidation(target,method,parameters,arguments,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void applyArgumentValidation(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic void applyArgumentValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateArguments(target, method, parameters, arguments, groups);\n\t\tif (!result.hasErrors()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!result.getBeanResults().isEmpty()) {\n\t\t\tint bindingResultCount = 0;\n\t\t\tfor (ParameterErrors errors : result.getBeanResults()) {\n\t\t\t\tfor (Object arg : arguments) {\n\t\t\t\t\tif (arg instanceof BindingResult bindingResult) {\n\t\t\t\t\t\tif (bindingResult.getObjectName().equals(errors.getObjectName())) {\n\t\t\t\t\t\t\tbindingResult.addAllErrors(errors);\n\t\t\t\t\t\t\tbindingResultCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.getParameterValidationResults().size() == bindingResultCount) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new HandlerMethodValidationException(\n\t\t\t\tresult, this.modelAttributePredicate, this.requestParamPredicate);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#applyReturnValueValidation(target,method,returnType,returnValue,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void applyReturnValueValidation(Object target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic void applyReturnValueValidation(\n\t\t\tObject target, Method method, @Nullable MethodParameter returnType,\n\t\t\t@Nullable Object returnValue, Class<?>[] groups) {\n\n\t\tMethodValidationResult result = validateReturnValue(target, method, returnType, returnValue, groups);\n\t\tif (result.hasErrors()) {\n\t\t\tthrow new HandlerMethodValidationException(result);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#compare(o1,o2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "o1",
      "o2"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "int",
    "signature": "public int compare(ExceptionMapping o1, ExceptionMapping o2)",
    "source_code": "\t\tpublic int compare(ExceptionMapping o1, ExceptionMapping o2) {\n\t\t\tint result = this.exceptionDepthComparator.compare(o1.exceptionType(), o2.exceptionType());\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif(o1.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(o2.mediaType.equals(this.mediaType)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (o1.mediaType.equals(o2.mediaType)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (o1.mediaType.isMoreSpecific(o2.mediaType)) ? -1 : 1;\n\t\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 225
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, @Nullable Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tClass<?> paramType = parameter.getNestedParameterType();\n\t\tif (Map.class.isAssignableFrom(paramType) || MultipartFile.class == paramType || Part.class == paramType) {\n\t\t\treturn;\n\t\t}\n\n\t\tRequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);\n\t\tString name = (requestParam != null && StringUtils.hasLength(requestParam.name()) ?\n\t\t\t\trequestParam.name() : parameter.getParameterName());\n\t\tAssert.state(name != null, \"Unresolvable parameter name\");\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tif (value instanceof Optional<?> optional) {\n\t\t\tvalue = optional.orElse(null);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tif (requestParam != null &&\n\t\t\t\t\t(!requestParam.required() || !requestParam.defaultValue().equals(ValueConstants.DEFAULT_NONE))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuilder.queryParam(name);\n\t\t}\n\t\telse if (value instanceof Collection<?> elements) {\n\t\t\tfor (Object element : elements) {\n\t\t\t\telement = formatUriValue(conversionService, TypeDescriptor.nested(parameter, 1), element);\n\t\t\t\tbuilder.queryParam(name, element);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbuilder.queryParam(name, formatUriValue(conversionService, new TypeDescriptor(parameter), value));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#formatUriValue(cs,sourceType,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value)",
    "source_code": "\tprotected String formatUriValue(\n\t\t\t@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, @Nullable Object value) {\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if (value instanceof String string) {\n\t\t\treturn string;\n\t\t}\n\t\telse if (cs != null) {\n\t\t\treturn (String) cs.convert(value, sourceType, STRING_TYPE_DESCRIPTOR);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#from(initializer,paramNameDiscoverer,modelAttributePredicate,requestParamPredicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Static factory method to create a {@link HandlerMethodValidator} when Bean\n\t * Validation is enabled for use via {@link ConfigurableWebBindingInitializer},\n\t * for example in Spring MVC or WebFlux config.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "initializer",
      "paramNameDiscoverer",
      "modelAttributePredicate",
      "requestParamPredicate"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "MethodValidator",
    "signature": "public MethodValidator from(@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttributePredicate, Predicate<MethodParameter> requestParamPredicate)",
    "source_code": "\tpublic static MethodValidator from(\n\t\t\t@Nullable WebBindingInitializer initializer, @Nullable ParameterNameDiscoverer paramNameDiscoverer,\n\t\t\tPredicate<MethodParameter> modelAttributePredicate, Predicate<MethodParameter> requestParamPredicate) {\n\n\t\tif (initializer instanceof ConfigurableWebBindingInitializer configurableInitializer) {\n\t\t\tValidator validator = getValidator(configurableInitializer);\n\t\t\tif (validator != null) {\n\t\t\t\tMethodValidationAdapter adapter = new MethodValidationAdapter(validator);\n\t\t\t\tadapter.setObjectNameResolver(objectNameResolver);\n\t\t\t\tif (paramNameDiscoverer != null) {\n\t\t\t\t\tadapter.setParameterNameDiscoverer(paramNameDiscoverer);\n\t\t\t\t}\n\t\t\t\tMessageCodesResolver codesResolver = configurableInitializer.getMessageCodesResolver();\n\t\t\t\tif (codesResolver != null) {\n\t\t\t\t\tadapter.setMessageCodesResolver(codesResolver);\n\t\t\t\t}\n\t\t\t\treturn new HandlerMethodValidator(adapter, modelAttributePredicate, requestParamPredicate);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValue(name,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}\n\t * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {\n\t\tthrow new ServletRequestBindingException(\"Missing argument '\" + name +\n\t\t\t\t\"' for method parameter of type \" + parameter.getNestedParameterType().getSimpleName());\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValue(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 193
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, NativeWebRequest request)\n\t\t\tthrows Exception {\n\n\t\thandleMissingValueInternal(name, parameter, request, false);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValueAfterConversion(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\n\t\thandleMissingValueInternal(name, parameter, request, true);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleMissingValueInternal(name,parameter,request,missingAfterConversion)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request",
      "missingAfterConversion"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "void",
    "signature": "protected void handleMissingValueInternal(String name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)",
    "source_code": "\tprotected void handleMissingValueInternal(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request, boolean missingAfterConversion)\n\t\t\tthrows Exception {\n\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\t\tif (MultipartResolutionDelegate.isMultipartArgument(parameter)) {\n\t\t\tif (servletRequest == null || !MultipartResolutionDelegate.isMultipartRequest(servletRequest)) {\n\t\t\t\tthrow new MultipartException(\"Current request is not a multipart request\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MissingServletRequestPartException(name);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new MissingServletRequestParameterException(name, parameter, missingAfterConversion);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleResolvedValue(arg,name,parameter,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param mavContainer the {@link ModelAndViewContainer} (may be {@code null})\n\t * @param webRequest the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 314
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest) {\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue instanceof Map map) {\n\t\t\tmavContainer.addAllAttributes(map);\n\t\t}\n\t\telse if (returnValue != null) {\n\t\t\t// should not happen\n\t\t\tthrow new UnsupportedOperationException(\"Unexpected return type [\" +\n\t\t\t\t\treturnType.getParameterType().getName() + \"] in method: \" + returnType.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#isHandlerSessionAttribute(attributeName,attributeType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Whether the attribute name or type match the names and types specified\n\t * via {@code @SessionAttributes} on the underlying controller.\n\t * <p>Attributes successfully resolved through this method are \"remembered\"\n\t * and subsequently used in {@link #retrieveAttributes(WebRequest)} and\n\t * {@link #cleanupAttributes(WebRequest)}.\n\t * @param attributeName the attribute name to check\n\t * @param attributeType the type for the attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeType"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "boolean",
    "signature": "public boolean isHandlerSessionAttribute(String attributeName, Class<?> attributeType)",
    "source_code": "\tpublic boolean isHandlerSessionAttribute(String attributeName, Class<?> attributeType) {\n\t\tAssert.notNull(attributeName, \"Attribute name must not be null\");\n\t\tif (this.attributeTypes.contains(attributeType)) {\n\t\t\tthis.knownAttributeNames.add(attributeName);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn this.attributeNames.contains(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tAssert.state(mavContainer != null, \"ModelAndViewContainer is required for model exposure\");\n\t\treturn mavContainer.getModel();\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveExceptionMapping(exception,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given Throwable for the requested {@link MediaType}.\n\t * <p>Uses {@link ExceptionDepthComparator} and {@link MediaType#isMoreSpecific(MimeType)}\n\t * if more than one match is found.\n\t * @param exception the exception\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exception",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 192
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMapping(Throwable exception, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = resolveExceptionMappingByExceptionType(exception.getClass(), mediaType);\n\t\tif (mappingInfo == null) {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tif (cause != null) {\n\t\t\t\tmappingInfo = resolveExceptionMapping(cause, mediaType);\n\t\t\t}\n\t\t}\n\t\treturn mappingInfo;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveExceptionMappingByExceptionType(exceptionType,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find a {@link Method} to handle the given exception type and media type.\n\t * This can be useful if an {@link Exception} instance is not available (for example, for tools).\n\t * @param exceptionType the exception type\n\t * @param mediaType the media type requested by the HTTP client\n\t * @return a Method to handle the exception, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exceptionType",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "ExceptionHandlerMappingInfo",
    "signature": "public ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType)",
    "source_code": "\tpublic ExceptionHandlerMappingInfo resolveExceptionMappingByExceptionType(Class<? extends Throwable> exceptionType, MediaType mediaType) {\n\t\tExceptionHandlerMappingInfo mappingInfo = this.lookupCache.get(new ExceptionMapping(exceptionType, mediaType));\n\t\treturn (mappingInfo != NO_MATCHING_EXCEPTION_HANDLER ? mappingInfo : null);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveName(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 162
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tHttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);\n\n\t\tif (servletRequest != null) {\n\t\t\tObject mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);\n\t\t\tif (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {\n\t\t\t\treturn mpArg;\n\t\t\t}\n\t\t}\n\n\t\tObject arg = null;\n\t\tMultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);\n\t\tif (multipartRequest != null) {\n\t\t\tList<MultipartFile> files = multipartRequest.getFiles(name);\n\t\t\tif (!files.isEmpty()) {\n\t\t\t\targ = (files.size() == 1 ? files.get(0) : files);\n\t\t\t}\n\t\t}\n\t\tif (arg == null) {\n\t\t\tString[] paramValues = request.getParameterValues(name);\n\t\t\tif (paramValues == null) {\n\t\t\t\tparamValues = request.getParameterValues(name + \"[]\");\n\t\t\t}\n\t\t\tif (paramValues != null) {\n\t\t\t\targ = (paramValues.length == 1 ? paramValues[0] : paramValues);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#resolveName(param,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "String",
    "signature": "public String resolveName(MethodParameter param, @Nullable Object value)",
    "source_code": "\t\tpublic String resolveName(MethodParameter param, @Nullable Object value) {\n\t\t\tif (param.hasParameterAnnotation(RequestBody.class) || param.hasParameterAnnotation(RequestPart.class)) {\n\t\t\t\treturn Conventions.getVariableNameForParameter(param);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (param.getParameterIndex() != -1 ?\n\t\t\t\t\t\tModelFactory.getNameForParameter(param) :\n\t\t\t\t\t\tModelFactory.getNameForReturnValue(value, param));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#storeAttributes(request,Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Store a subset of the given attributes in the session. Attributes not\n\t * declared as session attributes via {@code @SessionAttributes} are ignored.\n\t * @param request the current request\n\t * @param attributes candidate attributes for session storage\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void storeAttributes(WebRequest request, Map<String, ?> attributes)",
    "source_code": "\tpublic void storeAttributes(WebRequest request, Map<String, ?> attributes) {\n\t\tattributes.forEach((name, value) -> {\n\t\t\tif (value != null && isHandlerSessionAttribute(name, value.getClass())) {\n\t\t\t\tthis.sessionAttributeStore.storeAttribute(request, name, value);\n\t\t\t}\n\t\t});\n\n\t\t// Store known attribute names in session (for distributed sessions)\n\t\t// Only necessary for type-based attributes which get added to knownAttributeNames when touched.\n\t\tif (!this.attributeTypes.isEmpty()) {\n\t\t\tthis.sessionAttributeStore.storeAttribute(request,\n\t\t\t\t\tSESSION_KNOWN_ATTRIBUTE, StringUtils.toStringArray(this.knownAttributeNames));\n\t\t}\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateArguments(target,method,parameters,arguments,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "parameters",
      "arguments",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateArguments(Object target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateArguments(\n\t\t\tObject target, Method method, @Nullable MethodParameter[] parameters,\n\t\t\tObject[] arguments, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateArguments(target, method, parameters, arguments, groups);\n\t}"
  },
  "org.springframework.web.method.annotation.<unknown>#validateReturnValue(target,method,returnType,returnValue,groups)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "target",
      "method",
      "returnType",
      "returnValue",
      "groups"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "MethodValidationResult",
    "signature": "public MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups)",
    "source_code": "\tpublic MethodValidationResult validateReturnValue(Object target, Method method,\n\t\t\t@Nullable MethodParameter returnType, @Nullable Object returnValue, Class<?>[] groups) {\n\n\t\treturn this.validationAdapter.validateReturnValue(target, method, returnType, returnValue, groups);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAllAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all attributes to the underlying model.\n\t * A shortcut for {@code getModel().addAllAttributes(Map)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 295
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().addAllAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#addAttribute(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the supplied attribute to the underlying model.\n\t * A shortcut for {@code getModel().addAttribute(String, Object)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer addAttribute(String name, @Nullable Object value)",
    "source_code": "\tpublic ModelAndViewContainer addAttribute(String name, @Nullable Object value) {\n\t\tgetModel().addAttribute(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded method that uses the ConversionService created at construction.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 144
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value, UriComponentsBuilder builder,\n\t\t\tMap<String, Object> uriVariables)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value, UriComponentsBuilder builder,\n\t\t\tMap<String, Object> uriVariables) {\n\n\t\tcontributeMethodArgument(parameter, value, builder, uriVariables, this.conversionService);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tfor (Object contributor : this.contributors) {\n\t\t\tif (contributor instanceof UriComponentsContributor ucc) {\n\t\t\t\tif (ucc.supportsParameter(parameter)) {\n\t\t\t\t\tucc.contributeMethodArgument(parameter, value, builder, uriVariables, conversionService);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (contributor instanceof HandlerMethodArgumentResolver resolver) {\n\t\t\t\tif (resolver.supportsParameter(parameter)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#getMethodArgumentValues(request,mavContainer,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the method argument values for the current request, checking the provided\n\t * argument values and falling back to the configured argument resolvers.\n\t * <p>The resulting array will be passed into {@link #doInvoke}.\n\t * @since 5.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "Object[]",
    "signature": "protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) {\n\t\t\treturn EMPTY_ARGS;\n\t\t}\n\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) {\n\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n\t\t\t}\n\t\t\ttry {\n\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tString exMsg = ex.getMessage();\n\t\t\t\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#invokeForRequest(request,mavContainer,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method after resolving its argument values in the context of the given request.\n\t * <p>Argument values are commonly resolved through\n\t * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution. Examples of provided argument values include a\n\t * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.\n\t * Provided argument values are checked before argument resolvers.\n\t * <p>Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the\n\t * resolved arguments.\n\t * @param request the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @throws Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t * @see #getMethodArgumentValues\n\t * @see #doInvoke\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 175
    },
    "return": "Object",
    "signature": "public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Arguments: \" + Arrays.toString(args));\n\t\t}\n\n\t\tif (shouldValidateArguments() && this.methodValidator != null) {\n\t\t\tthis.methodValidator.applyArgumentValidation(\n\t\t\t\t\tgetBean(), getBridgedMethod(), getMethodParameters(), args, this.validationGroups);\n\t\t}\n\n\t\tObject returnValue = doInvoke(args);\n\n\t\tif (shouldValidateReturnValue() && this.methodValidator != null) {\n\t\t\tthis.methodValidator.applyReturnValueValidation(\n\t\t\t\t\tgetBean(), getBridgedMethod(), getReturnType(), returnValue, this.validationGroups);\n\t\t}\n\n\t\treturn returnValue;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#invokeFunction(method,target,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {\n\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t// For property accessors\n\t\t\tif (function == null) {\n\t\t\t\treturn method.invoke(target, args);\n\t\t\t}\n\t\t\tif (!KCallablesJvm.isAccessible(function)) {\n\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t}\n\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\tint index = 0;\n\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\tcase VALUE, EXTENSION_RECEIVER -> {\n\t\t\t\t\t\tObject arg = args[index];\n\t\t\t\t\t\tif (!(parameter.isOptional() && arg == null)) {\n\t\t\t\t\t\t\tKType type = parameter.getType();\n\t\t\t\t\t\t\tif (!(type.isMarkedNullable() && arg == null) && type.getClassifier() instanceof KClass<?> kClass\n\t\t\t\t\t\t\t\t\t&& KotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {\n\t\t\t\t\t\t\t\tKFunction<?> constructor = KClasses.getPrimaryConstructor(kClass);\n\t\t\t\t\t\t\t\tif (!KCallablesJvm.isAccessible(constructor)) {\n\t\t\t\t\t\t\t\t\tKCallablesJvm.setAccessible(constructor, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\targ = constructor.call(arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targMap.put(parameter, arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject result = function.callBy(argMap);\n\t\t\tif (result != null && KotlinDetector.isInlineClass(result.getClass())) {\n\t\t\t\treturn result.getClass().getDeclaredMethod(\"unbox-impl\").invoke(result);\n\t\t\t}\n\t\t\treturn (result == Unit.INSTANCE ? null : result);\n\t\t}"
  },
  "org.springframework.web.method.support.<unknown>#invokeSuspendingFunction(method,target,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the given Kotlin coroutine suspended function.\n\t * <p>The default implementation invokes\n\t * {@link CoroutinesUtils#invokeSuspendingFunction(Method, Object, Object...)},\n\t * but subclasses can override this method to use\n\t * {@link CoroutinesUtils#invokeSuspendingFunction(kotlin.coroutines.CoroutineContext, Method, Object, Object...)}\n\t * instead.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "target",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "Object",
    "signature": "protected Object invokeSuspendingFunction(Method method, Object target, Object[] args)",
    "source_code": "\tprotected Object invokeSuspendingFunction(Method method, Object target, Object[] args) {\n\t\treturn CoroutinesUtils.invokeSuspendingFunction(method, target, args);\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#mergeAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy attributes in the supplied {@code Map} with existing objects of\n\t * the same name taking precedence (i.e. not getting replaced).\n\t * A shortcut for {@code getModel().mergeAttributes(Map<String, ?>)}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tgetModel().mergeAttributes(attributes);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#removeAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Remove the given attributes from the model.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 313
    },
    "return": "ModelAndViewContainer",
    "signature": "public ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tfor (String key : attributes.keySet()) {\n\t\t\t\tgetModel().remove(key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.method.support.<unknown>#setBinding(attributeName,enabled)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register whether data binding should occur for a corresponding model attribute,\n\t * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.\n\t * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},\n\t * a hard {@link #setBindingDisabled} declaration will always override it.\n\t * @param attributeName the name of the attribute\n\t * @since 4.3.13\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "enabled"
    ],
    "position": {
      "column": 1,
      "line": 238
    },
    "return": "void",
    "signature": "public void setBinding(String attributeName, boolean enabled)",
    "source_code": "\tpublic void setBinding(String attributeName, boolean enabled) {\n\t\tif (!enabled) {\n\t\t\tthis.noBinding.add(attributeName);\n\t\t}\n\t\telse {\n\t\t\tthis.noBinding.remove(attributeName);\n\t\t}\n\t}"
  },
  "org.springframework.web.multipart.support.<unknown>#doFilterInternal(request,response,filterChain)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check for a multipart request via this filter's MultipartResolver,\n\t * and wrap the original request with a MultipartHttpServletRequest if appropriate.\n\t * <p>All later elements in the filter chain, most importantly servlets, benefit\n\t * from proper parameter extraction in the multipart case, and are able to cast to\n\t * MultipartHttpServletRequest if they need to.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "void",
    "signature": "protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)",
    "source_code": "\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tMultipartResolver multipartResolver = lookupMultipartResolver(request);\n\n\t\tHttpServletRequest processedRequest = request;\n\t\tif (multipartResolver.isMultipart(processedRequest)) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Resolving multipart request\");\n\t\t\t}\n\t\t\tprocessedRequest = multipartResolver.resolveMultipart(processedRequest);\n\t\t}\n\t\telse {\n\t\t\t// A regular request...\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Not a multipart request\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfilterChain.doFilter(processedRequest, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (processedRequest instanceof MultipartHttpServletRequest multipartRequest) {\n\t\t\t\tmultipartResolver.cleanupMultipart(multipartRequest);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#createDataBinder(exchange,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut method to create a binder without a target object.\n\t * @param exchange the current exchange\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, String name) {\n\t\treturn createDataBinder(exchange, null, name, null);\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#createDataBinder(exchange,target,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object.\n\t * @param exchange the current exchange\n\t * @param target the object to create a data binder for\n\t * @param name the name of the target object\n\t * @return the created data binder\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name) {\n\t\treturn createDataBinder(exchange, target, name, null);\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#createDataBinder(exchange,target,name,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a binder with a target object and a {@link ResolvableType targetType}.\n\t * If the target is {@code null}, then\n\t * {@link WebExchangeDataBinder#setTargetType targetType} is set.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "target",
      "name",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "WebExchangeDataBinder",
    "signature": "public WebExchangeDataBinder createDataBinder(ServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType)",
    "source_code": "\tpublic WebExchangeDataBinder createDataBinder(\n\t\t\tServerWebExchange exchange, @Nullable Object target, String name, @Nullable ResolvableType targetType) {\n\n\t\tWebExchangeDataBinder dataBinder = new ExtendedWebExchangeDataBinder(target, name);\n\t\tdataBinder.setNameResolver(new BindParamNameResolver());\n\n\t\tif (target == null && targetType != null) {\n\t\t\tdataBinder.setTargetType(targetType);\n\t\t}\n\n\t\tif (this.initializer != null) {\n\t\t\tthis.initializer.initBinder(dataBinder);\n\t\t}\n\n\t\tdataBinder = initDataBinder(dataBinder, exchange);\n\n\t\tif (this.methodValidationApplicable && targetType != null) {\n\t\t\tif (targetType.getSource() instanceof MethodParameter parameter) {\n\t\t\t\tMethodValidationInitializer.initBinder(dataBinder, parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn dataBinder;\n\t}"
  },
  "org.springframework.web.reactive.<unknown>#initBinder(binder,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 253
    },
    "return": "void",
    "signature": "public void initBinder(DataBinder binder, MethodParameter parameter)",
    "source_code": "\t\tpublic static void initBinder(DataBinder binder, MethodParameter parameter) {\n\t\t\tif (ReactiveAdapterRegistry.getSharedInstance().getAdapter(parameter.getParameterType()) == null) {\n\t\t\t\tfor (Annotation annotation : parameter.getParameterAnnotations()) {\n\t\t\t\t\tif (annotation.annotationType().getName().equals(\"jakarta.validation.Valid\")) {\n\t\t\t\t\t\tbinder.setExcludedValidators(v -> v instanceof jakarta.validation.Validator ||\n\t\t\t\t\t\t\t\tv instanceof SmartValidator sv && sv.unwrap(jakarta.validation.Validator.class) != null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.<unknown>#initDataBinder(binder,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Initialize the data binder instance for the given exchange.\n\t * @throws ServerErrorException if {@code @InitBinder} method invocation fails\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 170
    },
    "return": "WebExchangeDataBinder",
    "signature": "protected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange)",
    "source_code": "\tprotected WebExchangeDataBinder initDataBinder(WebExchangeDataBinder binder, ServerWebExchange exchange) {\n\t\treturn binder;\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(MultiValueMap<String,formData)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given {@code MultiValueMap}\n\t * as URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * <p>Note that you can also use the {@code bodyValue(Object)} method in the\n\t * request builders of both the {@code WebClient} and {@code WebTestClient}.\n\t * In that case the setting of the request content type is also not required,\n\t * just be sure the map contains String values only or otherwise it would be\n\t * interpreted as a multipart request.\n\t * @param formData the form data to write to the output message\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "formData"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(MultiValueMap<String, String> formData)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(MultiValueMap<String, String> formData) {\n\t\treturn new DefaultFormInserter().with(formData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromFormData(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link FormInserter} to write the given key-value pair as\n\t * URL-encoded form data. The returned inserter allows for additional\n\t * entries to be added via {@link FormInserter#with(String, Object)}.\n\t * @param name the key to add to the form\n\t * @param value the value to add to the form\n\t * @return the inserter that allows adding more form data\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "FormInserter<String>",
    "signature": "public FormInserter<String> fromFormData(String name, String value)",
    "source_code": "\tpublic static FormInserter<String> fromFormData(String name, String value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultFormInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartAsyncData(name,publisher,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given asynchronous parts,\n\t * as multipart data.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param elementClass the class contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, elementClass);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartAsyncData(name,publisher,typeReference)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #fromMultipartAsyncData(String, Publisher, Class)} that\n\t * accepts a {@link ParameterizedTypeReference} for the element type, which\n\t * allows specifying generic type information.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param publisher the publisher that forms the part value\n\t * @param typeReference the type contained in the {@code publisher}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 372
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartAsyncData(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> MultipartInserter fromMultipartAsyncData(\n\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\treturn new DefaultMultipartInserter().withPublisher(name, publisher, typeReference);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartData(MultiValueMap<String,multipartData)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given\n\t * {@code MultiValueMap} as multipart data. Values in the map can be an\n\t * Object or an {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param multipartData the form data to write to the output message\n\t * @return the inserter that allows adding more parts\n\t * @see MultipartBodyBuilder\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "multipartData"
    ],
    "position": {
      "column": 1,
      "line": 321
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(MultiValueMap<String, ?> multipartData) {\n\t\tAssert.notNull(multipartData, \"'multipartData' must not be null\");\n\t\treturn new DefaultMultipartInserter().withInternal(multipartData);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromMultipartData(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@link MultipartInserter} to write the given parts,\n\t * as multipart data. Values in the map can be an Object or an\n\t * {@link HttpEntity}.\n\t * <p>Note that you can also build the multipart data externally with\n\t * {@link MultipartBodyBuilder}, and pass the resulting map directly to the\n\t * {@code bodyValue(Object)} shortcut method in {@code WebClient}.\n\t * @param name the part name\n\t * @param value the part value, an Object or {@code HttpEntity}\n\t * @return the inserter that allows adding more parts\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter fromMultipartData(String name, Object value)",
    "source_code": "\tpublic static MultipartInserter fromMultipartData(String name, Object value) {\n\t\tAssert.notNull(name, \"'name' must not be null\");\n\t\tAssert.notNull(value, \"'value' must not be null\");\n\t\treturn new DefaultMultipartInserter().with(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromOutputStream(outputStreamConsumer,executor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter based on bytes written to a {@code OutputStream}.\n\t * @param outputStreamConsumer invoked with an {@link OutputStream} that\n\t * writes to the output message\n\t * @param executor used to invoke the {@code outputStreamHandler} on a\n\t * separate thread\n\t * @return an inserter that writes what is written to the output stream\n\t * @since 6.1\n\t * @see DataBufferUtils#outputStreamPublisher(Consumer, DataBufferFactory, Executor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "executor"
    ],
    "position": {
      "column": 1,
      "line": 402
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromOutputStream(Consumer<OutputStream> outputStreamConsumer, Executor executor)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromOutputStream(\n\t\t\tConsumer<OutputStream> outputStreamConsumer, Executor executor) {\n\n\t\tAssert.notNull(outputStreamConsumer, \"OutputStreamConsumer must not be null\");\n\t\tAssert.notNull(executor, \"Executor must not be null\");\n\n\t\treturn (outputMessage, context) -> outputMessage.writeWith(\n\t\t\t\tDataBufferUtils.outputStreamPublisher(outputStreamConsumer, outputMessage.bufferFactory(), executor));\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromOutputStream(outputStreamConsumer,executor,chunkSize)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter based on bytes written to a {@code OutputStream}.\n\t * @param outputStreamConsumer invoked with an {@link OutputStream} that\n\t * writes to the output message\n\t * @param executor used to invoke the {@code outputStreamHandler} on a\n\t * separate thread\n\t * @param chunkSize minimum size of the buffer produced by the publisher\n\t * @return an inserter that writes what is written to the output stream\n\t * @since 6.1\n\t * @see DataBufferUtils#outputStreamPublisher(Consumer, DataBufferFactory, Executor, int)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputStreamConsumer",
      "executor",
      "chunkSize"
    ],
    "position": {
      "column": 1,
      "line": 423
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromOutputStream(Consumer<OutputStream> outputStreamConsumer, Executor executor, int chunkSize)",
    "source_code": "\tpublic static <T extends Publisher<DataBuffer>> BodyInserter<T, ReactiveHttpOutputMessage> fromOutputStream(\n\t\t\tConsumer<OutputStream> outputStreamConsumer, Executor executor, int chunkSize) {\n\n\t\tAssert.notNull(outputStreamConsumer, \"OutputStreamConsumer must not be null\");\n\t\tAssert.notNull(executor, \"Executor must not be null\");\n\t\tAssert.isTrue(chunkSize > 0, \"Chunk size must be > 0\");\n\n\t\treturn (outputMessage, context) -> outputMessage.writeWith(\n\t\t\t\tDataBufferUtils.outputStreamPublisher(outputStreamConsumer, outputMessage.bufferFactory(), executor,\n\t\t\t\t\t\tchunkSize));\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementClass the class of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(T producer, Class<?> elementClass) {\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forClass(elementClass), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromProducer(producer,elementTypeRef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given producer of value(s) which must be a {@link Publisher}\n\t * or another producer adaptable to a {@code Publisher} via\n\t * {@link ReactiveAdapterRegistry}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param <T> the type of the body\n\t * @param producer the source of body value(s).\n\t * @param elementTypeRef the type of values to be produced\n\t * @return the inserter to write a producer\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 188
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromProducer(T producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromProducer(\n\t\t\tT producer, ParameterizedTypeReference<?> elementTypeRef) {\n\n\t\tAssert.notNull(producer, \"'producer' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(producer.getClass());\n\t\tAssert.notNull(adapter, \"'producer' type is unknown to ReactiveAdapterRegistry\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, producer, ResolvableType.forType(elementTypeRef), adapter);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromPublisher(publisher,elementClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementClass the class of elements in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, Class<T> elementClass) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementClass, \"'elementClass' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forClass(elementClass), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromPublisher(publisher,elementTypeRef)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given {@link Publisher}.\n\t * <p>Alternatively, consider using the {@code body} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param publisher the publisher to write with\n\t * @param elementTypeRef the type of elements contained in the publisher\n\t * @param <T> the type of the elements contained in the publisher\n\t * @param <P> the {@code Publisher} type\n\t * @return the inserter to write a {@code Publisher}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 230
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromPublisher(P publisher, ParameterizedTypeReference<T> elementTypeRef)",
    "source_code": "\tpublic static <T, P extends Publisher<T>> BodyInserter<P, ReactiveHttpOutputMessage> fromPublisher(\n\t\t\tP publisher, ParameterizedTypeReference<T> elementTypeRef) {\n\n\t\tAssert.notNull(publisher, \"'publisher' must not be null\");\n\t\tAssert.notNull(elementTypeRef, \"'elementTypeRef' must not be null\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, publisher, ResolvableType.forType(elementTypeRef.getType()), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#fromValue(body,bodyType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Inserter to write the given value.\n\t * <p>Alternatively, consider using the {@code bodyValue(Object, ParameterizedTypeReference)} shortcuts on\n\t * {@link org.springframework.web.reactive.function.client.WebClient WebClient} and\n\t * {@link org.springframework.web.reactive.function.server.ServerResponse ServerResponse}.\n\t * @param body the value to write\n\t * @param bodyType the type of the body, used to capture the generic type\n\t * @param <T> the type of the body\n\t * @return the inserter to write a single value\n\t * @throws IllegalArgumentException if {@code body} is a {@link Publisher} or an\n\t * instance of a type supported by {@link ReactiveAdapterRegistry#getSharedInstance()},\n\t * for which {@link #fromPublisher(Publisher, ParameterizedTypeReference)} or\n\t * {@link #fromProducer(Object, ParameterizedTypeReference)} should be used.\n\t * @since 6.2\n\t * @see #fromPublisher(Publisher, ParameterizedTypeReference)\n\t * @see #fromProducer(Object, ParameterizedTypeReference)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 123
    },
    "return": "ReactiveHttpOutputMessage>",
    "signature": "public ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic static <T> BodyInserter<T, ReactiveHttpOutputMessage> fromValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\tAssert.notNull(body, \"'body' must not be null\");\n\t\tAssert.notNull(bodyType, \"'bodyType' must not be null\");\n\t\tAssert.isNull(registry.getAdapter(body.getClass()),\n\t\t\t\t\"'body' should be an object, for reactive types use a variant specifying a publisher/producer and its related element type\");\n\t\treturn (message, context) ->\n\t\t\t\twriteWithMessageWriters(message, context, Mono.just(body), ResolvableType.forType(bodyType), null);\n\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#insert(outputMessage,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "outputMessage",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 626
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> insert(ClientHttpRequest outputMessage, Context context)",
    "source_code": "\t\tpublic Mono<Void> insert(ClientHttpRequest outputMessage, Context context) {\n\t\t\tHttpMessageWriter<MultiValueMap<String, HttpEntity<?>>> messageWriter =\n\t\t\t\t\tfindWriter(context, MULTIPART_DATA_TYPE, MediaType.MULTIPART_FORM_DATA);\n\t\t\tMultiValueMap<String, HttpEntity<?>> body = this.builder.build();\n\t\t\treturn messageWriter.write(Mono.just(body), MULTIPART_DATA_TYPE,\n\t\t\t\t\tMediaType.MULTIPART_FORM_DATA, outputMessage, context.hints());\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#with(MultiValueMap<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 595
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(MultiValueMap<String, Object> values)",
    "source_code": "\t\tpublic MultipartInserter with(MultiValueMap<String, Object> values) {\n\t\t\treturn withInternal(values);\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#with(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 589
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter with(String key, Object value)",
    "source_code": "\t\tpublic MultipartInserter with(String key, Object value) {\n\t\t\tthis.builder.part(key, value);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 610
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, Class<T> elementClass)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, Class<T> elementClass) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, elementClass);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.<unknown>#withPublisher(name,publisher,typeReference)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "publisher",
      "typeReference"
    ],
    "position": {
      "column": 1,
      "line": 618
    },
    "return": "MultipartInserter",
    "signature": "public MultipartInserter withPublisher(String name, P publisher, ParameterizedTypeReference<T> typeReference)",
    "source_code": "\t\tpublic <T, P extends Publisher<T>> MultipartInserter withPublisher(\n\t\t\t\tString name, P publisher, ParameterizedTypeReference<T> typeReference) {\n\n\t\t\tthis.builder.asyncPart(name, publisher, typeReference);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthentication(username,password)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that applies HTTP Basic Authentication to the request\n\t * headers via {@link HttpHeaders#setBasicAuth(String)} and\n\t * {@link HttpHeaders#encodeBasicAuth(String, String, Charset)}.\n\t * @param username the username\n\t * @param password the password\n\t * @return the filter to add authentication headers with\n\t * @see HttpHeaders#encodeBasicAuth(String, String, Charset)\n\t * @see HttpHeaders#setBasicAuth(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 95
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction basicAuthentication(String username, String password)",
    "source_code": "\tpublic static ExchangeFilterFunction basicAuthentication(String username, String password) {\n\t\tString encodedCredentials = HttpHeaders.encodeBasicAuth(username, password, null);\n\t\treturn (request, next) ->\n\t\t\t\tnext.exchange(ClientRequest.from(request)\n\t\t\t\t\t\t.headers(headers -> headers.setBasicAuth(encodedCredentials))\n\t\t\t\t\t\t.build());\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#basicAuthenticationCredentials(username,password)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Return a {@literal Consumer} that stores the given username and password\n\t\t * as a request attribute of type {@code Credentials} that is in turn\n\t\t * used by {@link ExchangeFilterFunctions#basicAuthentication()}.\n\t\t * @param username the username\n\t\t * @param password the password\n\t\t * @return a consumer that can be passed into\n\t\t * {@linkplain ClientRequest.Builder#attributes(java.util.function.Consumer)}\n\t\t * @see ClientRequest.Builder#attributes(java.util.function.Consumer)\n\t\t * @see #BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "username",
      "password"
    ],
    "position": {
      "column": 1,
      "line": 163
    },
    "return": "Object>>",
    "signature": "public Object>> basicAuthenticationCredentials(String username, String password)",
    "source_code": "\t\tpublic static Consumer<Map<String, Object>> basicAuthenticationCredentials(String username, String password) {\n\t\t\tCredentials credentials = new Credentials(username, password);\n\t\t\treturn (map -> map.put(BASIC_AUTHENTICATION_CREDENTIALS_ATTRIBUTE, credentials));\n\t\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#body(BodyExtractor<T,extractor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ClientHttpResponse> extractor)",
    "source_code": "\tpublic <T> T body(BodyExtractor<T, ? super ClientHttpResponse> extractor) {\n\t\tT result = extractor.extract(this.response, this.bodyExtractorContext);\n\t\tString description = \"Body from \" + this.requestDescription + \" [DefaultClientResponse]\";\n\t\tif (result instanceof Mono<?> mono) {\n\t\t\treturn (T) mono.checkpoint(description);\n\t\t}\n\t\telse if (result instanceof Flux<?> flux) {\n\t\t\treturn (T) flux.checkpoint(description);\n\t\t}\n\t\telse {\n\t\t\treturn result;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#cookie(name,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 156
    },
    "return": "DefaultClientResponseBuilder",
    "signature": "public DefaultClientResponseBuilder cookie(String name, String... values)",
    "source_code": "\tpublic DefaultClientResponseBuilder cookie(String name, String... values) {\n\t\tfor (String value : values) {\n\t\t\tgetCookies().add(name, ResponseCookie.from(name, value).build());\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#create(statusCode,statusText,headers,body,charset)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code WebClientResponseException} or an HTTP status specific subclass.\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 294
    },
    "return": "WebClientResponseException",
    "signature": "public WebClientResponseException create(int statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset)",
    "source_code": "\tpublic static WebClientResponseException create(\n\t\t\tint statusCode, String statusText, HttpHeaders headers, byte[] body, @Nullable Charset charset) {\n\n\t\treturn create(statusCode, statusText, headers, body, charset, null);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#create(statusCode,statusText,headers,body,charset,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create {@code WebClientResponseException} or an HTTP status specific subclass.\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "statusText",
      "headers",
      "body",
      "charset",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "WebClientResponseException",
    "signature": "public WebClientResponseException create(HttpStatusCode statusCode, String statusText, HttpHeaders headers,\n\t\t\tbyte[] body, @Nullable Charset charset, @Nullable HttpRequest request)",
    "source_code": "\tpublic static WebClientResponseException create(\n\t\t\tHttpStatusCode statusCode, String statusText, HttpHeaders headers,\n\t\t\tbyte[] body, @Nullable Charset charset, @Nullable HttpRequest request) {\n\n\t\tif (statusCode instanceof HttpStatus httpStatus) {\n\t\t\treturn switch (httpStatus) {\n\t\t\t\tcase BAD_REQUEST -> new WebClientResponseException.BadRequest(statusText, headers, body, charset, request);\n\t\t\t\tcase UNAUTHORIZED -> new WebClientResponseException.Unauthorized(statusText, headers, body, charset, request);\n\t\t\t\tcase FORBIDDEN -> new WebClientResponseException.Forbidden(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_FOUND -> new WebClientResponseException.NotFound(statusText, headers, body, charset, request);\n\t\t\t\tcase METHOD_NOT_ALLOWED -> new WebClientResponseException.MethodNotAllowed(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_ACCEPTABLE -> new WebClientResponseException.NotAcceptable(statusText, headers, body, charset, request);\n\t\t\t\tcase CONFLICT -> new WebClientResponseException.Conflict(statusText, headers, body, charset, request);\n\t\t\t\tcase GONE -> new WebClientResponseException.Gone(statusText, headers, body, charset, request);\n\t\t\t\tcase UNSUPPORTED_MEDIA_TYPE -> new WebClientResponseException.UnsupportedMediaType(statusText, headers, body, charset, request);\n\t\t\t\tcase TOO_MANY_REQUESTS -> new WebClientResponseException.TooManyRequests(statusText, headers, body, charset, request);\n\t\t\t\tcase UNPROCESSABLE_ENTITY -> new WebClientResponseException.UnprocessableEntity(statusText, headers, body, charset, request);\n\t\t\t\tcase INTERNAL_SERVER_ERROR -> new WebClientResponseException.InternalServerError(statusText, headers, body, charset, request);\n\t\t\t\tcase NOT_IMPLEMENTED -> new WebClientResponseException.NotImplemented(statusText, headers, body, charset, request);\n\t\t\t\tcase BAD_GATEWAY -> new WebClientResponseException.BadGateway(statusText, headers, body, charset, request);\n\t\t\t\tcase SERVICE_UNAVAILABLE -> new WebClientResponseException.ServiceUnavailable(statusText, headers, body, charset, request);\n\t\t\t\tcase GATEWAY_TIMEOUT -> new WebClientResponseException.GatewayTimeout(statusText, headers, body, charset, request);\n\t\t\t\tdefault -> new WebClientResponseException(statusCode, statusText, headers, body, charset, request);\n\t\t\t};\n\t\t}\n\t\treturn new WebClientResponseException(statusCode, statusText, headers, body, charset, request);\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#setBodyDecodeFunction(Function<ResolvableType,decoderFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a function to find a decoder the given target type.\n\t * For use with {@link #getResponseBodyAs(Class)}.\n\t * @param decoderFunction the function to find a decoder with\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ResolvableType",
      "decoderFunction"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "public void setBodyDecodeFunction(Function<ResolvableType, ?> decoderFunction)",
    "source_code": "\tpublic void setBodyDecodeFunction(Function<ResolvableType, ?> decoderFunction) {\n\t\tthis.bodyDecodeFunction = decoderFunction;\n\t}"
  },
  "org.springframework.web.reactive.function.client.<unknown>#statusError(statusPredicate,Function<ClientResponse,exceptionFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a filter that generates an error signal when the given\n\t * {@link HttpStatusCode} predicate matches.\n\t * @param statusPredicate the predicate to check the HTTP status with\n\t * @param exceptionFunction the function to create the exception\n\t * @return the filter to generate an error signal\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusPredicate",
      "Function<ClientResponse",
      "exceptionFunction"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "ExchangeFilterFunction",
    "signature": "public ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction)",
    "source_code": "\tpublic static ExchangeFilterFunction statusError(Predicate<HttpStatusCode> statusPredicate,\n\t\t\tFunction<ClientResponse, ? extends Throwable> exceptionFunction) {\n\n\t\tAssert.notNull(statusPredicate, \"Predicate must not be null\");\n\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\n\t\treturn ExchangeFilterFunction.ofResponseProcessor(\n\t\t\t\tresponse -> (statusPredicate.test(response.statusCode()) ?\n\t\t\t\t\t\tMono.error(exceptionFunction.apply(response)) : Mono.just(response)));\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForBodyFlux(requestValues,bodyType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "Flux<T>",
    "signature": "public Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Flux<T> exchangeForBodyFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForBodyMono(requestValues,bodyType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<T> exchangeForBodyMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().bodyToMono(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForEntityFlux(requestValues,bodyType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "Mono<ResponseEntity<Flux<T>>>",
    "signature": "public Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<Flux<T>>> exchangeForEntityFlux(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntityFlux(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.client.support.<unknown>#exchangeForEntityMono(requestValues,bodyType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestValues",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "Mono<ResponseEntity<T>>",
    "signature": "public Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ResponseEntity<T>> exchangeForEntityMono(HttpRequestValues requestValues, ParameterizedTypeReference<T> bodyType) {\n\t\treturn newRequest(requestValues).retrieve().toEntity(bodyType);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#attributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "public void attributes(Map<String, Object> attributes)",
    "source_code": "\tpublic void attributes(Map<String, Object> attributes) {\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1226
    },
    "return": "Mono<T>",
    "signature": "public Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) {\n\t\t\treturn this.delegate.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyExtractor<T,extractor)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor"
    ],
    "position": {
      "column": 1,
      "line": 1191
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {\n\t\t\treturn this.delegate.body(extractor);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyExtractor<T,extractor,Map<String,hints)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyExtractor<T",
      "extractor",
      "Map<String",
      "hints"
    ],
    "position": {
      "column": 1,
      "line": 1196
    },
    "return": "T",
    "signature": "public T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints)",
    "source_code": "\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {\n\t\t\treturn this.delegate.body(extractor, hints);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(BodyInserter<?,inserter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BodyInserter<?",
      "inserter"
    ],
    "position": {
      "column": 1,
      "line": 257
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter)",
    "source_code": "\tpublic Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter) {\n\t\treturn Mono.just(new BodyInserterResponse<>(\n\t\t\t\tthis.statusCode, this.headers, this.cookies, inserter, this.hints));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(producer,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(Object producer, Class<?> elementClass)",
    "source_code": "\tpublic Mono<ServerResponse> body(Object producer, Class<?> elementClass) {\n\t\treturn initBuilder(producer, BodyInserters.fromProducer(producer, elementClass));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(producer,elementTypeRef)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "producer",
      "elementTypeRef"
    ],
    "position": {
      "column": 1,
      "line": 242
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(Object producer, ParameterizedTypeReference<?> elementTypeRef)",
    "source_code": "\tpublic Mono<ServerResponse> body(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\treturn initBuilder(producer, BodyInserters.fromProducer(producer, elementTypeRef));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(publisher,elementClass)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "elementClass"
    ],
    "position": {
      "column": 1,
      "line": 227
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(P publisher, Class<T> elementClass)",
    "source_code": "\tpublic <T, P extends Publisher<T>> Mono<ServerResponse> body(P publisher, Class<T> elementClass) {\n\t\treturn initBuilder(publisher, BodyInserters.fromPublisher(publisher, elementClass));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#body(publisher,typeRef)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "publisher",
      "typeRef"
    ],
    "position": {
      "column": 1,
      "line": 232
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> body(P publisher, ParameterizedTypeReference<T> typeRef)",
    "source_code": "\tpublic <T, P extends Publisher<T>> Mono<ServerResponse> body(P publisher, ParameterizedTypeReference<T> typeRef) {\n\t\treturn initBuilder(publisher, BodyInserters.fromPublisher(publisher, typeRef));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#bodyValue(body,bodyType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "bodyType"
    ],
    "position": {
      "column": 1,
      "line": 222
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType)",
    "source_code": "\tpublic <T> Mono<ServerResponse> bodyValue(T body, ParameterizedTypeReference<T> bodyType) {\n\t\treturn initBuilder(body, BodyInserters.fromValue(body, bodyType));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#build(BiFunction<ServerWebExchange,ServerResponse.Context,writeFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<ServerWebExchange",
      "ServerResponse.Context",
      "writeFunction"
    ],
    "position": {
      "column": 1,
      "line": 209
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> build(BiFunction<ServerWebExchange, ServerResponse.Context, Mono<Void>> writeFunction)",
    "source_code": "\tpublic Mono<ServerResponse> build(\n\t\t\tBiFunction<ServerWebExchange, ServerResponse.Context, Mono<Void>> writeFunction) {\n\n\t\treturn Mono.just(new WriterFunctionResponse(\n\t\t\t\tthis.statusCode, this.headers, this.cookies, writeFunction));\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#checkNotModified(lastModified,etag)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified",
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1296
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> checkNotModified(Instant lastModified, String etag)",
    "source_code": "\t\tpublic Mono<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.delegate.checkNotModified(lastModified, etag);\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#modifyAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 512
    },
    "return": "void",
    "signature": "public void modifyAttributes(Map<String, Object> attributes)",
    "source_code": "\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#of(value,Consumer<Map<String,modifyAttributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "Consumer<Map<String",
      "modifyAttributes"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#queryParam(name,predicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's query parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the query parameter to test against\n\t * @param predicate the predicate to test against the query parameter value\n\t * @return a predicate that matches the given predicate against the query parameter of the given name\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 311
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, Predicate<String> predicate) {\n\t\treturn new QueryParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#queryParam(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name\n\t * has the given value.\n\t * @param name the name of the query parameter to test against\n\t * @param value the value of the query parameter to test against\n\t * @return a predicate that matches if the query parameter has the given value\n\t * @since 5.0.7\n\t * @see ServerRequest#queryParam(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 299
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate queryParam(String name, String value)",
    "source_code": "\tpublic static RequestPredicate queryParam(String name, String value) {\n\t\treturn new QueryParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#render(name,Map<String,model)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 280
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> render(String name, Map<String, ?> model)",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Map<String, ?> model) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(model)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#render(name,modelAttributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "modelAttributes"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "Mono<ServerResponse>",
    "signature": "public Mono<ServerResponse> render(String name, Object... modelAttributes)",
    "source_code": "\tpublic Mono<ServerResponse> render(String name, Object... modelAttributes) {\n\t\treturn new DefaultRenderingResponseBuilder(name)\n\t\t\t\t.status(this.statusCode)\n\t\t\t\t.headers(this.headers)\n\t\t\t\t.cookies(cookies -> cookies.addAll(this.cookies))\n\t\t\t\t.modelAttributes(modelAttributes)\n\t\t\t\t.build()\n\t\t\t\t.map(Function.identity());\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Mono<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Mono<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#route(predicate,handlerFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "handlerFunction"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction)",
    "source_code": "\tpublic void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {\n\t\tchangeParser(predicate);\n\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#writeTo(exchange,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> writeTo(ServerWebExchange exchange, Context context)",
    "source_code": "\t\tpublic final Mono<Void> writeTo(ServerWebExchange exchange, Context context) {\n\t\t\twriteStatusAndHeaders(exchange.getResponse());\n\t\t\tInstant lastModified = Instant.ofEpochMilli(headers().getLastModified());\n\t\t\tHttpMethod httpMethod = exchange.getRequest().getMethod();\n\t\t\tif (SAFE_METHODS.contains(httpMethod) && exchange.checkNotModified(headers().getETag(), lastModified)) {\n\t\t\t\treturn exchange.getResponse().setComplete();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn writeToInternal(exchange, context);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.function.server.<unknown>#writeToInternal(exchange,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "Mono<Void>",
    "signature": "protected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context)",
    "source_code": "\t\tprotected Mono<Void> writeToInternal(ServerWebExchange exchange, Context context) {\n\t\t\treturn this.inserter.insert(exchange.getResponse(), new BodyInserter.Context() {\n\t\t\t\t@Override\n\t\t\t\tpublic List<HttpMessageWriter<?>> messageWriters() {\n\t\t\t\t\treturn context.messageWriters();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Optional<ServerHttpRequest> serverRequest() {\n\t\t\t\t\treturn Optional.of(exchange.getRequest());\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Map<String, Object> hints() {\n\t\t\t\t\thints.put(Hints.LOG_PREFIX_HINT, exchange.getLogPrefix());\n\t\t\t\t\treturn hints;\n\t\t\t\t}\n\t\t\t});\n\t\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#getCorsConfiguration(handler,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the CORS configuration for the given handler.\n\t * @param handler the handler to check (never {@code null})\n\t * @param exchange the current exchange\n\t * @return the CORS configuration for the handler, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 236
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tif (handler instanceof CorsConfigurationSource ccs) {\n\t\t\treturn ccs.getCorsConfiguration(exchange);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#lookupHandler(lookupPath,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL lookup path.\n\t * <p>Supports direct matches, for example, a registered \"/test\" matches \"/test\",\n\t * and various path pattern matches, for example, a registered \"/t*\" matches\n\t * both \"/test\" and \"/team\". For details, see the PathPattern class.\n\t * @param lookupPath the URL the handler is mapped to\n\t * @param exchange the current exchange\n\t * @return the associated handler instance, or {@code null} if not found\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange)",
    "source_code": "\tprotected Object lookupHandler(PathContainer lookupPath, ServerWebExchange exchange) throws Exception {\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.handlerMap.keySet()) {\n\t\t\tif (pattern.matches(lookupPath)) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.debug(exchange.getLogPrefix() + \"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\n\t\tPathPattern pattern = matches.get(0);\n\t\tPathContainer pathWithinMapping = pattern.extractPathWithinPattern(lookupPath);\n\t\tPathPattern.PathMatchInfo matchInfo = pattern.matchAndExtract(lookupPath);\n\t\tAssert.notNull(matchInfo, \"Expected a match\");\n\n\t\tObject handler = this.handlerMap.get(pattern);\n\n\t\t// Bean name or resolved handler?\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\n\t\tif (this.handlerPredicate != null && !this.handlerPredicate.test(handler, exchange)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvalidateHandler(handler, exchange);\n\n\t\texchange.getAttributes().put(BEST_MATCHING_HANDLER_ATTRIBUTE, handler);\n\t\texchange.getAttributes().put(BEST_MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\torg.springframework.web.filter.reactive.ServerHttpObservationFilter\n\t\t\t\t.findObservationContext(exchange)\n\t\t\t\t.ifPresent(context -> context.setPathPattern(pattern.toString()));\n\t\tServerRequestObservationContext.findCurrent(exchange.getAttributes())\n\t\t\t\t.ifPresent(context -> context.setPathPattern(pattern.toString()));\n\t\texchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);\n\t\texchange.getAttributes().put(URI_TEMPLATE_VARIABLES_ATTRIBUTE, matchInfo.getUriVariables());\n\n\t\treturn handler;\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandler(urlPath,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 214
    },
    "return": "void",
    "signature": "protected void registerHandler(String urlPath, Object handler)",
    "source_code": "\tprotected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Parse path pattern\n\t\tPathPatternParser parser = getPathPatternParser();\n\t\turlPath = parser.initFullPathPattern(urlPath);\n\t\tPathPattern pattern = parser.parse(urlPath);\n\t\tif (this.handlerMap.containsKey(pattern)) {\n\t\t\tObject existingHandler = this.handlerMap.get(pattern);\n\t\t\tif (existingHandler != null && existingHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to [\" + urlPath + \"]: \" +\n\t\t\t\t\t\t\"there is already \" + getHandlerDescription(existingHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tif (obtainApplicationContext().isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = obtainApplicationContext().getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\t// Register resolved handler\n\t\tthis.handlerMap.put(pattern, resolvedHandler);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "protected void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tprotected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#registerHandlers(Map<String,urlMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\tfor (Map.Entry<String, Object> entry : urlMap.entrySet()) {\n\t\t\t\tString url = entry.getKey();\n\t\t\t\tObject handler = entry.getValue();\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t}\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setCorsConfigurations(Map<String,corsConfigurations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the \"global\" CORS configurations based on URL patterns. By default, the\n\t * first matching URL pattern is combined with handler-level CORS configuration if any.\n\t * @see #setCorsConfigurationSource(CorsConfigurationSource)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tAssert.notNull(corsConfigurations, \"corsConfigurations must not be null\");\n\t\tif (!corsConfigurations.isEmpty()) {\n\t\t\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(this.patternParser);\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tthis.corsConfigurationSource = source;\n\t\t}\n\t\telse {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setHandlerPredicate(BiPredicate<Object,handlerPredicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a predicate for extended matching of the handler that was\n\t * matched by URL path. This allows for further narrowing of the mapping by\n\t * checking additional properties of the request. If the predicate returns\n\t * \"false\", it result in a no-match, which allows another\n\t * {@link org.springframework.web.reactive.HandlerMapping} to match or\n\t * result in a 404 (NOT_FOUND) response.\n\t * @param handlerPredicate a bi-predicate to match the candidate handler\n\t * against the current exchange.\n\t * @since 5.3.5\n\t * @see org.springframework.web.reactive.socket.server.support.WebSocketUpgradeHandlerPredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiPredicate<Object",
      "handlerPredicate"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "void",
    "signature": "public void setHandlerPredicate(BiPredicate<Object, ServerWebExchange> handlerPredicate)",
    "source_code": "\tpublic void setHandlerPredicate(BiPredicate<Object, ServerWebExchange> handlerPredicate) {\n\t\tthis.handlerPredicate = (this.handlerPredicate != null ?\n\t\t\t\tthis.handlerPredicate.and(handlerPredicate) : handlerPredicate);\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#setUrlMap(Map<String,urlMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax details,\n\t * see the {@link org.springframework.web.util.pattern.PathPattern} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.reactive.handler.<unknown>#validateHandler(handler,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given handler against the current request.\n\t * <p>The default implementation is empty. Can be overridden in subclasses,\n\t * for example to enforce specific preconditions expressed in URL mappings.\n\t * @param handler the handler object to validate\n\t * @param exchange current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 189
    },
    "return": "void",
    "signature": "protected void validateHandler(@Nullable Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected void validateHandler(@Nullable Object handler, ServerWebExchange exchange) {\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#addFixedVersionStrategy(version,pathPatterns)": {
    "deprecated": false,
    "doc": "\t * will also configure automatically a {@code \"/v1.0.0/js/**\"} with {@code \"v1.0.0\"} the\n\t * {@code version} String given as an argument.\n\t * @param version a version string\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see FixedVersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns) {\n\t\tList<String> patternsList = Arrays.asList(pathPatterns);\n\t\tList<String> prefixedPatterns = new ArrayList<>(pathPatterns.length);\n\t\tString versionPrefix = \"/\" + version;\n\t\tfor (String pattern : patternsList) {\n\t\t\tprefixedPatterns.add(pattern);\n\t\t\tif (!pattern.startsWith(versionPrefix) && !patternsList.contains(versionPrefix + pattern)) {\n\t\t\t\tprefixedPatterns.add(versionPrefix + pattern);\n\t\t\t}\n\t\t}\n\t\treturn addVersionStrategy(new FixedVersionStrategy(version), StringUtils.toStringArray(prefixedPatterns));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#createRelativeResource(location,resourcePath)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a resource relative to the given {@link Resource}, also decoding\n\t * the resource path for a {@link UrlResource}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resourcePath"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "Resource",
    "signature": "public Resource createRelativeResource(Resource location, String resourcePath)",
    "source_code": "\tpublic static Resource createRelativeResource(Resource location, String resourcePath) throws IOException {\n\t\tif (!(location instanceof UrlResource)) {\n\t\t\tresourcePath = UriUtils.decode(resourcePath, StandardCharsets.UTF_8);\n\t\t}\n\t\treturn location.createRelative(resourcePath);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractLink(index,endChar,content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "endChar",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 194
    },
    "return": "int",
    "signature": "protected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractLink(int index, char endChar, String content, Set<ContentChunkInfo> result) {\n\t\t\tint start = index + 1;\n\t\t\tint end = content.indexOf(endChar, start);\n\t\t\tresult.add(new ContentChunkInfo(start, end, true));\n\t\t\treturn end + 1;\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,linksToAdd)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Invoked after a keyword match, after whitespace has been removed, and when\n\t\t * the next char is neither a single nor double quote.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content,\n\t\t\t\tSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected abstract int extractUnquotedLink(int position, String content,\n\t\t\t\tSet<ContentChunkInfo> linksToAdd);\n\n\t}\n\n\n\tprivate static class ImportLinkParser extends AbstractLinkParser {"
  },
  "org.springframework.web.reactive.resource.<unknown>#extractUnquotedLink(position,content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "position",
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 239
    },
    "return": "int",
    "signature": "protected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result)",
    "source_code": "\t\tprotected int extractUnquotedLink(int position, String content, Set<ContentChunkInfo> result) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(position - 1, ')', content, result);\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#getForUriString(uriString,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Get the public resource URL for the given URI string.\n\t * <p>The URI string is expected to be a path and if it contains a query or\n\t * fragment those will be preserved in the resulting public resource URL.\n\t * @param uriString the URI string to transform\n\t * @param exchange the current exchange\n\t * @return the resolved public resource URL path, or empty if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriString",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 125
    },
    "return": "Mono<String>",
    "signature": "public Mono<String> getForUriString(String uriString, ServerWebExchange exchange)",
    "source_code": "\tpublic final Mono<String> getForUriString(String uriString, ServerWebExchange exchange) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tint queryIndex = getQueryIndex(uriString);\n\t\tString lookupPath = uriString.substring(0, queryIndex);\n\t\tString query = uriString.substring(queryIndex);\n\t\tPathContainer parsedLookupPath = PathContainer.parsePath(lookupPath);\n\n\t\treturn resolveResourceUrl(exchange, parsedLookupPath).map(resolvedPath ->\n\t\t\t\trequest.getPath().contextPath().value() + resolvedPath + query);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#isResourceUnderLocation(location,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the resource is under the given location.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 229
    },
    "return": "boolean",
    "signature": "public boolean isResourceUnderLocation(Resource location, Resource resource)",
    "source_code": "\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#parse(content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, '\\'', content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, '\"', content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractUnquotedLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#registerExtension(coding,extension)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#registerHandlers(Map<String,handlerMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure resource handler mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. If this property is used,\n\t * auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void registerHandlers(Map<String, ResourceWebHandler> handlerMap)",
    "source_code": "\tpublic void registerHandlers(Map<String, ResourceWebHandler> handlerMap) {\n\t\tthis.handlerMap.clear();\n\t\thandlerMap.forEach((rawPattern, resourceWebHandler) -> {\n\t\t\tPathPatternParser parser = PathPatternParser.defaultInstance;\n\t\t\trawPattern = parser.initFullPathPattern(rawPattern);\n\t\t\tPathPattern pattern = parser.parse(rawPattern);\n\t\t\tthis.handlerMap.put(pattern, resourceWebHandler);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveResourceInternal(exchange,requestPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "Mono<Resource>",
    "signature": "protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,\n\t\t\tString requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveResource(exchange, requestPath, locations)\n\t\t\t\t.switchIfEmpty(Mono.defer(() ->\n\t\t\t\t\t\tresolveVersionedResource(exchange, requestPath, locations, chain)));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "Mono<String>",
    "signature": "protected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Mono<String> resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\treturn chain.resolveUrlPath(resourceUrlPath, locations)\n\t\t\t\t.flatMap(baseUrl -> {\n\t\t\t\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\t\t\t\tVersionStrategy strategy = getStrategyForPath(resourceUrlPath);\n\t\t\t\t\t\tif (strategy == null) {\n\t\t\t\t\t\t\treturn Mono.just(baseUrl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chain.resolveResource(null, baseUrl, locations)\n\t\t\t\t\t\t\t\t.flatMap(resource -> strategy.getResourceVersion(resource)\n\t\t\t\t\t\t\t\t\t\t.map(version -> strategy.addVersion(baseUrl, version)));\n\t\t\t\t\t}\n\t\t\t\t\treturn Mono.empty();\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setEtagGenerator(Function<Resource,etagGenerator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServerWebExchange#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Resource",
      "etagGenerator"
    ],
    "position": {
      "column": 1,
      "line": 290
    },
    "return": "void",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setExtensions(Map<String,extensions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setHeaders(exchange,resource,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set headers on the response. Called for both GET and HEAD requests.\n\t * @param exchange current exchange\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "exchange",
      "resource",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 553
    },
    "return": "void",
    "signature": "protected void setHeaders(ServerWebExchange exchange, Resource resource, @Nullable MediaType mediaType)",
    "source_code": "\tprotected void setHeaders(ServerWebExchange exchange, Resource resource, @Nullable MediaType mediaType)\n\t\t\tthrows IOException {\n\n\t\tHttpHeaders headers = exchange.getResponse().getHeaders();\n\n\t\tlong length = resource.contentLength();\n\t\theaders.setContentLength(length);\n\n\t\tif (mediaType != null) {\n\t\t\theaders.setContentType(mediaType);\n\t\t}\n\n\t\tif (resource instanceof HttpResource httpResource) {\n\t\t\texchange.getResponse().getHeaders().putAll(httpResource.getResponseHeaders());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setMediaTypes(Map<String,mediaTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mappings between file extensions extracted from the filename of static\n\t * {@link Resource}s and the media types to use for the response.\n\t * <p>Use of this method is typically not necessary since mappings can be\n\t * also determined via {@link MediaTypeFactory#getMediaType(Resource)}.\n\t * @param mediaTypes media type mappings\n\t * @since 5.3.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "void",
    "signature": "public void setMediaTypes(Map<String, MediaType> mediaTypes)",
    "source_code": "\tpublic void setMediaTypes(Map<String, MediaType> mediaTypes) {\n\t\tif (this.mediaTypes == null) {\n\t\t\tthis.mediaTypes = new HashMap<>(mediaTypes.size());\n\t\t}\n\t\tmediaTypes.forEach((ext, type) ->\n\t\t\t\tthis.mediaTypes.put(ext.toLowerCase(Locale.ROOT), type));\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#setStrategyMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and {@code VersionStrategy} as values.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link AntPathMatcher} javadoc.\n\t * @param map a map with URLs as keys and version strategies as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setStrategyMap(Map<String, VersionStrategy> map)",
    "source_code": "\tpublic void setStrategyMap(Map<String, VersionStrategy> map) {\n\t\tthis.versionStrategyMap.clear();\n\t\tthis.versionStrategyMap.putAll(map);\n\t}"
  },
  "org.springframework.web.reactive.resource.<unknown>#transform(exchange,inputResource,transformerChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "inputResource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "Mono<Resource>",
    "signature": "public Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Mono<Resource> transform(ServerWebExchange exchange, Resource inputResource,\n\t\t\tResourceTransformerChain transformerChain) {\n\n\t\treturn transformerChain.transform(exchange, inputResource)\n\t\t\t\t.flatMap(outputResource -> {\n\t\t\t\t\tString filename = outputResource.getFilename();\n\t\t\t\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\t\t\t\tinputResource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\t\t\t\treturn Mono.just(outputResource);\n\t\t\t\t\t}\n\n\t\t\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\t\t\t\t\tFlux<DataBuffer> flux = DataBufferUtils\n\t\t\t\t\t\t\t.read(outputResource, bufferFactory, StreamUtils.BUFFER_SIZE);\n\t\t\t\t\treturn DataBufferUtils.join(flux)\n\t\t\t\t\t\t\t.flatMap(dataBuffer -> {\n\t\t\t\t\t\t\t\tString cssContent = dataBuffer.toString(DEFAULT_CHARSET);\n\t\t\t\t\t\t\t\tDataBufferUtils.release(dataBuffer);\n\t\t\t\t\t\t\t\treturn transformContent(cssContent, outputResource, transformerChain, exchange);\n\t\t\t\t\t\t\t});\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 668
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#compareTo(other,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(ServerWebExchange)} to ensure they have conditions with\n\t * content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, ServerWebExchange exchange)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, ServerWebExchange exchange) {\n\t\tint result = this.patternsCondition.compareTo(other.getPatternsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, exchange);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#createHandlerMethod(handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the HandlerMethod instance.\n\t * @param handler either a bean name or an actual handler instance\n\t * @param method the target method\n\t * @return the created HandlerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tif (handler instanceof String beanName) {\n\t\t\treturn new HandlerMethod(beanName,\n\t\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory(),\n\t\t\t\t\tobtainApplicationContext(),\n\t\t\t\t\tmethod);\n\t\t}\n\t\treturn new HandlerMethod(handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getCorsConfiguration(handler,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 405
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {\n\t\tCorsConfiguration corsConfig = super.getCorsConfiguration(handler, exchange);\n\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\tif (handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) {\n\t\t\t\treturn ALLOW_CORS_CONFIG;\n\t\t\t}\n\t\t\tCorsConfiguration methodConfig = this.mappingRegistry.getCorsConfiguration(handlerMethod);\n\t\t\tcorsConfig = (corsConfig != null ? corsConfig.combine(methodConfig) : methodConfig);\n\t\t}\n\t\treturn corsConfig;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 436
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.reactive.result.method.<unknown>#getMatchingMapping(mapping,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param exchange the current exchange\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, ServerWebExchange exchange)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, ServerWebExchange exchange);"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleMatch(mapping,handlerMethod,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a matching mapping is found.\n\t * @param mapping the matching mapping\n\t * @param handlerMethod the matching method\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "handlerMethod",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 380
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange) {\n\t\tString lookupPath = exchange.getRequest().getPath().pathWithinApplication().value();\n\t\texchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handleNoMatch(mappings,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param exchange the current exchange\n\t * @return an alternative HandlerMethod or {@code null}\n\t * @throws Exception provides details that can be translated into an error status code\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 393
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange) throws Exception {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#handlerMethodsInitialized(Map<T,handlerMethods)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after all handler methods have been detected.\n\t * @param handlerMethods a read-only map with handler methods and mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<T",
      "handlerMethods"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "void",
    "signature": "protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods)",
    "source_code": "\tprotected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#initCorsConfiguration(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the CORS configuration for the mapping.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#invoke(exchange,bindingContext,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method for the given exchange.\n\t * @param exchange the current exchange\n\t * @param bindingContext the binding context to use\n\t * @param providedArgs optional list of argument values to match by type\n\t * @return a Mono with a {@link HandlerResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "bindingContext",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 183
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> invoke(ServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs)",
    "source_code": "\tpublic Mono<HandlerResult> invoke(\n\t\t\tServerWebExchange exchange, BindingContext bindingContext, Object... providedArgs) {\n\n\t\treturn getMethodArgumentValuesOnScheduler(exchange, bindingContext, providedArgs).flatMap(args -> {\n\t\t\tif (shouldValidateArguments() && this.methodValidator != null) {\n\t\t\t\tthis.methodValidator.applyArgumentValidation(\n\t\t\t\t\t\tgetBean(), getBridgedMethod(), getMethodParameters(), args, this.validationGroups);\n\t\t\t}\n\t\t\tObject value;\n\t\t\tMethod method = getBridgedMethod();\n\t\t\tboolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method);\n\t\t\ttry {\n\t\t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n\t\t\t\t\tvalue = KotlinDelegate.invokeFunction(method, getBean(), args, isSuspendingFunction, exchange);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = method.invoke(getBean(), args);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(text, args), ex));\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\treturn Mono.error(ex.getTargetException());\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Unlikely to ever get here, but it must be handled...\n\t\t\t\treturn Mono.error(new IllegalStateException(formatInvokeError(\"Invocation failure\", args), ex));\n\t\t\t}\n\n\t\t\tHttpStatusCode status = getResponseStatus();\n\t\t\tif (status != null) {\n\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t}\n\n\t\t\tMethodParameter returnType = getReturnType();\n\t\t\tif (isResponseHandled(args, exchange)) {\n\t\t\t\tClass<?> parameterType = returnType.getParameterType();\n\t\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(parameterType);\n\t\t\t\tboolean asyncVoid = isAsyncVoidReturnType(returnType, adapter);\n\t\t\t\tif (value == null || asyncVoid) {\n\t\t\t\t\treturn (asyncVoid ? Mono.from(adapter.toPublisher(value)) : Mono.empty());\n\t\t\t\t}\n\t\t\t\tif (isSuspendingFunction && parameterType == void.class) {\n\t\t\t\t\treturn (Mono<HandlerResult>) value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tHandlerResult result = new HandlerResult(this, value, returnType, bindingContext);\n\t\t\treturn Mono.just(result);\n\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#invokeFunction(method,target,args,isSuspendingFunction,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "target",
      "args",
      "isSuspendingFunction",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 327
    },
    "return": "Object",
    "signature": "public Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,\n\t\t\t\tServerWebExchange exchange)",
    "source_code": "\t\tpublic static Object invokeFunction(Method method, Object target, Object[] args, boolean isSuspendingFunction,\n\t\t\t\tServerWebExchange exchange) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {\n\n\t\t\tif (isSuspendingFunction) {\n\t\t\t\tObject coroutineContext = exchange.getAttribute(COROUTINE_CONTEXT_ATTRIBUTE);\n\t\t\t\tif (coroutineContext == null) {\n\t\t\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(method, target, args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn CoroutinesUtils.invokeSuspendingFunction((CoroutineContext) coroutineContext, method, target, args);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\t// For property accessors\n\t\t\t\tif (function == null) {\n\t\t\t\t\treturn method.invoke(target, args);\n\t\t\t\t}\n\t\t\t\tif (!KCallablesJvm.isAccessible(function)) {\n\t\t\t\t\tKCallablesJvm.setAccessible(function, true);\n\t\t\t\t}\n\t\t\t\tMap<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\n\t\t\t\tint index = 0;\n\t\t\t\tfor (KParameter parameter : function.getParameters()) {\n\t\t\t\t\tswitch (parameter.getKind()) {\n\t\t\t\t\t\tcase INSTANCE -> argMap.put(parameter, target);\n\t\t\t\t\t\tcase VALUE, EXTENSION_RECEIVER -> {\n\t\t\t\t\t\t\tObject arg = args[index];\n\t\t\t\t\t\t\tif (!(parameter.isOptional() && arg == null)) {\n\t\t\t\t\t\t\t\tKType type = parameter.getType();\n\t\t\t\t\t\t\t\tif (!(type.isMarkedNullable() && arg == null) && type.getClassifier() instanceof KClass<?> kClass\n\t\t\t\t\t\t\t\t\t\t&& KotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {\n\t\t\t\t\t\t\t\t\tKFunction<?> constructor = KClasses.getPrimaryConstructor(kClass);\n\t\t\t\t\t\t\t\t\tif (!KCallablesJvm.isAccessible(constructor)) {\n\t\t\t\t\t\t\t\t\t\tKCallablesJvm.setAccessible(constructor, true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\targ = constructor.call(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\targMap.put(parameter, arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tObject result = function.callBy(argMap);\n\t\t\t\tif (result != null && KotlinDetector.isInlineClass(result.getClass())) {\n\t\t\t\t\treturn result.getClass().getDeclaredMethod(\"unbox-impl\").invoke(result);\n\t\t\t\t}\n\t\t\t\treturn (result == Unit.INSTANCE ? null : result);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#register(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\t// Enable method validation, if applicable\n\t\t\t\thandlerMethod = handlerMethod.createWithValidateFlags();\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tcorsConfig.validateAllowPrivateNetwork();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping. Invoked at startup for\n\t * each detected handler method.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 249
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given mapping.\n\t * <p>This method may be invoked at runtime after initialization has completed.\n\t * @param mapping the mapping for the handler method\n\t * @param handler the handler\n\t * @param method the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 132
    },
    "return": "void",
    "signature": "public void registerMapping(T mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(T mapping, Object handler, Method method) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Register \\\"\" + mapping + \"\\\" to \" + method.toGenericString());\n\t\t}\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}; if {@code null} then\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)} is used\n\t * to determine the default message code to use\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @return the created {@code ProblemDetail} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, ServerWebExchange exchange) {\n\n\t\tErrorResponse.Builder builder = ErrorResponse.builder(ex, status, defaultDetail);\n\t\tif (detailMessageCode != null) {\n\t\t\tbuilder.detailMessageCode(detailMessageCode);\n\t\t}\n\t\tif (detailMessageArguments != null) {\n\t\t\tbuilder.detailMessageArguments(detailMessageArguments);\n\t\t}\n\t\treturn builder.build().updateAndGetBody(this.messageSource, getLocale(exchange));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createRequestMappingInfo(httpExchange,customCondition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 292
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tHttpExchange httpExchange, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(toStringArray(httpExchange.value())))\n\t\t\t\t.methods(toMethodArray(httpExchange.method()))\n\t\t\t\t.consumes(toStringArray(httpExchange.contentType()))\n\t\t\t\t.produces(httpExchange.accept())\n\t\t\t\t.headers(httpExchange.headers());\n\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createRequestMappingInfo(requestMapping,customCondition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tRequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n\t\t\t\t.methods(requestMapping.method())\n\t\t\t\t.params(requestMapping.params())\n\t\t\t\t.headers(requestMapping.headers())\n\t\t\t\t.consumes(requestMapping.consumes())\n\t\t\t\t.produces(requestMapping.produces())\n\t\t\t\t.mappingName(requestMapping.name());\n\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#createResponseEntity(body,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link ResponseEntity} to use from the given body, headers,\n\t * and statusCode. Subclasses can override this method to inspect and possibly\n\t * modify the body, headers, or statusCode, for example, to re-create an instance of\n\t * {@link ProblemDetail} as an extension of {@link ProblemDetail}.\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the created {@code ResponseEntity}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 426
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> createResponseEntity(@Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> createResponseEntity(\n\t\t\t@Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn Mono.just(new ResponseEntity<>(body, headers, status));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Uses type-level and method-level {@link RequestMapping @RequestMapping}\n\t * and {@link HttpExchange @HttpExchange} annotations to create the\n\t * {@link RequestMappingInfo}.\n\t * @return the created {@code RequestMappingInfo}, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} or {@code @HttpExchange} annotation\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tif (info.getPatternsCondition().isEmptyPathMapping()) {\n\t\t\t\tinfo = info.mutate().paths(\"\", \"/\").options(this.config).build();\n\t\t\t}\n\t\t\tfor (Map.Entry<String, Predicate<Class<?>>> entry : this.pathPrefixes.entrySet()) {\n\t\t\t\tif (entry.getValue().test(handlerType)) {\n\t\t\t\t\tString prefix = entry.getKey();\n\t\t\t\t\tif (this.embeddedValueResolver != null) {\n\t\t\t\t\t\tprefix = this.embeddedValueResolver.resolveStringValue(prefix);\n\t\t\t\t\t}\n\t\t\t\t\tAssert.state(prefix != null, \"Prefix must not be null\");\n\t\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handle(exchange,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler)",
    "source_code": "\tpublic Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler) {\n\n\t\tAssert.state(this.methodResolver != null &&\n\t\t\t\tthis.modelInitializer != null && this.reactiveAdapterRegistry != null, \"Not initialized\");\n\n\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n\n\t\tInitBinderBindingContext bindingContext = new InitBinderBindingContext(\n\t\t\t\tthis.webBindingInitializer, this.methodResolver.getInitBinderMethods(handlerMethod),\n\t\t\t\tthis.methodResolver.hasMethodValidator() && handlerMethod.shouldValidateArguments(),\n\t\t\t\tthis.reactiveAdapterRegistry);\n\n\t\tInvocableHandlerMethod invocableMethod = this.methodResolver.getRequestMappingMethod(handlerMethod);\n\n\t\tDispatchExceptionHandler exceptionHandler =\n\t\t\t\t(exchange2, ex) -> handleException(exchange, ex, handlerMethod, bindingContext);\n\n\t\tMono<HandlerResult> resultMono = this.modelInitializer\n\t\t\t\t.initModel(handlerMethod, bindingContext, exchange)\n\t\t\t\t.then(Mono.defer(() -> invocableMethod.invoke(exchange, bindingContext)))\n\t\t\t\t.doOnNext(result -> result.setExceptionHandler(exceptionHandler))\n\t\t\t\t.onErrorResume(ex -> exceptionHandler.handleError(exchange, ex));\n\n\t\tScheduler optionalScheduler = this.methodResolver.getSchedulerFor(handlerMethod);\n\t\tif (optionalScheduler != null) {\n\t\t\treturn resultMono.subscribeOn(optionalScheduler);\n\t\t}\n\n\t\treturn resultMono;\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleError(exchange,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 361
    },
    "return": "Mono<HandlerResult>",
    "signature": "public Mono<HandlerResult> handleError(ServerWebExchange exchange, Throwable ex)",
    "source_code": "\tpublic Mono<HandlerResult> handleError(ServerWebExchange exchange, Throwable ex) {\n\t\treturn handleException(exchange, ex, null, null);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleErrorResponseException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link ErrorResponseException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 325
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleErrorResponseException(ErrorResponseException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleErrorResponseException(\n\t\t\tErrorResponseException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleException(ex,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "public Mono<ResponseEntity<Object>> handleException(Exception ex, ServerWebExchange exchange)",
    "source_code": "\tpublic final Mono<ResponseEntity<Object>> handleException(Exception ex, ServerWebExchange exchange) {\n\t\tif (ex instanceof MethodNotAllowedException theEx) {\n\t\t\treturn handleMethodNotAllowedException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof NotAcceptableStatusException theEx) {\n\t\t\treturn handleNotAcceptableStatusException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof UnsupportedMediaTypeStatusException theEx) {\n\t\t\treturn handleUnsupportedMediaTypeStatusException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof MissingRequestValueException theEx) {\n\t\t\treturn handleMissingRequestValueException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof UnsatisfiedRequestParameterException theEx) {\n\t\t\treturn handleUnsatisfiedRequestParameterException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof WebExchangeBindException theEx) {\n\t\t\treturn handleWebExchangeBindException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof HandlerMethodValidationException theEx) {\n\t\t\treturn handleHandlerMethodValidationException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ServerWebInputException theEx) {\n\t\t\treturn handleServerWebInputException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ServerErrorException theEx) {\n\t\t\treturn handleServerErrorException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ResponseStatusException theEx) {\n\t\t\treturn handleResponseStatusException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof ErrorResponseException theEx) {\n\t\t\treturn handleErrorResponseException(theEx, theEx.getHeaders(), theEx.getStatusCode(), exchange);\n\t\t}\n\t\telse if (ex instanceof MethodValidationException theEx) {\n\t\t\treturn handleMethodValidationException(theEx, HttpStatus.INTERNAL_SERVER_ERROR, exchange);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Unexpected exception type: \" + ex.getClass().getName());\n\t\t\t}\n\t\t\treturn Mono.error(ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleExceptionInternal(ex,body,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Internal handler method that all others in this class delegate to, for\n\t * common handling, and for the creation of a {@link ResponseEntity}.\n\t * <p>The default implementation does the following:\n\t * <ul>\n\t * <li>return {@code null} if response is already committed\n\t * <li>set the {@code \"jakarta.servlet.error.exception\"} request attribute\n\t * if the response status is 500 (INTERNAL_SERVER_ERROR).\n\t * <li>extract the {@link ErrorResponse#getBody() body} from\n\t * {@link ErrorResponse} exceptions, if the {@code body} is {@code null}.\n\t * </ul>\n\t * @param ex the exception to handle\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "body",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 399
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleExceptionInternal(Exception ex, @Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleExceptionInternal(\n\t\t\tException ex, @Nullable Object body, @Nullable HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\tif (exchange.getResponse().isCommitted()) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\n\t\tif (body == null && ex instanceof ErrorResponse errorResponse) {\n\t\t\tbody = errorResponse.updateAndGetBody(this.messageSource, getLocale(exchange));\n\t\t}\n\n\t\treturn createResponseEntity(body, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleHandlerMethodValidationException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 261
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleHandlerMethodValidationException(\n\t\t\tHandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMethodNotAllowedException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodNotAllowedException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodNotAllowedException(MethodNotAllowedException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodNotAllowedException(\n\t\t\tMethodNotAllowedException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMethodValidationException(ex,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 341
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMethodValidationException(MethodValidationException ex, HttpStatus status, ServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMethodValidationException(\n\t\t\tMethodValidationException ex, HttpStatus status, ServerWebExchange exchange) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Validation failed\", null, null, exchange);\n\t\treturn handleExceptionInternal(ex, body, null, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMissingRequestValueException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingRequestValueException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 212
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleMissingRequestValueException(MissingRequestValueException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleMissingRequestValueException(\n\t\t\tMissingRequestValueException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMissingValue(name,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but\n\t * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned\n\t * {@code null} and there is no default value. Subclasses typically throw an\n\t * exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) {\n\t\tthrow new MissingRequestValueException(\n\t\t\t\tname, parameter.getNestedParameterType(), \"request value\", parameter);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleMissingValue(name,parameter,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a named value is required, but\n\t * {@link #resolveName(String, MethodParameter, ServerWebExchange)} returned\n\t * {@code null} and there is no default value. Subclasses typically throw an\n\t * exception in this case.\n\t * @param name the name for the value\n\t * @param parameter the method parameter\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter, ServerWebExchange exchange) {\n\t\thandleMissingValue(name, parameter);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleNotAcceptableStatusException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NotAcceptableStatusException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleNotAcceptableStatusException(NotAcceptableStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleNotAcceptableStatusException(\n\t\t\tNotAcceptableStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleResolvedValue(arg,name,parameter,model,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after a value is resolved.\n\t * @param arg the resolved argument value\n\t * @param name the argument name\n\t * @param parameter the argument parameter type\n\t * @param model the model\n\t * @param exchange the current exchange\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "model",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter, Model model, ServerWebExchange exchange)",
    "source_code": "\tprotected void handleResolvedValue(\n\t\t\t@Nullable Object arg, String name, MethodParameter parameter, Model model, ServerWebExchange exchange) {\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleResponseStatusException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link ResponseStatusException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleResponseStatusException(ResponseStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleResponseStatusException(\n\t\t\tResponseStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleResult(exchange,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body = result.getReturnValue();\n\t\tMethodParameter bodyTypeParameter = result.getReturnTypeSource();\n\t\tif (body instanceof ProblemDetail detail) {\n\t\t\texchange.getResponse().setStatusCode(HttpStatusCode.valueOf(detail.getStatus()));\n\t\t\tif (detail.getInstance() == null) {\n\t\t\t\tURI path = URI.create(exchange.getRequest().getPath().value());\n\t\t\t\tdetail.setInstance(path);\n\t\t\t}\n\t\t\tinvokeErrorResponseInterceptors(detail, null);\n\t\t}\n\t\treturn writeBody(body, bodyTypeParameter, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleServerErrorException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServerErrorException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleServerErrorException(ServerErrorException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleServerErrorException(\n\t\t\tServerErrorException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleServerWebInputException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServerWebInputException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleServerWebInputException(ServerWebInputException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleServerWebInputException(\n\t\t\tServerWebInputException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleUnsatisfiedRequestParameterException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link UnsatisfiedRequestParameterException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleUnsatisfiedRequestParameterException(UnsatisfiedRequestParameterException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleUnsatisfiedRequestParameterException(\n\t\t\tUnsatisfiedRequestParameterException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleUnsupportedMediaTypeStatusException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link UnsupportedMediaTypeStatusException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 196
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleUnsupportedMediaTypeStatusException(UnsupportedMediaTypeStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleUnsupportedMediaTypeStatusException(\n\t\t\tUnsupportedMediaTypeStatusException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#handleWebExchangeBindException(ex,headers,status,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link WebExchangeBindException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param exchange the current request and response\n\t * @return a {@code Mono} with the {@code ResponseEntity} for the response\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Mono<ResponseEntity<Object>>",
    "signature": "protected Mono<ResponseEntity<Object>> handleWebExchangeBindException(WebExchangeBindException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange)",
    "source_code": "\tprotected Mono<ResponseEntity<Object>> handleWebExchangeBindException(\n\t\t\tWebExchangeBindException ex, HttpHeaders headers, HttpStatusCode status,\n\t\t\tServerWebExchange exchange) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, exchange);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 342
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 336
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgument(parameter,bindingContext,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "bindingContext",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "Mono<Object>",
    "signature": "public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange)",
    "source_code": "\tpublic Mono<Object> resolveArgument(\n\t\t\tMethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {\n\n\t\tNamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n\t\tMethodParameter nestedParameter = parameter.nestedIfOptional();\n\n\t\tObject resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);\n\t\tif (resolvedName == null) {\n\t\t\treturn Mono.error(new IllegalArgumentException(\n\t\t\t\t\t\"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\"));\n\t\t}\n\n\t\tModel model = bindingContext.getModel();\n\n\t\treturn resolveName(resolvedName.toString(), nestedParameter, exchange)\n\t\t\t\t.flatMap(arg -> {\n\t\t\t\t\tif (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n\t\t\t\t\t\targ = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);\n\t\t\t\t\t}\n\t\t\t\t\targ = applyConversion(arg, namedValueInfo, parameter, bindingContext, exchange);\n\t\t\t\t\thandleResolvedValue(arg, namedValueInfo.name, parameter, model, exchange);\n\t\t\t\t\treturn Mono.justOrEmpty(arg);\n\t\t\t\t})\n\t\t\t\t.switchIfEmpty(getDefaultValue(\n\t\t\t\t\t\tnamedValueInfo, resolvedName.toString(), parameter, bindingContext, model, exchange));\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveArgumentValue(methodParameter,context,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "methodParameter",
      "context",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "Object",
    "signature": "public Object resolveArgumentValue(MethodParameter methodParameter, BindingContext context, ServerWebExchange exchange)",
    "source_code": "\tpublic Object resolveArgumentValue(\n\t\t\tMethodParameter methodParameter, BindingContext context, ServerWebExchange exchange) {\n\n\t\tClass<?> paramType = methodParameter.getParameterType();\n\t\tif (ServerWebExchange.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange;\n\t\t}\n\t\telse if (ServerHttpRequest.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getRequest();\n\t\t}\n\t\telse if (ServerHttpResponse.class.isAssignableFrom(paramType)) {\n\t\t\treturn exchange.getResponse();\n\t\t}\n\t\telse if (HttpMethod.class == paramType) {\n\t\t\treturn exchange.getRequest().getMethod();\n\t\t}\n\t\telse if (Locale.class == paramType) {\n\t\t\treturn exchange.getLocaleContext().getLocale();\n\t\t}\n\t\telse if (TimeZone.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone : TimeZone.getDefault());\n\t\t}\n\t\telse if (ZoneId.class == paramType) {\n\t\t\tLocaleContext localeContext = exchange.getLocaleContext();\n\t\t\tTimeZone timeZone = getTimeZone(localeContext);\n\t\t\treturn (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault());\n\t\t}\n\t\telse if (UriBuilder.class == paramType || UriComponentsBuilder.class == paramType) {\n\t\t\tURI uri = exchange.getRequest().getURI();\n\t\t\tString contextPath = exchange.getRequest().getPath().contextPath().value();\n\t\t\treturn UriComponentsBuilder.fromUri(uri).replacePath(contextPath).replaceQuery(null);\n\t\t}\n\t\telse {\n\t\t\t// should never happen...\n\t\t\tthrow new IllegalArgumentException(\"Unknown parameter type: \" +\n\t\t\t\t\tparamType + \" in method: \" + methodParameter.getMethod());\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#resolveName(name,parameter,exchange)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given parameter type and value name into an argument value.\n\t * @param name the name of the value being resolved\n\t * @param parameter the method parameter to resolve to an argument value\n\t * (pre-nested in case of a {@link java.util.Optional} declaration)\n\t * @param exchange the current exchange\n\t * @return the resolved argument (may be empty {@link Mono})\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 191
    },
    "return": "Mono<Object>",
    "signature": "protected Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange)",
    "source_code": "\tprotected abstract Mono<Object> resolveName(String name, MethodParameter parameter, ServerWebExchange exchange);"
  },
  "org.springframework.web.reactive.result.method.annotation.<unknown>#setPathPrefixes(Map<String,prefixes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method and {@code @HttpExchange} method whose controller type is matched\n\t * by a corresponding {@code Predicate} in the map. The prefix for the first\n\t * matching predicate is used, assuming the input map has predictable order.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t * @see org.springframework.web.method.HandlerTypePredicate\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 98
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes.clear();\n\t\tprefixes.entrySet().stream()\n\t\t\t\t.filter(entry -> StringUtils.hasText(entry.getKey()))\n\t\t\t\t.forEach(entry -> this.pathPrefixes.put(entry.getKey(), entry.getValue()));\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#applyLifecycleMethods(viewName,view)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#canHandle(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link ViewResolver} can handle the supplied\n\t * view name. If not, an empty result is returned. The default implementation\n\t * checks against the configured {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#changeLocale(locale,timeZone)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified locale and time zone context.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale, TimeZone timeZone)",
    "source_code": "\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#format(fragmentFlux,fragment,exchange)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "fragmentFlux",
      "fragment",
      "exchange"
    ],
    "position": {
      "column": 1,
      "line": 542
    },
    "return": "Flux<DataBuffer>",
    "signature": "public Flux<DataBuffer> format(Flux<DataBuffer> fragmentFlux, Fragment fragment, ServerWebExchange exchange)",
    "source_code": "\t\tpublic Flux<DataBuffer> format(\n\t\t\t\tFlux<DataBuffer> fragmentFlux, Fragment fragment, ServerWebExchange exchange) {\n\n\t\t\tMediaType mediaType = exchange.getResponse().getHeaders().getContentType();\n\t\t\tCharset charset = (mediaType != null && mediaType.getCharset() != null ?\n\t\t\t\t\tmediaType.getCharset() : StandardCharsets.UTF_8);\n\n\t\t\tDataBufferFactory bufferFactory = exchange.getResponse().bufferFactory();\n\n\t\t\tString eventLine = (fragment.viewName() != null ? \"event:\" + fragment.viewName() + \"\\n\" : \"\");\n\t\t\tDataBuffer prefix = encodeText(eventLine + \"data:\", charset, bufferFactory);\n\t\t\tDataBuffer suffix = encodeText(\"\\n\\n\", charset, bufferFactory);\n\n\t\t\tMono<DataBuffer> content = DataBufferUtils.join(fragmentFlux)\n\t\t\t\t\t.map(buffer -> {\n\t\t\t\t\t\tString text;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttext = buffer.toString(charset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext = text.replace(\"\\n\", \"\\ndata:\");\n\t\t\t\t\t\treturn bufferFactory.wrap(text.getBytes(charset));\n\t\t\t\t\t});\n\n\t\t\treturn Flux.concat(Flux.just(prefix), content, Flux.just(suffix));\n\t\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getBindStatus(path,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the\n\t * \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will\n\t * be resolved (for example, \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 440
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders --\n\t * named keys with braces {@code {}}. For example, send in a relative URL\n\t * {@code foo/{bar}?spam={spam}} and a parameter map {@code {bar=baz,spam=nuts}}\n\t * and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the current web application with an\n\t * absolute path also URL-encoded accordingly\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 219
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = StringUtils.applyRelativePath(getContextPath() + \"/\", relativeUrl);\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\treturn getExchange().transformUrl(url);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getErrors(name,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name, boolean htmlEscape)",
    "source_code": "\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tif (errors == null) {\n\t\t\terrors = getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (errors instanceof BindException bindException) {\n\t\t\terrors = bindException.getBindingResult();\n\t\t}\n\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t}\n\n\t\tthis.errorsMap.put(name, errors);\n\t\treturn errors;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 270
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,defaultMessage,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 282
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = this.messageSource.getMessage(code, args, defaultMessage, this.locale);\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,args,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(code, args, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(code,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#getMessage(resolvable,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (for example, an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 352
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = this.messageSource.getMessage(resolvable, this.locale);\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#handleResult(exchange,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 203
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result)",
    "source_code": "\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tMono<Object> valueMono;\n\t\tResolvableType valueType;\n\t\tReactiveAdapter adapter = getAdapter(result);\n\n\t\tif (adapter != null) {\n\t\t\tif (adapter.isMultiValue()) {\n\t\t\t\tvalueMono = (result.getReturnValue() != null ?\n\t\t\t\t\t\tMono.just(FragmentsRendering.withPublisher(adapter.toPublisher(result.getReturnValue())).build()) :\n\t\t\t\t\t\tMono.empty());\n\n\t\t\t\tvalueType = ResolvableType.forClass(FragmentsRendering.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueMono = (result.getReturnValue() != null ?\n\t\t\t\t\t\tMono.from(adapter.toPublisher(result.getReturnValue())) : Mono.empty());\n\n\t\t\t\tvalueType = (adapter.isNoValue() ? ResolvableType.forClass(Void.class) :\n\t\t\t\t\t\tresult.getReturnType().getGeneric());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvalueMono = Mono.justOrEmpty(result.getReturnValue());\n\t\t\tvalueType = result.getReturnType();\n\t\t}\n\n\t\treturn valueMono\n\t\t\t\t.switchIfEmpty(exchange.isNotModified() ? Mono.empty() : NO_VALUE_MONO)\n\t\t\t\t.flatMap(returnValue -> {\n\n\t\t\t\t\tMono<List<View>> viewsMono;\n\t\t\t\t\tModel model = result.getModel();\n\t\t\t\t\tMethodParameter parameter = result.getReturnTypeSource();\n\t\t\t\t\tBindingContext bindingContext = result.getBindingContext();\n\t\t\t\t\tLocale locale = LocaleContextHolder.getLocale(exchange.getLocaleContext());\n\n\t\t\t\t\tClass<?> clazz = valueType.toClass();\n\t\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\t\tclazz = returnValue.getClass();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Collection.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\treturnValue = FragmentsRendering.withCollection((Collection<Fragment>) returnValue).build();\n\t\t\t\t\t\tclazz = FragmentsRendering.class;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnValue == NO_VALUE || ClassUtils.isVoidType(clazz)) {\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CharSequence.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tviewsMono = resolveViews(returnValue.toString(), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Rendering.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tRendering render = (Rendering) returnValue;\n\t\t\t\t\t\tHttpStatusCode status = render.status();\n\t\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t\texchange.getResponse().setStatusCode(status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texchange.getResponse().getHeaders().putAll(render.headers());\n\t\t\t\t\t\tmodel.addAllAttributes(render.modelAttributes());\n\t\t\t\t\t\tObject view = render.view();\n\t\t\t\t\t\tif (view == null) {\n\t\t\t\t\t\t\tview = getDefaultViewName(exchange);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tviewsMono = (view instanceof String viewName ? resolveViews(viewName, locale) :\n\t\t\t\t\t\t\t\tMono.just(Collections.singletonList((View) view)));\n\t\t\t\t\t}\n\t\t\t\t\telse if (FragmentsRendering.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tServerHttpResponse response = exchange.getResponse();\n\t\t\t\t\t\tFragmentsRendering render = (FragmentsRendering) returnValue;\n\t\t\t\t\t\tHttpStatusCode status = render.status();\n\t\t\t\t\t\tif (status != null) {\n\t\t\t\t\t\t\tresponse.setStatusCode(status);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresponse.getHeaders().putAll(render.headers());\n\t\t\t\t\t\tbindingContext.updateModel(exchange);\n\n\t\t\t\t\t\tStreamHandler streamHandler = getStreamHandler(exchange);\n\t\t\t\t\t\tif (streamHandler != null) {\n\t\t\t\t\t\t\tstreamHandler.updateResponse(exchange);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tFlux<Flux<DataBuffer>> renderFlux = render.fragments()\n\t\t\t\t\t\t\t\t.concatMap(fragment -> renderFragment(fragment, streamHandler, locale, bindingContext, exchange))\n\t\t\t\t\t\t\t\t.doOnDiscard(DataBuffer.class, DataBufferUtils::release);\n\n\t\t\t\t\t\treturn response.writeAndFlushWith(renderFlux);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Model.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tmodel.addAllAttributes(((Model) returnValue).asMap());\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (Map.class.isAssignableFrom(clazz) && !hasModelAnnotation(parameter)) {\n\t\t\t\t\t\tmodel.addAllAttributes((Map<String, ?>) returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\telse if (View.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\tviewsMono = Mono.just(Collections.singletonList((View) returnValue));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString name = getNameForReturnValue(parameter);\n\t\t\t\t\t\tmodel.addAttribute(name, returnValue);\n\t\t\t\t\t\tviewsMono = resolveViews(getDefaultViewName(exchange), locale);\n\t\t\t\t\t}\n\t\t\t\t\tbindingContext.updateModel(exchange);\n\t\t\t\t\treturn viewsMono.flatMap(views -> render(views, model.asMap(), null, bindingContext, exchange));\n\t\t\t\t});\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#header(headerName,headerValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValues"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "DefaultRenderingBuilder",
    "signature": "public DefaultRenderingBuilder header(String headerName, String... headerValues)",
    "source_code": "\tpublic DefaultRenderingBuilder header(String headerName, String... headerValues) {\n\t\tinitHeaders().put(headerName, Arrays.asList(headerValues));\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#model(Map<String,map)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "DefaultRenderingBuilder",
    "signature": "public DefaultRenderingBuilder model(Map<String, ?> map)",
    "source_code": "\tpublic DefaultRenderingBuilder model(Map<String, ?> map) {\n\t\tinitModel().addAllAttributes(map);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#modelAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "DefaultRenderingBuilder",
    "signature": "public DefaultRenderingBuilder modelAttribute(String name, Object value)",
    "source_code": "\tpublic DefaultRenderingBuilder modelAttribute(String name, Object value) {\n\t\tinitModel().addAttribute(name, value);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#resolveViewName(viewName,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 226
    },
    "return": "Mono<View>",
    "signature": "public Mono<View> resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic Mono<View> resolveViewName(String viewName, Locale locale) {\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tAbstractUrlBasedView urlBasedView;\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\turlBasedView = this.redirectViewProvider.apply(redirectUrl);\n\t\t}\n\t\telse {\n\t\t\turlBasedView = createView(viewName);\n\t\t}\n\n\t\tView view = applyLifecycleMethods(viewName, urlBasedView);\n\t\treturn urlBasedView.resourceExists(locale)\n\t\t\t\t.flatMap(exists -> exists ? Mono.just(view) : Mono.empty());\n\t}"
  },
  "org.springframework.web.reactive.result.view.<unknown>#setRedirectViewProvider(Function<String,redirectViewProvider)": {
    "deprecated": false,
    "doc": "\t/**\n\t * URL based {@link RedirectView} provider which can be used to provide, for example,\n\t * redirect views with a custom default status code.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "redirectViewProvider"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "void",
    "signature": "public void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider)",
    "source_code": "\tpublic void setRedirectViewProvider(Function<String, RedirectView> redirectViewProvider) {\n\t\tthis.redirectViewProvider = redirectViewProvider;\n\t}"
  },
  "org.springframework.web.reactive.socket.<unknown>#create(code,reason)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a constant for the given code, or create a new instance if the\n\t * code does not match or there is a reason.\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 204
    },
    "return": "CloseStatus",
    "signature": "public CloseStatus create(int code, @Nullable String reason)",
    "source_code": "\tpublic static CloseStatus create(int code, @Nullable String reason) {\n\t\tif (!StringUtils.hasText(reason)) {\n\t\t\treturn switch (code) {\n\t\t\t\tcase 1000 -> NORMAL;\n\t\t\t\tcase 1001 -> GOING_AWAY;\n\t\t\t\tcase 1002 -> PROTOCOL_ERROR;\n\t\t\t\tcase 1003 -> NOT_ACCEPTABLE;\n\t\t\t\tcase 1005 -> NO_STATUS_CODE;\n\t\t\t\tcase 1006 -> NO_CLOSE_FRAME;\n\t\t\t\tcase 1007 -> BAD_DATA;\n\t\t\t\tcase 1008 -> POLICY_VIOLATION;\n\t\t\t\tcase 1009 -> TOO_BIG_TO_PROCESS;\n\t\t\t\tcase 1010 -> REQUIRED_EXTENSION;\n\t\t\t\tcase 1011 -> SERVER_ERROR;\n\t\t\t\tcase 1012 -> SERVICE_RESTARTED;\n\t\t\t\tcase 1013 -> SERVICE_OVERLOAD;\n\t\t\t\tdefault -> new CloseStatus(code, reason);\n\t\t\t};\n\t\t}\n\t\treturn new CloseStatus(code, reason);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#asByteBuffer(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer asByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer asByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.asByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#complete(channel,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void complete(WebSocketChannel channel, Void context)",
    "source_code": "\t\tpublic void complete(WebSocketChannel channel, Void context) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().setReadyToSend(true);\n\t\t\tgetSendProcessor().onWritePossible();\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#indexOf(predicate,fromIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "int",
    "signature": "public int indexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int indexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.indexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#lastIndexOf(predicate,fromIndex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "fromIndex"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "int",
    "signature": "public int lastIndexOf(IntPredicate predicate, int fromIndex)",
    "source_code": "\t\tpublic int lastIndexOf(IntPredicate predicate, int fromIndex) {\n\t\t\treturn this.delegate.lastIndexOf(predicate, fromIndex);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onClose(session,reason)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "void",
    "signature": "public void onClose(Session session, CloseReason reason)",
    "source_code": "\tpublic void onClose(Session session, CloseReason reason) {\n\t\tif (this.delegateSession != null) {\n\t\t\tint code = reason.getCloseCode().getCode();\n\t\t\tthis.delegateSession.handleClose(CloseStatus.create(code, reason.getReasonPhrase()));\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(channel,context,throwable)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "channel",
      "context",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "void",
    "signature": "public void onError(WebSocketChannel channel, Void context, Throwable throwable)",
    "source_code": "\t\tpublic void onError(WebSocketChannel channel, Void context, Throwable throwable) {\n\t\t\tDataBufferUtils.release(this.payload);\n\t\t\tgetSendProcessor().cancel();\n\t\t\tgetSendProcessor().onError(throwable);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onError(session,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 120
    },
    "return": "void",
    "signature": "public void onError(Session session, Throwable exception)",
    "source_code": "\tpublic void onError(Session session, Throwable exception) {\n\t\tif (this.delegateSession != null) {\n\t\t\tthis.delegateSession.handleError(exception);\n\t\t}\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onOpen(session,config)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "config"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "public void onOpen(Session session, EndpointConfig config)",
    "source_code": "\tpublic void onOpen(Session session, EndpointConfig config) {\n\t\tthis.delegateSession = this.sessionFactory.apply(session);\n\t\tAssert.state(this.delegateSession != null, \"No delegate session\");\n\n\t\tsession.addMessageHandler(String.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\t\tsession.addMessageHandler(ByteBuffer.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\t\tsession.addMessageHandler(PongMessage.class, message -> {\n\t\t\tWebSocketMessage webSocketMessage = toMessage(message);\n\t\t\tthis.delegateSession.handleMessage(webSocketMessage.getType(), webSocketMessage);\n\t\t});\n\n\t\tthis.delegateHandler.handle(this.delegateSession)\n\t\t\t\t.checkpoint(session.getRequestURI() + \" [StandardWebSocketHandlerAdapter]\")\n\t\t\t\t.subscribe(this.delegateSession);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onWebSocketBinary(byteBuffer,callback)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "byteBuffer",
      "callback"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback)",
    "source_code": "\tpublic void onWebSocketBinary(ByteBuffer byteBuffer, Callback callback) {\n\t\tAssert.state(this.delegateSession != null, \"No delegate session available\");\n\t\tDataBuffer buffer = this.delegateSession.bufferFactory().wrap(byteBuffer);\n\t\tbuffer = new JettyCallbackDataBuffer(buffer, callback);\n\t\tWebSocketMessage webSocketMessage = new WebSocketMessage(Type.BINARY, buffer);\n\t\tthis.delegateSession.handleMessage(webSocketMessage);\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#onWebSocketClose(statusCode,reason)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "statusCode",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void onWebSocketClose(int statusCode, String reason)",
    "source_code": "\tpublic void onWebSocketClose(int statusCode, String reason) {\n\t\tAssert.state(this.delegateSession != null, \"No delegate session available\");\n\t\tthis.delegateSession.handleClose(CloseStatus.create(statusCode, reason));\n\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#read(destination,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "destination",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 217
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer read(byte[] destination, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer read(byte[] destination, int offset, int length) {\n\t\t\tthis.delegate.read(destination, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#slice(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer slice(int index, int length)",
    "source_code": "\t\tpublic DataBuffer slice(int index, int length) {\n\t\t\tDataBuffer delegateSlice = this.delegate.slice(index, length);\n\t\t\treturn new JettyCallbackDataBuffer(delegateSlice, this.callback);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toByteBuffer(index,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 279
    },
    "return": "ByteBuffer",
    "signature": "public ByteBuffer toByteBuffer(int index, int length)",
    "source_code": "\t\tpublic ByteBuffer toByteBuffer(int index, int length) {\n\t\t\treturn this.delegate.toByteBuffer(index, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toByteBuffer(srcPos,dest,destPos,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "srcPos",
      "dest",
      "destPos",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 284
    },
    "return": "void",
    "signature": "public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length)",
    "source_code": "\t\tpublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\n\t\t\tthis.delegate.toByteBuffer(srcPos, dest, destPos, length);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#toString(index,length,charset)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "length",
      "charset"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "String",
    "signature": "public String toString(int index, int length, Charset charset)",
    "source_code": "\t\tpublic String toString(int index, int length, Charset charset) {\n\t\t\treturn this.delegate.toString(index, length, charset);\n\t\t}"
  },
  "org.springframework.web.reactive.socket.adapter.<unknown>#write(source,offset,length)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "offset",
      "length"
    ],
    "position": {
      "column": 1,
      "line": 235
    },
    "return": "DataBuffer",
    "signature": "public DataBuffer write(byte[] source, int offset, int length)",
    "source_code": "\t\tpublic DataBuffer write(byte[] source, int offset, int length) {\n\t\t\tthis.delegate.write(source, offset, length);\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.reactive.socket.server.support.<unknown>#handleRequest(exchange,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler)",
    "source_code": "\tpublic Mono<Void> handleRequest(ServerWebExchange exchange, WebSocketHandler handler) {\n\t\tServerHttpRequest request = exchange.getRequest();\n\t\tHttpMethod method = request.getMethod();\n\t\tHttpHeaders headers = request.getHeaders();\n\n\t\tif (HttpMethod.GET != method) {\n\t\t\treturn Mono.error(new MethodNotAllowedException(\n\t\t\t\t\trequest.getMethod(), Collections.singleton(HttpMethod.GET)));\n\t\t}\n\n\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Upgrade' header: \" + headers);\n\t\t}\n\n\t\tList<String> connectionValue = headers.getConnection();\n\t\tif (!connectionValue.contains(\"Upgrade\") && !connectionValue.contains(\"upgrade\")) {\n\t\t\treturn handleBadRequest(exchange, \"Invalid 'Connection' header: \" + headers);\n\t\t}\n\n\t\tString key = headers.getFirst(SEC_WEBSOCKET_KEY);\n\t\tif (key == null) {\n\t\t\treturn handleBadRequest(exchange, \"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t}\n\n\t\tString protocol = selectProtocol(headers, handler);\n\n\t\treturn initAttributes(exchange).flatMap(attributes ->\n\t\t\t\tthis.upgradeStrategy.upgrade(exchange, handler, protocol,\n\t\t\t\t\t\t() -> createHandshakeInfo(exchange, request, protocol, attributes))\n\t\t);\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#addUrlTransformer(Function<String,transformer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<String",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "void",
    "signature": "public void addUrlTransformer(Function<String, String> transformer)",
    "source_code": "\tpublic void addUrlTransformer(Function<String, String> transformer) {\n\t\tAssert.notNull(transformer, \"'encoder' must not be null\");\n\t\tthis.urlTransformer = this.urlTransformer.andThen(transformer);\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#checkNotModified(eTag,lastModified)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "eTag",
      "lastModified"
    ],
    "position": {
      "column": 1,
      "line": 302
    },
    "return": "boolean",
    "signature": "public boolean checkNotModified(@Nullable String eTag, Instant lastModified)",
    "source_code": "\tpublic boolean checkNotModified(@Nullable String eTag, Instant lastModified) {\n\t\tHttpStatusCode status = getResponse().getStatusCode();\n\t\tif (this.notModified || (status != null && !HttpStatus.OK.equals(status))) {\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// Evaluate conditions in order of precedence.\n\t\t// See https://datatracker.ietf.org/doc/html/rfc9110#section-13.2.2\n\t\t// 1) If-Match\n\t\tif (validateIfMatch(eTag)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 2) If-Unmodified-Since\n\t\telse if (validateIfUnmodifiedSince(lastModified)) {\n\t\t\tupdateResponseStateChanging(eTag, lastModified);\n\t\t\treturn this.notModified;\n\t\t}\n\t\t// 3) If-None-Match\n\t\tif (!validateIfNoneMatch(eTag)) {\n\t\t\t// 4) If-Modified-Since\n\t\t\tvalidateIfModifiedSince(lastModified);\n\t\t}\n\t\tupdateResponseIdempotent(eTag, lastModified);\n\t\treturn this.notModified;\n\t}"
  },
  "org.springframework.web.server.adapter.<unknown>#registerCloseListener(servletContext,applicationContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a {@link ServletContextListener} that closes the given\n\t * application context when the servlet context is destroyed.\n\t * @param servletContext the servlet context to listen to\n\t * @param applicationContext the application context that is to be\n\t * closed when {@code servletContext} is destroyed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletContext",
      "applicationContext"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "protected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext)",
    "source_code": "\tprotected void registerCloseListener(ServletContext servletContext, ApplicationContext applicationContext) {\n\t\tif (applicationContext instanceof ConfigurableApplicationContext cac) {\n\t\t\tservletContext.addListener(new ServletContextDestroyedListener(cac));\n\t\t}\n\t}"
  },
  "org.springframework.web.server.handler.<unknown>#handle(exchange,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "exchange",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "Mono<Void>",
    "signature": "public Mono<Void> handle(ServerWebExchange exchange, Throwable ex)",
    "source_code": "\tpublic Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {\n\t\tif (!updateResponse(exchange.getResponse(), ex)) {\n\t\t\treturn Mono.error(ex);\n\t\t}\n\n\t\t// Mirrors AbstractHandlerExceptionResolver in spring-webmvc...\n\t\tString logPrefix = exchange.getLogPrefix();\n\t\tif (this.warnLogger != null && this.warnLogger.isWarnEnabled()) {\n\t\t\tthis.warnLogger.warn(logPrefix + formatError(ex, exchange.getRequest()));\n\t\t}\n\t\telse if (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(logPrefix + formatError(ex, exchange.getRequest()));\n\t\t}\n\n\t\treturn exchange.getResponse().setComplete();\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerMethodHints(hints,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 51
    },
    "return": "void",
    "signature": "protected void registerMethodHints(ReflectionHints hints, Method method)",
    "source_code": "\tprotected void registerMethodHints(ReflectionHints hints, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tfor (Parameter parameter : method.getParameters()) {\n\t\t\tregisterParameterTypeHints(hints, MethodParameter.forParameter(parameter));\n\t\t}\n\t\tregisterReturnTypeHints(hints, MethodParameter.forExecutable(method, -1));\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerParameterTypeHints(hints,methodParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "methodParameter"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter)",
    "source_code": "\tprotected void registerParameterTypeHints(ReflectionHints hints, MethodParameter methodParameter) {\n\t\tif (methodParameter.hasParameterAnnotation(RequestBody.class)) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, methodParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReflectionHints(hints,element)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "hints",
      "element"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "void",
    "signature": "public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element)",
    "source_code": "\tpublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\n\t\tif (element instanceof Method method) {\n\t\t\tregisterMethodHints(hints, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.service.annotation.<unknown>#registerReturnTypeHints(hints,returnTypeParameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "hints",
      "returnTypeParameter"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "void",
    "signature": "protected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter)",
    "source_code": "\tprotected void registerReturnTypeHints(ReflectionHints hints, MethodParameter returnTypeParameter) {\n\t\tif (!void.class.equals(returnTypeParameter.getParameterType())) {\n\t\t\tthis.bindingRegistrar.registerReflectionHints(hints, returnTypeParameter.getGenericParameterType());\n\t\t}\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#addRequestValue(name,value,parameter,requestValues)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single request value. This may be called multiples times\n\t * if the request value is multivalued.\n\t * <p>If the resolver was created with a {@link ConversionService}, the value\n\t * will have been converted to a String and may be cast down.\n\t * @param name the request value name\n\t * @param value the value\n\t * @param parameter the method parameter type, nested if Map, List/array, or Optional\n\t * @param requestValues builder to add the request value to\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "protected void addRequestValue(String name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tprotected abstract void addRequestValue(\n\t\t\tString name, Object value, MethodParameter parameter, HttpRequestValues.Builder requestValues);\n\n\n\t/**\n\t * Info about a request value, typically extracted from a method parameter annotation.\n\t */\n\tprotected static class NamedValueInfo {\n\n\t\tprivate final String name;\n\n\t\tprivate final boolean required;\n\n\t\t@Nullable\n\t\tprivate final String defaultValue;\n\n\t\tprivate final String label;\n\n\t\tprivate final boolean multiValued;\n\n\t\t/**\n\t\t * Create an instance.\n\t\t * @param name the name to use, possibly empty if not specified\n\t\t * @param required whether it is marked as required\n\t\t * @param defaultValue fallback value, possibly {@link ValueConstants#DEFAULT_NONE}\n\t\t * @param label how it should appear in error messages, for example, \"path variable\", \"request header\"\n\t\t * @param multiValued whether this argument resolver supports sending multiple values;\n\t\t * if not, then multiple values are formatted as a String value\n\t\t */\n\t\tpublic NamedValueInfo(\n\t\t\t\tString name, boolean required, @Nullable String defaultValue, String label, boolean multiValued) {\n\n\t\t\tthis.name = name;\n\t\t\tthis.required = required;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t\tthis.label = label;\n\t\t\tthis.multiValued = multiValued;\n\t\t}\n\n\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(client,method)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "client",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "ResponseFunction",
    "signature": "public ResponseFunction create(ReactorHttpExchangeAdapter client, Method method)",
    "source_code": "\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (ClassUtils.isVoidType(actualType)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#create(method,containingClass,embeddedValueResolver,requestValuesSupplier)": {
    "deprecated": false,
    "doc": "\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "method",
      "containingClass",
      "embeddedValueResolver",
      "requestValuesSupplier"
    ],
    "position": {
      "column": 1,
      "line": 197
    },
    "return": "HttpRequestValuesInitializer",
    "signature": "public HttpRequestValuesInitializer create(Method method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier)",
    "source_code": "\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tList<AnnotationDescriptor> methodHttpExchanges = getAnnotationDescriptors(method);\n\t\t\tAssert.state(!methodHttpExchanges.isEmpty(),\n\t\t\t\t\t() -> \"Expected @HttpExchange annotation on method \" + method);\n\t\t\tAssert.state(methodHttpExchanges.size() == 1,\n\t\t\t\t\t() -> \"Multiple @HttpExchange annotations found on method %s, but only one is allowed: %s\"\n\t\t\t\t\t\t\t.formatted(method, methodHttpExchanges));\n\n\t\t\tList<AnnotationDescriptor> typeHttpExchanges = getAnnotationDescriptors(containingClass);\n\t\t\tAssert.state(typeHttpExchanges.size() <= 1,\n\t\t\t\t\t() -> \"Multiple @HttpExchange annotations found on %s, but only one is allowed: %s\"\n\t\t\t\t\t\t\t.formatted(containingClass, typeHttpExchanges));\n\n\t\t\tHttpExchange methodAnnotation = methodHttpExchanges.get(0).httpExchange;\n\t\t\tHttpExchange typeAnnotation = (!typeHttpExchanges.isEmpty() ? typeHttpExchanges.get(0).httpExchange : null);\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\t\t\tMultiValueMap<String, String> headers = initHeaders(typeAnnotation, methodAnnotation,\n\t\t\t\t\tembeddedValueResolver);\n\t\t\treturn new HttpRequestValuesInitializer(httpMethod, url, contentType,\n\t\t\t\t\tacceptableMediaTypes, headers, requestValuesSupplier);\n\t\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#createNamedValueInfo(parameter,metadata)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Variant of {@link #createNamedValueInfo(MethodParameter)} that also provides\n\t * access to the static values set from {@code @HttpExchange} attributes.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "parameter",
      "metadata"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "NamedValueInfo",
    "signature": "protected NamedValueInfo createNamedValueInfo(MethodParameter parameter, HttpRequestValues.Metadata metadata)",
    "source_code": "\tprotected NamedValueInfo createNamedValueInfo(\n\t\t\tMethodParameter parameter, HttpRequestValues.Metadata metadata) {\n\n\t\treturn createNamedValueInfo(parameter);\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#resolve(argument,parameter,requestValues)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "argument",
      "parameter",
      "requestValues"
    ],
    "position": {
      "column": 1,
      "line": 66
    },
    "return": "boolean",
    "signature": "public boolean resolve(@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues)",
    "source_code": "\tpublic boolean resolve(\n\t\t\t@Nullable Object argument, MethodParameter parameter, HttpRequestValues.Builder requestValues) {\n\n\t\tRequestBody annot = parameter.getParameterAnnotation(RequestBody.class);\n\t\tif (annot == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (argument instanceof Optional<?> optionalValue) {\n\t\t\targument = optionalValue.orElse(null);\n\t\t}\n\n\t\tif (argument == null) {\n\t\t\tAssert.isTrue(!annot.required() || parameter.isOptional(), \"RequestBody is required\");\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.reactiveAdapterRegistry != null) {\n\t\t\tReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(parameter.getParameterType());\n\t\t\tif (adapter != null) {\n\t\t\t\tMethodParameter nestedParameter = parameter.nested();\n\n\t\t\t\tString message = \"Async type for @RequestBody should produce value(s)\";\n\t\t\t\tAssert.isTrue(!adapter.isNoValue(), message);\n\t\t\t\tAssert.isTrue(nestedParameter.getNestedParameterType() != Void.class, message);\n\n\t\t\t\tif (requestValues instanceof ReactiveHttpRequestValues.Builder reactiveRequestValues) {\n\t\t\t\t\treactiveRequestValues.setBodyPublisher(\n\t\t\t\t\t\t\tadapter.toPublisher(argument), asParameterizedTypeRef(nestedParameter));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"RequestBody with a reactive type is only supported with reactive client\");\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Not a reactive type\n\t\trequestValues.setBodyValue(argument);\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.service.invoker.<unknown>#update(name,required,defaultValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "required",
      "defaultValue"
    ],
    "position": {
      "column": 1,
      "line": 262
    },
    "return": "NamedValueInfo",
    "signature": "public NamedValueInfo update(String name, boolean required, @Nullable String defaultValue)",
    "source_code": "\t\tpublic NamedValueInfo update(String name, boolean required, @Nullable String defaultValue) {\n\t\t\treturn new NamedValueInfo(name, required, defaultValue, this.label, this.multiValued);\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#addAllObjects(Map<String,modelMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add all attributes contained in the provided Map to the model.\n\t * @param modelMap a Map of attributeName &rarr; attributeValue pairs\n\t * @see ModelMap#addAllAttributes(Map)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "modelMap"
    ],
    "position": {
      "column": 1,
      "line": 310
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap)",
    "source_code": "\tpublic ModelAndView addAllObjects(@Nullable Map<String, ?> modelMap) {\n\t\tgetModelMap().addAllAttributes(modelMap);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addInterceptor(index,interceptor)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given interceptor at the specified index of this chain.\n\t * @since 5.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "interceptor"
    ],
    "position": {
      "column": 1,
      "line": 106
    },
    "return": "void",
    "signature": "public void addInterceptor(int index, HandlerInterceptor interceptor)",
    "source_code": "\tpublic void addInterceptor(int index, HandlerInterceptor interceptor) {\n\t\tthis.interceptorList.add(index, interceptor);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addObject(attributeName,attributeValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add an attribute to the model.\n\t * @param attributeName name of the object to add to the model (never {@code null})\n\t * @param attributeValue object to add to the model (can be {@code null})\n\t * @see ModelMap#addAttribute(String, Object)\n\t * @see #getModelMap()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "attributeName",
      "attributeValue"
    ],
    "position": {
      "column": 1,
      "line": 288
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView addObject(String attributeName, @Nullable Object attributeValue)",
    "source_code": "\tpublic ModelAndView addObject(String attributeName, @Nullable Object attributeValue) {\n\t\tgetModelMap().addAttribute(attributeName, attributeValue);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParam(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide a request parameter identifying the request for this FlashMap.\n\t * @param name the expected parameter name (skipped if empty)\n\t * @param value the expected value (skipped if empty)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParam(String name, String value)",
    "source_code": "\tpublic FlashMap addTargetRequestParam(String name, String value) {\n\t\tif (StringUtils.hasText(name) && StringUtils.hasText(value)) {\n\t\t\tthis.targetRequestParams.add(name, value);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#addTargetRequestParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide request parameters identifying the request for this FlashMap.\n\t * @param params a Map with the names and values of expected parameters\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 81
    },
    "return": "FlashMap",
    "signature": "public FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic FlashMap addTargetRequestParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tparams.forEach((key, values) -> {\n\t\t\t\tfor (String value : values) {\n\t\t\t\t\taddTargetRequestParam(key, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#buildRequestAttributes(request,response,previousAttributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build ServletRequestAttributes for the given request (potentially also\n\t * holding a reference to the response), taking pre-bound attributes\n\t * (and their type) into consideration.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param previousAttributes pre-bound RequestAttributes instance, if any\n\t * @return the ServletRequestAttributes to bind, or {@code null} to preserve\n\t * the previously bound instance (or not binding any, if none bound before)\n\t * @see RequestContextHolder#setRequestAttributes\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "previousAttributes"
    ],
    "position": {
      "column": 1,
      "line": 1059
    },
    "return": "ServletRequestAttributes",
    "signature": "protected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,\n\t\t\t@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes)",
    "source_code": "\tprotected ServletRequestAttributes buildRequestAttributes(HttpServletRequest request,\n\t\t\t@Nullable HttpServletResponse response, @Nullable RequestAttributes previousAttributes) {\n\n\t\tif (previousAttributes == null || previousAttributes instanceof ServletRequestAttributes) {\n\t\t\treturn new ServletRequestAttributes(request, response);\n\t\t}\n\t\telse {\n\t\t\treturn null;  // preserve the pre-bound RequestAttributes instance\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#createDefaultStrategy(context,clazz)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a default strategy.\n\t * <p>The default implementation uses\n\t * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean(Class)}.\n\t * @param context the current WebApplicationContext\n\t * @param clazz the strategy implementation class to instantiate\n\t * @return the fully configured strategy instance\n\t * @see org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#createBean(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "clazz"
    ],
    "position": {
      "column": 1,
      "line": 929
    },
    "return": "Object",
    "signature": "protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz)",
    "source_code": "\tprotected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {\n\t\treturn context.getAutowireCapableBeanFactory().createBean(clazz);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doDelete(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate DELETE requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 933
    },
    "return": "void",
    "signature": "protected void doDelete(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doDelete(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doDispatch(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the actual dispatching to the handler.\n\t * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.\n\t * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters\n\t * to find the first that supports the handler class.\n\t * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers\n\t * themselves to decide which methods are acceptable.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1048
    },
    "return": "void",
    "signature": "protected void doDispatch(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n\t\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new ServletException(\"Handler dispatch failed: \" + err, err);\n\t\t\t}\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew ServletException(\"Handler processing failed: \" + err, err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t\tasyncManager.setMultipartRequestParsed(multipartRequestParsed);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed || asyncManager.isMultipartRequestParsed()) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doGet(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate GET requests to processRequest/doService.\n\t * <p>Will also be invoked by HttpServlet's default implementation of {@code doHead},\n\t * with a {@code NoBodyResponse} that just captures the content length.\n\t * @see #doService\n\t * @see #doHead\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 900
    },
    "return": "void",
    "signature": "protected void doGet(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doOptions(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate OPTIONS requests to {@link #processRequest}, if desired.\n\t * <p>Applies HttpServlet's standard OPTIONS processing otherwise,\n\t * and also if there is still no 'Allow' header set after dispatching.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 946
    },
    "return": "void",
    "signature": "protected void doOptions(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doOptions(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) {\n\t\t\tprocessRequest(request, response);\n\t\t\tif (response.containsHeader(HttpHeaders.ALLOW)) {\n\t\t\t\t// Proper OPTIONS response coming from a handler - we're done.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Use response wrapper in order to always add PATCH to the allowed methods\n\t\tsuper.doOptions(request, new HttpServletResponseWrapper(response) {\n\t\t\t@Override\n\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\tif (HttpHeaders.ALLOW.equals(name)) {\n\t\t\t\t\tvalue = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name();\n\t\t\t\t}\n\t\t\t\tsuper.setHeader(name, value);\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPost(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate POST requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 911
    },
    "return": "void",
    "signature": "protected void doPost(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doPut(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate PUT requests to {@link #processRequest}.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 922
    },
    "return": "void",
    "signature": "protected void doPut(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void doPut(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#doService(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Subclasses must implement this method to do the work of request handling,\n\t * receiving a centralized callback for GET, POST, PUT and DELETE.\n\t * <p>The contract is essentially the same as that for the commonly overridden\n\t * {@code doGet} or {@code doPost} methods of HttpServlet.\n\t * <p>This class intercepts calls to ensure that exception handling and\n\t * event publication takes place.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t * @see jakarta.servlet.http.HttpServlet#doGet\n\t * @see jakarta.servlet.http.HttpServlet#doPost\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1185
    },
    "return": "void",
    "signature": "protected void doService(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected abstract void doService(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception;\n\n\n\t/**\n\t * ApplicationListener endpoint that receives events from this servlet's WebApplicationContext\n\t * only, delegating to {@code onApplicationEvent} on the FrameworkServlet instance."
  },
  "org.springframework.web.servlet.<unknown>#doTrace(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegate TRACE requests to {@link #processRequest}, if desired.\n\t * <p>Applies HttpServlet's standard TRACE processing otherwise.\n\t * @see #doService\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 975
    },
    "return": "void",
    "signature": "protected void doTrace(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void doTrace(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.dispatchTraceRequest) {\n\t\t\tprocessRequest(request, response);\n\t\t\tif (\"message/http\".equals(response.getContentType())) {\n\t\t\t\t// Proper TRACE response coming from a handler - we're done.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// Work around until https://github.com/jakartaee/servlet/pull/545 is fixed and in use\n\t\tif (request.getDispatcherType() != DispatcherType.ERROR) {\n\t\t\tsuper.doTrace(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#getDefaultStrategies(context,strategyInterface)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a List of default strategy objects for the given strategy interface.\n\t * <p>The default implementation uses the \"DispatcherServlet.properties\" file (in the same\n\t * package as the DispatcherServlet class) to determine the class names. It instantiates\n\t * the strategy objects through the context's BeanFactory.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the List of corresponding strategy objects\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "strategyInterface"
    ],
    "position": {
      "column": 1,
      "line": 876
    },
    "return": "List<T>",
    "signature": "protected List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface)",
    "source_code": "\tprotected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {\n\t\tif (defaultStrategies == null) {\n\t\t\ttry {\n\t\t\t\t// Load default strategy implementations from properties file.\n\t\t\t\t// This is currently strictly internal and not meant to be customized\n\t\t\t\t// by application developers.\n\t\t\t\tClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n\t\t\t\tdefaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tString key = strategyInterface.getName();\n\t\tString value = defaultStrategies.getProperty(key);\n\t\tif (value != null) {\n\t\t\tString[] classNames = StringUtils.commaDelimitedListToStringArray(value);\n\t\t\tList<T> strategies = new ArrayList<>(classNames.length);\n\t\t\tfor (String className : classNames) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());\n\t\t\t\t\tObject strategy = createDefaultStrategy(context, clazz);\n\t\t\t\t\tstrategies.add((T) strategy);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Could not find DispatcherServlet's default strategy class [\" + className +\n\t\t\t\t\t\t\t\"] for interface [\" + key + \"]\", ex);\n\t\t\t\t}\n\t\t\t\tcatch (LinkageError err) {\n\t\t\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\t\t\"Unresolvable class definition for DispatcherServlet's default strategy class [\" +\n\t\t\t\t\t\t\tclassName + \"] for interface [\" + key + \"]\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn strategies;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#getDefaultStrategy(context,strategyInterface)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the default strategy object for the given strategy interface.\n\t * <p>The default implementation delegates to {@link #getDefaultStrategies},\n\t * expecting a single object in the list.\n\t * @param context the current WebApplicationContext\n\t * @param strategyInterface the strategy interface\n\t * @return the corresponding strategy object\n\t * @see #getDefaultStrategies\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "context",
      "strategyInterface"
    ],
    "position": {
      "column": 1,
      "line": 857
    },
    "return": "T",
    "signature": "protected T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface)",
    "source_code": "\tprotected <T> T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface) {\n\t\tList<T> strategies = getDefaultStrategies(context, strategyInterface);\n\t\tif (strategies.size() != 1) {\n\t\t\tthrow new BeanInitializationException(\n\t\t\t\t\t\"DispatcherServlet needs exactly 1 strategy for interface [\" + strategyInterface.getName() + \"]\");\n\t\t}\n\t\treturn strategies.get(0);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#noHandlerFound(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * No handler found &rarr; set appropriate HTTP response status.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception if preparing the response failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1298
    },
    "return": "void",
    "signature": "protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tif (pageNotFoundLogger.isWarnEnabled()) {\n\t\t\tpageNotFoundLogger.warn(\"No mapping for \" + request.getMethod() + \" \" + getRequestUri(request));\n\t\t}\n\t\tif (this.throwExceptionIfNoHandlerFound) {\n\t\t\tthrow new NoHandlerFoundException(request.getMethod(), getRequestUri(request),\n\t\t\t\t\tnew ServletServerHttpRequest(request).getHeaders());\n\t\t}\n\t\telse {\n\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#postProcess(webRequest,task,concurrentResult)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task",
      "concurrentResult"
    ],
    "position": {
      "column": 1,
      "line": 1218
    },
    "return": "void",
    "signature": "public void postProcess(NativeWebRequest webRequest, Callable<T> task, @Nullable Object concurrentResult)",
    "source_code": "\t\tpublic <T> void postProcess(NativeWebRequest webRequest, Callable<T> task, @Nullable Object concurrentResult) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tresetContextHolders(request, null, null);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#preProcess(webRequest,task)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "task"
    ],
    "position": {
      "column": 1,
      "line": 1209
    },
    "return": "void",
    "signature": "public void preProcess(NativeWebRequest webRequest, Callable<T> task)",
    "source_code": "\t\tpublic <T> void preProcess(NativeWebRequest webRequest, Callable<T> task) {\n\t\t\tHttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\t\tif (request != null) {\n\t\t\t\tHttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\t\t\t\tinitContextHolders(request, buildLocaleContext(request),\n\t\t\t\t\t\tbuildRequestAttributes(request, response, null));\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.<unknown>#processHandlerException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine an error ModelAndView via the registered HandlerExceptionResolvers.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the time of the exception\n\t * (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to\n\t * @throws Exception if no error ModelAndView found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 1339
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n\t\t\t@Nullable Object handler, Exception ex) throws Exception {\n\n\t\t// Success and error responses may use different content types\n\t\trequest.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\t\t// Reset the response body buffer if the response is not committed already,\n\t\t// leaving the response headers in place.\n\t\ttry {\n\t\t\tresponse.resetBuffer();\n\t\t}\n\t\tcatch (IllegalStateException illegalStateException) {\n\t\t\t// the response is already committed, leave it to exception handlers anyway\n\t\t}\n\n\t\t// Check registered HandlerExceptionResolvers...\n\t\tModelAndView exMv = null;\n\t\tif (this.handlerExceptionResolvers != null) {\n\t\t\tfor (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {\n\t\t\t\texMv = resolver.resolveException(request, response, handler, ex);\n\t\t\t\tif (exMv != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (exMv != null) {\n\t\t\tif (exMv.isEmpty()) {\n\t\t\t\trequest.setAttribute(EXCEPTION_ATTRIBUTE, ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// We might still need view name translation for a plain error model...\n\t\t\tif (!exMv.hasView()) {\n\t\t\t\tString defaultViewName = getDefaultViewName(request);\n\t\t\t\tif (defaultViewName != null) {\n\t\t\t\t\texMv.setViewName(defaultViewName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Using resolved error view: \" + exMv, ex);\n\t\t\t}\n\t\t\telse if (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using resolved error view: \" + exMv);\n\t\t\t}\n\t\t\tWebUtils.exposeErrorRequestAttributes(request, ex, getServletName());\n\t\t\treturn exMv;\n\t\t}\n\n\t\tthrow ex;\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#processRequest(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process this request, publishing an event regardless of the outcome.\n\t * <p>The actual event handling is performed by the abstract\n\t * {@link #doService} template method.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 996
    },
    "return": "void",
    "signature": "protected void processRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tThrowable failureCause = null;\n\n\t\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\t\tLocaleContext localeContext = buildLocaleContext(request);\n\n\t\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\t\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n\t\tinitContextHolders(request, localeContext, requestAttributes);\n\n\t\ttry {\n\t\t\tdoService(request, response);\n\t\t}\n\t\tcatch (ServletException | IOException ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureCause = ex;\n\t\t\tthrow new ServletException(\"Request processing failed: \" + ex, ex);\n\t\t}\n\n\t\tfinally {\n\t\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);\n\t\t\tif (requestAttributes != null) {\n\t\t\t\trequestAttributes.requestCompleted();\n\t\t\t}\n\t\t\tlogResult(request, response, failureCause, asyncManager);\n\t\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#render(mv,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Render the given ModelAndView.\n\t * <p>This is the last stage in handling a request. It may involve resolving the view by name.\n\t * @param mv the ModelAndView to render\n\t * @param request current HTTP servlet request\n\t * @param response current HTTP servlet response\n\t * @throws ServletException if view is missing or cannot be resolved\n\t * @throws Exception if there's a problem rendering the view\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mv",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 1397
    },
    "return": "void",
    "signature": "protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\t// Determine locale for request and apply it to the response.\n\t\tLocale locale =\n\t\t\t\t(this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t// We need to resolve the view name.\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No need to lookup: the ModelAndView object contains the actual View object.\n\t\t\tview = mv.getView();\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a \" +\n\t\t\t\t\t\t\"View object in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\n\t\tif (view instanceof SmartView smartView) {\n\t\t\tsmartView.resolveNestedViews(this::resolveViewNameInternal, locale);\n\t\t}\n\n\t\t// Delegate to the View object for rendering.\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Rendering view [\" + view + \"] \");\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, mv.getStatus());\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#resolveViewName(viewName,Map<String,model,locale,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve the given view name into a View object (to be rendered).\n\t * <p>The default implementations asks all ViewResolvers of this dispatcher.\n\t * Can be overridden for custom resolution strategies, potentially based on\n\t * specific model attributes or request parameters.\n\t * @param viewName the name of the view to resolve\n\t * @param model the model to be passed to the view\n\t * @param locale the current locale\n\t * @param request current HTTP servlet request\n\t * @return the View object, or {@code null} if none found\n\t * @throws Exception if the view cannot be resolved\n\t * (typically in case of problems creating an actual View object)\n\t * @see ViewResolver#resolveViewName\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "Map<String",
      "model",
      "locale",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 1471
    },
    "return": "View",
    "signature": "protected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\t\tLocale locale, HttpServletRequest request)",
    "source_code": "\tprotected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\t\tLocale locale, HttpServletRequest request) throws Exception {\n\n\t\treturn resolveViewNameInternal(viewName, locale);\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#service(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Override the parent class implementation in order to intercept requests\n\t * using PATCH or non-standard HTTP methods (WebDAV).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 881
    },
    "return": "void",
    "signature": "protected void service(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (HTTP_SERVLET_METHODS.contains(request.getMethod())) {\n\t\t\tsuper.service(request, response);\n\t\t}\n\t\telse {\n\t\t\tprocessRequest(request, response);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 960
    },
    "return": "void",
    "signature": "public void setHeader(String name, String value)",
    "source_code": "\t\t\tpublic void setHeader(String name, String value) {\n\t\t\t\tif (HttpHeaders.ALLOW.equals(name)) {\n\t\t\t\t\tvalue = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name();\n\t\t\t\t}\n\t\t\t\tsuper.setHeader(name, value);\n\t\t\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#parse(element,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext context)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext context) {\n\t\tObject source = context.extractSource(element);\n\t\tXmlReaderContext readerContext = context.getReaderContext();\n\n\t\tCompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);\n\t\tcontext.pushContainingComponent(compDefinition);\n\n\t\tRuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, context);\n\n\t\tRootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n\t\thandlerMappingDef.setSource(source);\n\t\thandlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerMappingDef.getPropertyValues().add(\"order\", 0);\n\t\thandlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\n\t\tif (element.hasAttribute(\"enable-matrix-variables\")) {\n\t\t\tboolean enableMatrixVariables = Boolean.parseBoolean(element.getAttribute(\"enable-matrix-variables\"));\n\t\t\thandlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n\t\t}\n\n\t\tconfigurePathMatchingProperties(handlerMappingDef, element, context);\n\t\treaderContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);\n\n\t\tRuntimeBeanReference corsRef = MvcNamespaceUtils.registerCorsConfigurations(null, context, source);\n\t\thandlerMappingDef.getPropertyValues().add(\"corsConfigurations\", corsRef);\n\n\t\tRuntimeBeanReference conversionService = getConversionService(element, source, context);\n\t\tRuntimeBeanReference validator = getValidator(element, source, context);\n\t\tRuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);\n\n\t\tRootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);\n\t\tbindingDef.setSource(source);\n\t\tbindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tbindingDef.getPropertyValues().add(\"conversionService\", conversionService);\n\t\tbindingDef.getPropertyValues().add(\"validator\", validator);\n\t\tbindingDef.getPropertyValues().add(\"messageCodesResolver\", messageCodesResolver);\n\n\t\tManagedList<?> messageConverters = getMessageConverters(element, source, context);\n\t\tManagedList<?> argumentResolvers = getArgumentResolvers(element, context);\n\t\tManagedList<?> returnValueHandlers = getReturnValueHandlers(element, context);\n\t\tString asyncTimeout = getAsyncTimeout(element);\n\t\tRuntimeBeanReference asyncExecutor = getAsyncExecutor(element);\n\t\tManagedList<?> callableInterceptors = getInterceptors(element, source, context, \"callable-interceptors\");\n\t\tManagedList<?> deferredResultInterceptors = getInterceptors(element, source, context, \"deferred-result-interceptors\");\n\n\t\tRootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);\n\t\thandlerAdapterDef.setSource(source);\n\t\thandlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerAdapterDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\thandlerAdapterDef.getPropertyValues().add(\"webBindingInitializer\", bindingDef);\n\t\thandlerAdapterDef.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\taddRequestBodyAdvice(handlerAdapterDef);\n\t\taddResponseBodyAdvice(handlerAdapterDef);\n\n\t\tif (element.hasAttribute(\"ignore-default-model-on-redirect\")) {\n\t\t\tBoolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\"ignore-default-model-on-redirect\"));\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n\t\t}\n\t\tif (argumentResolvers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tif (asyncTimeout != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"asyncRequestTimeout\", asyncTimeout);\n\t\t}\n\t\tif (asyncExecutor != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"taskExecutor\", asyncExecutor);\n\t\t}\n\n\t\thandlerAdapterDef.getPropertyValues().add(\"callableInterceptors\", callableInterceptors);\n\t\thandlerAdapterDef.getPropertyValues().add(\"deferredResultInterceptors\", deferredResultInterceptors);\n\t\treaderContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);\n\n\t\tRootBeanDefinition uriContributorDef =\n\t\t\t\tnew RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);\n\t\turiContributorDef.setSource(source);\n\t\turiContributorDef.getPropertyValues().addPropertyValue(\"handlerAdapter\", handlerAdapterDef);\n\t\turiContributorDef.getPropertyValues().addPropertyValue(\"conversionService\", conversionService);\n\t\tString uriContributorName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;\n\t\treaderContext.getRegistry().registerBeanDefinition(uriContributorName, uriContributorDef);\n\n\t\tRootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);\n\t\tcsInterceptorDef.setSource(source);\n\t\tcsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);\n\t\tRootBeanDefinition mappedInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);\n\t\tmappedInterceptorDef.setSource(source);\n\t\tmappedInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);\n\t\tmappedInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);\n\t\tString mappedInterceptorName = readerContext.registerWithGeneratedName(mappedInterceptorDef);\n\n\t\tRootBeanDefinition methodExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);\n\t\tmethodExceptionResolver.setSource(source);\n\t\tmethodExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\tmethodExceptionResolver.getPropertyValues().add(\"order\", 0);\n\t\taddResponseBodyAdvice(methodExceptionResolver);\n\t\tif (argumentResolvers != null) {\n\t\t\tmethodExceptionResolver.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\tmethodExceptionResolver.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tString methodExResolverName = readerContext.registerWithGeneratedName(methodExceptionResolver);\n\n\t\tRootBeanDefinition statusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);\n\t\tstatusExceptionResolver.setSource(source);\n\t\tstatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tstatusExceptionResolver.getPropertyValues().add(\"order\", 1);\n\t\tString statusExResolverName = readerContext.registerWithGeneratedName(statusExceptionResolver);\n\n\t\tRootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);\n\t\tdefaultExceptionResolver.setSource(source);\n\t\tdefaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tdefaultExceptionResolver.getPropertyValues().add(\"order\", 2);\n\t\tString defaultExResolverName = readerContext.registerWithGeneratedName(defaultExceptionResolver);\n\n\t\tcontext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME));\n\t\tcontext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME));\n\t\tcontext.registerComponent(new BeanComponentDefinition(uriContributorDef, uriContributorName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(mappedInterceptorDef, mappedInterceptorName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(methodExceptionResolver, methodExResolverName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(statusExceptionResolver, statusExResolverName));\n\t\tcontext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExResolverName));\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(context, source);\n\n\t\tcontext.popAndRegisterContainingComponent();\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#parse(element,parserContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "element",
      "parserContext"
    ],
    "position": {
      "column": 1,
      "line": 65
    },
    "return": "BeanDefinition",
    "signature": "public BeanDefinition parse(Element element, ParserContext parserContext)",
    "source_code": "\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tObject source = parserContext.extractSource(element);\n\n\t\t// Register SimpleUrlHandlerMapping for view controllers\n\t\tBeanDefinition hm = registerHandlerMapping(parserContext, source);\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(parserContext, source);\n\n\t\t// Create view controller bean definition\n\t\tRootBeanDefinition controller = new RootBeanDefinition(ParameterizableViewController.class);\n\t\tcontroller.setSource(source);\n\n\t\tHttpStatusCode statusCode = null;\n\t\tif (element.hasAttribute(\"status-code\")) {\n\t\t\tint statusValue = Integer.parseInt(element.getAttribute(\"status-code\"));\n\t\t\tstatusCode = HttpStatusCode.valueOf(statusValue);\n\t\t}\n\n\t\tString name = element.getLocalName();\n\t\tswitch (name) {\n\t\t\tcase \"view-controller\" -> {\n\t\t\t\tif (element.hasAttribute(\"view-name\")) {\n\t\t\t\t\tcontroller.getPropertyValues().add(\"viewName\", element.getAttribute(\"view-name\"));\n\t\t\t\t}\n\t\t\t\tif (statusCode != null) {\n\t\t\t\t\tcontroller.getPropertyValues().add(\"statusCode\", statusCode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase \"redirect-view-controller\" ->\n\t\t\t\tcontroller.getPropertyValues().add(\"view\", getRedirectView(element, statusCode, source));\n\t\t\tcase \"status-controller\" -> {\n\t\t\t\tcontroller.getPropertyValues().add(\"statusCode\", statusCode);\n\t\t\t\tcontroller.getPropertyValues().add(\"statusOnly\", true);\n\t\t\t}\n\t\t\tdefault ->\n\t\t\t\t// Should never happen...\n\t\t\t\tthrow new IllegalStateException(\"Unexpected tag name: \" + name);\n\t\t}\n\n\t\tMap<String, BeanDefinition> urlMap = (Map<String, BeanDefinition>) hm.getPropertyValues().get(\"urlMap\");\n\t\tif (urlMap == null) {\n\t\t\turlMap = new ManagedMap<>();\n\t\t\thm.getPropertyValues().add(\"urlMap\", urlMap);\n\t\t}\n\t\turlMap.put(element.getAttribute(\"path\"), controller);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerCorsConfigurations(Map<String,corsConfigurations,context,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Registers a {@code Map<String, CorsConfiguration>} (mapped {@code CorsConfiguration}s)\n\t * under a well-known name unless already registered. The bean definition may be updated\n\t * if a non-null CORS configuration is provided.\n\t * @return a RuntimeBeanReference to this {@code Map<String, CorsConfiguration>} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerCorsConfigurations(@Nullable Map<String, CorsConfiguration> corsConfigurations,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerCorsConfigurations(\n\t\t\t@Nullable Map<String, CorsConfiguration> corsConfigurations,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (!context.getRegistry().containsBeanDefinition(CORS_CONFIGURATION_BEAN_NAME)) {\n\t\t\tRootBeanDefinition corsDef = new RootBeanDefinition(LinkedHashMap.class);\n\t\t\tcorsDef.setSource(source);\n\t\t\tcorsDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tif (corsConfigurations != null) {\n\t\t\t\tcorsDef.getConstructorArgumentValues().addIndexedArgumentValue(0, corsConfigurations);\n\t\t\t}\n\t\t\tcontext.getReaderContext().getRegistry().registerBeanDefinition(CORS_CONFIGURATION_BEAN_NAME, corsDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(corsDef, CORS_CONFIGURATION_BEAN_NAME));\n\t\t}\n\t\telse if (corsConfigurations != null) {\n\t\t\tBeanDefinition corsDef = context.getRegistry().getBeanDefinition(CORS_CONFIGURATION_BEAN_NAME);\n\t\t\tcorsDef.getConstructorArgumentValues().addIndexedArgumentValue(0, corsConfigurations);\n\t\t}\n\t\treturn new RuntimeBeanReference(CORS_CONFIGURATION_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerDefaultComponents(context,source)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "void",
    "signature": "public void registerDefaultComponents(ParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static void registerDefaultComponents(ParserContext context, @Nullable Object source) {\n\t\tregisterBeanNameUrlHandlerMapping(context, source);\n\t\tregisterHttpRequestHandlerAdapter(context, source);\n\t\tregisterSimpleControllerHandlerAdapter(context, source);\n\t\tregisterHandlerMappingIntrospector(context, source);\n\t\tregisterLocaleResolver(context, source);\n\t\tregisterThemeResolver(context, source);\n\t\tregisterViewNameTranslator(context, source);\n\t\tregisterFlashMapManager(context, source);\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerPathMatcher(pathMatcherRef,context,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link PathMatcher}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link PathMatcher} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathMatcherRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerPathMatcher(@Nullable RuntimeBeanReference pathMatcherRef,\n\t\t\tParserContext context, @Nullable Object source) {\n\n\t\tif (pathMatcherRef != null) {\n\t\t\tif (context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(PATH_MATCHER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(pathMatcherRef.getBeanName(), PATH_MATCHER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(PATH_MATCHER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition pathMatcherDef = new RootBeanDefinition(AntPathMatcher.class);\n\t\t\tpathMatcherDef.setSource(source);\n\t\t\tpathMatcherDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(PATH_MATCHER_BEAN_NAME, pathMatcherDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(pathMatcherDef, PATH_MATCHER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(PATH_MATCHER_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.config.<unknown>#registerUrlPathHelper(urlPathHelperRef,context,source)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adds an alias to an existing well-known name or registers a new instance of a {@link UrlPathHelper}\n\t * under that well-known name, unless already registered.\n\t * @return a RuntimeBeanReference to this {@link UrlPathHelper} instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPathHelperRef",
      "context",
      "source"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "RuntimeBeanReference",
    "signature": "public RuntimeBeanReference registerUrlPathHelper(@Nullable RuntimeBeanReference urlPathHelperRef, ParserContext context, @Nullable Object source)",
    "source_code": "\tpublic static RuntimeBeanReference registerUrlPathHelper(\n\t\t\t@Nullable RuntimeBeanReference urlPathHelperRef, ParserContext context, @Nullable Object source) {\n\n\t\tif (urlPathHelperRef != null) {\n\t\t\tif (context.getRegistry().isAlias(URL_PATH_HELPER_BEAN_NAME)) {\n\t\t\t\tcontext.getRegistry().removeAlias(URL_PATH_HELPER_BEAN_NAME);\n\t\t\t}\n\t\t\tcontext.getRegistry().registerAlias(urlPathHelperRef.getBeanName(), URL_PATH_HELPER_BEAN_NAME);\n\t\t}\n\t\telse if (!context.getRegistry().isAlias(URL_PATH_HELPER_BEAN_NAME) &&\n\t\t\t\t!context.getRegistry().containsBeanDefinition(URL_PATH_HELPER_BEAN_NAME)) {\n\t\t\tRootBeanDefinition urlPathHelperDef = new RootBeanDefinition(UrlPathHelper.class);\n\t\t\turlPathHelperDef.setSource(source);\n\t\t\turlPathHelperDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\t\tcontext.getRegistry().registerBeanDefinition(URL_PATH_HELPER_BEAN_NAME, urlPathHelperDef);\n\t\t\tcontext.registerComponent(new BeanComponentDefinition(urlPathHelperDef, URL_PATH_HELPER_BEAN_NAME));\n\t\t}\n\t\treturn new RuntimeBeanReference(URL_PATH_HELPER_BEAN_NAME);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addAll(Entry<String,c)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Entry<String",
      "c"
    ],
    "position": {
      "column": 1,
      "line": 532
    },
    "return": "boolean",
    "signature": "public boolean addAll(Collection<? extends Entry<String, Object>> c)",
    "source_code": "\t\t\t\tpublic boolean addAll(Collection<? extends Entry<String, Object>> c) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addDateHeader(name,date)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 695
    },
    "return": "void",
    "signature": "public void addDateHeader(String name, long date)",
    "source_code": "\t\tpublic void addDateHeader(String name, long date) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addErrorHandler(predicate,BiFunction<Throwable,ServerRequest,errorHandler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "predicate",
      "BiFunction<Throwable",
      "ServerRequest",
      "errorHandler"
    ],
    "position": {
      "column": 1,
      "line": 47
    },
    "return": "void",
    "signature": "protected void addErrorHandler(Predicate<Throwable> predicate,\n\t\t\tBiFunction<Throwable, ServerRequest, T> errorHandler)",
    "source_code": "\tprotected final <T extends ServerResponse> void addErrorHandler(Predicate<Throwable> predicate,\n\t\t\tBiFunction<Throwable, ServerRequest, T> errorHandler) {\n\n\t\tAssert.notNull(predicate, \"Predicate must not be null\");\n\t\tAssert.notNull(errorHandler, \"ErrorHandler must not be null\");\n\t\tthis.errorHandlers.add(new ErrorHandler<>(predicate, errorHandler));\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 523
    },
    "return": "void",
    "signature": "public void addHeader(String name, String value)",
    "source_code": "\t\t\tpublic void addHeader(String name, String value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#addIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 516
    },
    "return": "void",
    "signature": "public void addIntHeader(String name, int value)",
    "source_code": "\t\t\tpublic void addIntHeader(String name, int value) {\n\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n\t\t\t\t\tsuper.addIntHeader(name, value);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#attributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 64
    },
    "return": "void",
    "signature": "public void attributes(Map<String, Object> attributes)",
    "source_code": "\tpublic void attributes(Map<String, Object> attributes) {\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#bind(bindType,dataBinderCustomizer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindType",
      "dataBinderCustomizer"
    ],
    "position": {
      "column": 1,
      "line": 1199
    },
    "return": "T",
    "signature": "public T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer)",
    "source_code": "\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\treturn this.delegate.bind(bindType, dataBinderCustomizer);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#checkNotModified(lastModified,etag)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lastModified",
      "etag"
    ],
    "position": {
      "column": 1,
      "line": 1264
    },
    "return": "Optional<ServerResponse>",
    "signature": "public Optional<ServerResponse> checkNotModified(Instant lastModified, String etag)",
    "source_code": "\t\tpublic Optional<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.delegate.checkNotModified(lastModified, etag);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#create(sseConsumer,timeout)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sseConsumer",
      "timeout"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "ServerResponse",
    "signature": "public ServerResponse create(Consumer<SseBuilder> sseConsumer, @Nullable Duration timeout)",
    "source_code": "\tpublic static ServerResponse create(Consumer<SseBuilder> sseConsumer, @Nullable Duration timeout) {\n\t\tAssert.notNull(sseConsumer, \"SseConsumer must not be null\");\n\n\t\treturn new SseServerResponse(sseConsumer, timeout);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#errorResponse(t,servletRequest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "servletRequest"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "ServerResponse",
    "signature": "protected ServerResponse errorResponse(Throwable t, HttpServletRequest servletRequest)",
    "source_code": "\tprotected final ServerResponse errorResponse(Throwable t, HttpServletRequest servletRequest) {\n\t\tfor (ErrorHandler<?> errorHandler : this.errorHandlers) {\n\t\t\tif (errorHandler.test(t)) {\n\t\t\t\tServerRequest serverRequest = (ServerRequest)\n\t\t\t\t\t\tservletRequest.getAttribute(RouterFunctions.REQUEST_ATTRIBUTE);\n\t\t\t\treturn errorHandler.handle(t, serverRequest);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handle(t,serverRequest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "t",
      "serverRequest"
    ],
    "position": {
      "column": 1,
      "line": 103
    },
    "return": "T",
    "signature": "public T handle(Throwable t, ServerRequest serverRequest)",
    "source_code": "\t\tpublic T handle(Throwable t, ServerRequest serverRequest) {\n\t\t\treturn this.responseProvider.apply(t, serverRequest);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#handleError(t,servletRequest,servletResponse,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "t",
      "servletRequest",
      "servletResponse",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleError(Throwable t, HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse, Context context)",
    "source_code": "\tprotected final ModelAndView handleError(Throwable t, HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse, Context context) throws ServletException, IOException {\n\n\t\tServerResponse serverResponse = errorResponse(t, servletRequest);\n\t\tif (serverResponse != null) {\n\t\t\treturn serverResponse.writeTo(servletRequest, servletResponse, context);\n\t\t}\n\t\telse if (t instanceof ServletException servletException) {\n\t\t\tthrow servletException;\n\t\t}\n\t\telse if (t instanceof IOException ioException ) {\n\t\t\tthrow ioException;\n\t\t}\n\t\telse {\n\t\t\tthrow new ServletException(t);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#modifyAttributes(Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 510
    },
    "return": "void",
    "signature": "public void modifyAttributes(Map<String, Object> attributes)",
    "source_code": "\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#of(value,Consumer<Map<String,modifyAttributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "value",
      "Consumer<Map<String",
      "modifyAttributes"
    ],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "Result",
    "signature": "public Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes)",
    "source_code": "\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#param(name,predicate)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that tests the request's parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the parameter to test against\n\t * @param predicate the predicate to test against the parameter value\n\t * @return a predicate that matches the given predicate against the parameter of the given name\n\t * @see ServerRequest#param(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "predicate"
    ],
    "position": {
      "column": 1,
      "line": 309
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate param(String name, Predicate<String> predicate)",
    "source_code": "\tpublic static RequestPredicate param(String name, Predicate<String> predicate) {\n\t\treturn new ParamPredicate(name, predicate);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#param(name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's parameter of the given name\n\t * has the given value.\n\t * @param name the name of the parameter to test against\n\t * @param value the value of the parameter to test against\n\t * @return a predicate that matches if the parameter has the given value\n\t * @see ServerRequest#param(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "RequestPredicate",
    "signature": "public RequestPredicate param(String name, String value)",
    "source_code": "\tpublic static RequestPredicate param(String name, String value) {\n\t\treturn new ParamPredicate(name, value);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 565
    },
    "return": "Object",
    "signature": "public Object put(String key, Object value)",
    "source_code": "\t\tpublic Object put(String key, Object value) {\n\t\t\tObject oldValue = this.servletRequest.getAttribute(key);\n\t\t\tthis.servletRequest.setAttribute(key, value);\n\t\t\treturn oldValue;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#read(b,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 450
    },
    "return": "int",
    "signature": "public int read(byte[] b, int off, int len)",
    "source_code": "\t\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t\t\treturn this.delegate.read(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#resources(Function<ServerRequest,lookupFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<ServerRequest",
      "lookupFunction"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "public void resources(Function<ServerRequest, Optional<Resource>> lookupFunction)",
    "source_code": "\tpublic void resources(Function<ServerRequest, Optional<Resource>> lookupFunction) {\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#route(predicate,handlerFunction)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "predicate",
      "handlerFunction"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "void",
    "signature": "public void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction)",
    "source_code": "\tpublic void route(RequestPredicate predicate, HandlerFunction<?> handlerFunction) {\n\t\tchangeParser(predicate);\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendError(sc,msg)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sc",
      "msg"
    ],
    "position": {
      "column": 1,
      "line": 675
    },
    "return": "void",
    "signature": "public void sendError(int sc, String msg)",
    "source_code": "\t\tpublic void sendError(int sc, String msg) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#sendRedirect(location,sc,clearBuffer)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "sc",
      "clearBuffer"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "void",
    "signature": "public void sendRedirect(String location, int sc, boolean clearBuffer)",
    "source_code": "\t\tpublic void sendRedirect(String location, int sc, boolean clearBuffer) throws IOException {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setDateHeader(name,date)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "date"
    ],
    "position": {
      "column": 1,
      "line": 615
    },
    "return": "void",
    "signature": "public void setDateHeader(String name, long date)",
    "source_code": "\t\tpublic void setDateHeader(String name, long date) {\n\t\t\tthis.headers.setDate(name, date);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 620
    },
    "return": "void",
    "signature": "public void setHeader(String name, String value)",
    "source_code": "\t\tpublic void setHeader(String name, String value) {\n\t\t\tthis.headers.set(name, value);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#setIntHeader(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "void",
    "signature": "public void setIntHeader(String name, int value)",
    "source_code": "\t\tpublic void setIntHeader(String name, int value) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#tryWriteEntityWithMessageConverters(entity,request,response,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "entity",
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "void",
    "signature": "protected void tryWriteEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)",
    "source_code": "\t\tprotected void tryWriteEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context) throws ServletException, IOException {\n\t\t\ttry {\n\t\t\t\twriteEntityWithMessageConverters(entity, request, response, context);\n\t\t\t}\n\t\t\tcatch (IOException | ServletException ex) {\n\t\t\t\thandleError(ex, request, response, context);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#write(object,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "StreamBuilder",
    "signature": "public StreamBuilder write(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic StreamBuilder write(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\t\tAssert.notNull(object, \"data must not be null\");\n\t\t\ttry {\n\t\t\t\tif (object instanceof byte[] bytes) {\n\t\t\t\t\tthis.outputMessage.getBody().write(bytes);\n\t\t\t\t}\n\t\t\t\telse if (object instanceof String str) {\n\t\t\t\t\tthis.outputMessage.getBody().write(str.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteObject(object, mediaType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthis.sendFailed = true;\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeEntityWithMessageConverters(entity,request,response,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "entity",
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)",
    "source_code": "\t\tprotected void writeEntityWithMessageConverters(Object entity, HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, ServerResponse.Context context)\n\t\t\t\tthrows ServletException, IOException {\n\n\t\t\tServletServerHttpResponse serverResponse = new ServletServerHttpResponse(response);\n\t\t\tMediaType contentType = getContentType(response);\n\t\t\tClass<?> entityClass = entity.getClass();\n\t\t\tType entityType = this.entityType;\n\n\t\t\tif (entityClass != InputStreamResource.class && Resource.class.isAssignableFrom(entityClass)) {\n\t\t\t\tserverResponse.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\t\tString rangeHeader = request.getHeader(HttpHeaders.RANGE);\n\t\t\t\tif (rangeHeader != null) {\n\t\t\t\t\tResource resource = (Resource) entity;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tList<HttpRange> httpRanges = HttpRange.parseRanges(rangeHeader);\n\t\t\t\t\t\tserverResponse.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n\t\t\t\t\t\tentity = HttpRange.toResourceRegions(httpRanges, resource);\n\t\t\t\t\t\tentityClass = entity.getClass();\n\t\t\t\t\t\tentityType = RESOURCE_REGION_LIST_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\t\tserverResponse.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\t\t\tserverResponse.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (HttpMessageConverter<?> messageConverter : context.messageConverters()) {\n\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter genericMessageConverter) {\n\t\t\t\t\tif (genericMessageConverter.canWrite(entityType, entityClass, contentType)) {\n\t\t\t\t\t\tgenericMessageConverter.write(entity, entityType, contentType, serverResponse);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (messageConverter instanceof SmartHttpMessageConverter smartMessageConverter) {\n\t\t\t\t\tResolvableType resolvableType = ResolvableType.forType(entityType);\n\t\t\t\t\tif (smartMessageConverter.canWrite(resolvableType, entityClass, contentType)) {\n\t\t\t\t\t\tsmartMessageConverter.write(entity, resolvableType, contentType, serverResponse, null);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (messageConverter.canWrite(entityClass, contentType)) {\n\t\t\t\t\t((HttpMessageConverter<Object>) messageConverter).write(entity, contentType, serverResponse);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<MediaType> producibleMediaTypes = producibleMediaTypes(context.messageConverters(), entityClass);\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n\t\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(request,response,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 72
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest request, HttpServletResponse response, Context context)",
    "source_code": "\tprotected ModelAndView writeToInternal(HttpServletRequest request, HttpServletResponse response, Context context) throws Exception {\n\t\tDeferredResult<?> result;\n\t\tif (this.timeout != null) {\n\t\t\tresult = new DeferredResult<>(this.timeout.toMillis());\n\t\t}\n\t\telse {\n\t\t\tresult = new DeferredResult<>();\n\t\t}\n\t\tDefaultAsyncServerResponse.writeAsync(request, response, result);\n\t\tthis.streamConsumer.accept(new DefaultStreamBuilder(response, context, result, this.headers()));\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.function.<unknown>#writeToInternal(servletRequest,servletResponse,context)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "servletRequest",
      "servletResponse",
      "context"
    ],
    "position": {
      "column": 1,
      "line": 425
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,\n\t\t\t\tContext context)",
    "source_code": "\t\tprotected ModelAndView writeToInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse,\n\t\t\t\tContext context) throws ServletException, IOException {\n\n\t\t\tDeferredResult<?> deferredResult = new DeferredResult<>();\n\t\t\tDefaultAsyncServerResponse.writeAsync(servletRequest, servletResponse, deferredResult);\n\n\t\t\tentity().subscribe(new DeferredResultSubscriber(servletRequest, servletResponse, context, deferredResult));\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.function.support.<unknown>#getLastModified(request,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 179
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.function.support.<unknown>#handle(servletRequest,servletResponse,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse,\n\t\t\tObject handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest servletRequest,\n\t\t\tHttpServletResponse servletResponse,\n\t\t\tObject handler) throws Exception {\n\n\t\tWebAsyncManager asyncManager = getWebAsyncManager(servletRequest, servletResponse);\n\t\tservletResponse = getWrappedResponse(asyncManager);\n\n\t\tServerRequest serverRequest = getServerRequest(servletRequest);\n\t\tServerResponse serverResponse;\n\n\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\tserverResponse = handleAsync(asyncManager);\n\t\t}\n\t\telse {\n\t\t\tHandlerFunction<?> handlerFunction = (HandlerFunction<?>) handler;\n\t\t\tserverResponse = handlerFunction.handle(serverRequest);\n\t\t}\n\n\t\tif (serverResponse != null) {\n\t\t\treturn serverResponse.writeTo(servletRequest, servletResponse, new ServerRequestContext(serverRequest));\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#afterCompletion(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\n\t\tthis.requestInterceptor.afterCompletion(new DispatcherServletWebRequest(request, response), ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#afterConcurrentHandlingStarted(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "void",
    "signature": "public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) {\n\t\tif (this.requestInterceptor instanceof AsyncWebRequestInterceptor asyncInterceptor) {\n\t\t\tDispatcherServletWebRequest webRequest = new DispatcherServletWebRequest(request, response);\n\t\t\tasyncInterceptor.afterConcurrentHandlingStarted(webRequest);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#buildPathExposingHandler(rawHandler,bestMatchingPattern,pathWithinMapping,Map<String,uriTemplateVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a handler object for the given raw handler, exposing the actual\n\t * handler, the {@link #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE}, as well as\n\t * the {@link #URI_TEMPLATE_VARIABLES_ATTRIBUTE} before executing the handler.\n\t * <p>The default implementation builds a {@link HandlerExecutionChain}\n\t * with a special interceptor that exposes the path attribute and URI\n\t * template variables\n\t * @param rawHandler the raw handler to expose\n\t * @param pathWithinMapping the path to expose before executing the handler\n\t * @param uriTemplateVariables the URI template variables, can be {@code null} if no variables found\n\t * @return the final handler object\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "rawHandler",
      "bestMatchingPattern",
      "pathWithinMapping",
      "Map<String",
      "uriTemplateVariables"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "Object",
    "signature": "protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,\n\t\t\tString pathWithinMapping, @Nullable Map<String, String> uriTemplateVariables)",
    "source_code": "\tprotected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,\n\t\t\tString pathWithinMapping, @Nullable Map<String, String> uriTemplateVariables) {\n\n\t\tHandlerExecutionChain chain = new HandlerExecutionChain(rawHandler);\n\t\tchain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));\n\t\tif (!CollectionUtils.isEmpty(uriTemplateVariables)) {\n\t\t\tchain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#compare(match1,match2)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "match1",
      "match2"
    ],
    "position": {
      "column": 1,
      "line": 836
    },
    "return": "int",
    "signature": "public int compare(Match match1, Match match2)",
    "source_code": "\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#createHandlerMethod(handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the HandlerMethod instance.\n\t * @param handler either a bean name or an actual handler instance\n\t * @param method the target method\n\t * @return the created HandlerMethod\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 340
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod createHandlerMethod(Object handler, Method method)",
    "source_code": "\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tif (handler instanceof String beanName) {\n\t\t\treturn new HandlerMethod(beanName,\n\t\t\t\t\tobtainApplicationContext().getAutowireCapableBeanFactory(),\n\t\t\t\t\tobtainApplicationContext(),\n\t\t\t\t\tmethod);\n\t\t}\n\t\treturn new HandlerMethod(handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected final ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\tHandlerMethod handlerMethod = (handler instanceof HandlerMethod hm ? hm : null);\n\t\treturn doResolveHandlerMethodException(request, response, handlerMethod, ex);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#doResolveHandlerMethodException(request,response,handlerMethod,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Actually resolve the given exception that got thrown during on handler execution,\n\t * returning a ModelAndView that represents a specific error page if appropriate.\n\t * <p>May be overridden in subclasses, in order to apply specific exception checks.\n\t * Note that this template method will be invoked <i>after</i> checking whether this\n\t * resolved applies (\"mappedHandlers\" etc), so an implementation may simply proceed\n\t * with its actual exception handling.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod the executed handler method, or {@code null} if none chosen at the time\n\t * of the exception (for example, if multipart resolution failed)\n\t * @param ex the exception that got thrown during handler execution\n\t * @return a corresponding ModelAndView to forward to, or {@code null} for default processing\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 91
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex)",
    "source_code": "\tprotected abstract ModelAndView doResolveHandlerMethodException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex);\n\n}"
  },
  "org.springframework.web.servlet.handler.<unknown>#exposePathWithinMapping(bestMatchingPattern,pathWithinMapping,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the path within the current mapping as request attribute.\n\t * @param pathWithinMapping the path within the current mapping\n\t * @param request the request to expose the path to\n\t * @see #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bestMatchingPattern",
      "pathWithinMapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 471
    },
    "return": "void",
    "signature": "protected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping,\n\t\t\tHttpServletRequest request)",
    "source_code": "\tprotected void exposePathWithinMapping(String bestMatchingPattern, String pathWithinMapping,\n\t\t\tHttpServletRequest request) {\n\n\t\trequest.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestMatchingPattern);\n\t\tServerHttpObservationFilter.findObservationContext(request)\n\t\t\t\t.ifPresent(context -> context.setPathPattern(bestMatchingPattern));\n\t\trequest.setAttribute(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#exposeUriTemplateVariables(Map<String,uriTemplateVariables,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the URI templates variables as request attribute.\n\t * @param uriTemplateVariables the URI template variables\n\t * @param request the request to expose the path to\n\t * @see #PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "uriTemplateVariables",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 486
    },
    "return": "void",
    "signature": "protected void exposeUriTemplateVariables(Map<String, String> uriTemplateVariables, HttpServletRequest request)",
    "source_code": "\tprotected void exposeUriTemplateVariables(Map<String, String> uriTemplateVariables, HttpServletRequest request) {\n\t\trequest.setAttribute(URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriTemplateVariables);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getCorsConfiguration(handler,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the CORS configuration for the given handler.\n\t * @param handler the handler to check (never {@code null}).\n\t * @param request the current request.\n\t * @return the CORS configuration for the handler, or {@code null} if none\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 660
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) {\n\t\tObject resolvedHandler = handler;\n\t\tif (handler instanceof HandlerExecutionChain handlerExecutionChain) {\n\t\t\tresolvedHandler = handlerExecutionChain.getHandler();\n\t\t}\n\t\tif (resolvedHandler instanceof CorsConfigurationSource configSource) {\n\t\t\treturn configSource.getCorsConfiguration(request);\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getCorsHandlerExecutionChain(request,chain,config)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Update {@link HandlerExecutionChain} for CORS requests, inserting an\n\t * interceptor at the start of the chain to perform CORS checks, and\n\t * also using a no-op handler for preflight requests.\n\t * @param request the current request\n\t * @param chain the chain to update\n\t * @param config the CORS configuration applicable to the handler\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "chain",
      "config"
    ],
    "position": {
      "column": 1,
      "line": 680
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getCorsHandlerExecutionChain(HttpServletRequest request, HandlerExecutionChain chain, @Nullable CorsConfiguration config)",
    "source_code": "\tprotected HandlerExecutionChain getCorsHandlerExecutionChain(\n\t\t\tHttpServletRequest request, HandlerExecutionChain chain, @Nullable CorsConfiguration config) {\n\n\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\tPreFlightHttpRequestHandler handler = new PreFlightHttpRequestHandler(config);\n\t\t\tchain.addInterceptor(0, handler);\n\t\t\treturn new HandlerExecutionChain(handler, chain.getInterceptors());\n\t\t}\n\t\telse {\n\t\t\tchain.addInterceptor(0, new CorsInterceptor(config));\n\t\t\treturn chain;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getHandlerExecutionChain(handler,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@link HandlerExecutionChain} for the given handler, including\n\t * applicable interceptors.\n\t * <p>The default implementation builds a standard {@link HandlerExecutionChain}\n\t * with the given handler, the common interceptors of the handler mapping, and any\n\t * {@link MappedInterceptor MappedInterceptors} matching to the current request URL. Interceptors\n\t * are added in the order they were registered. Subclasses may override this\n\t * in order to extend/rearrange the list of interceptors.\n\t * <p><b>NOTE:</b> The passed-in handler object may be a raw handler or a\n\t * pre-built {@link HandlerExecutionChain}. This method should handle those\n\t * two cases explicitly, either building a new {@link HandlerExecutionChain}\n\t * or extending the existing chain.\n\t * <p>For simply adding an interceptor in a custom subclass, consider calling\n\t * {@code super.getHandlerExecutionChain(handler, request)} and invoking\n\t * {@link HandlerExecutionChain#addInterceptor} on the returned chain object.\n\t * @param handler the resolved handler instance (never {@code null})\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain (never {@code null})\n\t * @see #getAdaptedInterceptors()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 624
    },
    "return": "HandlerExecutionChain",
    "signature": "protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n\t\tHandlerExecutionChain chain = (handler instanceof HandlerExecutionChain handlerExecutionChain ?\n\t\t\t\thandlerExecutionChain : new HandlerExecutionChain(handler));\n\n\t\tfor (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n\t\t\tif (interceptor instanceof MappedInterceptor mappedInterceptor) {\n\t\t\t\tif (mappedInterceptor.matches(request)) {\n\t\t\t\t\tchain.addInterceptor(mappedInterceptor.getInterceptor());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchain.addInterceptor(interceptor);\n\t\t\t}\n\t\t}\n\t\treturn chain;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Provide the mapping for a handler method. A method for which no\n\t * mapping can be provided is not a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's\n\t * declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 521
    },
    "return": "T",
    "signature": "protected T getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);"
  },
  "org.springframework.web.servlet.handler.<unknown>#getMatchingMapping(mapping,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a mapping matches the current request and return a (potentially\n\t * new) mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param request the current HTTP servlet request\n\t * @return the match, or {@code null} if the mapping doesn't match\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 556
    },
    "return": "T",
    "signature": "protected T getMatchingMapping(T mapping, HttpServletRequest request)",
    "source_code": "\tprotected abstract T getMatchingMapping(T mapping, HttpServletRequest request);"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleMatch(mapping,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a matching mapping is found.\n\t * @param mapping the matching mapping\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mapping",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 461
    },
    "return": "void",
    "signature": "protected void handleMatch(T mapping, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected void handleMatch(T mapping, String lookupPath, HttpServletRequest request) {\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleNoMatch(mappings,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when no matching mapping is not found.\n\t * @param mappings all registered mappings\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t * @throws ServletException in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mappings",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 473
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(Set<T> mappings, String lookupPath, HttpServletRequest request)\n\t\t\tthrows Exception {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handlePreFlight(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 744
    },
    "return": "void",
    "signature": "public void handlePreFlight(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handlePreFlight(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t\tinvokeCorsProcessor(request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handleRequest(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 739
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n\t\t\t// no-op\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#handlerMethodsInitialized(Map<T,handlerMethods)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked after all handler methods have been detected.\n\t * @param handlerMethods a read-only map with handler methods and mappings.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<T",
      "handlerMethods"
    ],
    "position": {
      "column": 1,
      "line": 362
    },
    "return": "void",
    "signature": "protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods)",
    "source_code": "\tprotected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {\n\t\t// Total includes detected mappings + explicit registrations via registerMapping\n\t\tint total = handlerMethods.size();\n\t\tif ((logger.isTraceEnabled() && total == 0) || (logger.isDebugEnabled() && total > 0) ) {\n\t\t\tlogger.debug(total + \" mappings in \" + formatMappingName());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initCorsConfiguration(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Extract and return the CORS configuration for the mapping.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 354
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#initPatterns(patterns,parser)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "patterns",
      "parser"
    ],
    "position": {
      "column": 1,
      "line": 335
    },
    "return": "PatternAdapter[]",
    "signature": "public PatternAdapter[] initPatterns(@Nullable String[] patterns, @Nullable PathPatternParser parser)",
    "source_code": "\t\tpublic static PatternAdapter[] initPatterns(\n\t\t\t\t@Nullable String[] patterns, @Nullable PathPatternParser parser) {\n\n\t\t\tif (ObjectUtils.isEmpty(patterns)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.stream(patterns)\n\t\t\t\t\t.map(pattern -> new PatternAdapter(pattern, parser))\n\t\t\t\t\t.toArray(PatternAdapter[]::new);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#invokeCorsProcessor(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 723
    },
    "return": "boolean",
    "signature": "protected boolean invokeCorsProcessor(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tprotected boolean invokeCorsProcessor(\n\t\t\t\tHttpServletRequest request, HttpServletResponse response) throws IOException {\n\n\t\t\treturn corsProcessor.processRequest(this.config, request, response);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when String pattern matching with {@code PathMatcher} is in use.\n\t * @param lookupPath the path to match patterns against\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @see #exposePathWithinMapping\n\t * @see AntPathMatcher\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(String lookupPath, HttpServletRequest request) throws Exception {\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<String> matchingPatterns = new ArrayList<>();\n\t\tfor (String registeredPattern : this.handlerMap.keySet()) {\n\t\t\tif (getPathMatcher().match(registeredPattern, lookupPath)) {\n\t\t\t\tmatchingPatterns.add(registeredPattern);\n\t\t\t}\n\t\t\telse if (useTrailingSlashMatch()) {\n\t\t\t\tif (!registeredPattern.endsWith(\"/\") && getPathMatcher().match(registeredPattern + \"/\", lookupPath)) {\n\t\t\t\t\tmatchingPatterns.add(registeredPattern + \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString bestMatch = null;\n\t\tComparator<String> patternComparator = getPathMatcher().getPatternComparator(lookupPath);\n\t\tif (!matchingPatterns.isEmpty()) {\n\t\t\tmatchingPatterns.sort(patternComparator);\n\t\t\tif (logger.isTraceEnabled() && matchingPatterns.size() > 1) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matchingPatterns);\n\t\t\t}\n\t\t\tbestMatch = matchingPatterns.get(0);\n\t\t}\n\t\tif (bestMatch != null) {\n\t\t\thandler = this.handlerMap.get(bestMatch);\n\t\t\tif (handler == null) {\n\t\t\t\tif (bestMatch.endsWith(\"/\")) {\n\t\t\t\t\thandler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));\n\t\t\t\t}\n\t\t\t\tif (handler == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Could not find handler for best pattern match [\" + bestMatch + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Bean name or resolved handler?\n\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t\t}\n\t\t\tvalidateHandler(handler, request);\n\t\t\tString pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);\n\n\t\t\t// There might be multiple 'best patterns', let's make sure we have the correct URI template variables\n\t\t\t// for all of them\n\t\t\tMap<String, String> uriTemplateVariables = new LinkedHashMap<>();\n\t\t\tfor (String matchingPattern : matchingPatterns) {\n\t\t\t\tif (patternComparator.compare(bestMatch, matchingPattern) == 0) {\n\t\t\t\t\tMap<String, String> vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);\n\t\t\t\t\tMap<String, String> decodedVars = getUrlPathHelper().decodePathVariables(request, vars);\n\t\t\t\t\turiTemplateVariables.putAll(decodedVars);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled() && uriTemplateVariables.size() > 0) {\n\t\t\t\tlogger.trace(\"URI variables \" + uriTemplateVariables);\n\t\t\t}\n\t\t\treturn buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);\n\t\t}\n\n\t\t// No handler found...\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandler(path,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up a handler instance for the given URL path. This method is used\n\t * when parsed {@code PathPattern}s are {@link #usesPathPatterns() enabled}.\n\t * @param path the parsed RequestPath\n\t * @param lookupPath the String lookupPath for checking direct hits\n\t * @param request current HTTP request\n\t * @return a matching handler, or {@code null} if not found\n\t * @since 5.3\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "path",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 303
    },
    "return": "Object",
    "signature": "protected Object lookupHandler(RequestPath path, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected Object lookupHandler(\n\t\t\tRequestPath path, String lookupPath, HttpServletRequest request) throws Exception {\n\n\t\tObject handler = getDirectMatch(lookupPath, request);\n\t\tif (handler != null) {\n\t\t\treturn handler;\n\t\t}\n\n\t\t// Pattern match?\n\t\tList<PathPattern> matches = null;\n\t\tfor (PathPattern pattern : this.pathPatternHandlerMap.keySet()) {\n\t\t\tif (pattern.matches(path.pathWithinApplication())) {\n\t\t\t\tmatches = (matches != null ? matches : new ArrayList<>());\n\t\t\t\tmatches.add(pattern);\n\t\t\t}\n\t\t}\n\t\tif (matches == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches.size() > 1) {\n\t\t\tmatches.sort(PathPattern.SPECIFICITY_COMPARATOR);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Matching patterns \" + matches);\n\t\t\t}\n\t\t}\n\t\tPathPattern pattern = matches.get(0);\n\t\thandler = this.pathPatternHandlerMap.get(pattern);\n\t\tif (handler instanceof String handlerName) {\n\t\t\thandler = obtainApplicationContext().getBean(handlerName);\n\t\t}\n\t\tvalidateHandler(handler, request);\n\t\tString pathWithinMapping = pattern.extractPathWithinPattern(path.pathWithinApplication()).value();\n\t\tpathWithinMapping = UrlPathHelper.defaultInstance.removeSemicolonContent(pathWithinMapping);\n\t\tPathPattern.PathMatchInfo pathMatchInfo = pattern.matchAndExtract(path);\n\t\tMap<String, String> uriVariables = (pathMatchInfo != null ? pathMatchInfo.getUriVariables(): null);\n\t\treturn buildPathExposingHandler(handler, pattern.getPatternString(), pathWithinMapping, uriVariables);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#lookupHandlerMethod(lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look up the best-matching handler method for the current request.\n\t * If multiple matches are found, the best match is selected.\n\t * @param lookupPath mapping lookup path within the current servlet mapping\n\t * @param request the current request\n\t * @return the best-matching handler method, or {@code null} if no match\n\t * @see #handleMatch(Object, String, HttpServletRequest)\n\t * @see #handleNoMatch(Set, String, HttpServletRequest)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 400
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n\t\tList<Match> matches = new ArrayList<>();\n\t\tList<T> directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath);\n\t\tif (directPathMatches != null) {\n\t\t\taddMatchingMappings(directPathMatches, matches, request);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\taddMatchingMappings(this.mappingRegistry.getRegistrations().keySet(), matches, request);\n\t\t}\n\t\tif (!matches.isEmpty()) {\n\t\t\tMatch bestMatch = matches.get(0);\n\t\t\tif (matches.size() > 1) {\n\t\t\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(request));\n\t\t\t\tmatches.sort(comparator);\n\t\t\t\tbestMatch = matches.get(0);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(matches.size() + \" matching mappings: \" + matches);\n\t\t\t\t}\n\t\t\t\tif (CorsUtils.isPreFlightRequest(request)) {\n\t\t\t\t\tfor (Match match : matches) {\n\t\t\t\t\t\tif (match.hasCorsConfig()) {\n\t\t\t\t\t\t\treturn PREFLIGHT_AMBIGUOUS_MATCH;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\t\t\tMethod m1 = bestMatch.getHandlerMethod().getMethod();\n\t\t\t\t\t\tMethod m2 = secondBestMatch.getHandlerMethod().getMethod();\n\t\t\t\t\t\tString uri = request.getRequestURI();\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Ambiguous handler methods mapped for '\" + uri + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trequest.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());\n\t\t\thandleMatch(bestMatch.mapping, lookupPath, request);\n\t\t\treturn bestMatch.getHandlerMethod();\n\t\t}\n\t\telse {\n\t\t\treturn handleNoMatch(this.mappingRegistry.getRegistrations().keySet(), lookupPath, request);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#match(path,isPathContainer,pathMatcher)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "isPathContainer",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "boolean",
    "signature": "public boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher)",
    "source_code": "\t\tpublic boolean match(Object path, boolean isPathContainer, PathMatcher pathMatcher) {\n\t\t\tif (isPathContainer) {\n\t\t\t\tPathContainer pathContainer = (PathContainer) path;\n\t\t\t\tif (this.pathPattern != null) {\n\t\t\t\t\treturn this.pathPattern.matches(pathContainer);\n\t\t\t\t}\n\t\t\t\tString lookupPath = pathContainer.value();\n\t\t\t\tpath = UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);\n\t\t\t}\n\t\t\treturn pathMatcher.match(this.patternString, (String) path);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#match(request,pattern)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 492
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.state(getPatternParser() == null, \"This HandlerMapping uses PathPatterns.\");\n\t\tString lookupPath = UrlPathHelper.getResolvedLookupPath(request);\n\t\tif (getPathMatcher().match(pattern, lookupPath)) {\n\t\t\treturn new RequestMatchResult(pattern, lookupPath, getPathMatcher());\n\t\t}\n\t\telse if (useTrailingSlashMatch()) {\n\t\t\tif (!pattern.endsWith(\"/\") && getPathMatcher().match(pattern + \"/\", lookupPath)) {\n\t\t\t\treturn new RequestMatchResult(pattern + \"/\", lookupPath, getPathMatcher());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#matches(lookupPath,pathMatcher)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine if there is a match for the given lookup path.\n\t * @param lookupPath the current request path\n\t * @param pathMatcher a path matcher for path pattern matching\n\t * @return {@code true} if the interceptor applies to the given request path\n\t * @deprecated as of 5.3 in favor of {@link #matches(HttpServletRequest)}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "lookupPath",
      "pathMatcher"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "boolean",
    "signature": "public boolean matches(String lookupPath, PathMatcher pathMatcher)",
    "source_code": "\tpublic boolean matches(String lookupPath, PathMatcher pathMatcher) {\n\t\tpathMatcher = (this.pathMatcher != defaultPathMatcher ? this.pathMatcher : pathMatcher);\n\t\tif (!ObjectUtils.isEmpty(this.excludePatterns)) {\n\t\t\tfor (PatternAdapter adapter : this.excludePatterns) {\n\t\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ObjectUtils.isEmpty(this.includePatterns)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (PatternAdapter adapter : this.includePatterns) {\n\t\t\tif (pathMatcher.match(adapter.getPatternString(), lookupPath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postHandle(request,response,handler,modelAndView)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\n\t\tthis.requestInterceptor.postHandle(new DispatcherServletWebRequest(request, response),\n\t\t\t\t(modelAndView != null && !modelAndView.wasCleared() ? modelAndView.getModelMap() : null));\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessAfterInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "Object",
    "signature": "public Object postProcessAfterInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tServletConfig config = this.servletConfig;\n\t\t\tif (config == null || !this.useSharedServletConfig) {\n\t\t\t\tconfig = new DelegatingServletConfig(beanName, this.servletContext);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tservlet.init(config);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tthrow new BeanInitializationException(\"Servlet.init threw exception\", ex);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessBeforeDestruction(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 126
    },
    "return": "void",
    "signature": "public void postProcessBeforeDestruction(Object bean, String beanName)",
    "source_code": "\tpublic void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {\n\t\tif (bean instanceof Servlet servlet) {\n\t\t\tservlet.destroy();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#postProcessBeforeInitialization(bean,beanName)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bean",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 104
    },
    "return": "Object",
    "signature": "public Object postProcessBeforeInitialization(Object bean, String beanName)",
    "source_code": "\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#preHandle(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\tthis.requestInterceptor.preHandle(new DispatcherServletWebRequest(request, response));\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#register(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 633
    },
    "return": "void",
    "signature": "public void register(T mapping, Object handler, Method method)",
    "source_code": "\t\tpublic void register(T mapping, Object handler, Method method) {\n\t\t\tthis.readWriteLock.writeLock().lock();\n\t\t\ttry {\n\t\t\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\t\t\tvalidateMethodMapping(handlerMethod, mapping);\n\n\t\t\t\t// Enable method validation, if applicable\n\t\t\t\thandlerMethod = handlerMethod.createWithValidateFlags();\n\n\t\t\t\tSet<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n\t\t\t\tfor (String path : directPaths) {\n\t\t\t\t\tthis.pathLookup.add(path, mapping);\n\t\t\t\t}\n\n\t\t\t\tString name = null;\n\t\t\t\tif (getNamingStrategy() != null) {\n\t\t\t\t\tname = getNamingStrategy().getName(handlerMethod, mapping);\n\t\t\t\t\taddMappingName(name, handlerMethod);\n\t\t\t\t}\n\n\t\t\t\tCorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n\t\t\t\tif (corsConfig != null) {\n\t\t\t\t\tcorsConfig.validateAllowCredentials();\n\t\t\t\t\tcorsConfig.validateAllowPrivateNetwork();\n\t\t\t\t\tthis.corsLookup.put(handlerMethod, corsConfig);\n\t\t\t\t}\n\n\t\t\t\tthis.registry.put(mapping,\n\t\t\t\t\t\tnew MappingRegistration<>(mapping, handlerMethod, directPaths, name, corsConfig != null));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.readWriteLock.writeLock().unlock();\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPath,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL path.\n\t * @param urlPath the URL the bean should be mapped to\n\t * @param handler the handler instance or handler bean name String\n\t * (a bean name will automatically be resolved into the corresponding handler bean)\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPath",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void registerHandler(String urlPath, Object handler)",
    "source_code": "\tpublic void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPath, \"URL path must not be null\");\n\t\tAssert.notNull(handler, \"Handler object must not be null\");\n\t\tObject resolvedHandler = handler;\n\n\t\t// Eagerly resolve handler if referencing singleton via name.\n\t\tif (!this.lazyInitHandlers && handler instanceof String handlerName) {\n\t\t\tApplicationContext applicationContext = obtainApplicationContext();\n\t\t\tif (applicationContext.isSingleton(handlerName)) {\n\t\t\t\tresolvedHandler = applicationContext.getBean(handlerName);\n\t\t\t}\n\t\t}\n\n\t\tObject mappedHandler = this.handlerMap.get(urlPath);\n\t\tif (mappedHandler != null) {\n\t\t\tif (mappedHandler != resolvedHandler) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot map \" + getHandlerDescription(handler) + \" to URL path [\" + urlPath +\n\t\t\t\t\t\t\t\t\"]: There is already \" + getHandlerDescription(mappedHandler) + \" mapped.\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (urlPath.equals(\"/\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Root mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetRootHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse if (urlPath.equals(\"/*\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Default mapping to \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t\tsetDefaultHandler(resolvedHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handlerMap.put(urlPath, resolvedHandler);\n\t\t\t\tif (getPatternParser() != null) {\n\t\t\t\t\tthis.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Mapped [\" + urlPath + \"] onto \" + getHandlerDescription(handler));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandler(urlPaths,beanName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the specified handler for the given URL paths.\n\t * @param urlPaths the URLs that the bean should be mapped to\n\t * @param beanName the name of the handler bean\n\t * @throws BeansException if the handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "urlPaths",
      "beanName"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "void",
    "signature": "public void registerHandler(String[] urlPaths, String beanName)",
    "source_code": "\tpublic void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {\n\t\tAssert.notNull(urlPaths, \"URL path array must not be null\");\n\t\tfor (String urlPath : urlPaths) {\n\t\t\tregisterHandler(urlPath, beanName);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a handler method and its unique mapping. Invoked at startup for\n\t * each detected handler method.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, T mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerHandlers(Map<String,urlMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register all handlers specified in the URL map for the corresponding paths.\n\t * @param urlMap a Map with URL paths as keys and handler beans or bean names as values\n\t * @throws BeansException if a handler couldn't be registered\n\t * @throws IllegalStateException if there is a conflicting handler registered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "void",
    "signature": "protected void registerHandlers(Map<String, Object> urlMap)",
    "source_code": "\tprotected void registerHandlers(Map<String, Object> urlMap) throws BeansException {\n\t\tif (urlMap.isEmpty()) {\n\t\t\tlogger.trace(\"No patterns in \" + formatMappingName());\n\t\t}\n\t\telse {\n\t\t\turlMap.forEach((url, handler) -> {\n\t\t\t\t// Prepend with slash if not already present.\n\t\t\t\tif (!url.startsWith(\"/\")) {\n\t\t\t\t\turl = \"/\" + url;\n\t\t\t\t}\n\t\t\t\t// Remove whitespace from handler bean name.\n\t\t\t\tif (handler instanceof String handlerName) {\n\t\t\t\t\thandler = handlerName.trim();\n\t\t\t\t}\n\t\t\t\tregisterHandler(url, handler);\n\t\t\t});\n\t\t\tlogMappings();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register the given mapping.\n\t * <p>This method may be invoked at runtime after initialization has completed.\n\t * @param mapping the mapping for the handler method\n\t * @param handler the handler\n\t * @param method the method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void registerMapping(T mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(T mapping, Object handler, Method method) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Register \\\"\" + mapping + \"\\\" to \" + method.toGenericString());\n\t\t}\n\t\tthis.mappingRegistry.register(mapping, handler, method);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#resetCache(request,cachedResult)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Restore a previous {@link CachedResult}. This method can be invoked from\n\t * a filter after delegating to the rest of the chain.\n\t * @since 6.0.14\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "cachedResult"
    ],
    "position": {
      "column": 1,
      "line": 300
    },
    "return": "void",
    "signature": "public void resetCache(ServletRequest request, @Nullable CachedResult cachedResult)",
    "source_code": "\tpublic void resetCache(ServletRequest request, @Nullable CachedResult cachedResult) {\n\t\trequest.setAttribute(CACHED_RESULT_ATTRIBUTE, cachedResult);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 546
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setCorsConfigurations(Map<String,corsConfigurations)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set \"global\" CORS configuration mappings. The first matching URL pattern\n\t * determines the {@code CorsConfiguration} to use which is then further\n\t * {@link CorsConfiguration#combine(CorsConfiguration) combined} with the\n\t * {@code CorsConfiguration} for the selected handler.\n\t * <p>This is mutually exclusive with\n\t * {@link #setCorsConfigurationSource(CorsConfigurationSource)}.\n\t * @since 4.2\n\t * @see #setCorsProcessor(CorsProcessor)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "corsConfigurations"
    ],
    "position": {
      "column": 1,
      "line": 322
    },
    "return": "void",
    "signature": "public void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations)",
    "source_code": "\tpublic void setCorsConfigurations(Map<String, CorsConfiguration> corsConfigurations) {\n\t\tif (CollectionUtils.isEmpty(corsConfigurations)) {\n\t\t\tthis.corsConfigurationSource = null;\n\t\t\treturn;\n\t\t}\n\t\tUrlBasedCorsConfigurationSource source;\n\t\tif (getPatternParser() != null) {\n\t\t\tsource = new UrlBasedCorsConfigurationSource(getPatternParser());\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t}\n\t\telse {\n\t\t\tsource = new UrlBasedCorsConfigurationSource();\n\t\t\tsource.setCorsConfigurations(corsConfigurations);\n\t\t\tsource.setPathMatcher(this.pathMatcher);\n\t\t\tsource.setUrlPathHelper(this.urlPathHelper);\n\t\t}\n\t\tsetCorsConfigurationSource(source);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#setUrlMap(Map<String,urlMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and handler beans (or handler bean names)\n\t * as values. Convenient for population with bean references.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param urlMap map with URLs as keys and beans as values\n\t * @see #setMappings\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "urlMap"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void setUrlMap(Map<String, ?> urlMap)",
    "source_code": "\tpublic void setUrlMap(Map<String, ?> urlMap) {\n\t\tthis.urlMap.putAll(urlMap);\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#shouldApplyTo(request,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Checks if the handler is a {@link HandlerMethod} or the resolver has global exception\n\t * handlers and then delegates to the base class implementation of {@code #shouldApplyTo}\n\t * passing the bean of the {@code HandlerMethod} if necessary. Otherwise, returns {@code false}.\n\t * @see HandlerMethod\n\t * @see #hasGlobalExceptionHandlers()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 45
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif (handler instanceof HandlerMethod handlerMethod) {\n\t\t\treturn super.shouldApplyTo(request, handlerMethod.getBean());\n\t\t}\n\t\telse if (handler == null || (hasGlobalExceptionHandlers() && hasHandlerMappings())) {\n\t\t\treturn super.shouldApplyTo(request, handler);\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.handler.<unknown>#validateHandler(handler,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the given handler against the current request.\n\t * <p>The default implementation is empty. Can be overridden in subclasses,\n\t * for example to enforce specific preconditions expressed in URL mappings.\n\t * @param handler the handler object to validate\n\t * @param request current HTTP request\n\t * @throws Exception if validation failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "void",
    "signature": "protected void validateHandler(Object handler, HttpServletRequest request)",
    "source_code": "\tprotected void validateHandler(Object handler, HttpServletRequest request) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#setDefaultLocaleFunction(Function<HttpServletRequest,defaultLocaleFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the function used to determine the default locale for the given request,\n\t * called if no locale cookie has been found.\n\t * <p>The default implementation returns the configured\n\t * {@linkplain #setDefaultLocale(Locale) default locale}, if any, and otherwise\n\t * falls back to the request's {@code Accept-Language} header locale or the\n\t * default locale for the server.\n\t * @param defaultLocaleFunction the function used to determine the default locale\n\t * @since 6.0\n\t * @see #setDefaultLocale\n\t * @see jakarta.servlet.http.HttpServletRequest#getLocale()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpServletRequest",
      "defaultLocaleFunction"
    ],
    "position": {
      "column": 1,
      "line": 269
    },
    "return": "void",
    "signature": "public void setDefaultLocaleFunction(Function<HttpServletRequest, Locale> defaultLocaleFunction)",
    "source_code": "\tpublic void setDefaultLocaleFunction(Function<HttpServletRequest, Locale> defaultLocaleFunction) {\n\t\tAssert.notNull(defaultLocaleFunction, \"defaultLocaleFunction must not be null\");\n\t\tthis.defaultLocaleFunction = defaultLocaleFunction;\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#setDefaultTimeZoneFunction(Function<HttpServletRequest,defaultTimeZoneFunction)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the function used to determine the default time zone for the given request,\n\t * called if no locale cookie has been found.\n\t * <p>The default implementation returns the configured default time zone,\n\t * if any, or {@code null} otherwise.\n\t * @param defaultTimeZoneFunction the function used to determine the default time zone\n\t * @since 6.0\n\t * @see #setDefaultTimeZone\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<HttpServletRequest",
      "defaultTimeZoneFunction"
    ],
    "position": {
      "column": 1,
      "line": 283
    },
    "return": "void",
    "signature": "public void setDefaultTimeZoneFunction(Function<HttpServletRequest, TimeZone> defaultTimeZoneFunction)",
    "source_code": "\tpublic void setDefaultTimeZoneFunction(Function<HttpServletRequest, TimeZone> defaultTimeZoneFunction) {\n\t\tAssert.notNull(defaultTimeZoneFunction, \"defaultTimeZoneFunction must not be null\");\n\t\tthis.defaultTimeZoneFunction = defaultTimeZoneFunction;\n\t}"
  },
  "org.springframework.web.servlet.i18n.<unknown>#setLocaleContext(request,response,localeContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "localeContext"
    ],
    "position": {
      "column": 1,
      "line": 366
    },
    "return": "void",
    "signature": "public void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response,\n\t\t\t@Nullable LocaleContext localeContext)",
    "source_code": "\tpublic void setLocaleContext(HttpServletRequest request, @Nullable HttpServletResponse response,\n\t\t\t@Nullable LocaleContext localeContext) {\n\n\t\tAssert.notNull(response, \"HttpServletResponse is required for CookieLocaleResolver\");\n\n\t\tLocale locale = null;\n\t\tTimeZone zone = null;\n\t\tif (localeContext != null) {\n\t\t\tlocale = localeContext.getLocale();\n\t\t\tif (localeContext instanceof TimeZoneAwareLocaleContext timeZoneAwareLocaleContext) {\n\t\t\t\tzone = timeZoneAwareLocaleContext.getTimeZone();\n\t\t\t}\n\t\t\tString value = (locale != null ? toLocaleValue(locale) : \"-\") + (zone != null ? '/' + zone.getID() : \"\");\n\t\t\tthis.cookie = this.cookie.mutate().value(value).build();\n\t\t}\n\t\tresponse.addHeader(HttpHeaders.SET_COOKIE, this.cookie.toString());\n\t\trequest.setAttribute(LOCALE_REQUEST_ATTRIBUTE_NAME,\n\t\t\t\t(locale != null ? locale : this.defaultLocaleFunction.apply(request)));\n\t\trequest.setAttribute(TIME_ZONE_REQUEST_ATTRIBUTE_NAME,\n\t\t\t\t(zone != null ? zone : this.defaultTimeZoneFunction.apply(request)));\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#addCacheMapping(cacheControl,paths)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Map specific URL paths to a specific {@link org.springframework.http.CacheControl}.\n\t * <p>Overrides the default cache seconds setting of this interceptor.\n\t * Can specify an empty {@link org.springframework.http.CacheControl} instance\n\t * to exclude a URL path from default caching.\n\t * <p>For pattern syntax see {@link AntPathMatcher} and {@link PathPattern}\n\t * as well as the class-level Javadoc for details for when each is used.\n\t * The syntax is largely the same with {@link PathPattern} more tailored for\n\t * web usage.\n\t * <p><b>NOTE:</b> Path patterns are not supposed to overlap. If a request\n\t * matches several mappings, it is effectively undefined which one will apply\n\t * (due to the lack of key ordering in the underlying {@code java.util.HashMap}).\n\t * @param cacheControl the {@code CacheControl} to use\n\t * @param paths the URL paths that will map to the given {@code CacheControl}\n\t * @since 4.2\n\t * @see #setCacheSeconds\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "cacheControl",
      "paths"
    ],
    "position": {
      "column": 1,
      "line": 199
    },
    "return": "void",
    "signature": "public void addCacheMapping(CacheControl cacheControl, String... paths)",
    "source_code": "\tpublic void addCacheMapping(CacheControl cacheControl, String... paths) {\n\t\tfor (String path : paths) {\n\t\t\tthis.cacheControlMappings.put(this.patternParser.parse(path), cacheControl);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#afterCompletion(request,response,handler,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 326
    },
    "return": "void",
    "signature": "public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex)",
    "source_code": "\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#getLastModified(request,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified lastModified) {\n\t\t\treturn lastModified.getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#handle(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 48
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn ((Controller) handler).handleRequest(request, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#handleRequestInternal(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a ModelAndView object with the specified view name.\n\t * <p>The content of the {@link RequestContextUtils#getInputFlashMap\n\t * \"input\" FlashMap} is also added to the model.\n\t * @see #getViewName()\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 153
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tString viewName = getViewName();\n\n\t\tif (getStatusCode() != null) {\n\t\t\tif (getStatusCode().is3xxRedirection()) {\n\t\t\t\trequest.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, getStatusCode());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.setStatus(getStatusCode().value());\n\t\t\t\tif (getStatusCode().equals(HttpStatus.NO_CONTENT) && viewName == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isStatusOnly()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tModelAndView modelAndView = new ModelAndView();\n\t\tmodelAndView.addAllObjects(RequestContextUtils.getInputFlashMap(request));\n\t\tif (viewName != null) {\n\t\t\tmodelAndView.setViewName(viewName);\n\t\t}\n\t\telse {\n\t\t\tmodelAndView.setView(getView());\n\t\t}\n\t\treturn modelAndView;\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#postHandle(request,response,handler,modelAndView)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation is empty.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "modelAndView"
    ],
    "position": {
      "column": 1,
      "line": 318
    },
    "return": "void",
    "signature": "public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView)",
    "source_code": "\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\t}"
  },
  "org.springframework.web.servlet.mvc.<unknown>#preHandle(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 207
    },
    "return": "boolean",
    "signature": "public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows ServletException {\n\n\t\tcheckRequest(request);\n\n\t\tObject path = ServletRequestPathUtils.getCachedPath(request);\n\t\tif (this.pathMatcher != defaultPathMatcher) {\n\t\t\tpath = path.toString();\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cacheControlMappings)) {\n\t\t\tCacheControl control = (path instanceof PathContainer pathContainer ?\n\t\t\t\t\tlookupCacheControl(pathContainer) : lookupCacheControl((String) path));\n\t\t\tif (control != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Applying \" + control);\n\t\t\t\t}\n\t\t\t\tapplyCacheControl(response, control);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (!ObjectUtils.isEmpty(this.cacheMappings)) {\n\t\t\tInteger cacheSeconds = (path instanceof PathContainer pathContainer ?\n\t\t\t\t\tlookupCacheSeconds(pathContainer) : lookupCacheSeconds((String) path));\n\t\t\tif (cacheSeconds != null) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Applying cacheSeconds \" + cacheSeconds);\n\t\t\t\t}\n\t\t\t\tapplyCacheSeconds(response, cacheSeconds);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tprepareResponse(response);\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#applyStatusAndReason(statusCode,reason,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the resolved status code and reason to the response.\n\t * <p>The default implementation sends a response error using\n\t * {@link HttpServletResponse#sendError(int)} or\n\t * {@link HttpServletResponse#sendError(int, String)} if there is a reason\n\t * and then returns an empty ModelAndView.\n\t * @param statusCode the HTTP status code\n\t * @param reason the associated reason (may be {@code null} or empty)\n\t * @param response current HTTP response\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "statusCode",
      "reason",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)",
    "source_code": "\tprotected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\tif (!StringUtils.hasLength(reason)) {\n\t\t\tresponse.sendError(statusCode);\n\t\t}\n\t\telse {\n\t\t\tString resolvedReason = (this.messageSource != null ?\n\t\t\t\t\tthis.messageSource.getMessage(reason, null, reason, LocaleContextHolder.getLocale()) :\n\t\t\t\t\treason);\n\t\t\tresponse.sendError(statusCode, resolvedReason);\n\t\t}\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#doResolveException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 71
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\tif (ex instanceof ResponseStatusException rse) {\n\t\t\t\treturn resolveResponseStatusException(rse, request, response, handler);\n\t\t\t}\n\n\t\t\tResponseStatus status = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);\n\t\t\tif (status != null) {\n\t\t\t\treturn resolveResponseStatus(status, request, response, handler, ex);\n\t\t\t}\n\n\t\t\tif (ex.getCause() instanceof Exception cause) {\n\t\t\t\treturn doResolveException(request, response, handler, cause);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception resolveEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", resolveEx);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#resolveResponseStatus(responseStatus,request,response,handler,ex)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that handles the {@link ResponseStatus @ResponseStatus} annotation.\n\t * <p>The default implementation delegates to {@link #applyStatusAndReason}\n\t * with the status code and reason from the annotation.\n\t * @param responseStatus the {@code @ResponseStatus} annotation\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, for example, if multipart resolution failed\n\t * @param ex the exception\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "responseStatus",
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 108
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {\n\n\t\tint statusCode = responseStatus.code().value();\n\t\tString reason = responseStatus.reason();\n\t\treturn applyStatusAndReason(statusCode, reason, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.annotation.<unknown>#resolveResponseStatusException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Template method that handles an {@link ResponseStatusException}.\n\t * <p>The default implementation applies the headers from\n\t * {@link ResponseStatusException#getHeaders()} and delegates to\n\t * {@link #applyStatusAndReason} with the status code and reason from the\n\t * exception.\n\t * @param ex the exception\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen at the\n\t * time of the exception, for example, if multipart resolution failed\n\t * @return an empty ModelAndView, i.e. exception resolved\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 130
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView resolveResponseStatusException(ResponseStatusException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView resolveResponseStatusException(ResponseStatusException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws Exception {\n\n\t\tex.getHeaders().forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));\n\t\treturn applyStatusAndReason(ex.getStatusCode().value(), ex.getReason(), response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#compareTo(other,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Compares \"this\" info (i.e. the current instance) with another info in the\n\t * context of a request.\n\t * <p>Note: It is assumed both instances have been obtained via\n\t * {@link #getMatchingCondition(HttpServletRequest)} to ensure they have\n\t * conditions with content relevant to current request.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "other",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "int",
    "signature": "public int compareTo(RequestMappingInfo other, HttpServletRequest request)",
    "source_code": "\tpublic int compareTo(RequestMappingInfo other, HttpServletRequest request) {\n\t\tint result;\n\t\t// Automatic vs explicit HTTP HEAD mapping\n\t\tif (HttpMethod.HEAD.matches(request.getMethod())) {\n\t\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tresult = getActivePatternsCondition().compareTo(other.getActivePatternsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.paramsCondition.compareTo(other.getParamsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.headersCondition.compareTo(other.getHeadersCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.consumesCondition.compareTo(other.getConsumesCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.producesCondition.compareTo(other.getProducesCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\t// Implicit (no method) vs explicit HTTP method mappings\n\t\tresult = this.methodsCondition.compareTo(other.getMethodsCondition(), request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this.customConditionHolder.compareTo(other.customConditionHolder, request);\n\t\tif (result != 0) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModified(request,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "long",
    "signature": "public long getLastModified(HttpServletRequest request, Object handler)",
    "source_code": "\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Same contract as for {@link jakarta.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t * @deprecated as of 5.3.9 along with\n\t * {@link org.springframework.web.servlet.mvc.LastModified}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#getMatchingMapping(info,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if the given RequestMappingInfo matches the current request and\n\t * return a (potentially new) instance with conditions that match the\n\t * current request -- for example with a subset of URL patterns.\n\t * @return an info in case of a match; or {@code null} otherwise.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 110
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request)",
    "source_code": "\tprotected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {\n\t\treturn info.getMatchingCondition(request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handle(request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "ModelAndView",
    "signature": "public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)",
    "source_code": "\tpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn handleInternal(request, response, (HandlerMethod) handler);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleInternal(request,response,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Use the given handler method to handle the request.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod handler method to use. This object must have previously been passed to the\n\t * {@link #supportsInternal(HandlerMethod)} this interface, which must have returned {@code true}.\n\t * @return a ModelAndView object with the name of the view and the required model data,\n\t * or {@code null} if the request has been handled directly\n\t * @throws Exception in case of errors\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 101
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected abstract ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception;\n\n\t/**\n\t * This implementation expects the handler to be an {@link HandlerMethod}."
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleMatch(info,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose URI template variables, matrix variables, and producible media types in the request.\n\t * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE\n\t * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "info",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "void",
    "signature": "protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {\n\t\tsuper.handleMatch(info, lookupPath, request);\n\n\t\tRequestCondition<?> condition = info.getActivePatternsCondition();\n\t\tif (condition instanceof PathPatternsRequestCondition pprc) {\n\t\t\textractMatchDetails(pprc, lookupPath, request);\n\t\t}\n\t\telse {\n\t\t\textractMatchDetails((PatternsRequestCondition) condition, lookupPath, request);\n\t\t}\n\n\t\tProducesRequestCondition producesCondition = info.getProducesCondition();\n\t\tif (!producesCondition.isEmpty()) {\n\t\t\tSet<MediaType> mediaTypes = producesCondition.getProducibleMediaTypes();\n\t\t\tif (!mediaTypes.isEmpty()) {\n\t\t\t\trequest.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.<unknown>#handleNoMatch(infos,lookupPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Iterate all RequestMappingInfo's once again, look if any match by URL at\n\t * least and raise exceptions according to what doesn't match.\n\t * @throws HttpRequestMethodNotSupportedException if there are matches by URL\n\t * but not by HTTP method\n\t * @throws HttpMediaTypeNotAcceptableException if there are matches by URL\n\t * but not by consumable/producible media types\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infos",
      "lookupPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 248
    },
    "return": "HandlerMethod",
    "signature": "protected HandlerMethod handleNoMatch(Set<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request)",
    "source_code": "\tprotected HandlerMethod handleNoMatch(\n\t\t\tSet<RequestMappingInfo> infos, String lookupPath, HttpServletRequest request) throws ServletException {\n\n\t\tif (CollectionUtils.isEmpty(infos)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPartialMatchHelper helper = new PartialMatchHelper(infos, request);\n\t\tif (helper.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (helper.hasMethodsMismatch()) {\n\t\t\tSet<String> methods = helper.getAllowedMethods();\n\t\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\t\tSet<MediaType> mediaTypes = helper.getConsumablePatchMediaTypes();\n\t\t\t\tHttpOptionsHandler handler = new HttpOptionsHandler(methods, mediaTypes);\n\t\t\t\treturn new HandlerMethod(handler, HTTP_OPTIONS_HANDLE_METHOD);\n\t\t\t}\n\t\t\tthrow new HttpRequestMethodNotSupportedException(request.getMethod(), methods);\n\t\t}\n\n\t\tif (helper.hasConsumesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getConsumableMediaTypes();\n\t\t\tMediaType contentType = null;\n\t\t\tif (StringUtils.hasLength(request.getContentType())) {\n\t\t\t\ttry {\n\t\t\t\t\tcontentType = MediaType.parseMediaType(request.getContentType());\n\t\t\t\t}\n\t\t\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage(), new ArrayList<>(mediaTypes));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tcontentType, new ArrayList<>(mediaTypes), HttpMethod.valueOf(request.getMethod()));\n\t\t}\n\n\t\tif (helper.hasProducesMismatch()) {\n\t\t\tSet<MediaType> mediaTypes = helper.getProducibleMediaTypes();\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(new ArrayList<>(mediaTypes));\n\t\t}\n\n\t\tif (helper.hasParamsMismatch()) {\n\t\t\tList<String[]> conditions = helper.getParamConditions();\n\t\t\tthrow new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap());\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#adaptArgumentIfNecessary(arg,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Adapt the given argument against the method parameter, if necessary.\n\t * @param arg the resolved argument\n\t * @param parameter the method parameter descriptor\n\t * @return the adapted argument, or the original resolved argument as-is\n\t * @since 4.3.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "Object",
    "signature": "protected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter)",
    "source_code": "\tprotected Object adaptArgumentIfNecessary(@Nullable Object arg, MethodParameter parameter) {\n\t\tif (parameter.getParameterType() == Optional.class) {\n\t\t\tif (arg == null || (arg instanceof Collection<?> collection && collection.isEmpty()) ||\n\t\t\t\t\t(arg instanceof Object[] array && array.length == 0)) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Optional.of(arg);\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#addBindValues(mpvs,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Merge URI variables into the property values to use for data binding.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "mpvs",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "protected void addBindValues(MutablePropertyValues mpvs, ServletRequest request)",
    "source_code": "\tprotected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n\t\tMap<String, String> uriVars = getUriVars(request);\n\t\tif (uriVars != null) {\n\t\t\turiVars.forEach((name, value) -> addValueIfNotPresent(mpvs, \"URI variable\", name, value));\n\t\t}\n\t\tif (request instanceof HttpServletRequest httpRequest) {\n\t\t\tEnumeration<String> names = httpRequest.getHeaderNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tObject value = getHeaderValue(httpRequest, name);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tname = name.replace(\"-\", \"\");\n\t\t\t\t\taddValueIfNotPresent(mpvs, \"Header\", name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#afterBodyRead(body,inputMessage,parameter,targetType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "inputMessage",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "Object",
    "signature": "public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\tbody = advice.afterBodyRead(body, inputMessage, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#arg(index,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "index",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 904
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder arg(int index, Object value)",
    "source_code": "\t\tpublic MethodArgumentBuilder arg(int index, Object value) {\n\t\t\tthis.argumentValues[index] = value;\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyRead(request,parameter,targetType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 87
    },
    "return": "HttpInputMessage",
    "signature": "public HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) throws IOException {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\trequest = advice.beforeBodyRead(request, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn request;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyWrite(body,returnType,contentType,converterType,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "returnType",
      "contentType",
      "converterType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 112
    },
    "return": "Object",
    "signature": "public Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n\t\t\tClass<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tpublic Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n\t\t\tClass<? extends HttpMessageConverter<?>> converterType,\n\t\t\tServerHttpRequest request, ServerHttpResponse response) {\n\n\t\treturn processBody(body, returnType, contentType, converterType, request, response);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#beforeBodyWriteInternal(bodyContainer,contentType,returnType,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked only if the converter type is {@code MappingJackson2HttpMessageConverter}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "bodyContainer",
      "contentType",
      "returnType",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 69
    },
    "return": "void",
    "signature": "protected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected abstract void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response);\n\n}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#canRead(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 409
    },
    "return": "boolean",
    "signature": "public boolean canRead(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic boolean canRead(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#canWrite(clazz,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 414
    },
    "return": "boolean",
    "signature": "public boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType) {\n\t\t\treturn false;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#connect(adapter,returnValue)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "adapter",
      "returnValue"
    ],
    "position": {
      "column": 1,
      "line": 493
    },
    "return": "void",
    "signature": "public void connect(ReactiveAdapter adapter, Object returnValue)",
    "source_code": "\t\tpublic void connect(ReactiveAdapter adapter, Object returnValue) {\n\t\t\tPublisher<Object> publisher = adapter.toPublisher(returnValue);\n\t\t\tpublisher.subscribe(this);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#contributeMethodArgument(parameter,value,builder,Map<String,uriVariables,conversionService)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "value",
      "builder",
      "Map<String",
      "uriVariables",
      "conversionService"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService)",
    "source_code": "\tpublic void contributeMethodArgument(MethodParameter parameter, Object value,\n\t\t\tUriComponentsBuilder builder, Map<String, Object> uriVariables, ConversionService conversionService) {\n\n\t\tif (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {\n\t\t\treturn;\n\t\t}\n\n\t\tPathVariable ann = parameter.getParameterAnnotation(PathVariable.class);\n\t\tString name = (ann != null && StringUtils.hasLength(ann.value()) ? ann.value() : parameter.getParameterName());\n\t\tString formatted = formatUriValue(conversionService, new TypeDescriptor(parameter.nestedIfOptional()), value);\n\t\turiVariables.put(name, formatted);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createProblemDetail(ex,status,defaultDetail,detailMessageCode,detailMessageArguments,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method to create a {@link ProblemDetail} for any exception\n\t * that doesn't implement {@link ErrorResponse}, also performing a\n\t * {@link MessageSource} lookup for the \"detail\" field.\n\t * @param ex the exception being handled\n\t * @param status the status to associate with the exception\n\t * @param defaultDetail default value for the \"detail\" field\n\t * @param detailMessageCode the code to use to look up the \"detail\" field\n\t * through a {@code MessageSource}; if {@code null} then\n\t * {@link ErrorResponse#getDefaultDetailMessageCode(Class, String)} is used\n\t * to determine the default message code to use\n\t * @param detailMessageArguments the arguments to go with the detailMessageCode\n\t * @param request the current request\n\t * @return the created {@code ProblemDetail} instance\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "status",
      "defaultDetail",
      "detailMessageCode",
      "detailMessageArguments",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "ProblemDetail",
    "signature": "protected ProblemDetail createProblemDetail(Exception ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request)",
    "source_code": "\tprotected ProblemDetail createProblemDetail(\n\t\t\tException ex, HttpStatusCode status, String defaultDetail, @Nullable String detailMessageCode,\n\t\t\t@Nullable Object[] detailMessageArguments, WebRequest request) {\n\n\t\tErrorResponse.Builder builder = ErrorResponse.builder(ex, status, defaultDetail);\n\t\tif (detailMessageCode != null) {\n\t\t\tbuilder.detailMessageCode(detailMessageCode);\n\t\t}\n\t\tif (detailMessageArguments != null) {\n\t\t\tbuilder.detailMessageArguments(detailMessageArguments);\n\t\t}\n\t\treturn builder.build().updateAndGetBody(this.messageSource, LocaleContextHolder.getLocale());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createRequestMappingInfo(httpExchange,customCondition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link HttpExchange @HttpExchange} annotation, meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "httpExchange",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(HttpExchange httpExchange, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tHttpExchange httpExchange, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(toStringArray(httpExchange.value())))\n\t\t\t\t.methods(toMethodArray(httpExchange.method()))\n\t\t\t\t.consumes(toStringArray(httpExchange.contentType()))\n\t\t\t\t.produces(httpExchange.accept())\n\t\t\t\t.headers(httpExchange.headers());\n\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createRequestMappingInfo(requestMapping,customCondition)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link RequestMappingInfo} from the supplied\n\t * {@link RequestMapping @RequestMapping} annotation, meta-annotation,\n\t * or synthesized result of merging annotation attributes within an\n\t * annotation hierarchy.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestMapping",
      "customCondition"
    ],
    "position": {
      "column": 1,
      "line": 419
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition)",
    "source_code": "\tprotected RequestMappingInfo createRequestMappingInfo(\n\t\t\tRequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n\t\tRequestMappingInfo.Builder builder = RequestMappingInfo\n\t\t\t\t.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n\t\t\t\t.methods(requestMapping.method())\n\t\t\t\t.params(requestMapping.params())\n\t\t\t\t.headers(requestMapping.headers())\n\t\t\t\t.consumes(requestMapping.consumes())\n\t\t\t\t.produces(requestMapping.produces())\n\t\t\t\t.mappingName(requestMapping.name());\n\n\t\tif (customCondition != null) {\n\t\t\tbuilder.customCondition(customCondition);\n\t\t}\n\n\t\treturn builder.options(this.config).build();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#createResponseEntity(body,headers,statusCode,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the {@link ResponseEntity} to use from the given body, headers,\n\t * and statusCode. Subclasses can override this method to inspect and possibly\n\t * modify the body, headers, or statusCode, for example, to re-create an instance of\n\t * {@link ProblemDetail} as an extension of {@link ProblemDetail}.\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param statusCode the status code to use for the response\n\t * @param request the current request\n\t * @return the {@code ResponseEntity} instance to use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "body",
      "headers",
      "statusCode",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 678
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> createResponseEntity(@Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> createResponseEntity(\n\t\t\t@Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request) {\n\n\t\treturn new ResponseEntity<>(body, headers, statusCode);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#data(object,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 240
    },
    "return": "SseEventBuilder",
    "signature": "public SseEventBuilder data(Object object, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic SseEventBuilder data(Object object, @Nullable MediaType mediaType) {\n\t\t\tif (object instanceof ModelAndView mav && !this.hasName && mav.getViewName() != null) {\n\t\t\t\tname(mav.getViewName());\n\t\t\t}\n\t\t\tappend(\"data:\");\n\t\t\tsaveAppendedText();\n\t\t\tif (object instanceof String text) {\n\t\t\t\tobject = StringUtils.replace(text, \"\\n\", \"\\ndata:\");\n\t\t\t}\n\t\t\tthis.dataToSend.add(new DataWithMediaType(object, mediaType));\n\t\t\tappend('\\n');\n\t\t\treturn this;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#doResolveHandlerMethodException(request,response,handlerMethod,exception)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method and invoke it to handle the raised exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 437
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception)",
    "source_code": "\tprotected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,\n\t\t\tHttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) {\n\n\t\tServletWebRequest webRequest = new ServletWebRequest(request, response);\n\t\tServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception, webRequest);\n\n\t\tif (exceptionHandlerMethod == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.argumentResolvers != null) {\n\t\t\texceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t}\n\t\tif (this.returnValueHandlers != null) {\n\t\t\texceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t}\n\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\n\t\tArrayList<Throwable> exceptions = new ArrayList<>();\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using @ExceptionHandler \" + exceptionHandlerMethod);\n\t\t\t}\n\t\t\t// Expose causes as provided arguments as well\n\t\t\tThrowable exToExpose = exception;\n\t\t\twhile (exToExpose != null) {\n\t\t\t\texceptions.add(exToExpose);\n\t\t\t\tThrowable cause = exToExpose.getCause();\n\t\t\t\texToExpose = (cause != exToExpose ? cause : null);\n\t\t\t}\n\t\t\tObject[] arguments = new Object[exceptions.size() + 1];\n\t\t\texceptions.toArray(arguments);  // efficient arraycopy call in ArrayList\n\t\t\targuments[arguments.length - 1] = handlerMethod;\n\t\t\texceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, arguments);\n\t\t}\n\t\tcatch (Throwable invocationEx) {\n\t\t\tif (disconnectedClientHelper.checkAndLogClientDisconnectedException(invocationEx)) {\n\t\t\t\treturn new ModelAndView();\n\t\t\t}\n\t\t\t// Any other than the original exception (or a cause) is unintended here,\n\t\t\t// probably an accident (for example, failed assertion or the like).\n\t\t\tif (!exceptions.contains(invocationEx) && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure in @ExceptionHandler \" + exceptionHandlerMethod, invocationEx);\n\t\t\t}\n\t\t\t// Continue with default processing of the original exception...\n\t\t\treturn null;\n\t\t}\n\n\t\tif (mavContainer.isRequestHandled()) {\n\t\t\treturn new ModelAndView();\n\t\t}\n\t\telse {\n\t\t\tModelMap model = mavContainer.getModel();\n\t\t\tHttpStatusCode status = mavContainer.getStatus();\n\t\t\tModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);\n\t\t\tmav.setViewName(mavContainer.getViewName());\n\t\t\tif (!mavContainer.isViewReference()) {\n\t\t\t\tmav.setView((View) mavContainer.getView());\n\t\t\t}\n\t\t\tif (model instanceof RedirectAttributes redirectAttributes) {\n\t\t\t\tMap<String, ?> flashAttributes = redirectAttributes.getFlashAttributes();\n\t\t\t\tRequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);\n\t\t\t}\n\t\t\treturn mav;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#formatUriValue(cs,sourceType,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "cs",
      "sourceType",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "String",
    "signature": "protected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, Object value)",
    "source_code": "\tprotected String formatUriValue(@Nullable ConversionService cs, @Nullable TypeDescriptor sourceType, Object value) {\n\t\tif (value instanceof String string) {\n\t\t\treturn string;\n\t\t}\n\t\telse if (cs != null) {\n\t\t\treturn (String) cs.convert(value, sourceType, STRING_TYPE_DESCRIPTOR);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromController(builder,controllerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromController(Class)} that accepts a\n\t * {@code UriComponentsBuilder} representing the base URL. This is useful\n\t * when using MvcUriComponentsBuilder outside the context of processing a\n\t * request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param controllerType the controller to build a URI for\n\t * @return a UriComponentsBuilder instance (never {@code null})\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "controllerType"
    ],
    "position": {
      "column": 1,
      "line": 176
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromController(@Nullable UriComponentsBuilder builder,\n\t\t\tClass<?> controllerType)",
    "source_code": "\tpublic static UriComponentsBuilder fromController(@Nullable UriComponentsBuilder builder,\n\t\t\tClass<?> controllerType) {\n\n\t\tbuilder = getBaseUrlToUse(builder);\n\n\t\t// Externally configured prefix via PathConfigurer..\n\t\tString prefix = getPathPrefix(controllerType);\n\t\tbuilder.path(prefix);\n\n\t\tString mapping = getClassMapping(controllerType);\n\t\tmapping = (!StringUtils.hasText(prefix + mapping) ? \"/\" : mapping);\n\t\tbuilder.path(mapping);\n\n\t\treturn builder;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromMappingName(builder,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMappingName(String)} that accepts a\n\t * {@code UriComponentsBuilder} representing the base URL. This is useful\n\t * when using MvcUriComponentsBuilder outside the context of processing a\n\t * request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param name the mapping name\n\t * @return a builder to prepare the URI String\n\t * @throws IllegalArgumentException if the mapping name is not found or\n\t * if there is no unique match\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 454
    },
    "return": "MethodArgumentBuilder",
    "signature": "public MethodArgumentBuilder fromMappingName(@Nullable UriComponentsBuilder builder, String name)",
    "source_code": "\tpublic static MethodArgumentBuilder fromMappingName(@Nullable UriComponentsBuilder builder, String name) {\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tAssert.state(wac != null, \"No WebApplicationContext\");\n\t\tMap<String, RequestMappingInfoHandlerMapping> map = wac.getBeansOfType(RequestMappingInfoHandlerMapping.class);\n\t\tList<HandlerMethod> handlerMethods = null;\n\t\tfor (RequestMappingInfoHandlerMapping mapping : map.values()) {\n\t\t\thandlerMethods = mapping.getHandlerMethodsForMappingName(name);\n\t\t\tif (handlerMethods != null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (handlerMethods == null) {\n\t\t\tthrow new IllegalArgumentException(\"Mapping not found: \" + name);\n\t\t}\n\t\telse if (handlerMethods.size() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"No unique match for mapping \" + name + \": \" + handlerMethods);\n\t\t}\n\t\telse {\n\t\t\tHandlerMethod handlerMethod = handlerMethods.get(0);\n\t\t\tClass<?> controllerType = handlerMethod.getBeanType();\n\t\t\tMethod method = handlerMethod.getMethod();\n\t\t\treturn new MethodArgumentBuilder(builder, controllerType, method);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromMethod(baseUrl,controllerType,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethod(Class, Method, Object...)}\n\t * that accepts a {@code UriComponentsBuilder} representing the base URL.\n\t * This is useful when using MvcUriComponentsBuilder outside the context of\n\t * processing a request or to apply a custom baseUrl not matching the\n\t * current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param baseUrl the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param controllerType the controller type\n\t * @param method the controller method\n\t * @param args argument values for the controller method\n\t * @return a UriComponentsBuilder instance (never {@code null})\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "baseUrl",
      "controllerType",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 271
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethod(UriComponentsBuilder baseUrl,\n\t\t\t@Nullable Class<?> controllerType, Method method, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethod(UriComponentsBuilder baseUrl,\n\t\t\t@Nullable Class<?> controllerType, Method method, Object... args) {\n\n\t\treturn fromMethodInternal(baseUrl,\n\t\t\t\t(controllerType != null ? controllerType : method.getDeclaringClass()), method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromMethod(controllerType,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link UriComponentsBuilder} from the mapping of a controller method\n\t * and an array of method argument values. The array of values  must match the\n\t * signature of the controller method. Values for {@code @RequestParam} and\n\t * {@code @PathVariable} are used for building the URI (via implementations of\n\t * {@link org.springframework.web.method.support.UriComponentsContributor\n\t * UriComponentsContributor}) while remaining argument values are ignored and\n\t * can be {@code null}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the controller type\n\t * @param method the controller method\n\t * @param args argument values for the controller method\n\t * @return a UriComponentsBuilder instance, never {@code null}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethod(Class<?> controllerType, Method method, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethod(Class<?> controllerType, Method method, Object... args) {\n\t\treturn fromMethodInternal(null, controllerType, method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromMethodCall(builder,info)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodCall(Object)} that accepts a\n\t * {@code UriComponentsBuilder} representing the base URL. This is useful\n\t * when using MvcUriComponentsBuilder outside the context of processing a\n\t * request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param info either the value returned from a \"mock\" controller\n\t * invocation or the \"mock\" controller itself after an invocation\n\t * @return a UriComponents instance\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "info"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodCall(UriComponentsBuilder builder, Object info)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodCall(UriComponentsBuilder builder, Object info) {\n\t\tAssert.isInstanceOf(MethodInvocationInfo.class, info, \"MethodInvocationInfo required\");\n\t\tMethodInvocationInfo invocationInfo = (MethodInvocationInfo) info;\n\t\tClass<?> controllerType = invocationInfo.getControllerType();\n\t\tMethod method = invocationInfo.getControllerMethod();\n\t\tObject[] arguments = invocationInfo.getArgumentValues();\n\t\treturn fromMethodInternal(builder, controllerType, method, arguments);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromMethodName(builder,controllerType,methodName,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodName(Class, String, Object...)} that\n\t * accepts a {@code UriComponentsBuilder} representing the base URL. This is\n\t * useful when using MvcUriComponentsBuilder outside the context of processing\n\t * a request or to apply a custom baseUrl not matching the current request.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param builder the builder for the base URL; the builder will be cloned\n\t * and therefore not modified and may be re-used for further calls.\n\t * @param controllerType the controller\n\t * @param methodName the method name\n\t * @param args the argument values\n\t * @return a UriComponentsBuilder instance, never {@code null}\n\t * @throws IllegalArgumentException if there is no matching or\n\t * if there is more than one matching method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "builder",
      "controllerType",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodName(UriComponentsBuilder builder,\n\t\t\tClass<?> controllerType, String methodName, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodName(UriComponentsBuilder builder,\n\t\t\tClass<?> controllerType, String methodName, Object... args) {\n\n\t\tMethod method = getMethod(controllerType, methodName, args);\n\t\treturn fromMethodInternal(builder, controllerType, method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#fromMethodName(controllerType,methodName,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a {@link UriComponentsBuilder} from the mapping of a controller\n\t * method and an array of method argument values. This method delegates\n\t * to {@link #fromMethod(Class, Method, Object...)}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @param controllerType the controller\n\t * @param methodName the method name\n\t * @param args the argument values\n\t * @return a UriComponentsBuilder instance, never {@code null}\n\t * @throws IllegalArgumentException if there is no matching or\n\t * if there is more than one matching method\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromMethodName(Class<?> controllerType,\n\t\t\tString methodName, Object... args)",
    "source_code": "\tpublic static UriComponentsBuilder fromMethodName(Class<?> controllerType,\n\t\t\tString methodName, Object... args) {\n\n\t\tMethod method = getMethod(controllerType, methodName, args);\n\t\treturn fromMethodInternal(null, controllerType, method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getExceptionHandlerMethod(handlerMethod,exception,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find an {@code @ExceptionHandler} method for the given exception. The default\n\t * implementation searches methods in the class hierarchy of the controller first\n\t * and if not found, it continues searching for additional {@code @ExceptionHandler}\n\t * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}\n\t * Spring-managed beans were detected.\n\t * @param handlerMethod the method where the exception was raised (may be {@code null})\n\t * @param exception the raised exception\n\t * @param webRequest the original web request that resulted in a handler error\n\t * @return a method to handle the exception, or {@code null} if none\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handlerMethod",
      "exception",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 517
    },
    "return": "ServletInvocableHandlerMethod",
    "signature": "protected ServletInvocableHandlerMethod getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception, ServletWebRequest webRequest)",
    "source_code": "\tprotected ServletInvocableHandlerMethod getExceptionHandlerMethod(\n\t\t\t@Nullable HandlerMethod handlerMethod, Exception exception, ServletWebRequest webRequest) {\n\n\t\tList<MediaType> acceptedMediaTypes = List.of(MediaType.ALL);\n\t\ttry {\n\t\t\tacceptedMediaTypes = this.contentNegotiationManager.resolveMediaTypes(webRequest);\n\t\t}\n\t\tcatch (HttpMediaTypeNotAcceptableException mediaTypeExc) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Could not resolve accepted media types for @ExceptionHandler [\" + webRequest.getHeader(HttpHeaders.ACCEPT) + \"]\", mediaTypeExc);\n\t\t\t}\n\t\t}\n\n\t\tClass<?> handlerType = null;\n\n\t\tif (handlerMethod != null) {\n\t\t\t// Local exception handler methods on the controller class itself.\n\t\t\t// To be invoked through the proxy, even in case of an interface-based proxy.\n\t\t\thandlerType = handlerMethod.getBeanType();\n\t\t\tExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.computeIfAbsent(\n\t\t\t\t\thandlerType, ExceptionHandlerMethodResolver::new);\n\n\t\t\tfor (MediaType mediaType : acceptedMediaTypes) {\n\t\t\t\tExceptionHandlerMappingInfo mappingInfo = resolver.resolveExceptionMapping(exception, mediaType);\n\t\t\t\tif (mappingInfo != null) {\n\t\t\t\t\tif (!mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\t\twebRequest.setAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mappingInfo.getProducibleTypes(), RequestAttributes.SCOPE_REQUEST);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ServletInvocableHandlerMethod(handlerMethod.getBean(), mappingInfo.getHandlerMethod(), this.applicationContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// For advice applicability check below (involving base packages, assignable types\n\t\t\t// and annotation presence), use target class instead of interface-based proxy.\n\t\t\tif (Proxy.isProxyClass(handlerType)) {\n\t\t\t\thandlerType = AopUtils.getTargetClass(handlerMethod.getBean());\n\t\t\t}\n\t\t}\n\n\t\tfor (Map.Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tControllerAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(handlerType)) {\n\t\t\t\tExceptionHandlerMethodResolver resolver = entry.getValue();\n\t\t\t\tfor (MediaType mediaType : acceptedMediaTypes) {\n\t\t\t\t\tExceptionHandlerMappingInfo mappingInfo = resolver.resolveExceptionMapping(exception, mediaType);\n\t\t\t\t\tif (mappingInfo != null) {\n\t\t\t\t\t\tif (!mappingInfo.getProducibleTypes().isEmpty()) {\n\t\t\t\t\t\t\twebRequest.setAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mappingInfo.getProducibleTypes(), RequestAttributes.SCOPE_REQUEST);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new ServletInvocableHandlerMethod(advice.resolveBean(), mappingInfo.getHandlerMethod(), this.applicationContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getLastModifiedInternal(request,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation always returns -1. An {@code @RequestMapping} method can\n\t * calculate the lastModified value, call {@link WebRequest#checkNotModified(long)},\n\t * and return {@code null} if the result of that call is {@code true}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 913
    },
    "return": "long",
    "signature": "protected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod)",
    "source_code": "\tprotected long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod) {\n\t\treturn -1;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getMappingForMethod(method,handlerType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Uses type-level and method-level {@link RequestMapping @RequestMapping}\n\t * and {@link HttpExchange @HttpExchange} annotations to create the\n\t * {@link RequestMappingInfo}.\n\t * @return the created {@code RequestMappingInfo}, or {@code null} if the method\n\t * does not have a {@code @RequestMapping} or {@code @HttpExchange} annotation\n\t * @see #getCustomMethodCondition(Method)\n\t * @see #getCustomTypeCondition(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "method",
      "handlerType"
    ],
    "position": {
      "column": 1,
      "line": 316
    },
    "return": "RequestMappingInfo",
    "signature": "protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType)",
    "source_code": "\tprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n\t\tRequestMappingInfo info = createRequestMappingInfo(method);\n\t\tif (info != null) {\n\t\t\tRequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n\t\t\tif (typeInfo != null) {\n\t\t\t\tinfo = typeInfo.combine(info);\n\t\t\t}\n\t\t\tif (info.isEmptyMapping()) {\n\t\t\t\tinfo = info.mutate().paths(\"\", \"/\").options(this.config).build();\n\t\t\t}\n\t\t\tString prefix = getPathPrefix(handlerType);\n\t\t\tif (prefix != null) {\n\t\t\t\tinfo = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n\t\t\t}\n\t\t}\n\t\treturn info;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getProducibleMediaTypes(request,valueClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types that can be produced.\n\t * @see #getProducibleMediaTypes(HttpServletRequest, Class, Type)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "valueClass"
    ],
    "position": {
      "column": 1,
      "line": 408
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass)",
    "source_code": "\tprotected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass) {\n\t\treturn getProducibleMediaTypes(request, valueClass, null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getProducibleMediaTypes(request,valueClass,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Returns the media types that can be produced. The resulting media types are:\n\t * <ul>\n\t * <li>The producible media types specified in the request mappings, or\n\t * <li>Media types of configured converters that can write the specific return value, or\n\t * <li>{@link MediaType#ALL}\n\t * </ul>\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "valueClass",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "List<MediaType>",
    "signature": "protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass, @Nullable Type targetType)",
    "source_code": "\tprotected List<MediaType> getProducibleMediaTypes(\n\t\t\tHttpServletRequest request, Class<?> valueClass, @Nullable Type targetType) {\n\n\t\tSet<MediaType> mediaTypes =\n\t\t\t\t(Set<MediaType>) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\t\tif (!CollectionUtils.isEmpty(mediaTypes)) {\n\t\t\treturn new ArrayList<>(mediaTypes);\n\t\t}\n\t\tSet<MediaType> result = new LinkedHashSet<>();\n\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\tif (converter instanceof GenericHttpMessageConverter<?> genericConverter && targetType != null) {\n\t\t\t\tif (genericConverter.canWrite(targetType, valueClass, null)) {\n\t\t\t\t\tresult.addAll(converter.getSupportedMediaTypes(valueClass));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (converter instanceof SmartHttpMessageConverter<?> smartConverter && targetType != null) {\n\t\t\t\tResolvableType resolvableType = ResolvableType.forType(targetType);\n\t\t\t\tif (smartConverter.canWrite(resolvableType, valueClass, null)) {\n\t\t\t\t\tresult.addAll(converter.getSupportedMediaTypes(valueClass));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (converter.canWrite(valueClass, null)) {\n\t\t\t\tresult.addAll(converter.getSupportedMediaTypes(valueClass));\n\t\t\t}\n\t\t}\n\t\treturn (result.isEmpty() ? Collections.singletonList(MediaType.ALL) : new ArrayList<>(result));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#getRequestParameter(name,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 152
    },
    "return": "Object",
    "signature": "protected Object getRequestParameter(String name, Class<?> type)",
    "source_code": "\t\tprotected Object getRequestParameter(String name, Class<?> type) {\n\t\t\tObject value = super.getRequestParameter(name, type);\n\t\t\tif (value == null) {\n\t\t\t\tMap<String, String> uriVars = getUriVars(getRequest());\n\t\t\t\tif (uriVars != null) {\n\t\t\t\t\tvalue = uriVars.get(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleAsyncRequestNotUsableException(ex,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link AsyncRequestNotUsableException}.\n\t * <p>By default, return {@code null} since the response is not usable.\n\t * @param ex the exception to handle\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleAsyncRequestNotUsableException(AsyncRequestNotUsableException ex, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleAsyncRequestNotUsableException(\n\t\t\tAsyncRequestNotUsableException ex, WebRequest request) {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleAsyncRequestTimeoutException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link AsyncRequestTimeoutException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 421
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleAsyncRequestTimeoutException(\n\t\t\tAsyncRequestTimeoutException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleConversionNotSupported(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ConversionNotSupportedException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleConversionNotSupported(ConversionNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleConversionNotSupported(\n\t\t\tConversionNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tObject[] args = {ex.getPropertyName(), ex.getValue()};\n\t\tString defaultDetail = \"Failed to convert '\" + args[0] + \"' with value: '\" + args[1] + \"'\";\n\t\tProblemDetail body = createProblemDetail(ex, status, defaultDetail, null, args, request);\n\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleEmptyBody(body,inputMessage,parameter,targetType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "body",
      "inputMessage",
      "parameter",
      "targetType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 121
    },
    "return": "Object",
    "signature": "public Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType, Class<? extends HttpMessageConverter<?>> converterType) {\n\n\t\tfor (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {\n\t\t\tif (advice.supports(parameter, targetType, converterType)) {\n\t\t\t\tbody = advice.handleEmptyBody(body, inputMessage, parameter, targetType, converterType);\n\t\t\t}\n\t\t}\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleErrorResponseException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link ErrorResponseException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 439
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleErrorResponseException(ErrorResponseException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleErrorResponseException(\n\t\t\tErrorResponseException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleException(ex,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 143
    },
    "return": "ResponseEntity<Object>",
    "signature": "public ResponseEntity<Object> handleException(Exception ex, WebRequest request)",
    "source_code": "\tpublic final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {\n\t\tif (ex instanceof HttpRequestMethodNotSupportedException subEx) {\n\t\t\treturn handleHttpRequestMethodNotSupported(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof HttpMediaTypeNotSupportedException subEx) {\n\t\t\treturn handleHttpMediaTypeNotSupported(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException subEx) {\n\t\t\treturn handleHttpMediaTypeNotAcceptable(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MissingPathVariableException subEx) {\n\t\t\treturn handleMissingPathVariable(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MissingServletRequestParameterException subEx) {\n\t\t\treturn handleMissingServletRequestParameter(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MissingServletRequestPartException subEx) {\n\t\t\treturn handleMissingServletRequestPart(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof ServletRequestBindingException subEx) {\n\t\t\treturn handleServletRequestBindingException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MethodArgumentNotValidException subEx) {\n\t\t\treturn handleMethodArgumentNotValid(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof HandlerMethodValidationException subEx) {\n\t\t\treturn handleHandlerMethodValidationException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof NoHandlerFoundException subEx) {\n\t\t\treturn handleNoHandlerFoundException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof NoResourceFoundException subEx) {\n\t\t\treturn handleNoResourceFoundException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof AsyncRequestTimeoutException subEx) {\n\t\t\treturn handleAsyncRequestTimeoutException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof ErrorResponseException subEx) {\n\t\t\treturn handleErrorResponseException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\t\telse if (ex instanceof MaxUploadSizeExceededException subEx) {\n\t\t\treturn handleMaxUploadSizeExceededException(subEx, subEx.getHeaders(), subEx.getStatusCode(), request);\n\t\t}\n\n\t\t// Lower level exceptions, and exceptions used symmetrically on client and server\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tif (ex instanceof ConversionNotSupportedException theEx) {\n\t\t\treturn handleConversionNotSupported(theEx, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof TypeMismatchException theEx) {\n\t\t\treturn handleTypeMismatch(theEx, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse if (ex instanceof HttpMessageNotReadableException theEx) {\n\t\t\treturn handleHttpMessageNotReadable(theEx, headers, HttpStatus.BAD_REQUEST, request);\n\t\t}\n\t\telse if (ex instanceof HttpMessageNotWritableException theEx) {\n\t\t\treturn handleHttpMessageNotWritable(theEx, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof MethodValidationException theEx) {\n\t\t\treturn handleMethodValidationException(theEx, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);\n\t\t}\n\t\telse if (ex instanceof AsyncRequestNotUsableException theEx) {\n\t\t\treturn handleAsyncRequestNotUsableException(theEx, request);\n\t\t}\n\t\telse {\n\t\t\t// Unknown exception, typically a wrapper with a common MVC exception as cause\n\t\t\t// (since @ExceptionHandler type declarations also match nested causes):\n\t\t\t// We only deal with top-level MVC exceptions here, so let's rethrow the given\n\t\t\t// exception for further processing through the HandlerExceptionResolver chain.\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleExceptionInternal(ex,body,headers,statusCode,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Internal handler method that all others in this class delegate to, for\n\t * common handling, and for the creation of a {@link ResponseEntity}.\n\t * <p>The default implementation does the following:\n\t * <ul>\n\t * <li>return {@code null} if response is already committed\n\t * <li>set the {@code \"jakarta.servlet.error.exception\"} request attribute\n\t * if the response status is 500 (INTERNAL_SERVER_ERROR).\n\t * <li>extract the {@link ErrorResponse#getBody() body} from\n\t * {@link ErrorResponse} exceptions, if the {@code body} is {@code null}.\n\t * </ul>\n\t * @param ex the exception to handle\n\t * @param body the body to use for the response\n\t * @param headers the headers to use for the response\n\t * @param statusCode the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "body",
      "headers",
      "statusCode",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 642
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleExceptionInternal(Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleExceptionInternal(\n\t\t\tException ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request) {\n\n\t\tif (request instanceof ServletWebRequest servletWebRequest) {\n\t\t\tHttpServletResponse response = servletWebRequest.getResponse();\n\t\t\tif (response != null && response.isCommitted()) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Response already committed. Ignoring: \" + ex);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (body == null && ex instanceof ErrorResponse errorResponse) {\n\t\t\tbody = errorResponse.updateAndGetBody(this.messageSource, LocaleContextHolder.getLocale());\n\t\t}\n\n\t\tif (statusCode.equals(HttpStatus.INTERNAL_SERVER_ERROR) && body == null) {\n\t\t\trequest.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);\n\t\t}\n\n\t\treturn createResponseEntity(body, headers, statusCode, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHandlerMethodValidationException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HandlerMethodValidationException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHandlerMethodValidationException(HandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHandlerMethodValidationException(\n\t\t\tHandlerMethodValidationException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotAcceptable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMediaTypeNotAcceptableException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 263
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotAcceptable(\n\t\t\tHttpMediaTypeNotAcceptableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMediaTypeNotSupported(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMediaTypeNotSupportedException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 246
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMediaTypeNotSupported(\n\t\t\tHttpMediaTypeNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMessageNotReadable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMessageNotReadableException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMessageNotReadable(HttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMessageNotReadable(\n\t\t\tHttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Failed to read request\", null, null, request);\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpMessageNotWritable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpMessageNotWritableException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 547
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpMessageNotWritable(HttpMessageNotWritableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpMessageNotWritable(\n\t\t\tHttpMessageNotWritableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Failed to write request\", null, null, request);\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleHttpRequestMethodNotSupported(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link HttpRequestMethodNotSupportedException}.\n\t * <p>This method logs a warning and delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleHttpRequestMethodNotSupported(\n\t\t\tHttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleInternal(request,response,handlerMethod)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 869
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tModelAndView mav;\n\t\tcheckRequest(request);\n\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No HttpSession available -> no mutex necessary\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No synchronization on session demanded at all...\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\n\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprepareResponse(response);\n\t\t\t}\n\t\t}\n\n\t\treturn mav;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMaxUploadSizeExceededException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of any {@link MaxUploadSizeExceededException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 457
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMaxUploadSizeExceededException(MaxUploadSizeExceededException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMaxUploadSizeExceededException(\n\t\t\tMaxUploadSizeExceededException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMethodArgumentNotValid(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodArgumentNotValidException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to be written to the response\n\t * @param status the selected response status\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 349
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodArgumentNotValid(\n\t\t\tMethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMethodValidationException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MethodValidationException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 569
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMethodValidationException(MethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMethodValidationException(\n\t\t\tMethodValidationException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {\n\n\t\tProblemDetail body = createProblemDetail(ex, status, \"Validation failed\", null, null, request);\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingPathVariable(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingPathVariableException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 281
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingPathVariable(MissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingPathVariable(\n\t\t\tMissingPathVariableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestParameter(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingServletRequestParameterException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestParameter(MissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestParameter(\n\t\t\tMissingServletRequestParameterException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingServletRequestPart(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link MissingServletRequestPartException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 315
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleMissingServletRequestPart(MissingServletRequestPartException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleMissingServletRequestPart(\n\t\t\tMissingServletRequestPartException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingValue(name,parameter)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "protected void handleMissingValue(String name, MethodParameter parameter)",
    "source_code": "\tprotected void handleMissingValue(String name, MethodParameter parameter) throws ServletRequestBindingException {\n\t\tthrow new MissingPathVariableException(name, parameter);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleMissingValueAfterConversion(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "protected void handleMissingValueAfterConversion(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected void handleMissingValueAfterConversion(\n\t\t\tString name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\n\t\tthrow new MissingPathVariableException(name, parameter, true);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleNoHandlerFoundException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoHandlerFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoHandlerFoundException(NoHandlerFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoHandlerFoundException(\n\t\t\tNoHandlerFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleNoResourceFoundException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link NoResourceFoundException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleNoResourceFoundException(NoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleNoResourceFoundException(\n\t\t\tNoResourceFoundException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleResolvedValue(arg,name,parameter,mavContainer,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "arg",
      "name",
      "parameter",
      "mavContainer",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "protected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest request)",
    "source_code": "\tprotected void handleResolvedValue(@Nullable Object arg, String name, MethodParameter parameter,\n\t\t\t@Nullable ModelAndViewContainer mavContainer, NativeWebRequest request) {\n\n\t\tString key = View.PATH_VARIABLES;\n\t\tint scope = RequestAttributes.SCOPE_REQUEST;\n\t\tMap<String, Object> pathVars = (Map<String, Object>) request.getAttribute(key, scope);\n\t\tif (pathVars == null) {\n\t\t\tpathVars = new HashMap<>();\n\t\t\trequest.setAttribute(key, pathVars, scope);\n\t\t}\n\t\tpathVars.put(name, arg);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleReturnValue(returnValue,returnType,mavContainer,webRequest)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mavContainer",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 86
    },
    "return": "void",
    "signature": "public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)",
    "source_code": "\tpublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tif (returnValue == null) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tif (returnValue instanceof Collection<?> mavs) {\n\t\t\treturnValue = FragmentsRendering.with((Collection<ModelAndView>) mavs).build();\n\t\t}\n\n\t\tif (returnValue instanceof FragmentsRendering rendering) {\n\t\t\tmavContainer.setView(rendering);\n\t\t\treturn;\n\t\t}\n\n\t\tModelAndView mav = (ModelAndView) returnValue;\n\t\tif (mav.isReference()) {\n\t\t\tString viewName = mav.getViewName();\n\t\t\tmavContainer.setViewName(viewName);\n\t\t\tif (viewName != null && isRedirectViewName(viewName)) {\n\t\t\t\tmavContainer.setRedirectModelScenario(true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tView view = mav.getView();\n\t\t\tmavContainer.setView(view);\n\t\t\tif (view instanceof SmartView smartView && smartView.isRedirectView()) {\n\t\t\t\tmavContainer.setRedirectModelScenario(true);\n\t\t\t}\n\t\t}\n\t\tmavContainer.setStatus(mav.getStatus());\n\t\tmavContainer.addAllAttributes(mav.getModel());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleServletRequestBindingException(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link ServletRequestBindingException}.\n\t * <p>This method delegates to {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 332
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleServletRequestBindingException(ServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleServletRequestBindingException(\n\t\t\tServletRequestBindingException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\treturn handleExceptionInternal(ex, null, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleTypeMismatch(ex,headers,status,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Customize the handling of {@link TypeMismatchException}.\n\t * <p>By default this method creates a {@link ProblemDetail} with the status\n\t * and a short detail message, and also looks up an override for the detail\n\t * via {@link MessageSource}, before delegating to\n\t * {@link #handleExceptionInternal}.\n\t * @param ex the exception to handle\n\t * @param headers the headers to use for the response\n\t * @param status the status code to use for the response\n\t * @param request the current request\n\t * @return a {@code ResponseEntity} for the response to use, possibly\n\t * {@code null} when the response is already committed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "headers",
      "status",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 501
    },
    "return": "ResponseEntity<Object>",
    "signature": "protected ResponseEntity<Object> handleTypeMismatch(TypeMismatchException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request)",
    "source_code": "\tprotected ResponseEntity<Object> handleTypeMismatch(\n\t\t\tTypeMismatchException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\n\n\t\tObject[] args = {ex.getPropertyName(), ex.getValue()};\n\t\tString defaultDetail = \"Failed to convert '\" + args[0] + \"' with value: '\" + args[1] + \"'\";\n\t\tString messageCode = ErrorResponse.getDefaultDetailMessageCode(TypeMismatchException.class, null);\n\t\tProblemDetail body = createProblemDetail(ex, status, defaultDetail, messageCode, args, request);\n\n\t\treturn handleExceptionInternal(ex, body, headers, status, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#handleValue(returnValue,returnType,mav,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given reactive return value and decide whether to adapt it\n\t * to a {@link ResponseBodyEmitter} or a {@link DeferredResult}.\n\t * @return an emitter for streaming, or {@code null} if handled internally\n\t * with a {@link DeferredResult}\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnValue",
      "returnType",
      "mav",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 141
    },
    "return": "ResponseBodyEmitter",
    "signature": "public ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request)",
    "source_code": "\tpublic ResponseBodyEmitter handleValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mav, NativeWebRequest request) throws Exception {\n\n\t\tAssert.notNull(returnValue, \"Expected return value\");\n\t\tClass<?> clazz = returnValue.getClass();\n\t\tReactiveAdapter adapter = this.adapterRegistry.getAdapter(clazz);\n\t\tAssert.state(adapter != null, () -> \"Unexpected return value type: \" + clazz);\n\n\t\tTaskDecorator taskDecorator = null;\n\t\tif (isContextPropagationPresent) {\n\t\t\tContextSnapshotHelper helper = (ContextSnapshotHelper) this.contextSnapshotHelper;\n\t\t\tAssert.notNull(helper, \"No ContextSnapshotHelper\");\n\t\t\treturnValue = helper.writeReactorContext(returnValue);\n\t\t\ttaskDecorator = helper.getTaskDecorator();\n\t\t}\n\n\t\tResolvableType elementType = ResolvableType.forMethodParameter(returnType).getGeneric();\n\t\tClass<?> elementClass = elementType.toClass();\n\n\t\tCollection<MediaType> mediaTypes = getMediaTypes(request);\n\t\tOptional<MediaType> mediaType = mediaTypes.stream().filter(MimeType::isConcrete).findFirst();\n\n\t\tif (adapter.isMultiValue()) {\n\t\t\tif (mediaTypes.stream().anyMatch(MediaType.TEXT_EVENT_STREAM::includes) ||\n\t\t\t\t\tServerSentEvent.class.isAssignableFrom(elementClass)) {\n\t\t\t\tSseEmitter emitter = new SseEmitter(STREAMING_TIMEOUT_VALUE);\n\t\t\t\tnew SseEmitterSubscriber(emitter, this.taskExecutor, taskDecorator).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tif (CharSequence.class.isAssignableFrom(elementClass)) {\n\t\t\t\tResponseBodyEmitter emitter = getEmitter(mediaType.orElse(MediaType.TEXT_PLAIN));\n\t\t\t\tnew TextEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t\tMediaType streamingResponseType = findConcreteJsonStreamMediaType(mediaTypes);\n\t\t\tif (streamingResponseType != null) {\n\t\t\t\tResponseBodyEmitter emitter = getEmitter(streamingResponseType);\n\t\t\t\tnew JsonEmitterSubscriber(emitter, this.taskExecutor).connect(adapter, returnValue);\n\t\t\t\treturn emitter;\n\t\t\t}\n\t\t}\n\n\t\t// Not streaming...\n\t\tDeferredResult<Object> result = new DeferredResult<>();\n\t\tnew DeferredResultSubscriber(result, adapter, elementType).connect(adapter, returnValue);\n\t\tWebAsyncUtils.getAsyncManager(request).startDeferredResultProcessing(result, mav);\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#initCorsConfiguration(handler,method,mappingInfo)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mappingInfo"
    ],
    "position": {
      "column": 1,
      "line": 541
    },
    "return": "CorsConfiguration",
    "signature": "protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo)",
    "source_code": "\tprotected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {\n\t\tHandlerMethod handlerMethod = createHandlerMethod(handler, method);\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tCrossOrigin typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(beanType, CrossOrigin.class);\n\t\tCrossOrigin methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, CrossOrigin.class);\n\n\t\tif (typeAnnotation == null && methodAnnotation == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCorsConfiguration config = new CorsConfiguration();\n\t\tupdateCorsConfig(config, typeAnnotation);\n\t\tupdateCorsConfig(config, methodAnnotation);\n\n\t\tif (CollectionUtils.isEmpty(config.getAllowedMethods())) {\n\t\t\tfor (RequestMethod allowedMethod : mappingInfo.getMethodsCondition().getMethods()) {\n\t\t\t\tconfig.addAllowedMethod(allowedMethod.name());\n\t\t\t}\n\t\t}\n\t\treturn config.applyPermitDefaultValues();\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#intercept(obj,method,args,proxy)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "obj",
      "method",
      "args",
      "proxy"
    ],
    "position": {
      "column": 1,
      "line": 737
    },
    "return": "Object",
    "signature": "public Object intercept(@Nullable Object obj, Method method, Object[] args, @Nullable MethodProxy proxy)",
    "source_code": "\t\tpublic Object intercept(@Nullable Object obj, Method method, Object[] args, @Nullable MethodProxy proxy) {\n\t\t\tswitch (method.getName()) {\n\t\t\t\tcase \"getControllerType\" -> {\n\t\t\t\t\treturn this.controllerType;\n\t\t\t\t}\n\t\t\t\tcase \"getControllerMethod\" -> {\n\t\t\t\t\treturn this.controllerMethod;\n\t\t\t\t}\n\t\t\t\tcase \"getArgumentValues\" -> {\n\t\t\t\t\treturn this.argumentValues;\n\t\t\t\t}\n\t\t\t\tdefault -> {\n\t\t\t\t\tif (ReflectionUtils.isObjectMethod(method)) {\n\t\t\t\t\t\treturn ReflectionUtils.invokeMethod(method, obj, args);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.controllerMethod = method;\n\t\t\t\t\t\tthis.argumentValues = args;\n\t\t\t\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn (returnType == void.class ? null : returnType.cast(initProxy(returnType, this)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"Failed to create proxy for controller method return type: \" + method, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invoke(proxy,method,args)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "proxy",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 770
    },
    "return": "Object",
    "signature": "public Object invoke(Object proxy, Method method, @Nullable Object[] args)",
    "source_code": "\t\tpublic Object invoke(Object proxy, Method method, @Nullable Object[] args) {\n\t\t\treturn intercept(proxy, method, (args != null ? args : new Object[0]), null);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeAndHandle(webRequest,mavContainer,providedArgs)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webRequest",
      "mavContainer",
      "providedArgs"
    ],
    "position": {
      "column": 1,
      "line": 115
    },
    "return": "void",
    "signature": "public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs)",
    "source_code": "\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\t\tsetResponseStatus(webRequest);\n\n\t\tif (returnValue == null) {\n\t\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\t\tdisableContentCachingIfNecessary(webRequest);\n\t\t\t\tmavContainer.setRequestHandled(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tmavContainer.setRequestHandled(false);\n\t\tAssert.state(this.returnValueHandlers != null, \"No return value handlers\");\n\t\ttry {\n\t\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeErrorResponseInterceptors(detail,errorResponse)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the configured {@link ErrorResponse.Interceptor}'s.\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "detail",
      "errorResponse"
    ],
    "position": {
      "column": 1,
      "line": 171
    },
    "return": "void",
    "signature": "protected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse)",
    "source_code": "\tprotected void invokeErrorResponseInterceptors(ProblemDetail detail, @Nullable ErrorResponse errorResponse) {\n\t\ttry {\n\t\t\tfor (ErrorResponse.Interceptor handler : this.errorResponseInterceptors) {\n\t\t\t\thandler.handleError(detail, errorResponse);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// ignore\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#invokeHandlerMethod(request,response,handlerMethod)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}\n\t * if view resolution is required.\n\t * @since 4.2\n\t * @see #createInvocableHandlerMethod(HandlerMethod)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handlerMethod"
    ],
    "position": {
      "column": 1,
      "line": 936
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod)",
    "source_code": "\tprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n\t\tasyncManager.setTaskExecutor(this.taskExecutor);\n\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\n\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n\t\t// Obtain wrapped response to enforce lifecycle rule from Servlet spec, section 2.3.3.4\n\t\tresponse = asyncWebRequest.getNativeResponse(HttpServletResponse.class);\n\n\t\tServletWebRequest webRequest = (asyncWebRequest instanceof ServletWebRequest ?\n\t\t\t\t(ServletWebRequest) asyncWebRequest : new ServletWebRequest(request, response));\n\n\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n\t\tServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n\t\tif (this.argumentResolvers != null) {\n\t\t\tinvocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t}\n\t\tif (this.returnValueHandlers != null) {\n\t\t\tinvocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t}\n\t\tinvocableMethod.setDataBinderFactory(binderFactory);\n\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\t\tinvocableMethod.setMethodValidator(this.methodValidator);\n\n\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\n\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\tObject result = asyncManager.getConcurrentResult();\n\t\t\tObject[] resultContext = asyncManager.getConcurrentResultContext();\n\t\t\tAssert.state(resultContext != null && resultContext.length > 0, \"Missing result context\");\n\t\t\tmavContainer = (ModelAndViewContainer) resultContext[0];\n\t\t\tasyncManager.clearConcurrentResult();\n\t\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\t\tString formatted = LogFormatUtils.formatValue(result, !traceOn);\n\t\t\t\treturn \"Resume with async result [\" + formatted + \"]\";\n\t\t\t});\n\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\n\t\t}\n\n\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#isBindExceptionRequired(binder,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Whether to raise a fatal bind exception on validation errors.\n\t * @param binder the data binder used to perform data binding\n\t * @param parameter the method parameter descriptor\n\t * @return {@code true} if the next method argument is not of type {@link Errors}\n\t * @since 4.1.5\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 304
    },
    "return": "boolean",
    "signature": "protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {\n\t\tint i = parameter.getParameterIndex();\n\t\tClass<?>[] paramTypes = parameter.getExecutable().getParameterTypes();\n\t\tboolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));\n\t\treturn !hasBindingResult;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#isResourceType(value,returnType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return whether the returned value or the declared return type extends {@link Resource}.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType"
    ],
    "position": {
      "column": 1,
      "line": 385
    },
    "return": "boolean",
    "signature": "protected boolean isResourceType(@Nullable Object value, MethodParameter returnType)",
    "source_code": "\tprotected boolean isResourceType(@Nullable Object value, MethodParameter returnType) {\n\t\tClass<?> clazz = getReturnValueType(value, returnType);\n\t\treturn clazz != InputStreamResource.class && Resource.class.isAssignableFrom(clazz);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#match(request,pattern)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "pattern"
    ],
    "position": {
      "column": 1,
      "line": 528
    },
    "return": "RequestMatchResult",
    "signature": "public RequestMatchResult match(HttpServletRequest request, String pattern)",
    "source_code": "\tpublic RequestMatchResult match(HttpServletRequest request, String pattern) {\n\t\tAssert.state(getPatternParser() == null, \"This HandlerMapping uses PathPatterns.\");\n\t\tRequestMappingInfo info = RequestMappingInfo.paths(pattern).options(this.config).build();\n\t\tRequestMappingInfo match = info.getMatchingCondition(request);\n\t\treturn (match != null && match.getPatternsCondition() != null ?\n\t\t\t\tnew RequestMatchResult(\n\t\t\t\t\t\tmatch.getPatternsCondition().getPatterns().iterator().next(),\n\t\t\t\t\t\tUrlPathHelper.getResolvedLookupPath(request),\n\t\t\t\t\t\tgetPathMatcher()) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#read(clazz,inputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clazz",
      "inputMessage"
    ],
    "position": {
      "column": 1,
      "line": 424
    },
    "return": "String",
    "signature": "public String read(Class<? extends String> clazz, HttpInputMessage inputMessage)",
    "source_code": "\t\tpublic String read(Class<? extends String> clazz, HttpInputMessage inputMessage) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#readWithMessageConverters(inputMessage,parameter,targetType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param parameter the method parameter descriptor\n\t * @param targetType the target type, not necessarily the same as the method\n\t * parameter type, for example, for {@code HttpEntity<String>}.\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "inputMessage",
      "parameter",
      "targetType"
    ],
    "position": {
      "column": 1,
      "line": 148
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType)",
    "source_code": "\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tClass<?> contextClass = parameter.getContainingClass();\n\t\tClass<T> targetClass = (targetType instanceof Class clazz ? clazz : null);\n\t\tResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);\n\t\tif (targetClass == null) {\n\t\t\ttargetClass = (Class<T>) resolvableType.resolve();\n\t\t}\n\n\t\tMediaType contentType;\n\t\tboolean noContentType = false;\n\t\ttry {\n\t\t\tcontentType = inputMessage.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new HttpMediaTypeNotSupportedException(\n\t\t\t\t\tex.getMessage(), getSupportedMediaTypes(targetClass != null ? targetClass : Object.class));\n\t\t}\n\t\tif (contentType == null) {\n\t\t\tnoContentType = true;\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tHttpMethod httpMethod = (inputMessage instanceof HttpRequest httpRequest ? httpRequest.getMethod() : null);\n\t\tObject body = NO_VALUE;\n\n\t\tEmptyBodyCheckingHttpInputMessage message = null;\n\t\ttry {\n\t\t\tResolvableType targetResolvableType = null;\n\t\t\tmessage = new EmptyBodyCheckingHttpInputMessage(inputMessage);\n\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\t\tClass<HttpMessageConverter<?>> converterClass = (Class<HttpMessageConverter<?>>) converter.getClass();\n\t\t\t\tConverterType converterTypeToUse = null;\n\t\t\t\tif (converter instanceof GenericHttpMessageConverter<?> genericConverter) {\n\t\t\t\t\tif (genericConverter.canRead(targetType, contextClass, contentType)) {\n\t\t\t\t\t\tconverterTypeToUse = ConverterType.GENERIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (converter instanceof SmartHttpMessageConverter<?> smartConverter) {\n\t\t\t\t\tif (targetResolvableType == null) {\n\t\t\t\t\t\ttargetResolvableType = getNestedTypeIfNeeded(resolvableType);\n\t\t\t\t\t}\n\t\t\t\t\tif (smartConverter.canRead(targetResolvableType, contentType)) {\n\t\t\t\t\t\tconverterTypeToUse = ConverterType.SMART;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (targetClass != null && converter.canRead(targetClass, contentType)) {\n\t\t\t\t\tconverterTypeToUse = ConverterType.BASE;\n\t\t\t\t}\n\t\t\t\tif (converterTypeToUse != null) {\n\t\t\t\t\tif (message.hasBody()) {\n\t\t\t\t\t\tHttpInputMessage msgToUse =\n\t\t\t\t\t\t\t\tgetAdvice().beforeBodyRead(message, parameter, targetType, converterClass);\n\t\t\t\t\t\tbody = switch (converterTypeToUse) {\n\t\t\t\t\t\t\tcase BASE -> ((HttpMessageConverter<T>) converter).read(targetClass, msgToUse);\n\t\t\t\t\t\t\tcase GENERIC -> ((GenericHttpMessageConverter<?>) converter).read(targetType, contextClass, msgToUse);\n\t\t\t\t\t\t\tcase SMART -> ((SmartHttpMessageConverter<?>) converter).read(targetResolvableType, msgToUse, null);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbody = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterClass);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbody = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterClass);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (body == NO_VALUE && noContentType && !message.hasBody()) {\n\t\t\t\tbody = getAdvice().handleEmptyBody(\n\t\t\t\t\t\tnull, message, parameter, targetType, NoContentTypeHttpMessageConverter.class);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\"I/O error while reading input message\", ex, inputMessage);\n\t\t}\n\t\tfinally {\n\t\t\tif (message != null && message.hasBody()) {\n\t\t\t\tcloseStreamIfNecessary(message.getBody());\n\t\t\t}\n\t\t}\n\n\t\tif (body == NO_VALUE) {\n\t\t\tif (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) || (noContentType && !message.hasBody())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(contentType,\n\t\t\t\t\tgetSupportedMediaTypes(targetClass != null ? targetClass : Object.class), httpMethod);\n\t\t}\n\n\t\tMediaType selectedContentType = contentType;\n\t\tObject theBody = body;\n\t\tLogFormatUtils.traceDebug(logger, traceOn -> {\n\t\t\tString formatted = LogFormatUtils.formatValue(theBody, !traceOn);\n\t\t\treturn \"Read \\\"\" + selectedContentType + \"\\\" to [\" + formatted + \"]\";\n\t\t});\n\n\t\treturn body;\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#readWithMessageConverters(webRequest,parameter,paramType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the method argument value of the expected parameter type by\n\t * reading from the given request.\n\t * @param webRequest the current request\n\t * @param parameter the method parameter descriptor (may be {@code null})\n\t * @param paramType the type of the argument value to be created\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "webRequest",
      "parameter",
      "paramType"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "Object",
    "signature": "protected Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType)",
    "source_code": "\tprotected Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tHttpInputMessage inputMessage = createInputMessage(webRequest);\n\t\treturn readWithMessageConverters(inputMessage, parameter, paramType);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#registerHandlerMethod(handler,method,mapping)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * <p><strong>Note:</strong> To create the {@link RequestMappingInfo},\n\t * please use {@link #getBuilderConfiguration()} and set the options on\n\t * {@link RequestMappingInfo.Builder#options(RequestMappingInfo.BuilderConfiguration)}\n\t * to match how this {@code HandlerMapping} is configured. This\n\t * is important for example to ensure use of\n\t * {@link org.springframework.web.util.pattern.PathPattern} or\n\t * {@link org.springframework.util.PathMatcher} based matching.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "handler",
      "method",
      "mapping"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "void",
    "signature": "protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping)",
    "source_code": "\tprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n\t\tsuper.registerHandlerMethod(handler, method, mapping);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#registerMapping(mapping,handler,method)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "mapping",
      "handler",
      "method"
    ],
    "position": {
      "column": 1,
      "line": 489
    },
    "return": "void",
    "signature": "public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)",
    "source_code": "\tpublic void registerMapping(RequestMappingInfo mapping, Object handler, Method method) {\n\t\tsuper.registerMapping(mapping, handler, method);\n\t\tupdateConsumesCondition(mapping, method);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveArgument(parameter,mavContainer,webRequest,binderFactory)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Throws MethodArgumentNotValidException if validation fails.\n\t * @throws HttpMessageNotReadableException if {@link RequestBody#required()}\n\t * is {@code true} and there is no body content or if there is no suitable\n\t * converter to read the content with.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "parameter",
      "mavContainer",
      "webRequest",
      "binderFactory"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "Object",
    "signature": "public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)",
    "source_code": "\tpublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tObject arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n\n\t\tif (binderFactory != null) {\n\t\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\t\t\tResolvableType type = ResolvableType.forMethodParameter(parameter);\n\t\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, arg, name, type);\n\t\t\tif (arg != null) {\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mavContainer != null) {\n\t\t\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\t\t}\n\t\t}\n\n\t\treturn adaptArgumentIfNecessary(arg, parameter);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveName(name,parameter,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "parameter",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 93
    },
    "return": "Object",
    "signature": "protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)",
    "source_code": "\tprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {\n\t\tMap<String, String> uriTemplateVars = (Map<String, String>) request.getAttribute(\n\t\t\t\tHandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);\n\t\treturn (uriTemplateVars != null ? uriTemplateVars.get(name) : null);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#resolveViewName(viewName,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\t\tpublic View resolveViewName(String viewName, Locale locale) throws Exception {\n\t\t\tfor (ViewResolver resolver : this.viewResolvers) {\n\t\t\t\tView view = resolver.resolveViewName(viewName, locale);\n\t\t\t\tif (view != null) {\n\t\t\t\t\treturn view;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#send(data,mediaType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "data",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 289
    },
    "return": "void",
    "signature": "public void send(Object data, @Nullable MediaType mediaType)",
    "source_code": "\t\tpublic void send(Object data, @Nullable MediaType mediaType) throws IOException {\n\t\t\tsendInternal(data, mediaType);\n\t\t\tthis.outputMessage.flush();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#send(object,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send the object formatted as a single SSE \"data\" line. It's equivalent to:\n\t * <pre>\n\t * // static import of SseEmitter.*\n\t *\n\t * SseEmitter emitter = new SseEmitter();\n\t * emitter.send(event().data(myObject, MediaType.APPLICATION_JSON));\n\t * </pre>\n\t * <p>Please, see {@link ResponseBodyEmitter#send(Object) parent Javadoc}\n\t * for important notes on exception handling.\n\t * @param object the object to write\n\t * @param mediaType a MediaType hint for selecting an HttpMessageConverter\n\t * @throws IOException raised when an I/O error occurs\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "object",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 117
    },
    "return": "void",
    "signature": "public void send(Object object, @Nullable MediaType mediaType)",
    "source_code": "\tpublic void send(Object object, @Nullable MediaType mediaType) throws IOException {\n\t\tsend(event().data(object, mediaType));\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#setPathPrefixes(Map<String,prefixes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure path prefixes to apply to controller methods.\n\t * <p>Prefixes are used to enrich the mappings of every {@code @RequestMapping}\n\t * method and {@code @HttpExchange} method whose controller type is matched\n\t * by a corresponding {@code Predicate} in the map. The prefix for the first\n\t * matching predicate is used, assuming the input map has predictable order.\n\t * <p>Consider using {@link org.springframework.web.method.HandlerTypePredicate\n\t * HandlerTypePredicate} to group controllers.\n\t * @param prefixes a map with path prefixes as key\n\t * @since 5.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "prefixes"
    ],
    "position": {
      "column": 1,
      "line": 180
    },
    "return": "void",
    "signature": "public void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes)",
    "source_code": "\tpublic void setPathPrefixes(Map<String, Predicate<Class<?>>> prefixes) {\n\t\tthis.pathPrefixes = (!prefixes.isEmpty() ?\n\t\t\t\tCollections.unmodifiableMap(new LinkedHashMap<>(prefixes)) :\n\t\t\t\tCollections.emptyMap());\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#shouldApplyTo(request,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 422
    },
    "return": "boolean",
    "signature": "protected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler)",
    "source_code": "\tprotected boolean shouldApplyTo(HttpServletRequest request, @Nullable Object handler) {\n\t\tif ((handler instanceof ResourceHttpRequestHandler || handler instanceof HandlerFunction) &&\n\t\t\t\thasGlobalExceptionHandlers() && !hasHandlerMappings()) {\n\t\t\treturn true;  // apply to ResourceHttpRequestHandler and HandlerFunction by default\n\t\t}\n\t\telse {\n\t\t\treturn super.shouldApplyTo(request, handler);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#supports(param,type,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "param",
      "type",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 77
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter param, Type type, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter param, Type type, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#supports(returnType,converterType)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "returnType",
      "converterType"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "boolean",
    "signature": "public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType)",
    "source_code": "\tpublic boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n\t\tthrow new UnsupportedOperationException(\"Not implemented\");\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#validateIfApplicable(binder,parameter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Validate the binding target if applicable.\n\t * <p>The default implementation checks for {@code @jakarta.validation.Valid},\n\t * Spring's {@link org.springframework.validation.annotation.Validated},\n\t * and custom annotations whose name starts with \"Valid\".\n\t * @param binder the DataBinder to be used\n\t * @param parameter the method parameter descriptor\n\t * @since 4.1.5\n\t * @see #isBindExceptionRequired\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "binder",
      "parameter"
    ],
    "position": {
      "column": 1,
      "line": 286
    },
    "return": "void",
    "signature": "protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter)",
    "source_code": "\tprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n\t\tAnnotation[] annotations = parameter.getParameterAnnotations();\n\t\tfor (Annotation ann : annotations) {\n\t\t\tObject[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);\n\t\t\tif (validationHints != null) {\n\t\t\t\tbinder.validate(validationHints);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#withMethod(controllerType,method,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethod(Class, Method, Object...)}\n\t * for use with an instance of this class created via {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "method",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 533
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder withMethod(Class<?> controllerType, Method method, Object... args)",
    "source_code": "\tpublic UriComponentsBuilder withMethod(Class<?> controllerType, Method method, Object... args) {\n\t\treturn fromMethod(this.baseUrl, controllerType, method, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#withMethodName(controllerType,methodName,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An alternative to {@link #fromMethodName(Class, String, Object...)}} for\n\t * use with an instance of this class created via {@link #relativeTo}.\n\t * <p><strong>Note:</strong> This method extracts values from \"Forwarded\"\n\t * and \"X-Forwarded-*\" headers if found. See class-level docs.\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "controllerType",
      "methodName",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder withMethodName(Class<?> controllerType, String methodName, Object... args)",
    "source_code": "\tpublic UriComponentsBuilder withMethodName(Class<?> controllerType, String methodName, Object... args) {\n\t\treturn fromMethodName(this.baseUrl, controllerType, methodName, args);\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#write(b,off,len)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "b",
      "off",
      "len"
    ],
    "position": {
      "column": 1,
      "line": 499
    },
    "return": "void",
    "signature": "public void write(byte[] b, int off, int len)",
    "source_code": "\t\tpublic void write(byte[] b, int off, int len) {\n\t\t\tthis.outputStream.write(b, off, len);\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#write(s,contentType,outputMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "s",
      "contentType",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 429
    },
    "return": "void",
    "signature": "public void write(String s, @Nullable MediaType contentType, HttpOutputMessage outputMessage)",
    "source_code": "\t\tpublic void write(String s, @Nullable MediaType contentType, HttpOutputMessage outputMessage) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#writeWithMessageConverters(value,returnType,inputMessage,outputMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return type to the given output message.\n\t * @param value the value to write to the output message\n\t * @param returnType the type of the value\n\t * @param inputMessage the input messages. Used to inspect the {@code Accept} header.\n\t * @param outputMessage the output message to write to\n\t * @throws IOException thrown in case of I/O errors\n\t * @throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\n\t * by the {@code Accept} header on the request cannot be met by the message converters\n\t * @throws HttpMessageNotWritableException thrown if a given message cannot\n\t * be written by a converter, or if the content-type chosen by the server\n\t * has no compatible converter.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "inputMessage",
      "outputMessage"
    ],
    "position": {
      "column": 1,
      "line": 208
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tObject body;\n\t\tClass<?> valueType;\n\t\tType targetType;\n\n\t\tif (value instanceof CharSequence) {\n\t\t\tbody = value.toString();\n\t\t\tvalueType = String.class;\n\t\t\ttargetType = String.class;\n\t\t}\n\t\telse {\n\t\t\tbody = value;\n\t\t\tvalueType = getReturnValueType(body, returnType);\n\t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n\t\t}\n\n\t\tif (isResourceType(value, returnType)) {\n\t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &&\n\t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) {\n\t\t\t\tResource resource = (Resource) value;\n\t\t\t\ttry {\n\t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n\t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n\t\t\t\t\tvalueType = body.getClass();\n\t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMediaType selectedMediaType = null;\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tboolean isContentTypePreset = contentType != null && contentType.isConcrete();\n\t\tif (isContentTypePreset) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n\t\t\t}\n\t\t\tselectedMediaType = contentType;\n\t\t}\n\t\telse {\n\t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n\t\t\tList<MediaType> acceptableTypes;\n\t\t\ttry {\n\t\t\t\tacceptableTypes = getAcceptableMediaTypes(request);\n\t\t\t}\n\t\t\tcatch (HttpMediaTypeNotAcceptableException ex) {\n\t\t\t\tint series = outputMessage.getServletResponse().getStatus() / 100;\n\t\t\t\tif (body == null || series == 4 || series == 5) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring error response content (if any). \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n\t\t\tif (body != null && producibleTypes.isEmpty()) {\n\t\t\t\tthrow new HttpMessageNotWritableException(\n\t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n\t\t\t}\n\n\t\t\tList<MediaType> compatibleMediaTypes = new ArrayList<>();\n\t\t\tdetermineCompatibleMediaTypes(acceptableTypes, producibleTypes, compatibleMediaTypes);\n\n\t\t\t// For ProblemDetail, fall back on RFC 9457 format\n\t\t\tif (compatibleMediaTypes.isEmpty() && ProblemDetail.class.isAssignableFrom(valueType)) {\n\t\t\t\tdetermineCompatibleMediaTypes(this.problemMediaTypes, producibleTypes, compatibleMediaTypes);\n\t\t\t}\n\n\t\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n\t\t\t\t}\n\t\t\t\tif (body != null) {\n\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMimeTypeUtils.sortBySpecificity(compatibleMediaTypes);\n\n\t\t\tfor (MediaType mediaType : compatibleMediaTypes) {\n\t\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\t\tselectedMediaType = mediaType;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {\n\t\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"', given \" +\n\t\t\t\t\t\tacceptableTypes + \" and supported \" + producibleTypes);\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType != null) {\n\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n\n\t\t\tResolvableType targetResolvableType = null;\n\t\t\tfor (HttpMessageConverter converter : this.messageConverters) {\n\t\t\t\tConverterType converterTypeToUse = null;\n\t\t\t\tif (converter instanceof GenericHttpMessageConverter genericConverter) {\n\t\t\t\t\tif (genericConverter.canWrite(targetType, valueType, selectedMediaType)) {\n\t\t\t\t\t\tconverterTypeToUse = ConverterType.GENERIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (converter instanceof SmartHttpMessageConverter smartConverter) {\n\t\t\t\t\ttargetResolvableType = getNestedTypeIfNeeded(ResolvableType.forMethodParameter(returnType));\n\t\t\t\t\tif (smartConverter.canWrite(targetResolvableType, valueType, selectedMediaType)) {\n\t\t\t\t\t\tconverterTypeToUse = ConverterType.SMART;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (converter.canWrite(valueType, selectedMediaType)){\n\t\t\t\t\tconverterTypeToUse = ConverterType.BASE;\n\t\t\t\t}\n\t\t\t\tif (converterTypeToUse != null) {\n\t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(), inputMessage, outputMessage);\n\t\t\t\t\tif (body != null) {\n\t\t\t\t\t\tObject theBody = body;\n\t\t\t\t\t\tLogFormatUtils.traceDebug(logger, traceOn ->\n\t\t\t\t\t\t\t\t\"Writing [\" + LogFormatUtils.formatValue(theBody, !traceOn) + \"]\");\n\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n\t\t\t\t\t\tswitch (converterTypeToUse) {\n\t\t\t\t\t\t\tcase BASE -> converter.write(body, selectedMediaType, outputMessage);\n\t\t\t\t\t\t\tcase GENERIC -> ((GenericHttpMessageConverter) converter).write(body, targetType, selectedMediaType, outputMessage);\n\t\t\t\t\t\t\tcase SMART -> ((SmartHttpMessageConverter) converter).write(body, targetResolvableType, selectedMediaType, outputMessage, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (body != null) {\n\t\t\tSet<MediaType> producibleMediaTypes =\n\t\t\t\t\t(Set<MediaType>) inputMessage.getServletRequest()\n\t\t\t\t\t\t\t.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n\n\t\t\tif (isContentTypePreset || !CollectionUtils.isEmpty(producibleMediaTypes)) {\n\t\t\t\tthrow new HttpMessageNotWritableException(\n\t\t\t\t\t\t\"No converter for [\" + valueType + \"] with preset Content-Type '\" + contentType + \"'\");\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(getSupportedMediaTypes(body.getClass()));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.mvc.method.annotation.<unknown>#writeWithMessageConverters(value,returnType,webRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Writes the given return value to the given web request. Delegates to\n\t * {@link #writeWithMessageConverters(Object, MethodParameter, ServletServerHttpRequest, ServletServerHttpResponse)}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "value",
      "returnType",
      "webRequest"
    ],
    "position": {
      "column": 1,
      "line": 186
    },
    "return": "void",
    "signature": "protected void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)",
    "source_code": "\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\t\twriteWithMessageConverters(value, returnType, inputMessage, outputMessage);\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#doResolveException(request,response,handler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 181
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)",
    "source_code": "\tprotected ModelAndView doResolveException(\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {\n\n\t\ttry {\n\t\t\t// ErrorResponse exceptions that expose HTTP response details\n\t\t\tif (ex instanceof ErrorResponse errorResponse) {\n\t\t\t\tModelAndView mav = null;\n\t\t\t\tif (ex instanceof HttpRequestMethodNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpRequestMethodNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotSupportedException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotSupported(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HttpMediaTypeNotAcceptableException theEx) {\n\t\t\t\t\tmav = handleHttpMediaTypeNotAcceptable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingPathVariableException theEx) {\n\t\t\t\t\tmav = handleMissingPathVariable(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestParameterException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestParameter(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MissingServletRequestPartException theEx) {\n\t\t\t\t\tmav = handleMissingServletRequestPartException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof ServletRequestBindingException theEx) {\n\t\t\t\t\tmav = handleServletRequestBindingException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof MethodArgumentNotValidException theEx) {\n\t\t\t\t\tmav = handleMethodArgumentNotValidException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof HandlerMethodValidationException theEx) {\n\t\t\t\t\tmav = handleHandlerMethodValidationException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof NoHandlerFoundException theEx) {\n\t\t\t\t\tmav = handleNoHandlerFoundException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof NoResourceFoundException theEx) {\n\t\t\t\t\tmav = handleNoResourceFoundException(theEx, request, response, handler);\n\t\t\t\t}\n\t\t\t\telse if (ex instanceof AsyncRequestTimeoutException theEx) {\n\t\t\t\t\tmav = handleAsyncRequestTimeoutException(theEx, request, response, handler);\n\t\t\t\t}\n\n\t\t\t\treturn (mav != null ? mav :\n\t\t\t\t\t\thandleErrorResponse(errorResponse, request, response, handler));\n\t\t\t}\n\n\t\t\t// Other, lower level exceptions\n\n\t\t\tif (ex instanceof ConversionNotSupportedException theEx) {\n\t\t\t\treturn handleConversionNotSupported(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof TypeMismatchException theEx) {\n\t\t\t\treturn handleTypeMismatch(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotReadableException theEx) {\n\t\t\t\treturn handleHttpMessageNotReadable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof HttpMessageNotWritableException theEx) {\n\t\t\t\treturn handleHttpMessageNotWritable(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof MethodValidationException theEx) {\n\t\t\t\treturn handleMethodValidationException(theEx, request, response, handler);\n\t\t\t}\n\t\t\telse if (ex instanceof AsyncRequestNotUsableException) {\n\t\t\t\treturn handleAsyncRequestNotUsableException(\n\t\t\t\t\t\t(AsyncRequestNotUsableException) ex, request, response, handler);\n\t\t\t}\n\t\t\telse if (DisconnectedClientHelper.isClientDisconnectedException(ex)) {\n\t\t\t\treturn handleDisconnectedClientException(ex, request, response, handler);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception handlerEx) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failure while trying to resolve exception [\" + ex.getClass().getName() + \"]\", handlerEx);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleAsyncRequestNotUsableException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case of an I/O failure from the ServletOutputStream.\n\t * <p>By default, do nothing since the response is not usable.\n\t * @param ex the {@link AsyncRequestTimeoutException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty ModelAndView indicating the exception was handled\n\t * @since 5.3.33\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 515
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleAsyncRequestNotUsableException(AsyncRequestNotUsableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleAsyncRequestNotUsableException(AsyncRequestNotUsableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) {\n\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleAsyncRequestTimeoutException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an async request timed out.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link AsyncRequestTimeoutException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2.8\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 498
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleAsyncRequestTimeoutException(AsyncRequestTimeoutException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleConversionNotSupported(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion cannot occur.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the ConversionNotSupportedException could be\n\t * rethrown as-is.\n\t * @param ex the ConversionNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 590
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleConversionNotSupported(ConversionNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleDisconnectedClientException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle an Exception that indicates the client has gone away. This is\n\t * typically an {@link IOException} of a specific subtype or with a message\n\t * specific to the underlying Servlet container. Those are detected through\n\t * {@link DisconnectedClientHelper#isClientDisconnectedException(Throwable)}\n\t * <p>By default, do nothing since the response is not usable.\n\t * @param ex the {@code Exception} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty ModelAndView indicating the exception was handled\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 535
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleDisconnectedClientException(Exception ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleDisconnectedClientException(\n\t\t\tException ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) {\n\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleErrorResponse(errorResponse,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle an {@link ErrorResponse} exception.\n\t * <p>The default implementation sets status and the headers of the response\n\t * to those obtained from the {@code ErrorResponse}. If available, the\n\t * {@link ProblemDetail#getDetail()} is used as the message for\n\t * {@link HttpServletResponse#sendError(int, String)}.\n\t * @param errorResponse the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "errorResponse",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 555
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleErrorResponse(ErrorResponse errorResponse,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleErrorResponse(ErrorResponse errorResponse,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tif (!response.isCommitted()) {\n\t\t\tHttpHeaders headers = errorResponse.getHeaders();\n\t\t\theaders.forEach((name, values) -> values.forEach(value -> response.addHeader(name, value)));\n\n\t\t\tint status = errorResponse.getStatusCode().value();\n\t\t\tString message = errorResponse.getBody().getDetail();\n\t\t\tif (message != null) {\n\t\t\t\tresponse.sendError(status, message);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponse.sendError(status);\n\t\t\t}\n\t\t}\n\t\telse if (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Ignoring exception, response committed already: \" + errorResponse);\n\t\t}\n\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHandlerMethodValidationException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation for a controller method failed.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 435
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHandlerMethodValidationException(HandlerMethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMediaTypeNotAcceptable(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found that were acceptable for the client (expressed via the {@code Accept} header).\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotAcceptableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMediaTypeNotAcceptable(HttpMediaTypeNotAcceptableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMediaTypeNotSupported(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converters}\n\t * were found for PUT or POSTed content.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpMediaTypeNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 298
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMediaTypeNotSupported(HttpMediaTypeNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMessageNotReadable(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where a {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot read from an HTTP request.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotReadableException could be\n\t * rethrown as-is.\n\t * @param ex the HttpMessageNotReadableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 628
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMessageNotReadable(HttpMessageNotReadableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tif (!response.isCommitted()) {\n\t\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\t}\n\t\telse if (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Ignoring exception, response committed already: \" + ex);\n\t\t}\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpMessageNotWritable(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where a\n\t * {@linkplain org.springframework.http.converter.HttpMessageConverter message converter}\n\t * cannot write to an HTTP response.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the HttpMessageNotWritableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 654
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpMessageNotWritable(HttpMessageNotWritableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tif (!response.isCommitted()) {\n\t\t\tsendServerError(ex, request, response);\n\t\t}\n\t\telse if (logger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"Ignoring exception, response committed already: \" + ex);\n\t\t}\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleHttpRequestMethodNotSupported(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no handler was found for the HTTP method.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the HttpRequestMethodNotSupportedException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 277
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMethodArgumentNotValidException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an argument annotated with {@code @Valid} such as\n\t * an {@link RequestBody} or {@link RequestPart} argument fails validation.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 415
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMethodValidationException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where method validation failed on a component that is\n\t * not a web controller, for example, on some underlying service.\n\t * <p>The default implementation sends an HTTP 500 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the HttpMessageNotWritableException could\n\t * be rethrown as-is.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 680
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMethodValidationException(MethodValidationException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tsendServerError(ex, request, response);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMissingPathVariable(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a declared path variable does not match any extracted URI variable.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingPathVariableException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 339
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingPathVariable(MissingPathVariableException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMissingServletRequestParameter(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a required parameter is missing.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the MissingServletRequestParameterException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 358
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingServletRequestParameter(MissingServletRequestParameterException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleMissingServletRequestPartException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where an {@linkplain RequestPart @RequestPart}, a {@link MultipartFile},\n\t * or a {@code jakarta.servlet.http.Part} argument is required but is missing.\n\t * <p>By default, an HTTP 400 error is sent back to the client.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 376
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleNoHandlerFoundException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no handler was found during the dispatch.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the NoHandlerFoundException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler, or {@code null} if none chosen\n\t * at the time of the exception (for example, if multipart resolution failed)\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 456
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoHandlerFoundException(NoHandlerFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tpageNotFoundLogger.warn(ex.getMessage());\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleNoResourceFoundException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case where no static resource was found.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the {@link NoResourceFoundException} to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the resource handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 477
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleNoResourceFoundException(NoResourceFoundException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleServletRequestBindingException(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when an unrecoverable binding exception occurs - for example,\n\t * required header, required cookie.\n\t * <p>The default implementation returns {@code null} in which case the\n\t * exception is handled in {@link #handleErrorResponse}.\n\t * @param ex the exception to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled, or\n\t * {@code null} indicating the exception should be handled in {@link #handleErrorResponse}\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 396
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleServletRequestBindingException(ServletRequestBindingException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#handleTypeMismatch(ex,request,response,handler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the case when a {@link org.springframework.web.bind.WebDataBinder} conversion error occurs.\n\t * <p>The default implementation sends an HTTP 400 error, and returns an empty {@code ModelAndView}.\n\t * Alternatively, a fallback view could be chosen, or the TypeMismatchException could be rethrown as-is.\n\t * @param ex the TypeMismatchException to be handled\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler the executed handler\n\t * @return an empty {@code ModelAndView} indicating the exception was handled\n\t * @throws IOException potentially thrown from {@link HttpServletResponse#sendError}\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 608
    },
    "return": "ModelAndView",
    "signature": "protected ModelAndView handleTypeMismatch(TypeMismatchException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler)",
    "source_code": "\tprotected ModelAndView handleTypeMismatch(TypeMismatchException ex,\n\t\t\tHttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {\n\n\t\tresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\n\t\treturn new ModelAndView();\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#logException(ex,request)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 699
    },
    "return": "void",
    "signature": "protected void logException(Exception ex, HttpServletRequest request)",
    "source_code": "\tprotected void logException(Exception ex, HttpServletRequest request) {\n\t\tif (ex instanceof NoHandlerFoundException || ex instanceof NoResourceFoundException) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(buildLogMessage(ex, request));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.logException(ex, request);\n\t}"
  },
  "org.springframework.web.servlet.mvc.support.<unknown>#sendServerError(ex,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked to send a server error. Sets the status to 500 and also sets the\n\t * request attribute \"jakarta.servlet.error.exception\" to the Exception.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "ex",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 691
    },
    "return": "void",
    "signature": "protected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void sendServerError(Exception ex, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows IOException {\n\n\t\trequest.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex);\n\t\tresponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addFixedVersionStrategy(version,pathPatterns)": {
    "deprecated": false,
    "doc": "\t * will also configure automatically a {@code \"/v1.0.0/js/**\"} with {@code \"v1.0.0\"} the\n\t * {@code version} String given as an argument.\n\t * @param version a version string\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see FixedVersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "version",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 129
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addFixedVersionStrategy(String version, String... pathPatterns) {\n\t\tList<String> patternsList = Arrays.asList(pathPatterns);\n\t\tList<String> prefixedPatterns = new ArrayList<>(pathPatterns.length);\n\t\tString versionPrefix = \"/\" + version;\n\t\tfor (String pattern : patternsList) {\n\t\t\tprefixedPatterns.add(pattern);\n\t\t\tif (!pattern.startsWith(versionPrefix) && !patternsList.contains(versionPrefix + pattern)) {\n\t\t\t\tprefixedPatterns.add(versionPrefix + pattern);\n\t\t\t}\n\t\t}\n\t\treturn addVersionStrategy(new FixedVersionStrategy(version), StringUtils.toStringArray(prefixedPatterns));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#addVersionStrategy(strategy,pathPatterns)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Register a custom VersionStrategy to apply to resource URLs that match the\n\t * given path patterns.\n\t * @param strategy the custom strategy\n\t * @param pathPatterns one or more resource URL path patterns,\n\t * relative to the pattern configured with the resource handler\n\t * @return the current instance for chained method invocation\n\t * @see VersionStrategy\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "strategy",
      "pathPatterns"
    ],
    "position": {
      "column": 1,
      "line": 151
    },
    "return": "VersionResourceResolver",
    "signature": "public VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns)",
    "source_code": "\tpublic VersionResourceResolver addVersionStrategy(VersionStrategy strategy, String... pathPatterns) {\n\t\tfor (String pattern : pathPatterns) {\n\t\t\tgetStrategyMap().put(pattern, strategy);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#doFilter(request,response,filterChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "filterChain"
    ],
    "position": {
      "column": 1,
      "line": 54
    },
    "return": "void",
    "signature": "public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)",
    "source_code": "\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (!(request instanceof HttpServletRequest httpRequest) || !(response instanceof HttpServletResponse httpResponse)) {\n\t\t\tthrow new ServletException(\"ResourceUrlEncodingFilter only supports HTTP requests\");\n\t\t}\n\n\t\tResourceUrlEncodingRequestWrapper wrappedRequest =\n\t\t\t\tnew ResourceUrlEncodingRequestWrapper(httpRequest);\n\t\tResourceUrlEncodingResponseWrapper wrappedResponse =\n\t\t\t\tnew ResourceUrlEncodingResponseWrapper(wrappedRequest, httpResponse);\n\n\t\tfilterChain.doFilter(wrappedRequest, wrappedResponse);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#extractLink(index,content,linksToAdd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 201
    },
    "return": "int",
    "signature": "protected int extractLink(int index, String content, SortedSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected int extractLink(int index, String content, SortedSet<ContentChunkInfo> linksToAdd) {\n\t\t\t// A url() function without unquoted\n\t\t\treturn extractLink(index - 1, \")\", content, linksToAdd);\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#extractLink(index,endKey,content,linksToAdd)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "index",
      "endKey",
      "content",
      "linksToAdd"
    ],
    "position": {
      "column": 1,
      "line": 158
    },
    "return": "int",
    "signature": "protected int extractLink(int index, String endKey, String content, SortedSet<ContentChunkInfo> linksToAdd)",
    "source_code": "\t\tprotected int extractLink(int index, String endKey, String content, SortedSet<ContentChunkInfo> linksToAdd) {\n\t\t\tint start = index + 1;\n\t\t\tint end = content.indexOf(endKey, start);\n\t\t\tlinksToAdd.add(new ContentChunkInfo(start, end));\n\t\t\treturn end + endKey.length();\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getForRequestUrl(request,requestUrl)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A variation on {@link #getForLookupPath(String)} that accepts a full request\n\t * URL path (i.e. including context and servlet path) and returns the full request\n\t * URL path to expose for public use.\n\t * @param request the current request\n\t * @param requestUrl the request URL path to resolve\n\t * @return the resolved public URL path, or {@code null} if unresolved\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requestUrl"
    ],
    "position": {
      "column": 1,
      "line": 173
    },
    "return": "String",
    "signature": "public String getForRequestUrl(HttpServletRequest request, String requestUrl)",
    "source_code": "\tpublic final String getForRequestUrl(HttpServletRequest request, String requestUrl) {\n\t\tint prefixIndex = getLookupPathIndex(request);\n\t\tint suffixIndex = getEndPathIndex(requestUrl);\n\t\tif (prefixIndex >= suffixIndex) {\n\t\t\treturn null;\n\t\t}\n\t\tString prefix = requestUrl.substring(0, prefixIndex);\n\t\tString suffix = requestUrl.substring(suffixIndex);\n\t\tString lookupPath = requestUrl.substring(prefixIndex, suffixIndex);\n\t\tString resolvedLookupPath = getForLookupPath(lookupPath);\n\t\treturn (resolvedLookupPath != null ? prefix + resolvedLookupPath + suffix : null);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#getMediaType(request,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine the media type for the given request and the resource matched\n\t * to it. This implementation tries to determine the MediaType using one of\n\t * the following lookups based on the resource filename and its path\n\t * extension:\n\t * <ol>\n\t * <li>{@link jakarta.servlet.ServletContext#getMimeType(String)}\n\t * <li>{@link #getMediaTypes()}\n\t * <li>{@link MediaTypeFactory#getMediaType(String)}\n\t * </ol>\n\t * @param request the current request\n\t * @param resource the resource to check\n\t * @return the corresponding media type, or {@code null} if none found\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 700
    },
    "return": "MediaType",
    "signature": "protected MediaType getMediaType(HttpServletRequest request, Resource resource)",
    "source_code": "\tprotected MediaType getMediaType(HttpServletRequest request, Resource resource) {\n\t\tMediaType result = null;\n\t\tString mimeType = request.getServletContext().getMimeType(resource.getFilename());\n\t\tif (StringUtils.hasText(mimeType)) {\n\t\t\tresult = MediaType.parseMediaType(mimeType);\n\t\t}\n\t\tif (result == null || MediaType.APPLICATION_OCTET_STREAM.equals(result)) {\n\t\t\tMediaType mediaType = null;\n\t\t\tString filename = resource.getFilename();\n\t\t\tString ext = StringUtils.getFilenameExtension(filename);\n\t\t\tif (ext != null) {\n\t\t\t\tmediaType = this.mediaTypes.get(ext.toLowerCase(Locale.ROOT));\n\t\t\t}\n\t\t\tif (mediaType == null) {\n\t\t\t\tList<MediaType> mediaTypes = MediaTypeFactory.getMediaTypes(filename);\n\t\t\t\tif (!CollectionUtils.isEmpty(mediaTypes)) {\n\t\t\t\t\tmediaType = mediaTypes.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mediaType != null) {\n\t\t\t\tresult = mediaType;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#handleRequest(request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Processes a resource request.\n\t * <p>Finds the requested resource under one of the configured locations.\n\t * If the resource does not exist, {@link NoResourceFoundException} is raised.\n\t * If the resource exists, the request will be checked for the presence of the\n\t * {@code Last-Modified} header, and its value will be compared against the last-modified\n\t * timestamp of the given resource, returning a {@code 304} status code if the\n\t * {@code Last-Modified} value  is greater. If the resource is newer than the\n\t * {@code Last-Modified} value, or the header is not present, the content resource\n\t * of the resource will be written to the response with caching headers\n\t * set to expire one year in the future.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\t// For very general mappings (for example, \"/\") we need to check 404 first\n\t\tResource resource = getResource(request);\n\t\tif (resource == null) {\n\t\t\tlogger.debug(\"Resource not found\");\n\t\t\tthrow new NoResourceFoundException(HttpMethod.valueOf(request.getMethod()), getPath(request));\n\t\t}\n\n\t\tif (HttpMethod.OPTIONS.matches(request.getMethod())) {\n\t\t\tresponse.setHeader(HttpHeaders.ALLOW, getAllowHeader());\n\t\t\treturn;\n\t\t}\n\n\t\t// Supported methods and required session\n\t\tcheckRequest(request);\n\n\t\t// Header phase\n\t\tString eTagValue = (this.getEtagGenerator() != null) ? this.getEtagGenerator().apply(resource) : null;\n\t\tlong lastModified = (this.isUseLastModified()) ? resource.lastModified() : -1;\n\t\tif (new ServletWebRequest(request, response).checkNotModified(eTagValue, lastModified)) {\n\t\t\tlogger.trace(\"Resource not modified\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Apply cache settings, if any\n\t\tprepareResponse(response);\n\n\t\t// Check the media type for the resource\n\t\tMediaType mediaType = getMediaType(request, resource);\n\t\tsetHeaders(response, resource, mediaType);\n\n\t\t// Content phase\n\t\tServletServerHttpResponse outputMessage = new ServletServerHttpResponse(response);\n\t\tif (request.getHeader(HttpHeaders.RANGE) == null) {\n\t\t\tAssert.state(this.resourceHttpMessageConverter != null, \"Not initialized\");\n\n\t\t\tif (HttpMethod.HEAD.matches(request.getMethod())) {\n\t\t\t\tthis.resourceHttpMessageConverter.addDefaultHeaders(outputMessage, resource, mediaType);\n\t\t\t\toutputMessage.flush();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.resourceHttpMessageConverter.write(resource, mediaType, outputMessage);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tAssert.state(this.resourceRegionHttpMessageConverter != null, \"Not initialized\");\n\t\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(request);\n\t\t\ttry {\n\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\t\t\t\tthis.resourceRegionHttpMessageConverter.write(\n\t\t\t\t\t\tHttpRange.toResourceRegions(httpRanges, resource), mediaType, outputMessage);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tresponse.setHeader(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#isResourceUnderLocation(location,resource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the resource is under the given location.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "resource"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "boolean",
    "signature": "public boolean isResourceUnderLocation(Resource location, Resource resource)",
    "source_code": "\tpublic static boolean isResourceUnderLocation(Resource location, Resource resource) throws IOException {\n\t\tif (resource.getClass() != location.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString resourcePath;\n\t\tString locationPath;\n\n\t\tif (resource instanceof UrlResource) {\n\t\t\tresourcePath = resource.getURL().toExternalForm();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().toString());\n\t\t}\n\t\telse if (resource instanceof ClassPathResource classPathResource) {\n\t\t\tresourcePath = classPathResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ClassPathResource) location).getPath());\n\t\t}\n\t\telse if (resource instanceof ServletContextResource servletContextResource) {\n\t\t\tresourcePath = servletContextResource.getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(((ServletContextResource) location).getPath());\n\t\t}\n\t\telse {\n\t\t\tresourcePath = resource.getURL().getPath();\n\t\t\tlocationPath = StringUtils.cleanPath(location.getURL().getPath());\n\t\t}\n\n\t\tif (locationPath.equals(resourcePath)) {\n\t\t\treturn true;\n\t\t}\n\t\tlocationPath = (locationPath.endsWith(\"/\") || locationPath.isEmpty() ? locationPath : locationPath + \"/\");\n\t\treturn (resourcePath.startsWith(locationPath) && !isInvalidEncodedResourcePath(resourcePath));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#parse(content,result)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "content",
      "result"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "void",
    "signature": "public void parse(String content, SortedSet<ContentChunkInfo> result)",
    "source_code": "\t\tpublic void parse(String content, SortedSet<ContentChunkInfo> result) {\n\t\t\tint position = 0;\n\t\t\twhile (true) {\n\t\t\t\tposition = content.indexOf(getKeyword(), position);\n\t\t\t\tif (position == -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tposition += getKeyword().length();\n\t\t\t\twhile (Character.isWhitespace(content.charAt(position))) {\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t\tif (content.charAt(position) == '\\'') {\n\t\t\t\t\tposition = extractLink(position, \"'\", content, result);\n\t\t\t\t}\n\t\t\t\telse if (content.charAt(position) == '\"') {\n\t\t\t\t\tposition = extractLink(position, \"\\\"\", content, result);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposition = extractLink(position, content, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#registerExtension(coding,extension)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Java config friendly alternative to {@link #setExtensions(Map)}.\n\t * @param coding the content coding\n\t * @param extension the associated file extension\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "coding",
      "extension"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void registerExtension(String coding, String extension)",
    "source_code": "\tpublic void registerExtension(String coding, String extension) {\n\t\tthis.extensions.put(coding, (extension.startsWith(\".\") ? extension : \".\" + extension));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveResourceInternal(request,requestPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 161
    },
    "return": "Resource",
    "signature": "protected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected Resource resolveResourceInternal(@Nullable HttpServletRequest request, String requestPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\tResource resolved = chain.resolveResource(request, requestPath, locations);\n\t\tif (resolved != null) {\n\t\t\treturn resolved;\n\t\t}\n\n\t\tVersionStrategy versionStrategy = getStrategyForPath(requestPath);\n\t\tif (versionStrategy == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString candidateVersion = versionStrategy.extractVersion(requestPath);\n\t\tif (!StringUtils.hasLength(candidateVersion)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString simplePath = versionStrategy.removeVersion(requestPath, candidateVersion);\n\t\tResource baseResource = chain.resolveResource(request, simplePath, locations);\n\t\tif (baseResource == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString actualVersion = versionStrategy.getResourceVersion(baseResource);\n\t\tif (candidateVersion.equals(actualVersion)) {\n\t\t\treturn new FileNameVersionedResource(baseResource, candidateVersion);\n\t\t}\n\t\telse {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Found resource for \\\"\" + requestPath + \"\\\", but version [\" +\n\t\t\t\t\t\tcandidateVersion + \"] does not match\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#resolveUrlPathInternal(resourceUrlPath,locations,chain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resourceUrlPath",
      "locations",
      "chain"
    ],
    "position": {
      "column": 1,
      "line": 200
    },
    "return": "String",
    "signature": "protected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain)",
    "source_code": "\tprotected String resolveUrlPathInternal(String resourceUrlPath,\n\t\t\tList<? extends Resource> locations, ResourceResolverChain chain) {\n\n\t\tString baseUrl = chain.resolveUrlPath(resourceUrlPath, locations);\n\t\tif (StringUtils.hasText(baseUrl)) {\n\t\t\tVersionStrategy versionStrategy = getStrategyForPath(resourceUrlPath);\n\t\t\tif (versionStrategy == null) {\n\t\t\t\treturn baseUrl;\n\t\t\t}\n\t\t\tResource resource = chain.resolveResource(null, baseUrl, locations);\n\t\t\tAssert.state(resource != null, \"Unresolvable resource\");\n\t\t\tString version = versionStrategy.getResourceVersion(resource);\n\t\t\treturn versionStrategy.addVersion(baseUrl, version);\n\t\t}\n\t\treturn baseUrl;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setAttribute(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 85
    },
    "return": "void",
    "signature": "public void setAttribute(String name, Object value)",
    "source_code": "\t\tpublic void setAttribute(String name, Object value) {\n\t\t\tsuper.setAttribute(name, value);\n\t\t\tif (ResourceUrlProviderExposingInterceptor.RESOURCE_URL_PROVIDER_ATTR.equals(name)) {\n\t\t\t\tif (value instanceof ResourceUrlProvider urlProvider) {\n\t\t\t\t\tinitLookupPath(urlProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setEtagGenerator(Function<Resource,etagGenerator)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure a generator function that will be used to create the ETag information,\n\t * given a {@link Resource} that is about to be written to the response.\n\t * <p>This function should return a String that will be used as an argument in\n\t * {@link ServletWebRequest#checkNotModified(String)}, or {@code null} if no value\n\t * can be generated for the given resource.\n\t * @param etagGenerator the HTTP ETag generator function to use.\n\t * @since 6.1\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Function<Resource",
      "etagGenerator"
    ],
    "position": {
      "column": 1,
      "line": 398
    },
    "return": "void",
    "signature": "public void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator)",
    "source_code": "\tpublic void setEtagGenerator(@Nullable Function<Resource, String> etagGenerator) {\n\t\tthis.etagGenerator = etagGenerator;\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setExtensions(Map<String,extensions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure mappings from content codings to file extensions. A dot \".\"\n\t * will be prepended in front of the extension value if not present.\n\t * <p>By default this is configured with {@literal [\"br\" -> \".br\"]} and\n\t * {@literal [\"gzip\" -> \".gz\"]}.\n\t * @param extensions the extensions to use.\n\t * @see #registerExtension(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "extensions"
    ],
    "position": {
      "column": 1,
      "line": 111
    },
    "return": "void",
    "signature": "public void setExtensions(Map<String, String> extensions)",
    "source_code": "\tpublic void setExtensions(Map<String, String> extensions) {\n\t\textensions.forEach(this::registerExtension);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHandlerMap(Map<String,handlerMap)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Manually configure the resource mappings.\n\t * <p><strong>Note:</strong> by default resource mappings are auto-detected\n\t * from the Spring {@code ApplicationContext}. However, if this property is\n\t * used, the auto-detection is turned off.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "handlerMap"
    ],
    "position": {
      "column": 1,
      "line": 113
    },
    "return": "void",
    "signature": "public void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap)",
    "source_code": "\tpublic void setHandlerMap(@Nullable Map<String, ResourceHttpRequestHandler> handlerMap) {\n\t\tif (handlerMap != null) {\n\t\t\tthis.handlerMap.clear();\n\t\t\tthis.handlerMap.putAll(handlerMap);\n\t\t\tthis.autodetect = false;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setHeaders(response,resource,mediaType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set headers on the given servlet response.\n\t * Called for GET requests as well as HEAD requests.\n\t * @param response current servlet response\n\t * @param resource the identified resource (never {@code null})\n\t * @param mediaType the resource's media type (never {@code null})\n\t * @throws IOException in case of errors while setting the headers\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "resource",
      "mediaType"
    ],
    "position": {
      "column": 1,
      "line": 734
    },
    "return": "void",
    "signature": "protected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)",
    "source_code": "\tprotected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)\n\t\t\tthrows IOException {\n\n\t\tif (mediaType != null) {\n\t\t\tresponse.setContentType(mediaType.toString());\n\t\t}\n\n\t\tif (resource instanceof HttpResource httpResource) {\n\t\t\tHttpHeaders resourceHeaders = httpResource.getResponseHeaders();\n\t\t\tresourceHeaders.forEach((headerName, headerValues) -> {\n\t\t\t\tboolean first = true;\n\t\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tresponse.setHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresponse.addHeader(headerName, headerValue);\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tresponse.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setMediaTypes(Map<String,mediaTypes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add mappings between file extensions, extracted from the filename of a\n\t * static {@link Resource}, and corresponding media type to set on the\n\t * response.\n\t * <p>Use of this method is typically not necessary since mappings are\n\t * otherwise determined via\n\t * {@link jakarta.servlet.ServletContext#getMimeType(String)} or via\n\t * {@link MediaTypeFactory#getMediaType(Resource)}.\n\t * @param mediaTypes media type mappings\n\t * @since 5.2.4\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "mediaTypes"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "void",
    "signature": "public void setMediaTypes(Map<String, MediaType> mediaTypes)",
    "source_code": "\tpublic void setMediaTypes(Map<String, MediaType> mediaTypes) {\n\t\tmediaTypes.forEach((ext, mediaType) ->\n\t\t\t\tthis.mediaTypes.put(ext.toLowerCase(Locale.ROOT), mediaType));\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#setStrategyMap(Map<String,map)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set a Map with URL paths as keys and {@code VersionStrategy} as values.\n\t * <p>Supports direct URL matches and Ant-style pattern matches. For syntax\n\t * details, see the {@link org.springframework.util.AntPathMatcher} javadoc.\n\t * @param map a map with URLs as keys and version strategies as values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "map"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void setStrategyMap(Map<String, VersionStrategy> map)",
    "source_code": "\tpublic void setStrategyMap(Map<String, VersionStrategy> map) {\n\t\tthis.versionStrategyMap.clear();\n\t\tthis.versionStrategyMap.putAll(map);\n\t}"
  },
  "org.springframework.web.servlet.resource.<unknown>#transform(request,resource,transformerChain)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "resource",
      "transformerChain"
    ],
    "position": {
      "column": 1,
      "line": 68
    },
    "return": "Resource",
    "signature": "public Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)",
    "source_code": "\tpublic Resource transform(HttpServletRequest request, Resource resource, ResourceTransformerChain transformerChain)\n\t\t\tthrows IOException {\n\n\t\tresource = transformerChain.transform(request, resource);\n\n\t\tString filename = resource.getFilename();\n\t\tif (!\"css\".equals(StringUtils.getFilenameExtension(filename)) ||\n\t\t\t\tresource instanceof EncodedResourceResolver.EncodedResource) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tbyte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream());\n\t\tString content = new String(bytes, DEFAULT_CHARSET);\n\n\t\tSortedSet<ContentChunkInfo> links = new TreeSet<>();\n\t\tfor (LinkParser parser : this.linkParsers) {\n\t\t\tparser.parse(content, links);\n\t\t}\n\n\t\tif (links.isEmpty()) {\n\t\t\treturn resource;\n\t\t}\n\n\t\tint index = 0;\n\t\tStringWriter writer = new StringWriter();\n\t\tfor (ContentChunkInfo linkContentChunkInfo : links) {\n\t\t\twriter.write(content.substring(index, linkContentChunkInfo.getStart()));\n\t\t\tString link = content.substring(linkContentChunkInfo.getStart(), linkContentChunkInfo.getEnd());\n\t\t\tString newLink = null;\n\t\t\tif (!hasScheme(link)) {\n\t\t\t\tString absolutePath = toAbsolutePath(link, request);\n\t\t\t\tnewLink = resolveUrlPath(absolutePath, request, resource, transformerChain);\n\t\t\t}\n\t\t\twriter.write(newLink != null ? newLink : link);\n\t\t\tindex = linkContentChunkInfo.getEnd();\n\t\t}\n\t\twriter.write(content.substring(index));\n\n\t\treturn new TransformedResource(resource, writer.toString().getBytes(DEFAULT_CHARSET));\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#changeLocale(locale,timeZone)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Change the current locale to the specified locale and time zone context,\n\t * storing the new locale context through the configured {@link LocaleResolver}.\n\t * @param locale the new locale\n\t * @param timeZone the new time zone\n\t * @see LocaleContextResolver#setLocaleContext\n\t * @see org.springframework.context.i18n.SimpleTimeZoneAwareLocaleContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "locale",
      "timeZone"
    ],
    "position": {
      "column": 1,
      "line": 381
    },
    "return": "void",
    "signature": "public void changeLocale(Locale locale, TimeZone timeZone)",
    "source_code": "\tpublic void changeLocale(Locale locale, TimeZone timeZone) {\n\t\tLocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(this.request);\n\t\tif (!(localeResolver instanceof LocaleContextResolver localeContextResolver)) {\n\t\t\tthrow new IllegalStateException(\"Cannot change locale context if no LocaleContextResolver configured\");\n\t\t}\n\t\tlocaleContextResolver.setLocaleContext(this.request, this.response,\n\t\t\t\tnew SimpleTimeZoneAwareLocaleContext(locale, timeZone));\n\t\tthis.locale = locale;\n\t\tthis.timeZone = timeZone;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#exposeLocalizationContext(request,messageSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Exposes JSTL-specific request attributes specifying locale\n\t * and resource bundle for JSTL's formatting and message tags,\n\t * using Spring's locale and MessageSource.\n\t * @param request the current HTTP request\n\t * @param messageSource the MessageSource to expose,\n\t * typically the current ApplicationContext (may be {@code null})\n\t * @see #exposeLocalizationContext(RequestContext)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 82
    },
    "return": "void",
    "signature": "public void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource)",
    "source_code": "\tpublic static void exposeLocalizationContext(HttpServletRequest request, @Nullable MessageSource messageSource) {\n\t\tLocale jstlLocale = RequestContextUtils.getLocale(request);\n\t\tConfig.set(request, Config.FMT_LOCALE, jstlLocale);\n\t\tTimeZone timeZone = RequestContextUtils.getTimeZone(request);\n\t\tif (timeZone != null) {\n\t\t\tConfig.set(request, Config.FMT_TIME_ZONE, timeZone);\n\t\t}\n\t\tif (messageSource != null) {\n\t\t\tLocalizationContext jstlContext = new SpringLocalizationContext(messageSource, request);\n\t\t\tConfig.set(request, Config.FMT_LOCALIZATION_CONTEXT, jstlContext);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#findWebApplicationContext(request,servletContext)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Look for the WebApplicationContext associated with the DispatcherServlet\n\t * that has initiated request processing, and for the global context if none\n\t * was found associated with the current request. The global context will\n\t * be found via the ServletContext or via ContextLoader's current context.\n\t * <p>NOTE: This variant remains compatible with Servlet 2.5, explicitly\n\t * checking a given ServletContext instead of deriving it from the request.\n\t * @param request current HTTP request\n\t * @param servletContext current servlet context\n\t * @return the request-specific WebApplicationContext, or the global one\n\t * if no request-specific context has been found, or {@code null} if none\n\t * @since 4.2.1\n\t * @see DispatcherServlet#WEB_APPLICATION_CONTEXT_ATTRIBUTE\n\t * @see WebApplicationContextUtils#getWebApplicationContext(ServletContext)\n\t * @see ContextLoader#getCurrentWebApplicationContext()\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "WebApplicationContext",
    "signature": "public WebApplicationContext findWebApplicationContext(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\tpublic static WebApplicationContext findWebApplicationContext(\n\t\t\tHttpServletRequest request, @Nullable ServletContext servletContext) {\n\n\t\tWebApplicationContext webApplicationContext = (WebApplicationContext) request.getAttribute(\n\t\t\t\tDispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n\t\tif (webApplicationContext == null) {\n\t\t\tif (servletContext != null) {\n\t\t\t\twebApplicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n\t\t\t}\n\t\t\tif (webApplicationContext == null) {\n\t\t\t\twebApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n\t\t\t}\n\t\t}\n\t\treturn webApplicationContext;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getBindStatus(path,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a BindStatus for the given bind object, using the \"defaultHtmlEscape\" setting.\n\t * @param path the bean and property path for which values and errors will be resolved (for example, \"person.age\")\n\t * @param htmlEscape create a BindStatus with automatic HTML escaping?\n\t * @return the new BindStatus instance\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "path",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 927
    },
    "return": "BindStatus",
    "signature": "public BindStatus getBindStatus(String path, boolean htmlEscape)",
    "source_code": "\tpublic BindStatus getBindStatus(String path, boolean htmlEscape) throws IllegalStateException {\n\t\treturn new BindStatus(this, path, htmlEscape);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getContextUrl(relativeUrl,Map<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a context-aware URl for the given relative URL with placeholders (named keys with braces {@code {}}).\n\t * For example, send in a relative URL {@code foo/{bar}?spam={spam}} and a parameter map\n\t * {@code {bar=baz,spam=nuts}} and the result will be {@code [contextpath]/foo/baz?spam=nuts}.\n\t * @param relativeUrl the relative URL part\n\t * @param params a map of parameters to insert as placeholders in the url\n\t * @return a URL that points back to the server with an absolute path (also URL-encoded accordingly)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "relativeUrl",
      "Map<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 575
    },
    "return": "String",
    "signature": "public String getContextUrl(String relativeUrl, Map<String, ?> params)",
    "source_code": "\tpublic String getContextUrl(String relativeUrl, Map<String, ?> params) {\n\t\tString url = getContextPath() + relativeUrl;\n\t\turl = UriComponentsBuilder.fromUriString(url).buildAndExpand(params).encode().toUri().toASCIIString();\n\t\tif (this.response != null) {\n\t\t\turl = this.response.encodeURL(url);\n\t\t}\n\t\treturn url;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getErrors(name,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the Errors instance for the given bind object.\n\t * @param name the name of the bind object\n\t * @param htmlEscape create an Errors instance with automatic HTML escaping?\n\t * @return the Errors instance, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 863
    },
    "return": "Errors",
    "signature": "public Errors getErrors(String name, boolean htmlEscape)",
    "source_code": "\tpublic Errors getErrors(String name, boolean htmlEscape) {\n\t\tif (this.errorsMap == null) {\n\t\t\tthis.errorsMap = new HashMap<>();\n\t\t}\n\t\tErrors errors = this.errorsMap.get(name);\n\t\tboolean put = false;\n\t\tif (errors == null) {\n\t\t\terrors = (Errors) getModelObject(BindingResult.MODEL_KEY_PREFIX + name);\n\t\t\t// Check old BindException prefix for backwards compatibility.\n\t\t\tif (errors instanceof BindException bindException) {\n\t\t\t\terrors = bindException.getBindingResult();\n\t\t\t}\n\t\t\tif (errors == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tput = true;\n\t\t}\n\t\tif (htmlEscape && !(errors instanceof EscapedErrors)) {\n\t\t\terrors = new EscapedErrors(errors);\n\t\t\tput = true;\n\t\t}\n\t\telse if (!htmlEscape && errors instanceof EscapedErrors escapedErrors) {\n\t\t\terrors = escapedErrors.getSource();\n\t\t\tput = true;\n\t\t}\n\t\tif (put) {\n\t\t\tthis.errorsMap.put(name, errors);\n\t\t}\n\t\treturn errors;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlAwareMessageSource(servletContext,messageSource)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Checks JSTL's \"jakarta.servlet.jsp.jstl.fmt.localizationContext\"\n\t * context-param and creates a corresponding child message source,\n\t * with the provided Spring-defined MessageSource as parent.\n\t * @param servletContext the ServletContext we're running in\n\t * (to check JSTL-related context-params in {@code web.xml})\n\t * @param messageSource the MessageSource to expose, typically\n\t * the ApplicationContext of the current DispatcherServlet\n\t * @return the MessageSource to expose to JSTL; first checking the\n\t * JSTL-defined bundle, then the Spring-defined MessageSource\n\t * @see org.springframework.context.ApplicationContext\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "messageSource"
    ],
    "position": {
      "column": 1,
      "line": 55
    },
    "return": "MessageSource",
    "signature": "public MessageSource getJstlAwareMessageSource(@Nullable ServletContext servletContext, MessageSource messageSource)",
    "source_code": "\tpublic static MessageSource getJstlAwareMessageSource(\n\t\t\t@Nullable ServletContext servletContext, MessageSource messageSource) {\n\n\t\tif (servletContext != null) {\n\t\t\tString jstlInitParam = servletContext.getInitParameter(Config.FMT_LOCALIZATION_CONTEXT);\n\t\t\tif (jstlInitParam != null) {\n\t\t\t\t// Create a ResourceBundleMessageSource for the specified resource bundle\n\t\t\t\t// basename in the JSTL context-param in web.xml, wiring it with the given\n\t\t\t\t// Spring-defined MessageSource as parent.\n\t\t\t\tResourceBundleMessageSource jstlBundleWrapper = new ResourceBundleMessageSource();\n\t\t\t\tjstlBundleWrapper.setBasename(jstlInitParam);\n\t\t\t\tjstlBundleWrapper.setParentMessageSource(messageSource);\n\t\t\t\treturn jstlBundleWrapper;\n\t\t\t}\n\t\t}\n\t\treturn messageSource;\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlLocale(request,servletContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 939
    },
    "return": "Locale",
    "signature": "public Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\t\tpublic static Locale getJstlLocale(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject localeObject = Config.get(request, Config.FMT_LOCALE);\n\t\t\tif (localeObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\tlocaleObject = Config.get(session, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t\tif (localeObject == null && servletContext != null) {\n\t\t\t\t\tlocaleObject = Config.get(servletContext, Config.FMT_LOCALE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (localeObject instanceof Locale locale ? locale : null);\n\t\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getJstlTimeZone(request,servletContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "servletContext"
    ],
    "position": {
      "column": 1,
      "line": 954
    },
    "return": "TimeZone",
    "signature": "public TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext)",
    "source_code": "\t\tpublic static TimeZone getJstlTimeZone(HttpServletRequest request, @Nullable ServletContext servletContext) {\n\t\t\tObject timeZoneObject = Config.get(request, Config.FMT_TIME_ZONE);\n\t\t\tif (timeZoneObject == null) {\n\t\t\t\tHttpSession session = request.getSession(false);\n\t\t\t\tif (session != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(session, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t\tif (timeZoneObject == null && servletContext != null) {\n\t\t\t\t\ttimeZoneObject = Config.get(servletContext, Config.FMT_TIME_ZONE);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (timeZoneObject instanceof TimeZone timeZone ? timeZone : null);\n\t\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 701
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\treturn getMessage(code, (args != null ? args.toArray() : null), defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,defaultMessage,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 665
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, String defaultMessage, boolean htmlEscape) {\n\t\tString msg = getMessageSource().getMessage(code, args, defaultMessage, getLocale());\n\t\tif (msg == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,args,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code.\n\t * @param code the code of the message\n\t * @param args arguments for the message, or {@code null} if none\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 713
    },
    "return": "String",
    "signature": "public String getMessage(String code, @Nullable Object[] args, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(String code, @Nullable Object[] args, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = getMessageSource().getMessage(code, args, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(code,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the message for the given code, using the \"defaultHtmlEscape\" setting.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 631
    },
    "return": "String",
    "signature": "public String getMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getMessage(String code, String defaultMessage) {\n\t\treturn getMessage(code, null, defaultMessage, isDefaultHtmlEscape());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getMessage(resolvable,htmlEscape)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the given MessageSourceResolvable (for example, an ObjectError instance).\n\t * @param resolvable the MessageSourceResolvable\n\t * @param htmlEscape if the message should be HTML-escaped\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "resolvable",
      "htmlEscape"
    ],
    "position": {
      "column": 1,
      "line": 735
    },
    "return": "String",
    "signature": "public String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape)",
    "source_code": "\tpublic String getMessage(MessageSourceResolvable resolvable, boolean htmlEscape) throws NoSuchMessageException {\n\t\tString msg = getMessageSource().getMessage(resolvable, getLocale());\n\t\treturn (htmlEscape ? HtmlUtils.htmlEscape(msg) : msg);\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @return the message\n\t * @throws org.springframework.context.NoSuchMessageException if not found\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args"
    ],
    "position": {
      "column": 1,
      "line": 828
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args) throws NoSuchMessageException {\n\t\treturn getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null), getLocale());\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,args,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param args arguments for the message as a List, or {@code null} if none\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "args",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 782
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, @Nullable List<?> args, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, (args != null ? args.toArray() : null),\n\t\t\t\tdefaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#getThemeMessage(code,defaultMessage)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the theme message for the given code.\n\t * <p>Note that theme messages are never HTML-escaped, as they typically denote\n\t * theme-specific resource paths and not client-visible messages.\n\t * @param code the code of the message\n\t * @param defaultMessage the String to return if the lookup fails\n\t * @return the message\n\t * @deprecated as of 6.0, with no direct replacement\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "defaultMessage"
    ],
    "position": {
      "column": 1,
      "line": 750
    },
    "return": "String",
    "signature": "public String getThemeMessage(String code, String defaultMessage)",
    "source_code": "\tpublic String getThemeMessage(String code, String defaultMessage) {\n\t\tString msg = getTheme().getMessageSource().getMessage(code, null, defaultMessage, getLocale());\n\t\treturn (msg != null ? msg : \"\");\n\t}"
  },
  "org.springframework.web.servlet.support.<unknown>#saveOutputFlashMap(location,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convenience method that retrieves the {@link #getOutputFlashMap \"output\"\n\t * FlashMap}, updates it with the path and query params of the target URL,\n\t * and then saves it using the {@link #getFlashMapManager FlashMapManager}.\n\t * @param location the target URL for the redirect\n\t * @param request the current request\n\t * @param response the current response\n\t * @since 5.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "location",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 272
    },
    "return": "void",
    "signature": "public void saveOutputFlashMap(String location, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tpublic static void saveOutputFlashMap(String location, HttpServletRequest request, HttpServletResponse response) {\n\t\tFlashMap flashMap = getOutputFlashMap(request);\n\t\tif (CollectionUtils.isEmpty(flashMap)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUriComponents uriComponents = UriComponentsBuilder.fromUriString(location).build();\n\t\tflashMap.setTargetRequestPath(uriComponents.getPath());\n\t\tflashMap.addTargetRequestParams(uriComponents.getQueryParams());\n\n\t\tFlashMapManager manager = getFlashMapManager(request);\n\t\tAssert.state(manager != null, \"No FlashMapManager. Is this a DispatcherServlet handled request?\");\n\t\tmanager.saveOutputFlashMap(flashMap, request, response);\n\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#createQueryString(params,usedParams,includeQueryStringDelimiter)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build the query string from available parameters that have not already\n\t * been applied as template params.\n\t * <p>The names and values of parameters are URL encoded.\n\t * @param params the parameters to build the query string from\n\t * @param usedParams set of parameter names that have been applied as\n\t * template params\n\t * @param includeQueryStringDelimiter true if the query string should start\n\t * with a '?' instead of '&amp;'\n\t * @return the query string\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "params",
      "usedParams",
      "includeQueryStringDelimiter"
    ],
    "position": {
      "column": 1,
      "line": 319
    },
    "return": "String",
    "signature": "protected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)",
    "source_code": "\tprotected String createQueryString(List<Param> params, Set<String> usedParams, boolean includeQueryStringDelimiter)\n\t\t\tthrows JspException {\n\n\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\tStringBuilder qs = new StringBuilder();\n\t\tfor (Param param : params) {\n\t\t\tif (!usedParams.contains(param.getName()) && StringUtils.hasLength(param.getName())) {\n\t\t\t\tif (includeQueryStringDelimiter && qs.isEmpty()) {\n\t\t\t\t\tqs.append('?');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqs.append('&');\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tqs.append(UriUtils.encodeQueryParam(param.getName(), encoding));\n\t\t\t\t\tif (param.getValue() != null) {\n\t\t\t\t\t\tqs.append('=');\n\t\t\t\t\t\tqs.append(UriUtils.encodeQueryParam(param.getValue(), encoding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn qs.toString();\n\t}"
  },
  "org.springframework.web.servlet.tags.<unknown>#replaceUriTemplateParams(uri,params,usedParams)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace template markers in the URL matching available parameters. The\n\t * name of matched parameters are added to the used parameters set.\n\t * <p>Parameter values are URL encoded.\n\t * @param uri the URL with template parameters to replace\n\t * @param params parameters used to replace template markers\n\t * @param usedParams set of template parameter names that have been replaced\n\t * @return the URL with template parameters replaced\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "uri",
      "params",
      "usedParams"
    ],
    "position": {
      "column": 1,
      "line": 356
    },
    "return": "String",
    "signature": "protected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)",
    "source_code": "\tprotected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)\n\t\t\tthrows JspException {\n\n\t\tString encoding = this.pageContext.getResponse().getCharacterEncoding();\n\t\tfor (Param param : params) {\n\t\t\tString template = URL_TEMPLATE_DELIMITER_PREFIX + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\tif (uri.contains(template)) {\n\t\t\t\tusedParams.add(param.getName());\n\t\t\t\tString value = param.getValue();\n\t\t\t\ttry {\n\t\t\t\t\turi = StringUtils.replace(uri, template,\n\t\t\t\t\t\t\t(value != null ? UriUtils.encodePath(value, encoding) : \"\"));\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemplate = URL_TEMPLATE_DELIMITER_PREFIX + '/' + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\t\tif (uri.contains(template)) {\n\t\t\t\t\tusedParams.add(param.getName());\n\t\t\t\t\tString value = param.getValue();\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi = StringUtils.replace(uri, template,\n\t\t\t\t\t\t\t\t(value != null ? UriUtils.encodePathSegment(value, encoding) : \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uri;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#isSelected(bindStatus,candidateValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Returns {@code true} if the supplied candidate value is equal to the value bound to\n\t * the supplied {@link BindStatus}. Equality in this case differs from standard Java equality and\n\t * is described in more detail <a href=\"#equality-contract\">here</a>.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "bindStatus",
      "candidateValue"
    ],
    "position": {
      "column": 1,
      "line": 63
    },
    "return": "boolean",
    "signature": "public boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue)",
    "source_code": "\tpublic static boolean isSelected(BindStatus bindStatus, @Nullable Object candidateValue) {\n\t\t// Check obvious equality matches with the candidate first,\n\t\t// both with the rendered value and with the original value.\n\t\tObject boundValue = bindStatus.getValue();\n\t\tif (ObjectUtils.nullSafeEquals(boundValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tObject actualValue = bindStatus.getActualValue();\n\t\tif (actualValue != null && actualValue != boundValue &&\n\t\t\t\tObjectUtils.nullSafeEquals(actualValue, candidateValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (actualValue != null) {\n\t\t\tboundValue = actualValue;\n\t\t}\n\t\telse if (boundValue == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Non-null value but no obvious equality with the candidate value:\n\t\t// go into more exhaustive comparisons.\n\t\tboolean selected = false;\n\t\tif (candidateValue != null) {\n\t\t\tif (boundValue.getClass().isArray()) {\n\t\t\t\tselected = collectionCompare(CollectionUtils.arrayToList(boundValue), candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Collection<?> collection) {\n\t\t\t\tselected = collectionCompare(collection, candidateValue, bindStatus);\n\t\t\t}\n\t\t\telse if (boundValue instanceof Map<?, ?> map) {\n\t\t\t\tselected = mapCompare(map, candidateValue, bindStatus);\n\t\t\t}\n\t\t}\n\t\tif (!selected) {\n\t\t\tselected = exhaustiveCompare(boundValue, candidateValue, bindStatus.getEditor(), null);\n\t\t}\n\t\treturn selected;\n\t}"
  },
  "org.springframework.web.servlet.tags.form.<unknown>#processFieldValue(name,value,type)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Process the given form field through a {@link RequestDataValueProcessor}\n\t * instance if one is configured or otherwise returns the same value.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "name",
      "value",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 243
    },
    "return": "String",
    "signature": "protected String processFieldValue(@Nullable String name, String value, String type)",
    "source_code": "\tprotected final String processFieldValue(@Nullable String name, String value, String type) {\n\t\tRequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();\n\t\tServletRequest request = this.pageContext.getRequest();\n\t\tif (processor != null && request instanceof HttpServletRequest httpServletRequest) {\n\t\t\tvalue = processor.processFormFieldValue(httpServletRequest, name, value, type);\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#appendCurrentQueryParams(targetUrl,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append the query string of the current request to the target redirect URL.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param request the current request\n\t * @since 4.1\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 411
    },
    "return": "void",
    "signature": "protected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request)",
    "source_code": "\tprotected void appendCurrentQueryParams(StringBuilder targetUrl, HttpServletRequest request) {\n\t\tString query = request.getQueryString();\n\t\tif (StringUtils.hasText(query)) {\n\t\t\t// Extract anchor fragment, if any.\n\t\t\tString fragment = null;\n\t\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\t\tif (anchorIndex > -1) {\n\t\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t\t}\n\n\t\t\tif (targetUrl.toString().indexOf('?') < 0) {\n\t\t\t\ttargetUrl.append('?').append(query);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetUrl.append('&').append(query);\n\t\t\t}\n\t\t\t// Append anchor fragment, if any, to end of URL.\n\t\t\tif (fragment != null) {\n\t\t\t\ttargetUrl.append(fragment);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#appendQueryProperties(targetUrl,Map<String,model,encodingScheme)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Append query properties to the redirect URL.\n\t * Stringifies, URL-encodes and formats model attributes as query properties.\n\t * @param targetUrl the StringBuilder to append the properties to\n\t * @param model a Map that contains model attributes\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t * @see #queryProperties\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 445
    },
    "return": "void",
    "signature": "protected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)",
    "source_code": "\tprotected void appendQueryProperties(StringBuilder targetUrl, Map<String, Object> model, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Extract anchor fragment, if any.\n\t\tString fragment = null;\n\t\tint anchorIndex = targetUrl.indexOf(\"#\");\n\t\tif (anchorIndex > -1) {\n\t\t\tfragment = targetUrl.substring(anchorIndex);\n\t\t\ttargetUrl.delete(anchorIndex, targetUrl.length());\n\t\t}\n\n\t\t// If there aren't already some parameters, we need a \"?\".\n\t\tboolean first = (targetUrl.toString().indexOf('?') < 0);\n\t\tfor (Map.Entry<String, Object> entry : queryProperties(model).entrySet()) {\n\t\t\tObject rawValue = entry.getValue();\n\t\t\tCollection<?> values;\n\t\t\tif (rawValue != null && rawValue.getClass().isArray()) {\n\t\t\t\tvalues = CollectionUtils.arrayToList(rawValue);\n\t\t\t}\n\t\t\telse if (rawValue instanceof Collection<?> collection) {\n\t\t\t\tvalues = collection;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = Collections.singleton(rawValue);\n\t\t\t}\n\t\t\tfor (Object value : values) {\n\t\t\t\tif (first) {\n\t\t\t\t\ttargetUrl.append('?');\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetUrl.append('&');\n\t\t\t\t}\n\t\t\t\tString encodedKey = urlEncode(entry.getKey(), encodingScheme);\n\t\t\t\tString encodedValue = (value != null ? urlEncode(value.toString(), encodingScheme) : \"\");\n\t\t\t\ttargetUrl.append(encodedKey).append('=').append(encodedValue);\n\t\t\t}\n\t\t}\n\n\t\t// Append anchor fragment, if any, to end of URL.\n\t\tif (fragment != null) {\n\t\t\ttargetUrl.append(fragment);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#applyLifecycleMethods(viewName,view)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Apply the containing {@link ApplicationContext}'s lifecycle methods\n\t * to the given {@link View} instance, if such a context is available.\n\t * @param viewName the name of the view\n\t * @param view the freshly created View instance, pre-configured with\n\t * {@link AbstractUrlBasedView}'s properties\n\t * @return the {@link View} instance to use (either the original one\n\t * or a decorated variant)\n\t * @since 5.0\n\t * @see #getApplicationContext()\n\t * @see ApplicationContext#getAutowireCapableBeanFactory()\n\t * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "view"
    ],
    "position": {
      "column": 1,
      "line": 615
    },
    "return": "View",
    "signature": "protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view)",
    "source_code": "\tprotected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context != null) {\n\t\t\tObject initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);\n\t\t\tif (initialized instanceof View initializedView) {\n\t\t\t\treturn initializedView;\n\t\t\t}\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#canHandle(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Indicates whether this {@link org.springframework.web.servlet.ViewResolver} can\n\t * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will\n\t * return {@code null}. The default implementation checks against the configured\n\t * {@link #setViewNames view names}.\n\t * @param viewName the name of the view to retrieve\n\t * @param locale the Locale to retrieve the view for\n\t * @return whether this resolver applies to the specified view\n\t * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 506
    },
    "return": "boolean",
    "signature": "protected boolean canHandle(String viewName, Locale locale)",
    "source_code": "\tprotected boolean canHandle(String viewName, Locale locale) {\n\t\tString[] viewNames = getViewNames();\n\t\treturn (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#createTargetUrl(Map<String,model,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create the target URL by checking if the redirect string is a URI template first,\n\t * expanding it with the given model, and then optionally appending simple type model\n\t * attributes as query String parameters.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 323
    },
    "return": "String",
    "signature": "protected String createTargetUrl(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected final String createTargetUrl(Map<String, Object> model, HttpServletRequest request)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\t// Prepare target URL.\n\t\tStringBuilder targetUrl = new StringBuilder();\n\t\tString url = getUrl();\n\t\tAssert.state(url != null, \"'url' not set\");\n\n\t\tif (this.contextRelative && url.startsWith(\"/\")) {\n\t\t\t// Do not apply context path to relative URLs.\n\t\t\ttargetUrl.append(getContextPath(request));\n\t\t}\n\t\ttargetUrl.append(url);\n\n\t\tString enc = this.encodingScheme;\n\t\tif (enc == null) {\n\t\t\tenc = request.getCharacterEncoding();\n\t\t}\n\t\tif (enc == null) {\n\t\t\tenc = WebUtils.DEFAULT_CHARACTER_ENCODING;\n\t\t}\n\n\t\tif (this.expandUriTemplateVariables && StringUtils.hasText(targetUrl)) {\n\t\t\tMap<String, String> variables = getCurrentRequestUriVariables(request);\n\t\t\ttargetUrl = replaceUriTemplateVariables(targetUrl.toString(), model, variables, enc);\n\t\t}\n\t\tif (isPropagateQueryProperties()) {\n\t\t\tappendCurrentQueryParams(targetUrl, request);\n\t\t}\n\t\tif (this.exposeModelAttributes) {\n\t\t\tappendQueryProperties(targetUrl, model, enc);\n\t\t}\n\n\t\treturn targetUrl.toString();\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#createView(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Overridden to implement check for \"redirect:\" prefix.\n\t * <p>Not possible in {@code loadView}, since overridden\n\t * {@code loadView} versions in subclasses might rely on the\n\t * superclass always creating instances of the required view class.\n\t * @see #loadView\n\t * @see #requiredViewClass\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 466
    },
    "return": "View",
    "signature": "protected View createView(String viewName, Locale locale)",
    "source_code": "\tprotected View createView(String viewName, Locale locale) throws Exception {\n\t\t// If this resolver is not supposed to handle the given view,\n\t\t// return null to pass on to the next resolver in the chain.\n\t\tif (!canHandle(viewName, locale)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check for special \"redirect:\" prefix.\n\t\tif (viewName.startsWith(REDIRECT_URL_PREFIX)) {\n\t\t\tString redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());\n\t\t\tRedirectView view = new RedirectView(redirectUrl,\n\t\t\t\t\tisRedirectContextRelative(), isRedirectHttp10Compatible());\n\t\t\tString[] hosts = getRedirectHosts();\n\t\t\tif (hosts != null) {\n\t\t\t\tview.setHosts(hosts);\n\t\t\t}\n\t\t\treturn applyLifecycleMethods(REDIRECT_URL_PREFIX, view);\n\t\t}\n\n\t\t// Check for special \"forward:\" prefix.\n\t\tif (viewName.startsWith(FORWARD_URL_PREFIX)) {\n\t\t\tString forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());\n\t\t\tInternalResourceView view = new InternalResourceView(forwardUrl);\n\t\t\treturn applyLifecycleMethods(FORWARD_URL_PREFIX, view);\n\t\t}\n\n\t\t// Else fall back to superclass implementation: calling loadView.\n\t\treturn super.createView(viewName, locale);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#getCacheKey(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This implementation returns just the view name,\n\t * as this ViewResolver doesn't support localized resolution.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 452
    },
    "return": "Object",
    "signature": "protected Object getCacheKey(String viewName, Locale locale)",
    "source_code": "\tprotected Object getCacheKey(String viewName, Locale locale) {\n\t\treturn viewName;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#getHttp11StatusCode(request,response,targetUrl)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determines the status code to use for HTTP 1.1 compatible requests.\n\t * <p>The default implementation returns the {@link #setStatusCode(HttpStatusCode) statusCode}\n\t * property if set, or the value of the {@link #RESPONSE_STATUS_ATTRIBUTE} attribute.\n\t * If neither are set, it defaults to {@link HttpStatus#SEE_OTHER} (303).\n\t * @param request the request to inspect\n\t * @param response the servlet response\n\t * @param targetUrl the target URL\n\t * @return the response status\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl"
    ],
    "position": {
      "column": 1,
      "line": 673
    },
    "return": "HttpStatusCode",
    "signature": "protected HttpStatusCode getHttp11StatusCode(HttpServletRequest request, HttpServletResponse response, String targetUrl)",
    "source_code": "\tprotected HttpStatusCode getHttp11StatusCode(\n\t\t\tHttpServletRequest request, HttpServletResponse response, String targetUrl) {\n\n\t\tif (this.statusCode != null) {\n\t\t\treturn this.statusCode;\n\t\t}\n\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\tif (attributeStatusCode != null) {\n\t\t\treturn attributeStatusCode;\n\t\t}\n\t\treturn HttpStatus.SEE_OTHER;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#isEligibleProperty(key,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the given model element should be exposed\n\t * as a query property.\n\t * <p>The default implementation considers Strings and primitives\n\t * as eligible, and also arrays and Collections/Iterables with\n\t * corresponding elements. This can be overridden in subclasses.\n\t * @param key the key of the model element\n\t * @param value the value of the model element\n\t * @return whether the element is eligible as query property\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 520
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleProperty(String key, @Nullable Object value)",
    "source_code": "\tprotected boolean isEligibleProperty(String key, @Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isEligibleValue(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value.getClass().isArray()) {\n\t\t\tint length = Array.getLength(value);\n\t\t\tif (length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tObject element = Array.get(value, i);\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Collection<?> coll) {\n\t\t\tif (coll.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Object element : coll) {\n\t\t\t\tif (!isEligibleValue(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#loadView(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@code buildView} for creating a new instance of the\n\t * specified view class. Applies the following Spring lifecycle methods\n\t * (as supported by the generic Spring bean factory):\n\t * <ul>\n\t * <li>ApplicationContextAware's {@code setApplicationContext}\n\t * <li>InitializingBean's {@code afterPropertiesSet}\n\t * </ul>\n\t * @param viewName the name of the view to retrieve\n\t * @return the View instance\n\t * @throws Exception if the view couldn't be resolved\n\t * @see #buildView(String)\n\t * @see org.springframework.context.ApplicationContextAware#setApplicationContext\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 551
    },
    "return": "View",
    "signature": "protected View loadView(String viewName, Locale locale)",
    "source_code": "\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tAbstractUrlBasedView view = buildView(viewName);\n\t\tView result = applyLifecycleMethods(viewName, view);\n\t\treturn (view.checkResource(locale) ? result : null);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#queryProperties(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine name-value pairs for query strings, which will be stringified,\n\t * URL-encoded and formatted by {@link #appendQueryProperties}.\n\t * <p>This implementation filters the model through checking\n\t * {@link #isEligibleProperty(String, Object)} for each element,\n\t * by default accepting Strings, primitives and primitive wrappers only.\n\t * @param model the original model Map\n\t * @return the filtered Map of eligible query properties\n\t * @see #isEligibleProperty(String, Object)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 500
    },
    "return": "Object>",
    "signature": "protected Object> queryProperties(Map<String, Object> model)",
    "source_code": "\tprotected Map<String, Object> queryProperties(Map<String, Object> model) {\n\t\tMap<String, Object> result = new LinkedHashMap<>();\n\t\tmodel.forEach((name, value) -> {\n\t\t\tif (isEligibleProperty(name, value)) {\n\t\t\t\tresult.put(name, value);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#render(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 375
    },
    "return": "void",
    "signature": "public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\t\tpublic void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {\n\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);\n\t\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Convert model to request parameters and redirect to the given URL.\n\t * @see #appendQueryProperties\n\t * @see #sendRedirect\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 305
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException {\n\n\t\tString targetUrl = createTargetUrl(model, request);\n\t\ttargetUrl = updateTargetUrl(targetUrl, model, request, response);\n\n\t\t// Save flash attributes\n\t\tRequestContextUtils.saveOutputFlashMap(targetUrl, request, response);\n\n\t\t// Redirect\n\t\tsendRedirect(request, response, targetUrl, this.http10Compatible);\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#replaceUriTemplateVariables(targetUrl,Map<String,model,Map<String,currentUriVariables,encodingScheme)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Replace URI template variables in the target URL with encoded model\n\t * attributes or URI variables from the current request. Model attributes\n\t * referenced in the URL are removed from the model.\n\t * @param targetUrl the redirect URL\n\t * @param model a Map that contains model attributes\n\t * @param currentUriVariables current request URI variables to use\n\t * @param encodingScheme the encoding scheme to use\n\t * @throws UnsupportedEncodingException if string encoding failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "Map<String",
      "currentUriVariables",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 377
    },
    "return": "StringBuilder",
    "signature": "protected StringBuilder replaceUriTemplateVariables(String targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)",
    "source_code": "\tprotected StringBuilder replaceUriTemplateVariables(\n\t\t\tString targetUrl, Map<String, Object> model, Map<String, String> currentUriVariables, String encodingScheme)\n\t\t\tthrows UnsupportedEncodingException {\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tMatcher matcher = URI_TEMPLATE_VARIABLE_PATTERN.matcher(targetUrl);\n\t\tint endLastMatch = 0;\n\t\twhile (matcher.find()) {\n\t\t\tString name = matcher.group(1);\n\t\t\tObject value = (model.containsKey(name) ? model.remove(name) : currentUriVariables.get(name));\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Model has no value for key '\" + name + \"'\");\n\t\t\t}\n\t\t\tresult.append(targetUrl, endLastMatch, matcher.start());\n\t\t\tresult.append(UriUtils.encodePathSegment(value.toString(), encodingScheme));\n\t\t\tendLastMatch = matcher.end();\n\t\t}\n\t\tresult.append(targetUrl.substring(endLastMatch));\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#resolveViewName(viewName,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "View",
    "signature": "public View resolveViewName(String viewName, Locale locale)",
    "source_code": "\tpublic View resolveViewName(String viewName, Locale locale) throws Exception {\n\t\tRequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n\t\tAssert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\");\n\t\tList<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n\t\tif (requestedMediaTypes != null) {\n\t\t\tList<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n\t\t\tView bestView = getBestView(candidateViews, requestedMediaTypes, attrs);\n\t\t\tif (bestView != null) {\n\t\t\t\treturn bestView;\n\t\t\t}\n\t\t}\n\n\t\tString mediaTypeInfo = (logger.isDebugEnabled() && requestedMediaTypes != null ?\n\t\t\t\t\" given \" + requestedMediaTypes.toString() : \"\");\n\n\t\tif (this.useNotAcceptableStatusCode) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Using 406 NOT_ACCEPTABLE\" + mediaTypeInfo);\n\t\t\t}\n\t\t\treturn NOT_ACCEPTABLE_VIEW;\n\t\t}\n\t\telse {\n\t\t\tlogger.debug(\"View remains unresolved\" + mediaTypeInfo);\n\t\t\treturn null;\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#sendRedirect(request,response,targetUrl,http10Compatible)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Send a redirect back to the HTTP client.\n\t * @param request current HTTP request (allows for reacting to request method)\n\t * @param response current HTTP response (for sending response headers)\n\t * @param targetUrl the target URL to redirect to\n\t * @param http10Compatible whether to stay compatible with HTTP 1.0 clients\n\t * @throws IOException if thrown by response methods\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "targetUrl",
      "http10Compatible"
    ],
    "position": {
      "column": 1,
      "line": 611
    },
    "return": "void",
    "signature": "protected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible)",
    "source_code": "\tprotected void sendRedirect(HttpServletRequest request, HttpServletResponse response,\n\t\t\tString targetUrl, boolean http10Compatible) throws IOException {\n\n\t\tString encodedURL = (isRemoteHost(targetUrl) ? targetUrl : response.encodeRedirectURL(targetUrl));\n\t\tif (http10Compatible) {\n\t\t\tHttpStatusCode attributeStatusCode = (HttpStatusCode) request.getAttribute(View.RESPONSE_STATUS_ATTRIBUTE);\n\t\t\tif (this.statusCode != null) {\n\t\t\t\tresponse.setStatus(this.statusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse if (attributeStatusCode != null) {\n\t\t\t\tresponse.setStatus(attributeStatusCode.value());\n\t\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Send status code 302 by default.\n\t\t\t\tresponse.sendRedirect(encodedURL);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tHttpStatusCode statusCode = getHttp11StatusCode(request, response, targetUrl);\n\t\t\tresponse.setStatus(statusCode.value());\n\t\t\tresponse.setHeader(\"Location\", encodedURL);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#setAttributesMap(Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set static attributes from a Map, for all views returned by this resolver.\n\t * This allows to set any kind of attribute values, for example bean references.\n\t * <p>Can be populated with a \"map\" or \"props\" element in XML bean definitions.\n\t * @param attributes a Map with name Strings as keys and attribute objects as values\n\t * @see AbstractView#setAttributesMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 328
    },
    "return": "void",
    "signature": "public void setAttributesMap(@Nullable Map<String, ?> attributes)",
    "source_code": "\tpublic void setAttributesMap(@Nullable Map<String, ?> attributes) {\n\t\tif (attributes != null) {\n\t\t\tthis.staticAttributes.putAll(attributes);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#updateTargetUrl(targetUrl,Map<String,model,request,response)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Find the registered {@link RequestDataValueProcessor}, if any, and allow\n\t * it to update the redirect target URL.\n\t * @param targetUrl the given redirect URL\n\t * @return the updated URL or the same as URL as the one passed in\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "targetUrl",
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 586
    },
    "return": "String",
    "signature": "protected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected String updateTargetUrl(String targetUrl, Map<String, Object> model,\n\t\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\tWebApplicationContext wac = getWebApplicationContext();\n\t\tif (wac == null) {\n\t\t\twac = RequestContextUtils.findWebApplicationContext(request, getServletContext());\n\t\t}\n\n\t\tif (wac != null && wac.containsBean(RequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME)) {\n\t\t\tRequestDataValueProcessor processor = wac.getBean(\n\t\t\t\t\tRequestContextUtils.REQUEST_DATA_VALUE_PROCESSOR_BEAN_NAME, RequestDataValueProcessor.class);\n\t\t\treturn processor.processUrl(request, targetUrl);\n\t\t}\n\n\t\treturn targetUrl;\n\t}"
  },
  "org.springframework.web.servlet.view.<unknown>#urlEncode(input,encodingScheme)": {
    "deprecated": false,
    "doc": "\t/**\n\t * URL-encode the given input String with the given encoding scheme.\n\t * <p>The default implementation uses {@code URLEncoder.encode(input, enc)}.\n\t * @param input the unencoded input String\n\t * @param encodingScheme the encoding scheme\n\t * @return the encoded output String\n\t * @throws UnsupportedEncodingException if thrown by the JDK URLEncoder\n\t * @see java.net.URLEncoder#encode(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "input",
      "encodingScheme"
    ],
    "position": {
      "column": 1,
      "line": 576
    },
    "return": "String",
    "signature": "protected String urlEncode(String input, String encodingScheme)",
    "source_code": "\tprotected String urlEncode(String input, String encodingScheme) throws UnsupportedEncodingException {\n\t\treturn URLEncoder.encode(input, encodingScheme);\n\t}"
  },
  "org.springframework.web.servlet.view.freemarker.<unknown>#loadView(viewName,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Delegates to {@code super.loadView(viewName, locale)} for standard behavior\n\t * and then to {@link #postProcessView(FreeMarkerView)} for customization.\n\t * @since 6.2\n\t * @see org.springframework.web.servlet.view.UrlBasedViewResolver#loadView(String, Locale)\n\t * @see #postProcessView(FreeMarkerView)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "viewName",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "View",
    "signature": "protected View loadView(String viewName, Locale locale)",
    "source_code": "\tprotected View loadView(String viewName, Locale locale) throws Exception {\n\t\tView view = super.loadView(viewName, locale);\n\t\tif (view instanceof FreeMarkerView freeMarkerView) {\n\t\t\tpostProcessView(freeMarkerView);\n\t\t}\n\t\treturn view;\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#filterAndWrapModel(Map<String,model,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter and optionally wrap the model in {@link MappingJacksonValue} container.\n\t * @param model the model, as passed on to {@link #renderMergedOutputModel}\n\t * @param request current HTTP request\n\t * @return the wrapped or unwrapped value to be rendered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 182
    },
    "return": "Object",
    "signature": "protected Object filterAndWrapModel(Map<String, Object> model, HttpServletRequest request)",
    "source_code": "\tprotected Object filterAndWrapModel(Map<String, Object> model, HttpServletRequest request) {\n\t\tObject value = filterModel(model);\n\t\tClass<?> serializationView = (Class<?>) model.get(JsonView.class.getName());\n\t\tFilterProvider filters = (FilterProvider) model.get(FilterProvider.class.getName());\n\t\tif (serializationView != null || filters != null) {\n\t\t\tMappingJacksonValue container = new MappingJacksonValue(value);\n\t\t\tif (serializationView != null) {\n\t\t\t\tcontainer.setSerializationView(serializationView);\n\t\t\t}\n\t\t\tif (filters != null) {\n\t\t\t\tcontainer.setFilters(filters);\n\t\t\t}\n\t\t\tvalue = container;\n\t\t}\n\t\treturn value;\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#filterModel(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter out undesired attributes from the given model.\n\t * The return value can be either another {@link Map} or a single value object.\n\t * @param model the model, as passed on to {@link #renderMergedOutputModel}\n\t * @return the value to be rendered\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 244
    },
    "return": "Object",
    "signature": "protected Object filterModel(Map<String, Object> model)",
    "source_code": "\tprotected abstract Object filterModel(Map<String, Object> model);"
  },
  "org.springframework.web.servlet.view.json.<unknown>#prepareResponse(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 145
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setCharacterEncoding(this.encoding.getJavaName());\n\t\tif (this.disableCaching) {\n\t\t\tresponse.addHeader(\"Cache-Control\", \"no-store\");\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\tByteArrayOutputStream temporaryStream = null;\n\t\tOutputStream stream;\n\n\t\tif (this.updateContentLength) {\n\t\t\ttemporaryStream = createTemporaryOutputStream();\n\t\t\tstream = temporaryStream;\n\t\t}\n\t\telse {\n\t\t\tstream = response.getOutputStream();\n\t\t}\n\n\t\tObject value = filterAndWrapModel(model, request);\n\t\twriteContent(stream, value);\n\n\t\tif (temporaryStream != null) {\n\t\t\twriteToResponse(response, temporaryStream);\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writeContent(stream,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write the actual JSON content to the stream.\n\t * @param stream the output stream to use\n\t * @param object the value to be rendered, as returned from {@link #filterModel}\n\t * @throws IOException if writing failed\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "stream",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "void",
    "signature": "protected void writeContent(OutputStream stream, Object object)",
    "source_code": "\tprotected void writeContent(OutputStream stream, Object object) throws IOException {\n\t\ttry (JsonGenerator generator = this.objectMapper.getFactory().createGenerator(stream, this.encoding)) {\n\t\t\twritePrefix(generator, object);\n\n\t\t\tObject value = object;\n\t\t\tClass<?> serializationView = null;\n\t\t\tFilterProvider filters = null;\n\n\t\t\tif (value instanceof MappingJacksonValue container) {\n\t\t\t\tvalue = container.getValue();\n\t\t\t\tserializationView = container.getSerializationView();\n\t\t\t\tfilters = container.getFilters();\n\t\t\t}\n\n\t\t\tObjectWriter objectWriter = (serializationView != null ?\n\t\t\t\t\tthis.objectMapper.writerWithView(serializationView) : this.objectMapper.writer());\n\t\t\tif (filters != null) {\n\t\t\t\tobjectWriter = objectWriter.with(filters);\n\t\t\t}\n\t\t\tobjectWriter.writeValue(generator, value);\n\n\t\t\twriteSuffix(generator, object);\n\t\t\tgenerator.flush();\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writePrefix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a prefix before the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 251
    },
    "return": "void",
    "signature": "protected void writePrefix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writePrefix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.web.servlet.view.json.<unknown>#writeSuffix(generator,object)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Write a suffix after the main content.\n\t * @param generator the generator to use for writing content.\n\t * @param object the object to write to the output message.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "generator",
      "object"
    ],
    "position": {
      "column": 1,
      "line": 259
    },
    "return": "void",
    "signature": "protected void writeSuffix(JsonGenerator generator, Object object)",
    "source_code": "\tprotected void writeSuffix(JsonGenerator generator, Object object) throws IOException {\n\t}"
  },
  "org.springframework.web.servlet.view.script.<unknown>#prepareResponse(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 387
    },
    "return": "void",
    "signature": "protected void prepareResponse(HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {\n\t\tsuper.prepareResponse(request, response);\n\n\t\tsetResponseContentType(request, response);\n\t\tif (this.charset != null) {\n\t\t\tresponse.setCharacterEncoding(this.charset.name());\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.script.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\ttry {\n\t\t\tScriptEngine engine = getEngine();\n\t\t\tString url = getUrl();\n\t\t\tAssert.state(url != null, \"'url' not set\");\n\t\t\tString template = getTemplate(url);\n\n\t\t\tFunction<String, String> templateLoader = path -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn getTemplate(path);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tLocale locale = RequestContextUtils.getLocale(request);\n\t\t\tRenderingContext context = new RenderingContext(obtainApplicationContext(), locale, templateLoader, url);\n\n\t\t\tObject html;\n\t\t\tif (this.renderFunction == null) {\n\t\t\t\tSimpleBindings bindings = new SimpleBindings();\n\t\t\t\tbindings.putAll(model);\n\t\t\t\tmodel.put(\"renderingContext\", context);\n\t\t\t\thtml = engine.eval(template, bindings);\n\t\t\t}\n\t\t\telse if (this.renderObject != null) {\n\t\t\t\tObject thiz = engine.eval(this.renderObject);\n\t\t\t\thtml = ((Invocable) engine).invokeMethod(thiz, this.renderFunction, template, model, context);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thtml = ((Invocable) engine).invokeFunction(this.renderFunction, template, model, context);\n\t\t\t}\n\n\t\t\tresponse.getWriter().write(String.valueOf(html));\n\t\t}\n\t\tcatch (ScriptException ex) {\n\t\t\tthrow new ServletException(\"Failed to render script template\", new StandardScriptEvalException(ex));\n\t\t}\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#isEligibleForMarshalling(modelKey,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check whether the given value from the current view's model is eligible\n\t * for marshalling through the configured {@link Marshaller}.\n\t * <p>The default implementation calls {@link Marshaller#supports(Class)},\n\t * unwrapping a given {@link JAXBElement} first if applicable.\n\t * @param modelKey the value's key in the model (never {@code null})\n\t * @param value the value to check (never {@code null})\n\t * @return whether the given value is to be considered as eligible\n\t * @see Marshaller#supports(Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "modelKey",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 166
    },
    "return": "boolean",
    "signature": "protected boolean isEligibleForMarshalling(String modelKey, Object value)",
    "source_code": "\tprotected boolean isEligibleForMarshalling(String modelKey, Object value) {\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tClass<?> classToCheck = value.getClass();\n\t\tif (value instanceof JAXBElement<?> jaxbElement) {\n\t\t\tclassToCheck = jaxbElement.getDeclaredType();\n\t\t}\n\t\treturn this.marshaller.supports(classToCheck);\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#locateToBeMarshalled(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Locate the object to be marshalled.\n\t * <p>The default implementation first attempts to look under the configured\n\t * {@linkplain #setModelKey(String) model key}, if any, before attempting to\n\t * locate an object of {@linkplain Marshaller#supports(Class) supported type}.\n\t * @param model the model Map\n\t * @return the Object to be marshalled (or {@code null} if none found)\n\t * @throws IllegalStateException if the model object specified by the\n\t * {@linkplain #setModelKey(String) model key} is not supported by the marshaller\n\t * @see #setModelKey(String)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "Object",
    "signature": "protected Object locateToBeMarshalled(Map<String, Object> model)",
    "source_code": "\tprotected Object locateToBeMarshalled(Map<String, Object> model) throws IllegalStateException {\n\t\tif (this.modelKey != null) {\n\t\t\tObject value = model.get(this.modelKey);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new IllegalStateException(\"Model contains no object with key [\" + this.modelKey + \"]\");\n\t\t\t}\n\t\t\tif (!isEligibleForMarshalling(this.modelKey, value)) {\n\t\t\t\tthrow new IllegalStateException(\"Model object [\" + value + \"] retrieved via key [\" +\n\t\t\t\t\t\tthis.modelKey + \"] is not supported by the Marshaller\");\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : model.entrySet()) {\n\t\t\tObject value = entry.getValue();\n\t\t\tif (value != null && (model.size() == 1 || !(value instanceof BindingResult)) &&\n\t\t\t\t\tisEligibleForMarshalling(entry.getKey(), value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.servlet.view.xml.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 105
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws Exception {\n\n\t\tObject toBeMarshalled = locateToBeMarshalled(model);\n\t\tif (toBeMarshalled == null) {\n\t\t\tthrow new IllegalStateException(\"Unable to locate object to be marshalled in model: \" + model);\n\t\t}\n\n\t\tAssert.state(this.marshaller != null, \"No Marshaller set\");\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n\t\tthis.marshaller.marshal(toBeMarshalled, new StreamResult(baos));\n\n\t\tsetResponseContentType(request, response);\n\t\tresponse.setContentLength(baos.size());\n\t\tbaos.writeTo(response.getOutputStream());\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureResponse(Map<String,model,response,transformer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link HttpServletResponse}.\n\t * <p>The default implementation of this method sets the\n\t * {@link HttpServletResponse#setContentType content type} and\n\t * {@link HttpServletResponse#setCharacterEncoding encoding}\n\t * from the \"media-type\" and \"encoding\" output properties\n\t * specified in the {@link Transformer}.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 412
    },
    "return": "void",
    "signature": "protected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer)",
    "source_code": "\tprotected void configureResponse(Map<String, Object> model, HttpServletResponse response, Transformer transformer) {\n\t\tString contentType = getContentType();\n\t\tString mediaType = transformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n\t\tString encoding = transformer.getOutputProperty(OutputKeys.ENCODING);\n\t\tif (StringUtils.hasText(mediaType)) {\n\t\t\tcontentType = mediaType;\n\t\t}\n\t\tif (StringUtils.hasText(encoding)) {\n\t\t\t// Only apply encoding if content type is specified but does not contain charset clause already.\n\t\t\tif (contentType != null && !contentType.toLowerCase(Locale.ROOT).contains(WebUtils.CONTENT_TYPE_CHARSET_PREFIX)) {\n\t\t\t\tcontentType = contentType + WebUtils.CONTENT_TYPE_CHARSET_PREFIX + encoding;\n\t\t\t}\n\t\t}\n\t\tresponse.setContentType(contentType);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#configureTransformer(Map<String,model,response,transformer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure the supplied {@link Transformer} instance.\n\t * <p>The default implementation copies parameters from the model into the\n\t * Transformer's {@link Transformer#setParameter parameter set}.\n\t * This implementation also copies the {@link #setOutputProperties output properties}\n\t * into the {@link Transformer} {@link Transformer#setOutputProperty output properties}.\n\t * Indentation properties are set as well.\n\t * @param model merged output Map (never {@code null})\n\t * @param response current HTTP response\n\t * @param transformer the target transformer\n\t * @see #copyModelParameters(Map, Transformer)\n\t * @see #copyOutputProperties(Transformer)\n\t * @see #configureIndentation(Transformer)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "response",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 351
    },
    "return": "void",
    "signature": "protected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer)",
    "source_code": "\tprotected void configureTransformer(Map<String, Object> model, HttpServletResponse response,\n\t\t\tTransformer transformer) {\n\n\t\tcopyModelParameters(model, transformer);\n\t\tcopyOutputProperties(transformer);\n\t\tconfigureIndentation(transformer);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#copyModelParameters(Map<String,model,transformer)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Copy all entries from the supplied Map into the\n\t * {@link Transformer#setParameter(String, Object) parameter set}\n\t * of the supplied {@link Transformer}.\n\t * @param model merged output Map (never {@code null})\n\t * @param transformer the target transformer\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "transformer"
    ],
    "position": {
      "column": 1,
      "line": 397
    },
    "return": "void",
    "signature": "protected void copyModelParameters(Map<String, Object> model, Transformer transformer)",
    "source_code": "\tprotected final void copyModelParameters(Map<String, Object> model, Transformer transformer) {\n\t\tmodel.forEach(transformer::setParameter);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#locateSource(Map<String,model)": {
    "deprecated": false,
    "doc": "\t/**\n\t * <p>Locate the {@link Source} object in the supplied model,\n\t * converting objects as required.\n\t * The default implementation first attempts to look under the configured\n\t * {@link #setSourceKey source key}, if any, before attempting to locate\n\t * an object of {@link #getSourceTypes() supported type}.\n\t * @param model the merged model Map\n\t * @return the XSLT Source object (or {@code null} if none found)\n\t * @throws Exception if an error occurred during locating the source\n\t * @see #setSourceKey\n\t * @see #convertSource\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model"
    ],
    "position": {
      "column": 1,
      "line": 287
    },
    "return": "Source",
    "signature": "protected Source locateSource(Map<String, Object> model)",
    "source_code": "\tprotected Source locateSource(Map<String, Object> model) throws Exception {\n\t\tif (this.sourceKey != null) {\n\t\t\treturn convertSource(model.get(this.sourceKey));\n\t\t}\n\t\tObject source = CollectionUtils.findValueOfType(model.values(), getSourceTypes());\n\t\treturn (source != null ? convertSource(source) : null);\n\t}"
  },
  "org.springframework.web.servlet.view.xslt.<unknown>#renderMergedOutputModel(Map<String,model,request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "Map<String",
      "model",
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 237
    },
    "return": "void",
    "signature": "protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)",
    "source_code": "\tprotected void renderMergedOutputModel(\n\t\t\tMap<String, Object> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tTemplates templates = this.cachedTemplates;\n\t\tif (templates == null) {\n\t\t\ttemplates = loadTemplates();\n\t\t}\n\n\t\tTransformer transformer = createTransformer(templates);\n\t\tconfigureTransformer(model, response, transformer);\n\t\tconfigureResponse(model, response, transformer);\n\t\tSource source = null;\n\t\ttry {\n\t\t\tsource = locateSource(model);\n\t\t\tif (source == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to locate Source object in model: \" + model);\n\t\t\t}\n\t\t\ttransformer.transform(source, createResult(response));\n\t\t}\n\t\tfinally {\n\t\t\tcloseSourceIfNecessary(source);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.<unknown>#add(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Add the given, single header value under the given name.\n\t * @param headerName  the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #set(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 210
    },
    "return": "void",
    "signature": "public void add(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void add(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.add(headerName, headerValue);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#forEach(String,action)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "action"
    ],
    "position": {
      "column": 1,
      "line": 301
    },
    "return": "void",
    "signature": "public void forEach(BiConsumer<? super String, ? super List<String>> action)",
    "source_code": "\tpublic void forEach(BiConsumer<? super String, ? super List<String>> action) {\n\t\tthis.headers.forEach(action);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#put(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 266
    },
    "return": "List<String>",
    "signature": "public List<String> put(String key, List<String> value)",
    "source_code": "\tpublic List<String> put(String key, List<String> value) {\n\t\treturn this.headers.put(key, value);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putAll(String,m)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "String",
      "m"
    ],
    "position": {
      "column": 1,
      "line": 276
    },
    "return": "void",
    "signature": "public void putAll(Map<? extends String, ? extends List<String>> m)",
    "source_code": "\tpublic void putAll(Map<? extends String, ? extends List<String>> m) {\n\t\tthis.headers.putAll(m);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#putIfAbsent(key,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 306
    },
    "return": "List<String>",
    "signature": "public List<String> putIfAbsent(String key, List<String> value)",
    "source_code": "\tpublic List<String> putIfAbsent(String key, List<String> value) {\n\t\treturn this.headers.putIfAbsent(key, value);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#set(headerName,headerValue)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the given, single header value under the given name.\n\t * @param headerName  the header name\n\t * @param headerValue the header value\n\t * @throws UnsupportedOperationException if adding headers is not supported\n\t * @see #put(String, List)\n\t * @see #add(String, String)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "headerName",
      "headerValue"
    ],
    "position": {
      "column": 1,
      "line": 223
    },
    "return": "void",
    "signature": "public void set(String headerName, @Nullable String headerValue)",
    "source_code": "\tpublic void set(String headerName, @Nullable String headerValue) {\n\t\tthis.headers.set(headerName, headerValue);\n\t}"
  },
  "org.springframework.web.socket.<unknown>#setAll(Map<String,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 228
    },
    "return": "void",
    "signature": "public void setAll(Map<String, String> values)",
    "source_code": "\tpublic void setAll(Map<String, String> values) {\n\t\tthis.headers.setAll(values);\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#createAnnotationMethodMessageHandler(clientInboundChannel,clientOutboundChannel,brokerMessagingTemplate)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel",
      "brokerMessagingTemplate"
    ],
    "position": {
      "column": 1,
      "line": 67
    },
    "return": "SimpAnnotationMethodMessageHandler",
    "signature": "protected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(AbstractSubscribableChannel clientInboundChannel,AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate)",
    "source_code": "\tprotected SimpAnnotationMethodMessageHandler createAnnotationMethodMessageHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel,AbstractSubscribableChannel clientOutboundChannel,\n\t\t\tSimpMessagingTemplate brokerMessagingTemplate) {\n\n\t\tWebSocketAnnotationMethodMessageHandler handler = new WebSocketAnnotationMethodMessageHandler(\n\t\t\t\tclientInboundChannel, clientOutboundChannel, brokerMessagingTemplate);\n\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#stompWebSocketHandlerMapping(subProtocolWebSocketHandler,messageBrokerTaskScheduler,clientInboundChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "subProtocolWebSocketHandler",
      "messageBrokerTaskScheduler",
      "clientInboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 88
    },
    "return": "HandlerMapping",
    "signature": "public HandlerMapping stompWebSocketHandlerMapping(WebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler,\n\t\t\tAbstractSubscribableChannel clientInboundChannel)",
    "source_code": "\tpublic HandlerMapping stompWebSocketHandlerMapping(\n\t\t\tWebSocketHandler subProtocolWebSocketHandler, TaskScheduler messageBrokerTaskScheduler,\n\t\t\tAbstractSubscribableChannel clientInboundChannel) {\n\n\t\tWebSocketHandler handler = decorateWebSocketHandler(subProtocolWebSocketHandler);\n\t\tWebMvcStompEndpointRegistry registry =\n\t\t\t\tnew WebMvcStompEndpointRegistry(handler, getTransportRegistration(), messageBrokerTaskScheduler);\n\t\tApplicationContext applicationContext = getApplicationContext();\n\t\tif (applicationContext != null) {\n\t\t\tregistry.setApplicationContext(applicationContext);\n\t\t}\n\t\tregisterStompEndpoints(registry);\n\t\tOrderedMessageChannelDecorator.configureInterceptor(clientInboundChannel, registry.isPreserveReceiveOrder());\n\t\tAbstractHandlerMapping handlerMapping = registry.getHandlerMapping();\n\t\tif (handlerMapping instanceof WebSocketHandlerMapping webSocketMapping) {\n\t\t\twebSocketMapping.setPhase(getPhase());\n\t\t}\n\t\treturn handlerMapping;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#subProtocolWebSocketHandler(clientInboundChannel,clientOutboundChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "clientInboundChannel",
      "clientOutboundChannel"
    ],
    "position": {
      "column": 1,
      "line": 109
    },
    "return": "WebSocketHandler",
    "signature": "public WebSocketHandler subProtocolWebSocketHandler(AbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel)",
    "source_code": "\tpublic WebSocketHandler subProtocolWebSocketHandler(\n\t\t\tAbstractSubscribableChannel clientInboundChannel, AbstractSubscribableChannel clientOutboundChannel) {\n\n\t\tSubProtocolWebSocketHandler handler =\n\t\t\t\tnew SubProtocolWebSocketHandler(clientInboundChannel, clientOutboundChannel);\n\n\t\thandler.setPhase(getPhase());\n\t\treturn handler;\n\t}"
  },
  "org.springframework.web.socket.config.annotation.<unknown>#webSocketMessageBrokerStats(stompBrokerRelayMessageHandler,subProtocolWebSocketHandler,@Qualifier(\"clientInboundChannelExecutor\")": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "stompBrokerRelayMessageHandler",
      "subProtocolWebSocketHandler",
      "@Qualifier(\"clientInboundChannelExecutor\""
    ],
    "position": {
      "column": 1,
      "line": 147
    },
    "return": "WebSocketMessageBrokerStats",
    "signature": "public WebSocketMessageBrokerStats webSocketMessageBrokerStats(@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\")",
    "source_code": "\tpublic WebSocketMessageBrokerStats webSocketMessageBrokerStats(\n\t\t\t@Nullable AbstractBrokerMessageHandler stompBrokerRelayMessageHandler,\n\t\t\tWebSocketHandler subProtocolWebSocketHandler,\n\t\t\t@Qualifier(\"clientInboundChannelExecutor\") TaskExecutor inboundExecutor,\n\t\t\t@Qualifier(\"clientOutboundChannelExecutor\") TaskExecutor outboundExecutor,\n\t\t\t@Qualifier(\"messageBrokerTaskScheduler\") TaskScheduler scheduler) {\n\n\t\tWebSocketMessageBrokerStats stats = new WebSocketMessageBrokerStats();\n\t\tstats.setSubProtocolWebSocketHandler((SubProtocolWebSocketHandler) subProtocolWebSocketHandler);\n\t\tif (stompBrokerRelayMessageHandler instanceof StompBrokerRelayMessageHandler sbrmh) {\n\t\t\tstats.setStompBrokerRelay(sbrmh);\n\t\t}\n\t\tstats.setInboundChannelExecutor(inboundExecutor);\n\t\tstats.setOutboundChannelExecutor(outboundExecutor);\n\t\tstats.setSockJsTaskScheduler(scheduler);\n\t\treturn stats;\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#afterConnectionClosed(session,closeStatus)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 84
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {\n\t\tthis.delegate.afterConnectionClosed(session, closeStatus);\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#afterConnectionClosed(session,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 70
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus status)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleBinaryMessage(session,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 59
    },
    "return": "void",
    "signature": "protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message)",
    "source_code": "\tprotected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleMessage(session,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 74
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> message)",
    "source_code": "\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {\n\t\tthis.delegate.handleMessage(session, message);\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handlePongMessage(session,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 62
    },
    "return": "void",
    "signature": "protected void handlePongMessage(WebSocketSession session, PongMessage message)",
    "source_code": "\tprotected void handlePongMessage(WebSocketSession session, PongMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleTextMessage(session,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 56
    },
    "return": "void",
    "signature": "protected void handleTextMessage(WebSocketSession session, TextMessage message)",
    "source_code": "\tprotected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n\t}"
  },
  "org.springframework.web.socket.handler.<unknown>#handleTransportError(session,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 79
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n\t\tthis.delegate.handleTransportError(session, exception);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#accept(webSocketSession,throwable)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "throwable"
    ],
    "position": {
      "column": 1,
      "line": 427
    },
    "return": "void",
    "signature": "public void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable)",
    "source_code": "\t\tpublic void accept(@Nullable WebSocketSession webSocketSession, @Nullable Throwable throwable) {\n\t\t\tif (throwable != null) {\n\t\t\t\tthis.stompSession.afterConnectFailure(throwable);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterConnectionClosed(session,closeStatus)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 463
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {\n\t\t\tthis.stompSession.afterConnectionClosed();\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterSessionEnded(session,closeStatus,outputChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "closeStatus",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 674
    },
    "return": "void",
    "signature": "public void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionEnded(WebSocketSession session, CloseStatus closeStatus, MessageChannel outputChannel) {\n\t\tthis.decoders.remove(session.getId());\n\n\t\tMessage<byte[]> message = createDisconnectMessage(session);\n\t\tSimpAttributes simpAttributes = SimpAttributes.fromMessage(message);\n\t\ttry {\n\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\tpublishEvent(this.eventPublisher, new SessionDisconnectEvent(this, message, session.getId(), closeStatus, user));\n\t\t\t}\n\t\t\toutputChannel.send(message);\n\t\t}\n\t\tfinally {\n\t\t\tif (this.orderedHandlingMessageChannels != null) {\n\t\t\t\tthis.orderedHandlingMessageChannels.remove(session.getId());\n\t\t\t}\n\t\t\tthis.stompAuthentications.remove(session.getId());\n\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\tsimpAttributes.sessionCompleted();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#afterSessionStarted(session,outputChannel)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "outputChannel"
    ],
    "position": {
      "column": 1,
      "line": 666
    },
    "return": "void",
    "signature": "public void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel)",
    "source_code": "\tpublic void afterSessionStarted(WebSocketSession session, MessageChannel outputChannel) {\n\t\tif (session.getTextMessageSizeLimit() < MINIMUM_WEBSOCKET_MESSAGE_SIZE) {\n\t\t\tsession.setTextMessageSizeLimit(MINIMUM_WEBSOCKET_MESSAGE_SIZE);\n\t\t}\n\t\tthis.decoders.put(session.getId(), new BufferingStompDecoder(this.stompDecoder, getMessageSizeLimit()));\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handler,uriVars)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Connect to the given WebSocket URL and notify the given\n\t * {@link org.springframework.messaging.simp.stomp.StompSessionHandler}\n\t * when connected on the STOMP level after the CONNECTED frame is received.\n\t * @param url the url to connect to\n\t * @param handler the session handler\n\t * @param uriVars the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handler",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 258
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, StompSessionHandler handler, Object... uriVars) {\n\t\treturn connectAsync(url, null, handler, uriVars);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,connectHeaders,handler,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also accepts\n\t * {@link WebSocketHttpHeaders} to use for the WebSocket handshake and\n\t * {@link StompHeaders} for the STOMP CONNECT frame.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "connectHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 334
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler handler, Object... uriVariables) {\n\n\t\tAssert.notNull(url, \"'url' must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(url).buildAndExpand(uriVariables).encode().toUri();\n\t\treturn connectAsync(uri, handshakeHeaders, connectHeaders, handler);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,connectHeaders,sessionHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, WebSocketHttpHeaders, StompSessionHandler, Object...)}\n\t * that accepts a fully prepared {@link java.net.URI}.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param connectHeaders headers for the STOMP CONNECT frame\n\t * @param sessionHandler the STOMP session handler\n\t * @return a CompletableFuture for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "connectHeaders",
      "sessionHandler"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(URI url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\t@Nullable StompHeaders connectHeaders, StompSessionHandler sessionHandler) {\n\n\t\tAssert.notNull(url, \"'url' must not be null\");\n\t\tConnectionHandlingStompSession session = createSession(connectHeaders, sessionHandler);\n\t\tWebSocketTcpConnectionHandlerAdapter adapter = new WebSocketTcpConnectionHandlerAdapter(session);\n\t\tgetWebSocketClient()\n\t\t\t\t.execute(new LoggingWebSocketHandlerDecorator(adapter), handshakeHeaders, url)\n\t\t\t\t.whenComplete(adapter);\n\t\treturn session.getSession();\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#connectAsync(url,handshakeHeaders,handler,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * An overloaded version of\n\t * {@link #connect(String, StompSessionHandler, Object...)} that also\n\t * accepts {@link WebSocketHttpHeaders} to use for the WebSocket handshake.\n\t * @param url the url to connect to\n\t * @param handshakeHeaders the headers for the WebSocket handshake\n\t * @param handler the session handler\n\t * @param uriVariables the URI variables to expand into the URL\n\t * @return a {@code ListenableFuture} for access to the session when ready for use\n\t * @since 6.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "handshakeHeaders",
      "handler",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "CompletableFuture<StompSession>",
    "signature": "public CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables)",
    "source_code": "\tpublic CompletableFuture<StompSession> connectAsync(String url, @Nullable WebSocketHttpHeaders handshakeHeaders,\n\t\t\tStompSessionHandler handler, Object... uriVariables) {\n\n\t\treturn connectAsync(url, handshakeHeaders, null, handler, uriVariables);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessage(session,webSocketMessage)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage"
    ],
    "position": {
      "column": 1,
      "line": 442
    },
    "return": "void",
    "signature": "public void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage)",
    "source_code": "\t\tpublic void handleMessage(WebSocketSession session, WebSocketMessage<?> webSocketMessage) {\n\t\t\tthis.lastReadTime = (this.lastReadTime != -1 ? System.currentTimeMillis() : -1);\n\t\t\tList<Message<byte[]>> messages;\n\t\t\ttry {\n\t\t\t\tmessages = this.codec.decode(webSocketMessage);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthis.stompSession.handleFailure(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (Message<byte[]> message : messages) {\n\t\t\t\tthis.stompSession.handleMessage(message);\n\t\t\t}\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageFromClient(session,webSocketMessage,targetChannel)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle incoming WebSocket messages from clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "webSocketMessage",
      "targetChannel"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel targetChannel)",
    "source_code": "\tpublic void handleMessageFromClient(WebSocketSession session,\n\t\t\tWebSocketMessage<?> webSocketMessage, MessageChannel targetChannel) {\n\n\t\tList<Message<byte[]>> messages;\n\t\ttry {\n\t\t\tByteBuffer byteBuffer;\n\t\t\tif (webSocketMessage instanceof TextMessage textMessage) {\n\t\t\t\tbyteBuffer = ByteBuffer.wrap(textMessage.asBytes());\n\t\t\t}\n\t\t\telse if (webSocketMessage instanceof BinaryMessage binaryMessage) {\n\t\t\t\tbyteBuffer = binaryMessage.getPayload();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBufferingStompDecoder decoder = this.decoders.get(session.getId());\n\t\t\tif (decoder == null) {\n\t\t\t\tif (!session.isOpen()) {\n\t\t\t\t\tlogger.trace(\"Dropped inbound WebSocket message due to closed session\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new IllegalStateException(\"No decoder for session id '\" + session.getId() + \"'\");\n\t\t\t}\n\n\t\t\tmessages = decoder.decode(byteBuffer);\n\t\t\tif (messages.isEmpty()) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Incomplete STOMP frame content received in session \" +\n\t\t\t\t\t\t\tsession + \", bufferSize=\" + decoder.getBufferSize() +\n\t\t\t\t\t\t\t\", bufferSizeLimit=\" + decoder.getBufferSizeLimit() + \".\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Failed to parse \" + webSocketMessage +\n\t\t\t\t\t\t\" in session \" + session.getId() + \". Sending STOMP ERROR to client.\", ex);\n\t\t\t}\n\t\t\thandleError(session, ex, null);\n\t\t\treturn;\n\t\t}\n\n\t\tMessageChannel channelToUse = targetChannel;\n\t\tif (this.orderedHandlingMessageChannels != null) {\n\t\t\tchannelToUse = this.orderedHandlingMessageChannels.computeIfAbsent(\n\t\t\t\t\tsession.getId(), id -> new OrderedMessageChannelDecorator(targetChannel, logger));\n\t\t}\n\n\t\tfor (Message<byte[]> message : messages) {\n\t\t\tStompHeaderAccessor headerAccessor =\n\t\t\t\t\tMessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\t\t\tAssert.state(headerAccessor != null, \"No StompHeaderAccessor\");\n\n\t\t\tStompCommand command = headerAccessor.getCommand();\n\t\t\tboolean isConnect = StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command);\n\n\t\t\tboolean sent = false;\n\t\t\ttry {\n\n\t\t\t\theaderAccessor.setSessionId(session.getId());\n\t\t\t\theaderAccessor.setSessionAttributes(session.getAttributes());\n\t\t\t\theaderAccessor.setUser(getUser(session));\n\t\t\t\tif (isConnect) {\n\t\t\t\t\theaderAccessor.setUserChangeCallback(user -> {\n\t\t\t\t\t\tif (user != null && user != session.getPrincipal()) {\n\t\t\t\t\t\t\tthis.stompAuthentications.put(session.getId(), user);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\theaderAccessor.setHeader(SimpMessageHeaderAccessor.HEART_BEAT_HEADER, headerAccessor.getHeartbeat());\n\t\t\t\tif (!detectImmutableMessageInterceptor(targetChannel)) {\n\t\t\t\t\theaderAccessor.setImmutable();\n\t\t\t\t}\n\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"From client: \" + headerAccessor.getShortLogMessage(message.getPayload()));\n\t\t\t\t}\n\n\t\t\t\tif (isConnect) {\n\t\t\t\t\tthis.stats.incrementConnectCount();\n\t\t\t\t}\n\t\t\t\telse if (StompCommand.DISCONNECT.equals(command)) {\n\t\t\t\t\tthis.stats.incrementDisconnectCount();\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n\t\t\t\t\tsent = channelToUse.send(message);\n\n\t\t\t\t\tif (sent) {\n\t\t\t\t\t\tif (this.eventPublisher != null) {\n\t\t\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\t\t\tif (isConnect) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.SUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionSubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (StompCommand.UNSUBSCRIBE.equals(command)) {\n\t\t\t\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionUnsubscribeEvent(this, message, user));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to send message to MessageChannel in session \" + session.getId(), ex);\n\t\t\t\t}\n\t\t\t\telse if (logger.isErrorEnabled()) {\n\t\t\t\t\t// Skip for unsent CONNECT or SUBSCRIBE (likely authentication/authorization issues)\n\t\t\t\t\tif (sent || !(isConnect || StompCommand.SUBSCRIBE.equals(command))) {\n\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" +\n\t\t\t\t\t\t\t\tsession.getId() + \":\" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thandleError(session, ex, message);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleMessageToClient(session,message)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle STOMP messages going back out to WebSocket clients.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 462
    },
    "return": "void",
    "signature": "public void handleMessageToClient(WebSocketSession session, Message<?> message)",
    "source_code": "\tpublic void handleMessageToClient(WebSocketSession session, Message<?> message) {\n\t\tif (!(message.getPayload() instanceof byte[] payload)) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Expected byte[] payload. Ignoring \" + message + \".\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStompHeaderAccessor accessor = getStompHeaderAccessor(message);\n\t\tStompCommand command = accessor.getCommand();\n\n\t\tif (StompCommand.MESSAGE.equals(command)) {\n\t\t\tif (accessor.getSubscriptionId() == null && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"No STOMP \\\"subscription\\\" header in \" + message);\n\t\t\t}\n\t\t\tString origDestination = accessor.getFirstNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\tif (origDestination != null) {\n\t\t\t\taccessor = toMutableAccessor(accessor, message);\n\t\t\t\taccessor.removeNativeHeader(SimpMessageHeaderAccessor.ORIGINAL_DESTINATION);\n\t\t\t\taccessor.setDestination(origDestination);\n\t\t\t}\n\t\t}\n\t\telse if (StompCommand.CONNECTED.equals(command)) {\n\t\t\tthis.stats.incrementConnectedCount();\n\t\t\taccessor = afterStompSessionConnected(message, accessor, session);\n\t\t\tif (this.eventPublisher != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSimpAttributes simpAttributes = new SimpAttributes(session.getId(), session.getAttributes());\n\t\t\t\t\tSimpAttributesContextHolder.setAttributes(simpAttributes);\n\t\t\t\t\tPrincipal user = getUser(session);\n\t\t\t\t\tpublishEvent(this.eventPublisher, new SessionConnectedEvent(this, (Message<byte[]>) message, user));\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tSimpAttributesContextHolder.resetAttributes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (StompCommand.ERROR.equals(command) && getErrorHandler() != null) {\n\t\t\tMessage<byte[]> errorMessage = getErrorHandler().handleErrorMessageToClient(\n\t\t\t\t\tMessageBuilder.createMessage(payload, accessor.getMessageHeaders()));\n\t\t\tif (errorMessage != null) {\n\t\t\t\taccessor = MessageHeaderAccessor.getAccessor(errorMessage, StompHeaderAccessor.class);\n\t\t\t\tAssert.state(accessor != null, \"No StompHeaderAccessor\");\n\t\t\t\tpayload = errorMessage.getPayload();\n\t\t\t}\n\t\t}\n\n\t\tRunnable task = OrderedMessageChannelDecorator.getNextMessageTask(message);\n\t\tif (task != null) {\n\t\t\tAssert.isInstanceOf(ConcurrentWebSocketSessionDecorator.class, session);\n\t\t\t((ConcurrentWebSocketSessionDecorator) session).setMessageCallback(m -> task.run());\n\t\t}\n\n\t\tsendToClient(session, accessor, payload);\n\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#handleTransportError(session,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "session",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 458
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession session, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession session, Throwable ex) {\n\t\t\tthis.stompSession.handleFailure(ex);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#onReadInactivity(runnable,duration)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 508
    },
    "return": "void",
    "signature": "public void onReadInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onReadInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastReadTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.readInactivityFuture = getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastReadTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"ReadInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#onWriteInactivity(runnable,duration)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "runnable",
      "duration"
    ],
    "position": {
      "column": 1,
      "line": 527
    },
    "return": "void",
    "signature": "public void onWriteInactivity(final Runnable runnable, final long duration)",
    "source_code": "\t\tpublic void onWriteInactivity(final Runnable runnable, final long duration) {\n\t\t\tAssert.state(getTaskScheduler() != null, \"No TaskScheduler configured\");\n\t\t\tthis.lastWriteTime = System.currentTimeMillis();\n\t\t\tDuration delay = Duration.ofMillis(duration / 2);\n\t\t\tthis.writeInactivityFuture = getTaskScheduler().scheduleWithFixedDelay(() -> {\n\t\t\t\tif (System.currentTimeMillis() - this.lastWriteTime > duration) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"WriteInactivityTask failure\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, delay);\n\t\t}"
  },
  "org.springframework.web.socket.messaging.<unknown>#toMutableAccessor(headerAccessor,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "headerAccessor",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 635
    },
    "return": "StompHeaderAccessor",
    "signature": "protected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message)",
    "source_code": "\tprotected StompHeaderAccessor toMutableAccessor(StompHeaderAccessor headerAccessor, Message<?> message) {\n\t\treturn (headerAccessor.isMutable() ? headerAccessor : StompHeaderAccessor.wrap(message));\n\t}"
  },
  "org.springframework.web.socket.server.standard.<unknown>#handleSuccess(request,response,upgradeInfo,upgradeResponse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "upgradeInfo",
      "upgradeResponse"
    ],
    "position": {
      "column": 1,
      "line": 60
    },
    "return": "void",
    "signature": "protected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse)",
    "source_code": "\tprotected void handleSuccess(HttpServletRequest request, HttpServletResponse response,\n\t\t\tUpgradeInfo upgradeInfo, TyrusUpgradeResponse upgradeResponse) throws IOException, ServletException {\n\n\t\tresponse.setStatus(upgradeResponse.getStatus());\n\t\tupgradeResponse.getHeaders().forEach((key, value) -> response.addHeader(key, Utils.getHeaderFromList(value)));\n\n\t\tAsyncContext asyncContext = request.startAsync();\n\t\tasyncContext.setTimeout(-1L);\n\n\t\tObject nativeRequest = getNativeRequest(request);\n\t\tBeanWrapper beanWrapper = new BeanWrapperImpl(nativeRequest);\n\t\tObject httpSocket = beanWrapper.getPropertyValue(\"connection.connectionHandler.rawConnection\");\n\t\tObject webSocket = webSocketHelper.newInstance(request, httpSocket);\n\t\twebSocketHelper.upgrade(webSocket, httpSocket, request.getServletContext());\n\n\t\tresponse.flushBuffer();\n\n\t\tboolean isProtected = request.getUserPrincipal() != null;\n\t\tWriter servletWriter = servletWriterHelper.newInstance(webSocket, isProtected);\n\t\tConnection connection = upgradeInfo.createConnection(servletWriter, noOpCloseListener);\n\t\tnew BeanWrapperImpl(webSocket).setPropertyValue(\"connection\", connection);\n\t\tnew BeanWrapperImpl(servletWriter).setPropertyValue(\"connection\", connection);\n\t\twebSocketHelper.registerForReadEvent(webSocket);\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#afterHandshake(request,response,wsHandler,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 174
    },
    "return": "void",
    "signature": "public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex)",
    "source_code": "\tpublic void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, @Nullable Exception ex) {\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#beforeHandshake(request,response,wsHandler,Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 146
    },
    "return": "boolean",
    "signature": "public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tpublic boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {\n\n\t\tHttpSession session = getSession(request);\n\t\tif (session != null) {\n\t\t\tif (isCopyHttpSessionId()) {\n\t\t\t\tattributes.put(HTTP_SESSION_ID_ATTR_NAME, session.getId());\n\t\t\t}\n\t\t\tEnumeration<String> names = session.getAttributeNames();\n\t\t\twhile (names.hasMoreElements()) {\n\t\t\t\tString name = names.nextElement();\n\t\t\t\tif (isCopyAllAttributes() || getAttributeNames().contains(name)) {\n\t\t\t\t\tattributes.put(name, session.getAttribute(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#determineUser(request,wsHandler,Map<String,attributes)": {
    "deprecated": false,
    "doc": "\t/**\n\t * A method that can be used to associate a user with the WebSocket session\n\t * in the process of being established. The default implementation calls\n\t * {@link ServerHttpRequest#getPrincipal()}\n\t * <p>Subclasses can provide custom logic for associating a user with a session,\n\t * for example for assigning a name to anonymous users (i.e. not fully authenticated).\n\t * @param request the handshake request\n\t * @param wsHandler the WebSocket handler that will handle messages\n\t * @param attributes handshake attributes to pass to the WebSocket session\n\t * @return the user for the WebSocket session, or {@code null} if not available\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 391
    },
    "return": "Principal",
    "signature": "protected Principal determineUser(ServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tprotected Principal determineUser(\n\t\t\tServerHttpRequest request, WebSocketHandler wsHandler, Map<String, Object> attributes) {\n\n\t\treturn request.getPrincipal();\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#doHandshake(request,response,wsHandler,Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 205
    },
    "return": "boolean",
    "signature": "public boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes)",
    "source_code": "\tpublic final boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, Map<String, Object> attributes) throws HandshakeFailureException {\n\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHeaders());\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Processing request \" + request.getURI() + \" with headers=\" + headers);\n\t\t}\n\t\ttry {\n\t\t\tif (HttpMethod.GET != request.getMethod()) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\t\t\tresponse.getHeaders().setAllow(Collections.singleton(HttpMethod.GET));\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Handshake failed due to unexpected HTTP method: \" + request.getMethod());\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!\"WebSocket\".equalsIgnoreCase(headers.getUpgrade())) {\n\t\t\t\thandleInvalidUpgradeHeader(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!headers.getConnection().contains(\"Upgrade\") && !headers.getConnection().contains(\"upgrade\")) {\n\t\t\t\thandleInvalidConnectHeader(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isWebSocketVersionSupported(headers)) {\n\t\t\t\thandleWebSocketVersionNotSupported(request, response);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isValidOrigin(request)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tString wsKey = headers.getSecWebSocketKey();\n\t\t\tif (wsKey == null) {\n\t\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\t\tlogger.error(\"Missing \\\"Sec-WebSocket-Key\\\" header\");\n\t\t\t\t}\n\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HandshakeFailureException(\n\t\t\t\t\t\"Response update failed during upgrade to WebSocket: \" + request.getURI(), ex);\n\t\t}\n\n\t\tString subProtocol = selectProtocol(headers.getSecWebSocketProtocol(), wsHandler);\n\t\tList<WebSocketExtension> requested = headers.getSecWebSocketExtensions();\n\t\tList<WebSocketExtension> supported = this.requestUpgradeStrategy.getSupportedExtensions(request);\n\t\tList<WebSocketExtension> extensions = filterRequestedExtensions(request, requested, supported);\n\t\tPrincipal user = determineUser(request, wsHandler, attributes);\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Upgrading to WebSocket, subProtocol=\" + subProtocol + \", extensions=\" + extensions);\n\t\t}\n\t\tthis.requestUpgradeStrategy.upgrade(request, response, subProtocol, extensions, user, wsHandler, attributes);\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#filterRequestedExtensions(request,requestedExtensions,supportedExtensions)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Filter the list of requested WebSocket extensions.\n\t * <p>As of 4.1, the default implementation of this method filters the list to\n\t * leave only extensions that are both requested and supported.\n\t * @param request the current request\n\t * @param requestedExtensions the list of extensions requested by the client\n\t * @param supportedExtensions the list of extensions supported by the server\n\t * @return the selected extensions or an empty list\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "requestedExtensions",
      "supportedExtensions"
    ],
    "position": {
      "column": 1,
      "line": 367
    },
    "return": "List<WebSocketExtension>",
    "signature": "protected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions)",
    "source_code": "\tprotected List<WebSocketExtension> filterRequestedExtensions(ServerHttpRequest request,\n\t\t\tList<WebSocketExtension> requestedExtensions, List<WebSocketExtension> supportedExtensions) {\n\n\t\tList<WebSocketExtension> result = new ArrayList<>(requestedExtensions.size());\n\t\tfor (WebSocketExtension extension : requestedExtensions) {\n\t\t\tif (supportedExtensions.contains(extension)) {\n\t\t\t\tresult.add(extension);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleInvalidConnectHeader(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 273
    },
    "return": "void",
    "signature": "protected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidConnectHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Connection header\" + request.getHeaders().getConnection(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"\\\"Connection\\\" must be \\\"upgrade\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleInvalidUpgradeHeader(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 264
    },
    "return": "void",
    "signature": "protected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleInvalidUpgradeHeader(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to invalid Upgrade header: \" + request.getHeaders().getUpgrade(), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\tresponse.getBody().write(\"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\".getBytes(StandardCharsets.UTF_8));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleRequest(servletRequest,servletResponse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 160
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, this.wsHandler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(servletRequest.getMethod() + \" \" + servletRequest.getRequestURI());\n\t\t\t}\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handshakeHandler.doHandshake(request, response, this.wsHandler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\n\t\t\t\t\t\"Uncaught failure for request \" + request.getURI() + \" - \" + ex.getMessage(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tresponse.close();\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#handleWebSocketVersionNotSupported(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 297
    },
    "return": "void",
    "signature": "protected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\tprotected void handleWebSocketVersionNotSupported(ServerHttpRequest request, ServerHttpResponse response) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tString version = request.getHeaders().getFirst(\"Sec-WebSocket-Version\");\n\t\t\tlogger.error(LogFormatUtils.formatValue(\n\t\t\t\t\t\"Handshake failed due to unsupported WebSocket version: \" + version +\n\t\t\t\t\t\t\t\". Supported versions: \" + Arrays.toString(getSupportedVersions()), -1, true));\n\t\t}\n\t\tresponse.setStatusCode(HttpStatus.UPGRADE_REQUIRED);\n\t\tresponse.getHeaders().set(WebSocketHttpHeaders.SEC_WEBSOCKET_VERSION,\n\t\t\t\tStringUtils.arrayToCommaDelimitedString(getSupportedVersions()));\n\t}"
  },
  "org.springframework.web.socket.server.support.<unknown>#selectProtocol(requestedProtocols,webSocketHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Perform the sub-protocol negotiation based on requested and supported sub-protocols.\n\t * For the list of supported sub-protocols, this method first checks if the target\n\t * WebSocketHandler is a {@link SubProtocolCapable} and then also checks if any\n\t * sub-protocols have been explicitly configured with\n\t * {@link #setSupportedProtocols(String...)}.\n\t * @param requestedProtocols the requested sub-protocols\n\t * @param webSocketHandler the WebSocketHandler that will be used\n\t * @return the selected protocols or {@code null}\n\t * @see #determineHandlerSupportedProtocols(WebSocketHandler)\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "requestedProtocols",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 330
    },
    "return": "String",
    "signature": "protected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected String selectProtocol(List<String> requestedProtocols, WebSocketHandler webSocketHandler) {\n\t\tList<String> handlerProtocols = determineHandlerSupportedProtocols(webSocketHandler);\n\t\tfor (String protocol : requestedProtocols) {\n\t\t\tif (handlerProtocols.contains(protocol.toLowerCase(Locale.ROOT))) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t\tif (this.supportedProtocols.contains(protocol.toLowerCase(Locale.ROOT))) {\n\t\t\t\treturn protocol;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#afterConnectionClosed(webSocketSession,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 164
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status)",
    "source_code": "\t\tpublic void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus status) throws Exception {\n\t\t\tthis.sockJsSession.afterTransportClosed(status);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#connectAsync(request,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 75
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,\n\t\t\tWebSocketHandler handler)",
    "source_code": "\tpublic CompletableFuture<WebSocketSession> connectAsync(TransportRequest request,\n\t\t\tWebSocketHandler handler) {\n\t\tCompletableFuture<WebSocketSession> future = new CompletableFuture<>();\n\t\tWebSocketClientSockJsSession session = new WebSocketClientSockJsSession(request, handler, future);\n\t\thandler = new ClientSockJsWebSocketHandler(session);\n\t\trequest.addTimeoutTask(session.getTimeoutTask());\n\n\t\tURI url = request.getTransportUrl();\n\t\tWebSocketHttpHeaders headers = new WebSocketHttpHeaders(request.getHandshakeHeaders());\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Starting WebSocket session on \" + url);\n\t\t}\n\t\tthis.webSocketClient.execute(handler, headers, url).whenComplete((webSocketSession, throwable) -> {\n\t\t\tif (throwable != null) {\n\t\t\t\tfuture.completeExceptionally(throwable);\n\t\t\t}\n\t\t});\n\t\treturn future;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#connectInternal(transportRequest,handler,receiveUrl,handshakeHeaders,session,connectFuture)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "transportRequest",
      "handler",
      "receiveUrl",
      "handshakeHeaders",
      "session",
      "connectFuture"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "void",
    "signature": "protected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,\n\t\t\tfinal URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,\n\t\t\tfinal CompletableFuture<WebSocketSession> connectFuture)",
    "source_code": "\tprotected void connectInternal(final TransportRequest transportRequest, final WebSocketHandler handler,\n\t\t\tfinal URI receiveUrl, final HttpHeaders handshakeHeaders, final XhrClientSockJsSession session,\n\t\t\tfinal CompletableFuture<WebSocketSession> connectFuture) {\n\n\t\tgetTaskExecutor().execute(() -> {\n\t\t\tHttpHeaders httpHeaders = transportRequest.getHttpRequestHeaders();\n\t\t\tXhrRequestCallback requestCallback = new XhrRequestCallback(handshakeHeaders);\n\t\t\tXhrRequestCallback requestCallbackAfterHandshake = new XhrRequestCallback(httpHeaders);\n\t\t\tXhrReceiveExtractor responseExtractor = new XhrReceiveExtractor(session);\n\t\t\twhile (true) {\n\t\t\t\tif (session.isDisconnected()) {\n\t\t\t\t\tsession.afterTransportClosed(null);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Starting XHR receive request, url=\" + receiveUrl);\n\t\t\t\t\t}\n\t\t\t\t\tgetRestTemplate().execute(receiveUrl, HttpMethod.POST, requestCallback, responseExtractor);\n\t\t\t\t\trequestCallback = requestCallbackAfterHandshake;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (!connectFuture.isDone()) {\n\t\t\t\t\t\tconnectFuture.completeExceptionally(ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsession.handleTransportError(ex);\n\t\t\t\t\t\tsession.afterTransportClosed(new CloseStatus(1006, ex.getMessage()));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#execute(handler,headers,url)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "headers",
      "url"
    ],
    "position": {
      "column": 1,
      "line": 233
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> execute(WebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url)",
    "source_code": "\tpublic final CompletableFuture<WebSocketSession> execute(\n\t\t\tWebSocketHandler handler, @Nullable WebSocketHttpHeaders headers, URI url) {\n\n\t\tAssert.notNull(handler, \"WebSocketHandler is required\");\n\t\tAssert.notNull(url, \"URL is required\");\n\n\t\tString scheme = url.getScheme();\n\t\tif (!supportedProtocols.contains(scheme)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scheme: '\" + scheme + \"'\");\n\t\t}\n\n\t\tCompletableFuture<WebSocketSession> connectFuture = new CompletableFuture<>();\n\t\ttry {\n\t\t\tSockJsUrlInfo sockJsUrlInfo = buildSockJsUrlInfo(url);\n\t\t\tServerInfo serverInfo = getServerInfo(sockJsUrlInfo, getHttpRequestHeaders(headers));\n\t\t\tcreateRequest(sockJsUrlInfo, headers, serverInfo).connect(handler, connectFuture);\n\t\t}\n\t\tcatch (Exception exception) {\n\t\t\tif (logger.isErrorEnabled()) {\n\t\t\t\tlogger.error(\"Initial SockJS \\\"Info\\\" request to server failed, url=\" + url, exception);\n\t\t\t}\n\t\t\tconnectFuture.completeExceptionally(exception);\n\t\t}\n\t\treturn connectFuture;\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#execute(handler,uriTemplate,uriVars)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "handler",
      "uriTemplate",
      "uriVars"
    ],
    "position": {
      "column": 1,
      "line": 224
    },
    "return": "CompletableFuture<WebSocketSession>",
    "signature": "public CompletableFuture<WebSocketSession> execute(WebSocketHandler handler, String uriTemplate, Object... uriVars)",
    "source_code": "\tpublic CompletableFuture<WebSocketSession> execute(\n\t\t\tWebSocketHandler handler, String uriTemplate, Object... uriVars) {\n\n\t\tAssert.notNull(uriTemplate, \"uriTemplate must not be null\");\n\t\tURI uri = UriComponentsBuilder.fromUriString(uriTemplate).buildAndExpand(uriVars).encode().toUri();\n\t\treturn execute(handler, null, uri);\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#executeInfoRequestInternal(infoUrl,headers)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "infoUrl",
      "headers"
    ],
    "position": {
      "column": 1,
      "line": 136
    },
    "return": "ResponseEntity<String>",
    "signature": "protected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers)",
    "source_code": "\tprotected ResponseEntity<String> executeInfoRequestInternal(URI infoUrl, HttpHeaders headers) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers);\n\t\treturn nonNull(this.restTemplate.execute(infoUrl, HttpMethod.GET, requestCallback, textResponseExtractor));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#executeSendRequestInternal(url,headers,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "url",
      "headers",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 142
    },
    "return": "ResponseEntity<String>",
    "signature": "public ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message)",
    "source_code": "\tpublic ResponseEntity<String> executeSendRequestInternal(URI url, HttpHeaders headers, TextMessage message) {\n\t\tRequestCallback requestCallback = new XhrRequestCallback(headers, message.getPayload());\n\t\treturn nonNull(this.restTemplate.execute(url, HttpMethod.POST, requestCallback, textResponseExtractor));\n\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTextMessage(webSocketSession,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession webSocketSession, TextMessage message)",
    "source_code": "\t\tpublic void handleTextMessage(WebSocketSession webSocketSession, TextMessage message) throws Exception {\n\t\t\tthis.sockJsSession.handleFrame(message.getPayload());\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.client.<unknown>#handleTransportError(webSocketSession,ex)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "ex"
    ],
    "position": {
      "column": 1,
      "line": 159
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable ex)",
    "source_code": "\t\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable ex) throws Exception {\n\t\t\tthis.sockJsSession.handleTransportError(ex);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.frame.<unknown>#closeFrame(code,reason)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "code",
      "reason"
    ],
    "position": {
      "column": 1,
      "line": 167
    },
    "return": "SockJsFrame",
    "signature": "public SockJsFrame closeFrame(int code, @Nullable String reason)",
    "source_code": "\tpublic static SockJsFrame closeFrame(int code, @Nullable String reason) {\n\t\treturn new SockJsFrame(\"c[\" + code + \",\\\"\" + (reason != null ? reason : \"\") + \"\\\"]\");\n\t}"
  },
  "org.springframework.web.socket.sockjs.frame.<unknown>#messageFrame(codec,messages)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "codec",
      "messages"
    ],
    "position": {
      "column": 1,
      "line": 154
    },
    "return": "SockJsFrame",
    "signature": "public SockJsFrame messageFrame(SockJsMessageCodec codec, String... messages)",
    "source_code": "\tpublic static SockJsFrame messageFrame(SockJsMessageCodec codec, String... messages) {\n\t\tString encoded = codec.encode(messages);\n\t\treturn new SockJsFrame(encoded);\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#checkOrigin(request,response,httpMethods)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 526
    },
    "return": "boolean",
    "signature": "protected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)\n\t\t\tthrows IOException {\n\n\t\tif (WebUtils.isSameOrigin(request)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.corsConfiguration.checkOrigin(request.getHeaders().getOrigin()) == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Origin header value '\" + request.getHeaders().getOrigin() + \"' not allowed.\");\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.FORBIDDEN);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handle(request,response)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response"
    ],
    "position": {
      "column": 1,
      "line": 640
    },
    "return": "void",
    "signature": "public void handle(ServerHttpRequest request, ServerHttpResponse response)",
    "source_code": "\t\tpublic void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {\n\t\t\tif (request.getMethod() != HttpMethod.GET) {\n\t\t\t\tsendMethodNotAllowed(response, HttpMethod.GET);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());\n\t\t\tbyte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\t\t\tStringBuilder builder = new StringBuilder(\"\\\"0\");\n\t\t\tDigestUtils.appendMd5DigestAsHex(contentBytes, builder);\n\t\t\tbuilder.append('\"');\n\t\t\tString etagValue = builder.toString();\n\n\t\t\tList<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();\n\t\t\tif (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {\n\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_MODIFIED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"html\", StandardCharsets.UTF_8));\n\t\t\tresponse.getHeaders().setContentLength(contentBytes.length);\n\n\t\t\t// No cache in order to check every time if IFrame are authorized\n\t\t\taddNoCacheHeaders(response);\n\t\t\tresponse.getHeaders().setETag(etagValue);\n\t\t\tresponse.getBody().write(contentBytes);\n\t\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRawWebSocketRequest(request,response,webSocketHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler"
    ],
    "position": {
      "column": 1,
      "line": 572
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler)",
    "source_code": "\tprotected abstract void handleRawWebSocketRequest(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, WebSocketHandler webSocketHandler) throws IOException;\n\n\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */\n\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRequest(request,response,sockJsPath,wsHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * This method determines the SockJS path and handles SockJS static URLs.\n\t * Session URLs and raw WebSocket requests are delegated to abstract methods.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsPath",
      "wsHandler"
    ],
    "position": {
      "column": 1,
      "line": 379
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler)",
    "source_code": "\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\t@Nullable String sockJsPath, WebSocketHandler wsHandler) throws SockJsException {\n\n\t\tif (sockJsPath == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\n\t\t\t\t\t\t\"Expected SockJS path. Failing request: \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trequest.getHeaders();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\t// As per SockJS protocol content-type can be ignored (it's always json)\n\t\t}\n\n\t\tString requestInfo = (logger.isDebugEnabled() ? request.getMethod() + \" \" + request.getURI() : null);\n\n\t\ttry {\n\t\t\tif (sockJsPath.isEmpty() || sockJsPath.equals(\"/\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tif (\"websocket\".equalsIgnoreCase(request.getHeaders().getUpgrade())) {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", StandardCharsets.UTF_8));\n\t\t\t\tresponse.getBody().write(\"Welcome to SockJS!\\n\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/info\")) {\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.infoHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.matches(\"/iframe[0-9-.a-z_]*.html\")) {\n\t\t\t\tif (!CollectionUtils.isEmpty(getAllowedOrigins()) && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t\t\t!CollectionUtils.isEmpty(getAllowedOriginPatterns())) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Iframe support is disabled when an origin check is required. \" +\n\t\t\t\t\t\t\t\t\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (CollectionUtils.isEmpty(getAllowedOrigins())) {\n\t\t\t\t\tresponse.getHeaders().add(XFRAME_OPTIONS_HEADER, \"SAMEORIGIN\");\n\t\t\t\t}\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\tthis.iframeHandler.handle(request, response);\n\t\t\t}\n\n\t\t\telse if (sockJsPath.equals(\"/websocket\")) {\n\t\t\t\tif (isWebSocketEnabled()) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\thandleRawWebSocketRequest(request, response, wsHandler);\n\t\t\t\t}\n\t\t\t\telse if (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tString[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");\n\t\t\t\tif (pathSegments.length != 3) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Invalid SockJS path '\" + sockJsPath + \"' - \" +\n\t\t\t\t\t\t\t\t\"required to have 3 path segments\", -1, true));\n\t\t\t\t\t}\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tString serverId = pathSegments[0];\n\t\t\t\tString sessionId = pathSegments[1];\n\t\t\t\tString transport = pathSegments[2];\n\n\t\t\t\tif (!isWebSocketEnabled() && transport.equals(\"websocket\")) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if (!validateRequest(serverId, sessionId, transport) || !validatePath(request)) {\n\t\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring transport request: \" + requestInfo);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (requestInfo != null) {\n\t\t\t\t\tlogger.debug(\"Processing transport request: \" + requestInfo);\n\t\t\t\t}\n\t\t\t\thandleTransportRequest(request, response, wsHandler, sessionId, transport);\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to write to the response\", null, ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleRequest(servletRequest,servletResponse)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletRequest",
      "servletResponse"
    ],
    "position": {
      "column": 1,
      "line": 127
    },
    "return": "void",
    "signature": "public void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)",
    "source_code": "\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\ttry {\n\t\t\tthis.sockJsService.handleRequest(request, response, getSockJsPath(servletRequest), this.webSocketHandler);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new SockJsException(\"Uncaught failure in SockJS request, uri=\" + request.getURI(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#handleTransportRequest(request,response,webSocketHandler,sessionId,transport)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle a SockJS session URL (i.e. transport-specific request).\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "webSocketHandler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 578
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport)",
    "source_code": "\tprotected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;\n\n\n\tprivate interface SockJsRequestHandler {\n\n\t\tvoid handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#sendMethodNotAllowed(response,httpMethods)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "response",
      "httpMethods"
    ],
    "position": {
      "column": 1,
      "line": 562
    },
    "return": "void",
    "signature": "protected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods)",
    "source_code": "\tprotected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods) {\n\t\tlogger.warn(\"Sending Method Not Allowed (405)\");\n\t\tresponse.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);\n\t\tresponse.getHeaders().setAllow(new LinkedHashSet<>(Arrays.asList(httpMethods)));\n\t}"
  },
  "org.springframework.web.socket.sockjs.support.<unknown>#validateRequest(serverId,sessionId,transport)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 496
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!StringUtils.hasText(serverId) || !StringUtils.hasText(sessionId) || !StringUtils.hasText(transport)) {\n\t\t\tlogger.warn(\"No server, session, or transport path segment in SockJS request.\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// Server and session id's must not contain \".\"\n\t\tif (serverId.contains(\".\") || sessionId.contains(\".\")) {\n\t\t\tlogger.warn(\"Either server or session contains a \\\".\\\" which is not allowed by SockJS protocol.\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#handleRawWebSocketRequest(request,response,handler)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler"
    ],
    "position": {
      "column": 1,
      "line": 198
    },
    "return": "void",
    "signature": "protected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler)",
    "source_code": "\tprotected void handleRawWebSocketRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler) throws IOException {\n\n\t\tTransportHandler transportHandler = this.handlers.get(TransportType.WEBSOCKET);\n\t\tif (!(transportHandler instanceof HandshakeHandler handshakeHandler)) {\n\t\t\tlogger.error(\"No handler configured for raw WebSocket messages\");\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler);\n\t\tHandshakeFailureException failure = null;\n\n\t\ttry {\n\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thandshakeHandler.doHandshake(request, response, handler, attributes);\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (HandshakeFailureException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new HandshakeFailureException(\"Uncaught failure for request \" + request.getURI(), ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#handleTransportRequest(request,response,handler,sessionId,transport)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 234
    },
    "return": "void",
    "signature": "protected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, String sessionId, String transport)",
    "source_code": "\tprotected void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, String sessionId, String transport) throws SockJsException {\n\n\t\tTransportType transportType = TransportType.fromValue(transport);\n\t\tif (transportType == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"Unknown transport type for \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tTransportHandler transportHandler = this.handlers.get(transportType);\n\t\tif (transportHandler == null) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(LogFormatUtils.formatValue(\"No TransportHandler for \" + request.getURI(), -1, true));\n\t\t\t}\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tSockJsException failure = null;\n\t\tHandshakeInterceptorChain chain = new HandshakeInterceptorChain(this.interceptors, handler);\n\n\t\ttry {\n\t\t\tHttpMethod supportedMethod = transportType.getHttpMethod();\n\t\t\tif (supportedMethod != request.getMethod()) {\n\t\t\t\tif (request.getMethod() == HttpMethod.OPTIONS && transportType.supportsCors()) {\n\t\t\t\t\tif (checkOrigin(request, response, HttpMethod.OPTIONS, supportedMethod)) {\n\t\t\t\t\t\tresponse.setStatusCode(HttpStatus.NO_CONTENT);\n\t\t\t\t\t\taddCacheHeaders(response);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (transportType.supportsCors()) {\n\t\t\t\t\tsendMethodNotAllowed(response, supportedMethod, HttpMethod.OPTIONS);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsendMethodNotAllowed(response, supportedMethod);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSockJsSession session = this.sessions.get(sessionId);\n\t\t\tboolean isNewSession = false;\n\t\t\tif (session == null) {\n\t\t\t\tif (transportHandler instanceof SockJsSessionFactory sessionFactory) {\n\t\t\t\t\tMap<String, Object> attributes = new HashMap<>();\n\t\t\t\t\tif (!chain.applyBeforeHandshake(request, response, attributes)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsession = createSockJsSession(sessionId, sessionFactory, handler, attributes);\n\t\t\t\t\tisNewSession = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Session not found, sessionId=\" + sessionId +\n\t\t\t\t\t\t\t\t\". The session may have been closed \" +\n\t\t\t\t\t\t\t\t\"(for example, missed heart-beat) while a message was coming in.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrincipal principal = session.getPrincipal();\n\t\t\t\tif (principal != null && !principal.equals(request.getPrincipal())) {\n\t\t\t\t\tlogger.debug(\"The user for the session does not match the user for the request.\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!transportHandler.checkSessionType(session)) {\n\t\t\t\t\tlogger.debug(\"Session type does not match the transport type for the request.\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (transportType.sendsNoCacheInstruction()) {\n\t\t\t\taddNoCacheHeaders(response);\n\t\t\t}\n\t\t\tif (transportType.supportsCors() && !checkOrigin(request, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttransportHandler.handleRequest(request, response, handler, session);\n\n\t\t\tif (isNewSession && response instanceof ServletServerHttpResponse servletResponse) {\n\t\t\t\tint status = servletResponse.getServletResponse().getStatus();\n\t\t\t\tif (HttpStatusCode.valueOf(status).is4xxClientError()) {\n\t\t\t\t\tthis.sessions.remove(sessionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchain.applyAfterHandshake(request, response, null);\n\t\t}\n\t\tcatch (SockJsException ex) {\n\t\t\tfailure = ex;\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tfailure = new SockJsException(\"Uncaught failure for request \" + request.getURI(), sessionId, ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (failure != null) {\n\t\t\t\tchain.applyAfterHandshake(request, response, failure);\n\t\t\t\tthrow failure;\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.<unknown>#validateRequest(serverId,sessionId,transport)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "serverId",
      "sessionId",
      "transport"
    ],
    "position": {
      "column": 1,
      "line": 344
    },
    "return": "boolean",
    "signature": "protected boolean validateRequest(String serverId, String sessionId, String transport)",
    "source_code": "\tprotected boolean validateRequest(String serverId, String sessionId, String transport) {\n\t\tif (!super.validateRequest(serverId, sessionId, transport)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!CollectionUtils.isEmpty(getAllowedOrigins()) && !getAllowedOrigins().contains(\"*\") ||\n\t\t\t\t!CollectionUtils.isEmpty(getAllowedOriginPatterns())) {\n\t\t\tTransportType transportType = TransportType.fromValue(transport);\n\t\t\tif (transportType == null || !transportType.supportsOrigin()) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Origin check enabled but transport '\" + transport + \"' does not support it.\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#afterConnectionClosed(wsSession,status)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession",
      "status"
    ],
    "position": {
      "column": 1,
      "line": 97
    },
    "return": "void",
    "signature": "public void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status)",
    "source_code": "\tpublic void afterConnectionClosed(WebSocketSession wsSession, CloseStatus status) throws Exception {\n\t\tthis.sockJsSession.delegateConnectionClosed(status);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#createSession(id,handler,Map<String,attrs)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "id",
      "handler",
      "Map<String",
      "attrs"
    ],
    "position": {
      "column": 1,
      "line": 114
    },
    "return": "AbstractSockJsSession",
    "signature": "public AbstractSockJsSession createSession(String id, WebSocketHandler handler, Map<String, Object> attrs)",
    "source_code": "\tpublic AbstractSockJsSession createSession(String id, WebSocketHandler handler, Map<String, Object> attrs) {\n\t\treturn new WebSocketServerSockJsSession(id, getServiceConfig(), handler, attrs);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#createSession(sessionId,handler,Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "sessionId",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 100
    },
    "return": "StreamingSockJsSession",
    "signature": "public StreamingSockJsSession createSession(String sessionId, WebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic StreamingSockJsSession createSession(\n\t\t\tString sessionId, WebSocketHandler handler, Map<String, Object> attributes) {\n\n\t\treturn new HtmlFileStreamingSockJsSession(sessionId, getServiceConfig(), handler, attributes);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#doHandshake(request,response,handler,Map<String,attributes)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "handler",
      "Map<String",
      "attributes"
    ],
    "position": {
      "column": 1,
      "line": 134
    },
    "return": "boolean",
    "signature": "public boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes)",
    "source_code": "\tpublic boolean doHandshake(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler handler, Map<String, Object> attributes) throws HandshakeFailureException {\n\n\t\treturn this.handshakeHandler.doHandshake(request, response, handler, attributes);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequest(request,response,wsHandler,wsSession)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "wsHandler",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "void",
    "signature": "public void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession)",
    "source_code": "\tpublic void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler, SockJsSession wsSession) throws SockJsException {\n\n\t\tWebSocketServerSockJsSession sockJsSession = (WebSocketServerSockJsSession) wsSession;\n\t\ttry {\n\t\t\twsHandler = new SockJsWebSocketHandler(getServiceConfig(), wsHandler, sockJsSession);\n\t\t\tthis.handshakeHandler.doHandshake(request, response, wsHandler, sockJsSession.getAttributes());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\tthrow new SockJsTransportFailureException(\"WebSocket handshake failure\", wsSession.getId(), ex);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleRequestInternal(request,response,sockJsSession)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "sockJsSession"
    ],
    "position": {
      "column": 1,
      "line": 107
    },
    "return": "void",
    "signature": "public void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession)",
    "source_code": "\tpublic void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tAbstractHttpSockJsSession sockJsSession) throws SockJsException {\n\n\t\tString callback = getCallbackParam(request);\n\t\tif (!StringUtils.hasText(callback)) {\n\t\t\tresponse.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\ttry {\n\t\t\t\tresponse.getBody().write(\"\\\"callback\\\" parameter required\".getBytes(StandardCharsets.UTF_8));\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tsockJsSession.tryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to write to response\", sockJsSession.getId(), ex);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.handleRequestInternal(request, response, sockJsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleTextMessage(wsSession,message)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "wsSession",
      "message"
    ],
    "position": {
      "column": 1,
      "line": 92
    },
    "return": "void",
    "signature": "public void handleTextMessage(WebSocketSession wsSession, TextMessage message)",
    "source_code": "\tpublic void handleTextMessage(WebSocketSession wsSession, TextMessage message) throws Exception {\n\t\tthis.sockJsSession.handleMessage(message, wsSession);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.handler.<unknown>#handleTransportError(webSocketSession,exception)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "webSocketSession",
      "exception"
    ],
    "position": {
      "column": 1,
      "line": 102
    },
    "return": "void",
    "signature": "public void handleTransportError(WebSocketSession webSocketSession, Throwable exception)",
    "source_code": "\tpublic void handleTransportError(WebSocketSession webSocketSession, Throwable exception) throws Exception {\n\t\tthis.sockJsSession.delegateError(exception);\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleInitialRequest(request,response,frameFormat)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle the first request for receiving messages on a SockJS HTTP transport\n\t * based session.\n\t * <p>Long polling-based transports (for example, \"xhr\", \"jsonp\") complete the request\n\t * after writing the open frame. Streaming-based transports (\"xhr_streaming\",\n\t * \"eventsource\", and \"htmlfile\") leave the response open longer for further\n\t * streaming of message frames but will also close it eventually after some\n\t * amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 202
    },
    "return": "void",
    "signature": "public void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleInitialRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tthis.uri = request.getURI();\n\t\tthis.handshakeHeaders = request.getHeaders();\n\t\tthis.principal = request.getPrincipal();\n\t\ttry {\n\t\t\tthis.localAddress = request.getLocalAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\t\ttry {\n\t\t\tthis.remoteAddress = request.getRemoteAddress();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\t// Let \"our\" handler know before sending the open frame to the remote handler\n\t\t\t\tdelegateConnectionEstablished();\n\t\t\t\thandleRequestInternal(request, response, true);\n\t\t\t\t// Request might have been reset (for example, polling sessions do after writing)\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to open session\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleMessage(message,wsSession)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "message",
      "wsSession"
    ],
    "position": {
      "column": 1,
      "line": 184
    },
    "return": "void",
    "signature": "public void handleMessage(TextMessage message, WebSocketSession wsSession)",
    "source_code": "\tpublic void handleMessage(TextMessage message, WebSocketSession wsSession) throws Exception {\n\t\tString payload = message.getPayload();\n\t\tif (!StringUtils.hasLength(payload)) {\n\t\t\treturn;\n\t\t}\n\t\tString[] messages;\n\t\ttry {\n\t\t\tmessages = getSockJsServiceConfig().getMessageCodec().decode(payload);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"Broken data received. Terminating WebSocket connection abruptly\", ex);\n\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.BAD_DATA);\n\t\t\treturn;\n\t\t}\n\t\tif (messages != null) {\n\t\t\tdelegateMessages(messages);\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleRequestInternal(request,response,initialRequest)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Invoked when a SockJS transport request is received.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param initialRequest whether it is the first request for the session\n\t */",
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "request",
      "response",
      "initialRequest"
    ],
    "position": {
      "column": 1,
      "line": 293
    },
    "return": "void",
    "signature": "protected void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tboolean initialRequest)",
    "source_code": "\tprotected abstract void handleRequestInternal(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tboolean initialRequest) throws IOException;\n\n\t@Override\n\tprotected final void sendMessageInternal(String message) throws SockJsTransportFailureException {\n\t\tsynchronized (this.responseLock) {\n\t\t\tthis.messageCache.add(message);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(this.messageCache.size() + \" message(s) to flush in session \" + getId());\n\t\t\t}\n\t\t\tif (isActive() && this.readyToSend) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is active, ready to flush.\");\n\t\t\t\t}\n\t\t\t\tcancelHeartbeat();\n\t\t\t\tflushCache();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Session is not active, not ready to flush.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#handleSuccessiveRequest(request,response,frameFormat)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Handle all requests, except the first one, to receive messages on a SockJS\n\t * HTTP transport based session.\n\t * <p>Long polling-based transports (for example, \"xhr\", \"jsonp\") complete the request\n\t * after writing any buffered message frames (or the next one). Streaming-based\n\t * transports (\"xhr_streaming\", \"eventsource\", and \"htmlfile\") leave the\n\t * response open longer for further streaming of message frames but will also\n\t * close it eventually after some amount of data has been sent.\n\t * @param request the current request\n\t * @param response the current response\n\t * @param frameFormat the transport-specific SocksJS frame format to use\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "response",
      "frameFormat"
    ],
    "position": {
      "column": 1,
      "line": 254
    },
    "return": "void",
    "signature": "public void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat)",
    "source_code": "\tpublic void handleSuccessiveRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tSockJsFrameFormat frameFormat) throws SockJsException {\n\n\t\tsynchronized (this.responseLock) {\n\t\t\ttry {\n\t\t\t\tif (isClosed()) {\n\t\t\t\t\tString formattedFrame = frameFormat.format(SockJsFrame.closeFrameGoAway());\n\t\t\t\t\tresponse.getBody().write(formattedFrame.getBytes(SockJsFrame.CHARSET));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.response = response;\n\t\t\t\tthis.frameFormat = frameFormat;\n\t\t\t\tServerHttpAsyncRequestControl control = request.getAsyncRequestControl(response);\n\t\t\t\tthis.asyncRequestControl = control;\n\t\t\t\tcontrol.start(-1);\n\t\t\t\tdisableShallowEtagHeaderFilter(request);\n\t\t\t\thandleRequestInternal(request, response, false);\n\t\t\t\tthis.readyToSend = isActive();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\ttryCloseWithSockJsTransportError(ex, CloseStatus.SERVER_ERROR);\n\t\t\t\tthrow new SockJsTransportFailureException(\"Failed to handle SockJS receive request\", getId(), ex);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.socket.sockjs.transport.session.<unknown>#tryCloseWithSockJsTransportError(error,closeStatus)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Close due to error arising from SockJS transport handling.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "error",
      "closeStatus"
    ],
    "position": {
      "column": 1,
      "line": 403
    },
    "return": "void",
    "signature": "public void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus)",
    "source_code": "\tpublic void tryCloseWithSockJsTransportError(Throwable error, CloseStatus closeStatus) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Closing due to transport error for \" + this);\n\t\t}\n\t\ttry {\n\t\t\tdelegateError(error);\n\t\t}\n\t\tcatch (Throwable delegateException) {\n\t\t\t// Ignore\n\t\t\tlogger.debug(\"Exception from error handling delegate\", delegateException);\n\t\t}\n\t\ttry {\n\t\t\tclose(closeStatus);\n\t\t}\n\t\tcatch (Throwable closeException) {\n\t\t\tlogger.debug(\"Failure while closing \" + this, closeException);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#apply(source,type)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "source",
      "type"
    ],
    "position": {
      "column": 1,
      "line": 788
    },
    "return": "String",
    "signature": "public String apply(String source, Type type)",
    "source_code": "\t\tpublic String apply(String source, Type type) {\n\t\t\t// URI variable only?\n\t\t\tif (isUriVariable(source)) {\n\t\t\t\treturn source;\n\t\t\t}\n\t\t\t// Literal template only?\n\t\t\tif (source.indexOf('{') == -1) {\n\t\t\t\treturn encodeUriComponent(source, this.charset, type);\n\t\t\t}\n\t\t\tint level = 0;\n\t\t\tclear(this.currentLiteral);\n\t\t\tclear(this.currentVariable);\n\t\t\tclear(this.output);\n\t\t\tfor (int i = 0; i < source.length(); i++) {\n\t\t\t\tchar c = source.charAt(i);\n\t\t\t\tif (c == ':' && level == 1) {\n\t\t\t\t\tthis.variableWithNameAndRegex = true;\n\t\t\t\t}\n\t\t\t\tif (c == '{') {\n\t\t\t\t\tlevel++;\n\t\t\t\t\tif (level == 1) {\n\t\t\t\t\t\tappend(this.currentLiteral, true, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == '}' && level > 0) {\n\t\t\t\t\tlevel--;\n\t\t\t\t\tthis.currentVariable.append('}');\n\t\t\t\t\tif (level == 0) {\n\t\t\t\t\t\tboolean encode = !isUriVariable(this.currentVariable);\n\t\t\t\t\t\tappend(this.currentVariable, encode, type);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.variableWithNameAndRegex) {\n\t\t\t\t\t\tappend(this.currentVariable, true, type);\n\t\t\t\t\t\tlevel = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (level > 0) {\n\t\t\t\t\tthis.currentVariable.append(c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.currentLiteral.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (level > 0) {\n\t\t\t\tthis.currentLiteral.append(this.currentVariable);\n\t\t\t}\n\t\t\tappend(this.currentLiteral, true, type);\n\t\t\treturn this.output.toString();\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#assertHasAncestorOfType(tag,ancestorTagClass,tagName,ancestorTagName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type, throwing an {@link IllegalStateException}\n\t * if not.\n\t * @param tag the tag whose ancestors are to be checked\n\t * @param ancestorTagClass the ancestor {@link Class} being searched for\n\t * @param tagName the name of the {@code tag}; for example '{@code option}'\n\t * @param ancestorTagName the name of the ancestor {@code tag}; for example '{@code select}'\n\t * @throws IllegalStateException if the supplied {@code tag} does not\n\t * have a tag of the supplied {@code parentTagClass} as an ancestor\n\t * @throws IllegalArgumentException if any of the supplied arguments is {@code null},\n\t * or in the case of the {@link String}-typed arguments, is composed wholly\n\t * of whitespace; or if the supplied {@code ancestorTagClass} is not\n\t * type-assignable to the {@link Tag} class\n\t * @see #hasAncestorOfType(jakarta.servlet.jsp.tagext.Tag, Class)\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag",
      "ancestorTagClass",
      "tagName",
      "ancestorTagName"
    ],
    "position": {
      "column": 1,
      "line": 122
    },
    "return": "void",
    "signature": "public void assertHasAncestorOfType(Tag tag, Class<?> ancestorTagClass, String tagName,\n\t\t\tString ancestorTagName)",
    "source_code": "\tpublic static void assertHasAncestorOfType(Tag tag, Class<?> ancestorTagClass, String tagName,\n\t\t\tString ancestorTagName) {\n\n\t\tAssert.hasText(tagName, \"'tagName' must not be empty\");\n\t\tAssert.hasText(ancestorTagName, \"'ancestorTagName' must not be empty\");\n\t\tif (!TagUtils.hasAncestorOfType(tag, ancestorTagClass)) {\n\t\t\tthrow new IllegalStateException(\"The '\" + tagName +\n\t\t\t\t\t\"' tag can only be used inside a valid '\" + ancestorTagName + \"' tag.\");\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#build(Map<String,uriVariables)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 384
    },
    "return": "URI",
    "signature": "public URI build(Map<String, ?> uriVariables)",
    "source_code": "\tpublic URI build(Map<String, ?> uriVariables) {\n\t\treturn buildInternal(EncodingHint.ENCODE_TEMPLATE).expand(uriVariables).toUri();\n\t}"
  },
  "org.springframework.web.util.<unknown>#buildAndExpand(Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Build a {@code UriComponents} instance and replaces URI template variables\n\t * with the values from a map. This is a shortcut method which combines\n\t * calls to {@link #build()} and then {@link UriComponents#expand(Map)}.\n\t * @param uriVariables the map of URI variables\n\t * @return the URI components with expanded values\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 363
    },
    "return": "UriComponents",
    "signature": "public UriComponents buildAndExpand(Map<String, ?> uriVariables)",
    "source_code": "\tpublic UriComponents buildAndExpand(Map<String, ?> uriVariables) {\n\t\treturn build().expand(uriVariables);\n\t}"
  },
  "org.springframework.web.util.<unknown>#convertToReference(character,encoding)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the reference mapped to the given character, or {@code null} if none found.\n\t * @since 4.1.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "character",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 135
    },
    "return": "String",
    "signature": "public String convertToReference(char character, String encoding)",
    "source_code": "\tpublic String convertToReference(char character, String encoding) {\n\t\tif (encoding.startsWith(\"UTF-\")){\n\t\t\treturn switch (character){\n\t\t\t\tcase '<' -> \"&lt;\";\n\t\t\t\tcase '>' -> \"&gt;\";\n\t\t\t\tcase '\"' -> \"&quot;\";\n\t\t\t\tcase '&' -> \"&amp;\";\n\t\t\t\tcase '\\'' -> \"&#39;\";\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t}\n\t\telse if (character < 1000 || (character >= 8000 && character < 10000)) {\n\t\t\tint index = (character < 1000 ? character : character - 7000);\n\t\t\tString entityReference = this.characterToEntityReferenceMap[index];\n\t\t\tif (entityReference != null) {\n\t\t\t\treturn entityReference;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#encode(BiFunction<String,Type,encoder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "BiFunction<String",
      "Type",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1055
    },
    "return": "PathComponent",
    "signature": "public PathComponent encode(BiFunction<String, Type, String> encoder)",
    "source_code": "\t\tpublic PathComponent encode(BiFunction<String, Type, String> encoder) {\n\t\t\tList<PathComponent> encodedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\tencodedComponents.add(pathComponent.encode(encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(encodedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#expand(uriVariables,encoder)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uriVariables",
      "encoder"
    ],
    "position": {
      "column": 1,
      "line": 1071
    },
    "return": "PathComponent",
    "signature": "public PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder)",
    "source_code": "\t\tpublic PathComponent expand(UriTemplateVariables uriVariables, @Nullable UnaryOperator<String> encoder) {\n\t\t\tList<PathComponent> expandedComponents = new ArrayList<>(this.pathComponents.size());\n\t\t\tfor (PathComponent pathComponent : this.pathComponents) {\n\t\t\t\texpandedComponents.add(pathComponent.expand(uriVariables, encoder));\n\t\t\t}\n\t\t\treturn new PathComponentComposite(expandedComponents);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#exposeErrorRequestAttributes(request,ex,servletName)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Expose the Servlet spec's error attributes as {@link jakarta.servlet.http.HttpServletRequest}\n\t * attributes under the keys defined in the Servlet 2.3 specification, for error pages that\n\t * are rendered directly rather than through the Servlet container's error page resolution:\n\t * {@code jakarta.servlet.error.status_code},\n\t * {@code jakarta.servlet.error.exception_type},\n\t * {@code jakarta.servlet.error.message},\n\t * {@code jakarta.servlet.error.exception},\n\t * {@code jakarta.servlet.error.request_uri},\n\t * {@code jakarta.servlet.error.servlet_name}.\n\t * <p>Does not override values if already present, to respect attribute values\n\t * that have been exposed explicitly before.\n\t * <p>Exposes status code 200 by default. Set the \"jakarta.servlet.error.status_code\"\n\t * attribute explicitly (before or after) in order to expose a different status code.\n\t * @param request current servlet request\n\t * @param ex the exception encountered\n\t * @param servletName the name of the offending servlet\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "ex",
      "servletName"
    ],
    "position": {
      "column": 1,
      "line": 524
    },
    "return": "void",
    "signature": "public void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,\n\t\t\t@Nullable String servletName)",
    "source_code": "\tpublic static void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,\n\t\t\t@Nullable String servletName) {\n\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_STATUS_CODE_ATTRIBUTE, HttpServletResponse.SC_OK);\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_TYPE_ATTRIBUTE, ex.getClass());\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_MESSAGE_ATTRIBUTE, ex.getMessage());\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_ATTRIBUTE, ex);\n\t\texposeRequestAttributeIfNotPresent(request, ERROR_REQUEST_URI_ATTRIBUTE, request.getRequestURI());\n\t\tif (servletName != null) {\n\t\t\texposeRequestAttributeIfNotPresent(request, ERROR_SERVLET_NAME_ATTRIBUTE, servletName);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(Map<String,parameters,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>This method will try to obtain a parameter value using the\n\t * following algorithm:\n\t * <ol>\n\t * <li>Try to get the parameter value using just the given <i>logical</i> name.\n\t * This handles parameters of the form {@code logicalName = value}. For normal\n\t * parameters, for example, submitted using a hidden HTML form field, this will return\n\t * the requested value.</li>\n\t * <li>Try to obtain the parameter value from the parameter name, where the\n\t * parameter name in the request is of the form {@code logicalName_value = xyz}\n\t * with \"_\" being the configured delimiter. This deals with parameter values\n\t * submitted using an HTML form submit button.</li>\n\t * <li>If the value obtained in the previous step has a \".x\" or \".y\" suffix,\n\t * remove that. This handles cases where the value was submitted using an\n\t * HTML form image button. In this case the parameter in the request would\n\t * actually be of the form {@code logicalName_value.x = 123}.</li>\n\t * </ol>\n\t * @param parameters the available parameter map\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "parameters",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 650
    },
    "return": "String",
    "signature": "public String findParameterValue(Map<String, ?> parameters, String name)",
    "source_code": "\tpublic static String findParameterValue(Map<String, ?> parameters, String name) {\n\t\t// First try to get it as a normal name=value parameter\n\t\tObject value = parameters.get(name);\n\t\tif (value instanceof String[] values) {\n\t\t\treturn (values.length > 0 ? values[0] : null);\n\t\t}\n\t\telse if (value != null) {\n\t\t\treturn value.toString();\n\t\t}\n\t\t// If no value yet, try to get it as a name_value=xyz parameter\n\t\tString prefix = name + \"_\";\n\t\tfor (String paramName : parameters.keySet()) {\n\t\t\tif (paramName.startsWith(prefix)) {\n\t\t\t\t// Support images buttons, which would submit parameters as name_value.x=123\n\t\t\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\t\t\tif (paramName.endsWith(suffix)) {\n\t\t\t\t\t\treturn paramName.substring(prefix.length(), paramName.length() - suffix.length());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn paramName.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\t// We couldn't find the parameter value...\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#findParameterValue(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Obtain a named parameter from the given request parameters.\n\t * <p>See {@link #findParameterValue(java.util.Map, String)}\n\t * for a description of the lookup algorithm.\n\t * @param request current HTTP request\n\t * @param name the <i>logical</i> name of the request parameter\n\t * @return the value of the parameter, or {@code null}\n\t * if the parameter does not exist in given request\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 622
    },
    "return": "String",
    "signature": "public String findParameterValue(ServletRequest request, String name)",
    "source_code": "\tpublic static String findParameterValue(ServletRequest request, String name) {\n\t\treturn findParameterValue(request.getParameterMap(), name);\n\t}"
  },
  "org.springframework.web.util.<unknown>#fromUriString(uri,parserType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Create a builder that is initialized by parsing the given URI string.\n\t * <p><strong>Note:</strong> The presence of reserved characters can prevent\n\t * correct parsing of the URI string. For example if a query parameter\n\t * contains {@code '='} or {@code '&'} characters, the query string cannot\n\t * be parsed unambiguously. Such values should be substituted for URI\n\t * variables to enable correct parsing:\n\t * <pre class=\"code\">\n\t * String uriString = &quot;/hotels/42?filter={value}&quot;;\n\t * UriComponentsBuilder.fromUriString(uriString).buildAndExpand(&quot;hot&amp;cold&quot;);\n\t * </pre>\n\t * @param uri the URI string to initialize with\n\t * @param parserType the parsing algorithm to use\n\t * @return the new {@code UriComponentsBuilder}\n\t * @throws InvalidUrlException if {@code uri} cannot be parsed\n\t * @since 6.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "uri",
      "parserType"
    ],
    "position": {
      "column": 1,
      "line": 206
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder fromUriString(String uri, ParserType parserType)",
    "source_code": "\tpublic static UriComponentsBuilder fromUriString(String uri, ParserType parserType) throws InvalidUrlException {\n\t\tAssert.notNull(uri, \"URI must not be null\");\n\t\tif (uri.isEmpty()) {\n\t\t\treturn new UriComponentsBuilder();\n\t\t}\n\t\tUriComponentsBuilder builder = new UriComponentsBuilder();\n\t\treturn switch (parserType) {\n\t\t\tcase RFC -> {\n\t\t\t\tRfcUriParser.UriRecord record = RfcUriParser.parse(uri);\n\t\t\t\tyield builder.rfcUriRecord(record);\n\t\t\t}\n\t\t\tcase WHAT_WG -> {\n\t\t\t\tWhatWgUrlParser.UrlRecord record =\n\t\t\t\t\t\tWhatWgUrlParser.parse(uri, WhatWgUrlParser.EMPTY_RECORD, null, null);\n\t\t\t\tyield builder.whatWgUrlRecord(record);\n\t\t\t}\n\t\t};\n\t}"
  },
  "org.springframework.web.util.<unknown>#getCookie(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Retrieve the first cookie with the given name. Note that multiple\n\t * cookies can have the same name but different paths or domains.\n\t * @param request current servlet request\n\t * @param name cookie name\n\t * @return the first cookie with the given name, or {@code null} if none is found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 577
    },
    "return": "Cookie",
    "signature": "public Cookie getCookie(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Cookie getCookie(HttpServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tCookie[] cookies = request.getCookies();\n\t\tif (cookies != null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tif (name.equals(cookie.getName())) {\n\t\t\t\t\treturn cookie;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getDefaultMessage(resolvable,locale)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "protected"
    ],
    "params": [
      "resolvable",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 119
    },
    "return": "String",
    "signature": "protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale)",
    "source_code": "\t\tprotected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {\n\t\t\tString message = super.getDefaultMessage(resolvable, locale);\n\t\t\treturn (resolvable instanceof FieldError error ? error.getField() + \": \" + message : message);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeRequest(request,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate request object of the specified type, if available,\n\t * unwrapping the given request as far as necessary.\n\t * @param request the servlet request to introspect\n\t * @param requiredType the desired type of request object\n\t * @return the matching request object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 459
    },
    "return": "T",
    "signature": "public T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(request)) {\n\t\t\t\treturn (T) request;\n\t\t\t}\n\t\t\telse if (request instanceof ServletRequestWrapper wrapper) {\n\t\t\t\treturn getNativeRequest(wrapper.getRequest(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getNativeResponse(response,requiredType)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return an appropriate response object of the specified type, if available,\n\t * unwrapping the given response as far as necessary.\n\t * @param response the servlet response to introspect\n\t * @param requiredType the desired type of response object\n\t * @return the matching response object, or {@code null} if none\n\t * of that type is available\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "response",
      "requiredType"
    ],
    "position": {
      "column": 1,
      "line": 481
    },
    "return": "T",
    "signature": "public T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType)",
    "source_code": "\tpublic static <T> T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType) {\n\t\tif (requiredType != null) {\n\t\t\tif (requiredType.isInstance(response)) {\n\t\t\t\treturn (T) response;\n\t\t\t}\n\t\t\telse if (response instanceof ServletResponseWrapper wrapper) {\n\t\t\t\treturn getNativeResponse(wrapper.getResponse(), requiredType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getParametersStartingWith(request,prefix)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return a map containing all parameters with the given prefix.\n\t * Maps single values to String and multiple values to String array.\n\t * <p>For example, with a prefix of \"spring_\", \"spring_param1\" and\n\t * \"spring_param2\" result in a Map with \"param1\" and \"param2\" as keys.\n\t * @param request the HTTP request in which to look for parameters\n\t * @param prefix the beginning of parameter names\n\t * (if this is null or the empty string, all parameters will match)\n\t * @return map containing request parameters <b>without the prefix</b>,\n\t * containing either a String or a String array as values\n\t * @see jakarta.servlet.ServletRequest#getParameterNames\n\t * @see jakarta.servlet.ServletRequest#getParameterValues\n\t * @see jakarta.servlet.ServletRequest#getParameterMap\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "prefix"
    ],
    "position": {
      "column": 1,
      "line": 690
    },
    "return": "Object>",
    "signature": "public Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix)",
    "source_code": "\tpublic static Map<String, Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tEnumeration<String> paramNames = request.getParameterNames();\n\t\tMap<String, Object> params = new TreeMap<>();\n\t\tif (prefix == null) {\n\t\t\tprefix = \"\";\n\t\t}\n\t\twhile (paramNames != null && paramNames.hasMoreElements()) {\n\t\t\tString paramName = paramNames.nextElement();\n\t\t\tif (prefix.isEmpty() || paramName.startsWith(prefix)) {\n\t\t\t\tString unprefixed = paramName.substring(prefix.length());\n\t\t\t\tString[] values = request.getParameterValues(paramName);\n\t\t\t\tif (values == null || values.length == 0) {\n\t\t\t\t\t// Do nothing, no values found at all.\n\t\t\t\t}\n\t\t\t\telse if (values.length > 1) {\n\t\t\t\t\tparams.put(unprefixed, values);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparams.put(unprefixed, values[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRealPath(servletContext,path)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return the real path of the given path within the web application,\n\t * as provided by the servlet container.\n\t * <p>Prepends a slash if the path does not already start with a slash,\n\t * and throws a FileNotFoundException if the path cannot be resolved to\n\t * a resource (in contrast to ServletContext's {@code getRealPath},\n\t * which returns null).\n\t * @param servletContext the servlet context of the web application\n\t * @param path the path within the web application\n\t * @return the corresponding real path\n\t * @throws FileNotFoundException if the path cannot be resolved to a resource\n\t * @see jakarta.servlet.ServletContext#getRealPath\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "servletContext",
      "path"
    ],
    "position": {
      "column": 1,
      "line": 337
    },
    "return": "String",
    "signature": "public String getRealPath(ServletContext servletContext, String path)",
    "source_code": "\tpublic static String getRealPath(ServletContext servletContext, String path) throws FileNotFoundException {\n\t\tAssert.notNull(servletContext, \"ServletContext must not be null\");\n\t\t// Interpret location as relative to the web application root directory.\n\t\tif (!path.startsWith(\"/\")) {\n\t\t\tpath = \"/\" + path;\n\t\t}\n\t\tString realPath = servletContext.getRealPath(path);\n\t\tif (realPath == null) {\n\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\"ServletContext resource [\" + path + \"] cannot be resolved to absolute file path - \" +\n\t\t\t\t\t\"web application archive not expanded?\");\n\t\t}\n\t\treturn realPath;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getRequiredSessionAttribute(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for a session attribute of the given name.\n\t * Throws an exception if there is no session or if the session has no such\n\t * attribute. Does not create a new session if none has existed before!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @return the value of the session attribute, or {@code null} if not found\n\t * @throws IllegalStateException if the session attribute could not be found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 388
    },
    "return": "Object",
    "signature": "public Object getRequiredSessionAttribute(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Object getRequiredSessionAttribute(HttpServletRequest request, String name)\n\t\t\tthrows IllegalStateException {\n\n\t\tObject attr = getSessionAttribute(request, name);\n\t\tif (attr == null) {\n\t\t\tthrow new IllegalStateException(\"No session attribute '\" + name + \"' found\");\n\t\t}\n\t\treturn attr;\n\t}"
  },
  "org.springframework.web.util.<unknown>#getSessionAttribute(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request for a session attribute of the given name.\n\t * Returns null if there is no session or if the session has no such attribute.\n\t * Does not create a new session if none has existed before!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @return the value of the session attribute, or {@code null} if not found\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 373
    },
    "return": "Object",
    "signature": "public Object getSessionAttribute(HttpServletRequest request, String name)",
    "source_code": "\tpublic static Object getSessionAttribute(HttpServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tHttpSession session = request.getSession(false);\n\t\treturn (session != null ? session.getAttribute(name) : null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#handle(c,url,p)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "c",
      "url",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 1712
    },
    "return": "void",
    "signature": "public void handle(int c, UrlRecord url, WhatWgUrlParser p)",
    "source_code": "\t\tpublic abstract void handle(int c, UrlRecord url, WhatWgUrlParser p);"
  },
  "org.springframework.web.util.<unknown>#hasAncestorOfType(tag,ancestorTagClass)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Determine whether the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type.\n\t * @param tag the tag whose ancestors are to be checked\n\t * @param ancestorTagClass the ancestor {@link Class} being searched for\n\t * @return {@code true} if the supplied {@link Tag} has any ancestor tag\n\t * of the supplied type\n\t * @throws IllegalArgumentException if either of the supplied arguments is {@code null};\n\t * or if the supplied {@code ancestorTagClass} is not type-assignable to\n\t * the {@link Tag} class\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "tag",
      "ancestorTagClass"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "boolean",
    "signature": "public boolean hasAncestorOfType(Tag tag, Class<?> ancestorTagClass)",
    "source_code": "\tpublic static boolean hasAncestorOfType(Tag tag, Class<?> ancestorTagClass) {\n\t\tAssert.notNull(tag, \"Tag cannot be null\");\n\t\tAssert.notNull(ancestorTagClass, \"Ancestor tag class cannot be null\");\n\t\tif (!Tag.class.isAssignableFrom(ancestorTagClass)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Class '\" + ancestorTagClass.getName() + \"' is not a valid Tag type\");\n\t\t}\n\t\tTag ancestor = tag.getParent();\n\t\twhile (ancestor != null) {\n\t\t\tif (ancestorTagClass.isAssignableFrom(ancestor.getClass())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tancestor = ancestor.getParent();\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.util.<unknown>#hasSubmitParameter(request,name)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check if a specific input type=\"submit\" parameter was sent in the request,\n\t * either via a button (directly with name) or via an image (name + \".x\" or\n\t * name + \".y\").\n\t * @param request current HTTP request\n\t * @param name the name of the parameter\n\t * @return if the parameter was sent\n\t * @see #SUBMIT_IMAGE_SUFFIXES\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name"
    ],
    "position": {
      "column": 1,
      "line": 599
    },
    "return": "boolean",
    "signature": "public boolean hasSubmitParameter(ServletRequest request, String name)",
    "source_code": "\tpublic static boolean hasSubmitParameter(ServletRequest request, String name) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tif (request.getParameter(name) != null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (String suffix : SUBMIT_IMAGE_SUFFIXES) {\n\t\t\tif (request.getParameter(name + suffix) != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
  },
  "org.springframework.web.util.<unknown>#isMappedToReference(character,encoding)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Return true if the given character is mapped to a supported entity reference.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "character",
      "encoding"
    ],
    "position": {
      "column": 1,
      "line": 118
    },
    "return": "boolean",
    "signature": "public boolean isMappedToReference(char character, String encoding)",
    "source_code": "\tpublic boolean isMappedToReference(char character, String encoding) {\n\t\treturn (convertToReference(character, encoding) != null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#isValidOrigin(request,allowedOrigins)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Check the given request origin against a list of allowed origins.\n\t * A list containing \"*\" means that all origins are allowed.\n\t * An empty list means only same origin is allowed.\n\t *\n\t * <p><strong>Note:</strong> as of 5.1 this method ignores\n\t * {@code \"Forwarded\"} and {@code \"X-Forwarded-*\"} headers that specify the\n\t * client-originated address. Consider using the {@code ForwardedHeaderFilter}\n\t * to extract and use, or to discard such headers.\n\t * @return {@code true} if the request origin is valid, {@code false} otherwise\n\t * @since 4.1.5\n\t * @see <a href=\"https://tools.ietf.org/html/rfc6454\">RFC 6454: The Web Origin Concept</a>\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "allowedOrigins"
    ],
    "position": {
      "column": 1,
      "line": 764
    },
    "return": "boolean",
    "signature": "public boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins)",
    "source_code": "\tpublic static boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tAssert.notNull(allowedOrigins, \"Allowed origins must not be null\");\n\n\t\tString origin = request.getHeaders().getOrigin();\n\t\tif (origin == null || allowedOrigins.contains(\"*\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (CollectionUtils.isEmpty(allowedOrigins)) {\n\t\t\treturn isSameOrigin(request);\n\t\t}\n\t\telse {\n\t\t\treturn allowedOrigins.contains(origin);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input,base,encoding,validationErrorHandler)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Parse the given input into a URL record.\n\t * @param input the scalar value string\n\t * @param base the optional base URL to resolve relative URLs against. If\n\t * {@code null}, relative URLs cannot be parsed.\n\t * @param encoding the optional encoding to use. If {@code null}, no\n\t * encoding is performed.\n\t * @param validationErrorHandler optional consumer for non-fatal URL\n\t * validation messages\n\t * @return a URL record, as defined in the\n\t * <a href=\"https://url.spec.whatwg.org/#concept-url\">living URL\n\t * specification</a>\n\t * @throws InvalidUrlException if the {@code input} does not contain a\n\t * parsable URL\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "base",
      "encoding",
      "validationErrorHandler"
    ],
    "position": {
      "column": 1,
      "line": 131
    },
    "return": "UrlRecord",
    "signature": "public UrlRecord parse(String input, @Nullable UrlRecord base,\n\t\t\t@Nullable Charset encoding, @Nullable Consumer<String> validationErrorHandler)",
    "source_code": "\tpublic static UrlRecord parse(String input, @Nullable UrlRecord base,\n\t\t\t@Nullable Charset encoding, @Nullable Consumer<String> validationErrorHandler)\n\t\t\tthrows InvalidUrlException {\n\n\t\tAssert.notNull(input, \"Input must not be null\");\n\n\t\tWhatWgUrlParser parser = new WhatWgUrlParser(input, base, encoding, validationErrorHandler);\n\t\treturn parser.basicUrlParser(null, null);\n\t}"
  },
  "org.springframework.web.util.<unknown>#parse(input,p)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "input",
      "p"
    ],
    "position": {
      "column": 1,
      "line": 2380
    },
    "return": "Ipv4Address",
    "signature": "public Ipv4Address parse(String input, WhatWgUrlParser p)",
    "source_code": "\t\tpublic static Ipv4Address parse(String input, WhatWgUrlParser p) {\n\t\t\t// Let parts be the result of strictly splitting input on U+002E (.).\n\t\t\tList<String> parts = strictSplit(input, '.');\n\t\t\tint partsSize = parts.size();\n\t\t\t// If the last item in parts is the empty string, then:\n\t\t\tif (parts.get(partsSize - 1).isEmpty()) {\n\t\t\t\t// IPv4-empty-part validation error.\n\t\t\t\tp.validationError(\"IPv4 address ends with \\\".\\\"\");\n\t\t\t\t// If parts\u2019s size is greater than 1, then remove the last item from parts.\n\t\t\t\tif (partsSize > 1) {\n\t\t\t\t\tparts.remove(partsSize - 1);\n\t\t\t\t\tpartsSize--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If parts\u2019s size is greater than 4, IPv4-too-many-parts validation error, return failure.\n\t\t\tif (partsSize > 4) {\n\t\t\t\tthrow new InvalidUrlException(\"IPv4 address does not consist of exactly 4 parts.\");\n\t\t\t}\n\t\t\t// Let numbers be an empty list.\n\t\t\tList<Integer> numbers = new ArrayList<>(partsSize);\n\t\t\t// For each part of parts:\n\t\t\tfor (int i = 0; i < partsSize; i++) {\n\t\t\t\tString part = parts.get(i);\n\t\t\t\t// Let result be the result of parsing part.\n\t\t\t\tParseIpv4NumberResult result = parseIpv4Number(part);\n\t\t\t\t// If result is failure, IPv4-non-numeric-part validation error, return failure.\n\t\t\t\tif (result == ParseIpv4NumberFailure.INSTANCE) {\n\t\t\t\t\tp.failure(\"An IPv4 address part is not numeric.\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParseIpv4NumberSuccess success = (ParseIpv4NumberSuccess) result;\n\t\t\t\t\tif (p.validate() && success.validationError()) {\n\t\t\t\t\t\tp.validationError(\n\t\t\t\t\t\t\t\t\"The IPv4 address contains numbers expressed using hexadecimal or octal digits.\");\n\t\t\t\t\t}\n\t\t\t\t\t// Append result to numbers.\n\t\t\t\t\tnumbers.add(success.number());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext(); ) {\n\t\t\t\tInteger number = iterator.next();\n\t\t\t\t// If any item in numbers is greater than 255, IPv4-out-of-range-part validation error.\n\t\t\t\tif (p.validate() && number > 255) {\n\t\t\t\t\tp.validationError(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t}\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\t// If any but the last item in numbers is greater than 255, then return failure.\n\t\t\t\t\tif (number > 255) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\"An IPv4 address part exceeds 255.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If the last item in numbers is greater than or equal to 256^(5 \u2212 numbers\u2019s size),\n\t\t\t\t\t// then return failure.\n\t\t\t\t\tdouble limit = Math.pow(256, (5 - numbers.size()));\n\t\t\t\t\tif (number >= limit) {\n\t\t\t\t\t\tthrow new InvalidUrlException(\n\t\t\t\t\t\t\t\t\"IPv4 address part \" + number + \" exceeds \" + limit + \".'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Let ipv4 be the last item in numbers.\n\t\t\tint ipv4 = numbers.get(numbers.size() - 1);\n\t\t\t// Remove the last item from numbers.\n\t\t\tnumbers.remove(numbers.size() - 1);\n\t\t\t// Let counter be 0.\n\t\t\tint counter = 0;\n\t\t\t// For each n of numbers:\n\t\t\tfor (Integer n : numbers) {\n\t\t\t\t// Increment ipv4 by n \u00d7 256^(3 \u2212 counter).\n\t\t\t\tint increment = n * (int) Math.pow(256, 3 - counter);\n\t\t\t\tipv4 += increment;\n\t\t\t\t// Increment counter by 1.\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\t// Return ipv4.\n\t\t\treturn new Ipv4Address(ipv4);\n\t\t}"
  },
  "org.springframework.web.util.<unknown>#queryParam(name,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 653
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder queryParam(String name, @Nullable Collection<?> values) {\n\t\treturn queryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParamIfPresent(name,value)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 658
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value)",
    "source_code": "\tpublic UriComponentsBuilder queryParamIfPresent(String name, Optional<?> value) {\n\t\tvalue.ifPresent(v -> {\n\t\t\tif (v instanceof Collection<?> values) {\n\t\t\t\tqueryParam(name, values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueryParam(name, v);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#queryParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.0\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 675
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder queryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tif (params != null) {\n\t\t\tthis.queryParams.addAll(params);\n\t\t\tresetSchemeSpecificPart();\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParam(name,values)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "name",
      "values"
    ],
    "position": {
      "column": 1,
      "line": 695
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParam(String name, @Nullable Collection<?> values) {\n\t\treturn replaceQueryParam(name, (CollectionUtils.isEmpty(values) ? EMPTY_VALUES : values.toArray()));\n\t}"
  },
  "org.springframework.web.util.<unknown>#replaceQueryParams(MultiValueMap<String,params)": {
    "deprecated": false,
    "doc": "\t/**\n\t * {@inheritDoc}\n\t * @since 4.2\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "MultiValueMap<String",
      "params"
    ],
    "position": {
      "column": 1,
      "line": 704
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params)",
    "source_code": "\tpublic UriComponentsBuilder replaceQueryParams(@Nullable MultiValueMap<String, String> params) {\n\t\tthis.queryParams.clear();\n\t\tif (params != null) {\n\t\t\tthis.queryParams.putAll(params);\n\t\t}\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.<unknown>#resolve(errors,messageSource,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource}.\n\t * @param errors the errors to resolve\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with an empty {@link MessageSource}\n\t * @return map with resolved errors as values, in the order of the input list\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 99
    },
    "return": "String>",
    "signature": "public String> resolve(List<E> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static <E extends MessageSourceResolvable> Map<E, String> resolve(\n\t\t\tList<E> errors, MessageSource messageSource, Locale locale) {\n\n\t\tMap<E, String> map = new LinkedHashMap<>(errors.size());\n\t\terrors.forEach(error -> map.put(error, messageSource.getMessage(error, locale)));\n\t\treturn map;\n\t}"
  },
  "org.springframework.web.util.<unknown>#resolveAndJoin(delimiter,prefix,suffix,errors,messageSource,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Resolve all errors through the given {@link MessageSource} and join them.\n\t * @param delimiter the delimiter to use between each error\n\t * @param prefix characters to insert at the beginning\n\t * @param suffix characters to insert at the end\n\t * @param errors the errors to resolve and join\n\t * @param messageSource the {@code MessageSource} to resolve with\n\t * @param locale the locale to resolve with\n\t * @return the resolved errors formatted as a string\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "delimiter",
      "prefix",
      "suffix",
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 73
    },
    "return": "String",
    "signature": "public String resolveAndJoin(CharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin(\n\t\t\tCharSequence delimiter, CharSequence prefix, CharSequence suffix,\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn errors.stream()\n\t\t\t\t.map(error -> messageSource.getMessage(error, locale))\n\t\t\t\t.filter(StringUtils::hasText)\n\t\t\t\t.collect(Collectors.joining(delimiter, prefix, suffix));\n\t}"
  },
  "org.springframework.web.util.<unknown>#resolveAndJoin(errors,messageSource,locale)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Shortcut for {@link #resolveAndJoin(CharSequence, CharSequence, CharSequence, List, MessageSource, Locale)}\n\t * with {@code \", and \"} as delimiter, and an empty prefix and suffix.\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "errors",
      "messageSource",
      "locale"
    ],
    "position": {
      "column": 1,
      "line": 57
    },
    "return": "String",
    "signature": "public String resolveAndJoin(List<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale)",
    "source_code": "\tpublic static String resolveAndJoin(\n\t\t\tList<? extends MessageSourceResolvable> errors, MessageSource messageSource, Locale locale) {\n\n\t\treturn resolveAndJoin(\", and \", \"\", \"\", errors, messageSource, locale);\n\t}"
  },
  "org.springframework.web.util.<unknown>#setParsedRequestPath(requestPath,request)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the cached, parsed {@code RequestPath} to the given value.\n\t * @param requestPath the value to set to, or if {@code null} the cache\n\t * value is cleared.\n\t * @param request the current request\n\t * @since 5.3.3\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "requestPath",
      "request"
    ],
    "position": {
      "column": 1,
      "line": 89
    },
    "return": "void",
    "signature": "public void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request)",
    "source_code": "\tpublic static void setParsedRequestPath(@Nullable RequestPath requestPath, ServletRequest request) {\n\t\tif (requestPath != null) {\n\t\t\trequest.setAttribute(PATH_ATTRIBUTE, requestPath);\n\t\t}\n\t\telse {\n\t\t\trequest.removeAttribute(PATH_ATTRIBUTE);\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#setSessionAttribute(request,name,value)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Set the session attribute with the given name to the given value.\n\t * Removes the session attribute if value is null, if a session existed at all.\n\t * Does not create a new session if not necessary!\n\t * @param request current HTTP request\n\t * @param name the name of the session attribute\n\t * @param value the value of the session attribute\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "request",
      "name",
      "value"
    ],
    "position": {
      "column": 1,
      "line": 406
    },
    "return": "void",
    "signature": "public void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value)",
    "source_code": "\tpublic static void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value) {\n\t\tAssert.notNull(request, \"Request must not be null\");\n\t\tif (value != null) {\n\t\t\trequest.getSession().setAttribute(name, value);\n\t\t}\n\t\telse {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tsession.removeAttribute(name);\n\t\t\t}\n\t\t}\n\t}"
  },
  "org.springframework.web.util.<unknown>#uriVariables(Map<String,uriVariables)": {
    "deprecated": false,
    "doc": "\t/**\n\t * Configure URI variables to be expanded at build time.\n\t * <p>The provided variables may be a subset of all required ones. At build\n\t * time, the available ones are expanded, while unresolved URI placeholders\n\t * are left in place and can still be expanded later.\n\t * <p>In contrast to {@link UriComponents#expand(Map)} or\n\t * {@link #buildAndExpand(Map)}, this method is useful when you need to\n\t * supply URI variables without building the {@link UriComponents} instance\n\t * just yet, or perhaps pre-expand some shared default values such as host\n\t * and port.\n\t * @param uriVariables the URI variables to use\n\t * @return this UriComponentsBuilder\n\t * @since 5.0.8\n\t */",
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "Map<String",
      "uriVariables"
    ],
    "position": {
      "column": 1,
      "line": 738
    },
    "return": "UriComponentsBuilder",
    "signature": "public UriComponentsBuilder uriVariables(Map<String, Object> uriVariables)",
    "source_code": "\tpublic UriComponentsBuilder uriVariables(Map<String, Object> uriVariables) {\n\t\tthis.uriVariables.putAll(uriVariables);\n\t\treturn this;\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#matches(pathIndex,matchingContext)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "pathIndex",
      "matchingContext"
    ],
    "position": {
      "column": 1,
      "line": 61
    },
    "return": "boolean",
    "signature": "public boolean matches(int pathIndex, MatchingContext matchingContext)",
    "source_code": "\tpublic boolean matches(int pathIndex, MatchingContext matchingContext) {\n\t\tif (pathIndex >= matchingContext.pathLength) {\n\t\t\t// no more path left to match this element\n\t\t\treturn false;\n\t\t}\n\n\t\tElement element = matchingContext.pathElements.get(pathIndex);\n\t\tif (!(element instanceof PathSegment pathSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tString value = pathSegment.valueToMatch();\n\t\tif (value.length() != this.len) {\n\t\t\t// Not enough data to match this path element\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.caseSensitive) {\n\t\t\tfor (int i = 0; i < this.len; i++) {\n\t\t\t\tchar ch = this.text[i];\n\t\t\t\tif ((ch != '?') && (ch != value.charAt((i)))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < this.len; i++) {\n\t\t\t\tchar ch = this.text[i];\n\t\t\t\t// TODO revisit performance if doing a lot of case insensitive matching\n\t\t\t\tif ((ch != '?') && (ch != Character.toLowerCase(value.charAt(i)))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpathIndex++;\n\t\tif (isNoMorePattern()) {\n\t\t\tif (matchingContext.determineRemainingPath) {\n\t\t\t\tmatchingContext.remainingPathIndex = pathIndex;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (pathIndex == matchingContext.pathLength) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (matchingContext.isMatchOptionalTrailingSeparator() &&\n\t\t\t\t\t\t\t(pathIndex + 1) == matchingContext.pathLength &&\n\t\t\t\t\t\t\tmatchingContext.isSeparator(pathIndex));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn (this.next != null && this.next.matches(pathIndex, matchingContext));\n\t\t}\n\t}"
  },
  "org.springframework.web.util.pattern.<unknown>#set(key,value,MultiValueMap<String,parameters)": {
    "deprecated": false,
    "doc": null,
    "kind": "method",
    "modifiers": [
      "public"
    ],
    "params": [
      "key",
      "value",
      "MultiValueMap<String",
      "parameters"
    ],
    "position": {
      "column": 1,
      "line": 688
    },
    "return": "void",
    "signature": "public void set(String key, String value, MultiValueMap<String,String> parameters)",
    "source_code": "\t\tpublic void set(String key, String value, MultiValueMap<String,String> parameters) {\n\t\t\tif (this.extractedUriVariables == null) {\n\t\t\t\tthis.extractedUriVariables = new HashMap<>();\n\t\t\t}\n\t\t\tthis.extractedUriVariables.put(key, value);\n\n\t\t\tif (!parameters.isEmpty()) {\n\t\t\t\tif (this.extractedMatrixVariables == null) {\n\t\t\t\t\tthis.extractedMatrixVariables = new HashMap<>();\n\t\t\t\t}\n\t\t\t\tthis.extractedMatrixVariables.put(key, CollectionUtils.unmodifiableMultiValueMap(parameters));\n\t\t\t}\n\t\t}"
  }
}